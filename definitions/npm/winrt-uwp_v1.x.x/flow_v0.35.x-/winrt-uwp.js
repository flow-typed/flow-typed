/**
 * Flowtype definitions for winrt-uwp
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


/**
 * Provides data when an app is activated to add an appointment to the user’s calendar. 
 */
declare class AppointmentsProviderAddAppointmentActivatedEventArgs {

    /**
     * Gets the appointment that is provided to the app when the user tries to add it. 
     */
    addAppointmentOperation: undefined.AddAppointmentOperation;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed by the appointments provider. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to remove an appointment from the user’s calendar. 
 */
declare class AppointmentsProviderRemoveAppointmentActivatedEventArgs {

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the appointment that is provided to the app when the user tries to remove it. 
     */
    removeAppointmentOperation: undefined.RemoveAppointmentOperation;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed by the appointments provider. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to replace an appointment in the user’s calendar. 
 */
declare class AppointmentsProviderReplaceAppointmentActivatedEventArgs {

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the appointment that is provided to the app when the user tries to replace it. 
     */
    replaceAppointmentOperation: undefined.ReplaceAppointmentOperation;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed by the appointments provider. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to show the details of an appointment. 
 */
declare class AppointmentsProviderShowAppointmentDetailsActivatedEventArgs {

    /**
     * Gets the start date of the appointment instance for which the app should display details. 
     */
    instanceStartDate: Date;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the local identifier of the appointment for which the app should display details. 
     */
    localId: string;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the roaming identifier of the appointment for which the app should display details. 
     */
    roamingId: string;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed by the appointments provider. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to show a specified time frame on the user’s calendar. 
 */
declare class AppointmentsProviderShowTimeFrameActivatedEventArgs {

    /**
     * Gets the duration of the time frame to be shown. 
     */
    duration: number;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the starting date and time of the time frame to be shown. 
     */
    timeToShow: Date;

    /**
     * Gets the action to be performed by the appointments provider. 
     */
    verb: string
}


/**
 * Provides information about the activated event that fires when the user saves or opens a file that needs updates from the app. 
 */
declare class CachedFileUpdaterActivatedEventArgs {

    /**
     * Gets the letterbox UI of the file picker that is displayed when a file needs updates from the app. 
     */
    cachedFileUpdaterUI: undefined.CachedFileUpdaterUI;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Enables a camera settings app to handle the activation parameters for the app. 
 */
declare class CameraSettingsActivatedEventArgs {

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the object that controls device settings on the camera. 
     */
    videoDeviceController: any;

    /**
     * Gets the object that implements additional extended settings for the camera. 
     */
    videoDeviceExtension: any
}


/**
 * Provides data when an app is activated to call a contact. 
 */
declare class ContactCallActivatedEventArgs {

    /**
     * Gets the contact for the call. 
     */
    contact: undefined.Contact;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the identifier of the service used for the call. 
     */
    serviceId: string;

    /**
     * Gets the user identifier of the service used for the call. 
     */
    serviceUserId: string;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to map a contact. 
 */
declare class ContactMapActivatedEventArgs {

    /**
     * Gets the address of a contact for the mapping operation. 
     */
    address: undefined.ContactAddress;

    /**
     * Gets the contact for the mapping operation. 
     */
    contact: undefined.Contact;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to send a message to a contact. 
 */
declare class ContactMessageActivatedEventArgs {

    /**
     * Gets the contact for the message. 
     */
    contact: undefined.Contact;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the identifier of the service used for the message. 
     */
    serviceId: string;

    /**
     * Gets the user identifier of the service used for the message. 
     */
    serviceUserId: string;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed. 
     */
    verb: string
}


/**
 * Provides data when an app is activated because it uses the Contact Picker. 
 */
declare class ContactPickerActivatedEventArgs {

    /**
     * Gets the letterbox UI of the contact picker that is displayed when the user wants to pick contacts that are provided by the app. 
     */
    contactPickerUI: undefined.ContactPickerUI;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides data when an app is activated to post a contact. 
 */
declare class ContactPostActivatedEventArgs {

    /**
     * Gets the contact for the post. 
     */
    contact: undefined.Contact;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the identifier of the service used for the post. 
     */
    serviceId: string;

    /**
     * Gets the user identifier of the service used for the post. 
     */
    serviceUserId: string;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to video call a contact. 
 */
declare class ContactVideoCallActivatedEventArgs {

    /**
     * Gets the contact for the video call. 
     */
    contact: undefined.Contact;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the identifier of the service used for the video call. 
     */
    serviceId: string;

    /**
     * Gets the user identifier of the service used for the video call. 
     */
    serviceUserId: string;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed. 
     */
    verb: string
}


/**
 * Provides information for a device that invokes AutoPlay. 
 */
declare class DeviceActivatedEventArgs {

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the device identifier for the device that invoked AutoPlay. 
     */
    deviceInformationId: string;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action associated with the activated device. 
     */
    verb: string;

    /**
     * Gets the view switcher object that allows you to set the view for the application. 
     */
    viewSwitcher: undefined.ActivationViewSwitcher
}

declare class DevicePairingActivatedEventArgs {
    deviceInformation: any;
    kind: any;
    previousExecutionState: any;
    splashScreen: any
}


/**
 * Provides data when an app is activated from another app by using the DIAL protocol. 
 */
declare class DialReceiverActivatedEventArgs {

    /**
     * Gets the name of the app that invoked the dial receiver app. 
     */
    appName: string;

    /**
     * Gets the arguments passed by the calling app. 
     */
    arguments: string;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the unique tile identifier for the calling app. 
     */
    tileId: string;

    /**
     * Gets the view switcher object that allows you to set the view for the application. 
     */
    viewSwitcher: undefined.ActivationViewSwitcher
}


/**
 * Provides data when an app is activated because it is the app associated with a file. 
 */
declare class FileActivatedEventArgs {

    /**
     * The package family name of the app that launched your app. 
     */
    callerPackageFamilyName: string;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the files for which the app was activated. 
     */
    files: undefined.IVectorView<undefined.IStorageItem>;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the neighboring files of the files for which the app was activated. 
     */
    neighboringFilesQuery: undefined.StorageFileQueryResult;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action associated with the activated file. 
     */
    verb: string;

    /**
     * Provides the object that allows you to set the view for the application. 
     */
    viewSwitcher: undefined.ActivationViewSwitcher
}


/**
 * Provides information about an activated event that fires when the user tries to pick files or folders that are provided by the app. 
 */
declare class FileOpenPickerActivatedEventArgs {

    /**
     * The package family name of the app that launched your app. 
     */
    callerPackageFamilyName: string;

    /**
     * Gets the letterbox UI of the file picker that is displayed when the user wants to pick files or folders that are provided by the app. 
     */
    fileOpenPickerUI: undefined.FileOpenPickerUI;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a file open picker operation. 
 */
declare class FileOpenPickerContinuationEventArgs {

    /**
     * Gets a set of values populated by the app before a FileOpenPicker operation that deactivates the app in order to provide context when the app is activated. 
     */
    continuationData: undefined.ValueSet;

    /**
     * Gets the list of files selected by the user during the file open picker operation. 
     */
    files: undefined.IVectorView<undefined.StorageFile>;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about an activated event that fires when the user saves a file through the file picker and selects the app as the location. 
 */
declare class FileSavePickerActivatedEventArgs {

    /**
     * The package family name of the app that launched this app. 
     */
    callerPackageFamilyName: string;

    /**
     * Gets the ID of the enterprise that owns the file. 
     */
    enterpriseId: string;

    /**
     * Gets the letterbox UI of the file picker that is displayed when the user saves a file and selects the app as the save location. 
     */
    fileSavePickerUI: undefined.FileSavePickerUI;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a file save picker operation. 
 */
declare class FileSavePickerContinuationEventArgs {

    /**
     * Gets a set of values populated by the app before a FileSavePicker operation that deactivates the app in order to provide context when the app is activated. 
     */
    continuationData: undefined.ValueSet;

    /**
     * Gets the file selected by the user during the file save picker operation. 
     */
    file: undefined.StorageFile;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a folder picker operation. 
 */
declare class FolderPickerContinuationEventArgs {

    /**
     * Gets a set of values populated by the app before a FolderPicker operation that deactivates the app in order to provide context when the app is activated. 
     */
    continuationData: undefined.ValueSet;

    /**
     * Gets the folder selected by the user during the folder picker operation. 
     */
    folder: undefined.StorageFolder;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides event information when an app is launched. 
 */
declare class LaunchActivatedEventArgs {

    /**
     * Gets the arguments that are passed to the app during its launch activation. 
     */
    arguments: string;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the reason that this app is being activated. 
     */
    kind: undefined.ActivationKind;

    /**
     * Indicates whether the app was pre-launched. 
     */
    prelaunchActivated: boolean;

    /**
     * Gets the execution state of the app before this activation. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the ID of the tile that was invoked to launch the app. 
     */
    tileId: string;

    /**
     * Gets the view switcher object that allows you to set the view for the application. 
     */
    viewSwitcher: undefined.ActivationViewSwitcher
}


/**
 * Provides information about an event that occurs when the app is activated as the lock screen. 
 */
declare class LockScreenActivatedEventArgs {

    /**
     * Gets an object that allows an app that is activated as the lock screen to get the same data that the default lock screen can access, and to register for updates to that data. 
     */
    info: any;

    /**
     * Gets the reason for the activation of the app for this event. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before the app was activated as the lock screen. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides event information when communication to and from the lock screen is required. 
 */
declare class LockScreenCallActivatedEventArgs {

    /**
     * Gets the arguments that are passed to the app to launch it. 
     */
    arguments: string;

    /**
     * Gets the UI that handles communication to and from the lock screen. 
     */
    callUI: undefined.LockScreenCallUI;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the identifier of the source that launched the app. 
     */
    tileId: string;

    /**
     * Gets the view switcher object that allows you to set the view for the application. 
     */
    viewSwitcher: undefined.ActivationViewSwitcher
}


/**
 * Provides data for the Activated event when it occurs after a picker returns. 
 */
declare class PickerReturnedActivatedEventArgs {

    /**
     * Gets the reason that this app is being activated. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets an identifier indicating the picker operation that was performed prior to the activation. 
     */
    pickerOperationId: string;

    /**
     * Gets the execution state of the app before this activation. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about an event that occurs when the app is launched as a 3D printing workflow. 
 */
declare class Print3DWorkflowActivatedEventArgs {

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets a customized printing experience for a 3D printer. 
     */
    workflow: undefined.Print3DWorkflow
}


/**
 * Provides information in response to the event that is raised when print task settings are activated. 
 */
declare class PrintTaskSettingsActivatedEventArgs {

    /**
     * Gets the configuration information for the print task. 
     */
    configuration: undefined.PrintTaskConfiguration;

    /**
     * Gets the activation type for the print task settings. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before the settings were activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides data when an app is activated because it is the app associated with a URI scheme name. 
 */
declare class ProtocolActivatedEventArgs {

    /**
     * Gets the package family name of the application that activated the current application. 
     */
    callerPackageFamilyName: string;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Data received from the application that activated the current application. 
     */
    data: undefined.ValueSet;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the Uniform Resource Identifier (URI) for which the app was activated. 
     */
    uri: undefined.Uri;

    /**
     * Gets the view switcher object that allows you to set the view for the application. 
     */
    viewSwitcher: undefined.ActivationViewSwitcher
}


/**
 * Received by an application when it is launched by another application with the expectation that it will return results back to the caller. 
 */
declare class ProtocolForResultsActivatedEventArgs {

    /**
     * Gets the package family name of the application that activated the current application. 
     */
    callerPackageFamilyName: string;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Data received from the application that activated the current application. 
     */
    data: undefined.ValueSet;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the ProtocolForResultsOperation that you use to signal that your app is ready to return to the app that launched it for results. 
     */
    protocolForResultsOperation: undefined.ProtocolForResultsOperation;

    /**
     * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the Uniform Resource Identifier (URI) used to activate the app. 
     */
    uri: undefined.Uri;

    /**
     * Gets the view switcher object that allows you to set the view for the application. 
     */
    viewSwitcher: undefined.ActivationViewSwitcher
}


/**
 * Provides event information when a restricted app is launched. 
 */
declare class RestrictedLaunchActivatedEventArgs {

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets information about a shared context for the restricted launch. 
     */
    sharedContext: any;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about the activated event that fires when the user searches the app from the Search charm and the app isn't the main app on screen. 
 */
declare class SearchActivatedEventArgs {

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device. 
     */
    language: string;

    /**
     * Gets a SearchPaneQueryLinguisticDetails object that provides info about query text that the user enters through an Input Method Editor (IME). 
     */
    linguisticDetails: undefined.SearchPaneQueryLinguisticDetails;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the text that the user wants the app to search for. The user entered this text into the search box of the search pane. 
     */
    queryText: string;

    /**
     * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the view switcher object that allows you to set the view for the application. 
     */
    viewSwitcher: undefined.ActivationViewSwitcher
}


/**
 * Provides information for an application that is a target for share operations. 
 */
declare class ShareTargetActivatedEventArgs {

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets information about data included in a share operation. 
     */
    shareOperation: undefined.ShareOperation;

    /**
     * Gets the splash screen object which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides a dismissal event and image location information for the app's splash screen. 
 */
declare class SplashScreen {

    /**
     * The coordinates of the app's splash screen image relative to the window. 
     */
    imageLocation: undefined.Rect;

    /**
     * Fires when the app's splash screen is dismissed. 
     */
    ondismissed: undefined.TypedEventHandler<undefined.SplashScreen, any>;
    addEventListener(
        type: "dismissed",
        listener: undefined.TypedEventHandler<undefined.SplashScreen, any>): void;
    removeEventListener(
        type: "dismissed",
        listener: undefined.TypedEventHandler<undefined.SplashScreen, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides information about an event that occurs when the app is activated because a user tapped on the body of a toast notification or performed an action inside a toast notification. 
 */
declare class ToastNotificationActivatedEventArgs {

    /**
     * Gets the arguments that the app can retrieve after it is activated through an interactive toast notification. 
     */
    argument: string;

    /**
     * Gets the reason for the activation of the app for this event. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before the app was activated because a user tapped on the body of a toast notification or performed an action inside a toast notification. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets a set of values that you can use to obtain the user input from an interactive toast notification. 
     */
    userInput: undefined.ValueSet
}


/**
 * Contains info for the app's activated event when the app is launched through a voice command. 
 */
declare class VoiceCommandActivatedEventArgs {

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the SpeechRecognitionResult object representing the voice command that activated the app. 
     */
    result: undefined.SpeechRecognitionResult;

    /**
     * Gets info about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information to an app that was launched as the result of a wallet action. 
 */
declare class WalletActionActivatedEventArgs {

    /**
     * Gets the ID of the action, such as the id of the verb, transaction and so on. 
     */
    actionId: string;

    /**
     * Gets the action that was performed on the WalletItem . 
     */
    actionKind: undefined.WalletActionKind;

    /**
     * Gets the ID of the WalletItem on which the user performed the action. 
     */
    itemId: string;

    /**
     * Gets the type of action that was performed on the WalletItem . 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information to an app activated as a result of a web account provider operation. 
 */
declare class WebAccountProviderActivatedEventArgs {

    /**
     * Gets the kind of web account provider activation. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the web account provider operation. 
     */
    operation: undefined.IWebAccountProviderOperation;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information to an app that was launched after being suspended for a web authentication broker operation. 
 */
declare class WebAuthenticationBrokerContinuationEventArgs {

    /**
     * Gets a set of values populated by the app before a web authentication broker operation that deactivates the app in order to provide context when the app is activated. 
     */
    continuationData: undefined.ValueSet;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets a SplashScreen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the WebAuthenticationResult object returned from the web authentication broker operation. 
     */
    webAuthenticationResult: undefined.WebAuthenticationResult
}


/**
 * Provides common properties for all activation types. 
 */
declare interface Activation$IActivatedEventArgs {

    /**
     * Gets the reason that this app is being activated. 
     */
    kind: undefined.ActivationKind,

        /**
         * Gets the execution state of the app before this activation. 
         */
        previousExecutionState: undefined.ApplicationExecutionState,

        /**
         * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
         */
        splashScreen: undefined.SplashScreen
}


/**
 * Provides an application's name, description, and logo. 
 */
declare class AppDisplayInfo {

    /**
     * Gets the application's description. 
     */
    description: string;

    /**
     * Gets the application's display name. 
     */
    displayName: string;

    /**
     * Get the application's logo.
     * @param size The size of the rectangle in which the logo must fit.
     * @return  The largest logo in your Package.appxmanifest file that will fit in the specified Size.
     */
    getLogo(size: undefined.Size): undefined.RandomAccessStreamReference
}


/**
 * Provides information about an application such as it name, logo, package information, ID. 
 */
declare class AppInfo {

    /**
     * An identifier that uniquely identifies the app. 
     */
    appUserModelId: string;

    /**
     * Gets information that describes the application. 
     */
    displayInfo: undefined.AppDisplayInfo;

    /**
     * Gets the app identifier. 
     */
    id: string;

    /**
     * An identifier that uniquely identifies the app's package. 
     */
    packageFamilyName: string
}


/**
 * Enumerates the available app service providers on the device. 
 */
declare class AppServiceCatalog {
    findAppServiceProvidersAsync: any
}


/**
 * Provides data for the AppServiceConnection.ServiceClosed event that occurs when the other endpoint closes connection to the app service. 
 */
declare class AppServiceClosedEventArgs {

    /**
     * Gets the status that was set when the endpoint for the app service was closed. 
     */
    status: undefined.AppServiceClosedStatus
}


/**
 * Represents a connection to the endpoint for an app service. 
 */
declare class AppServiceConnection {

    /**
     * Creates and initializes a new instance of the AppServiceConnection class. 
     */
    constructor(): this;

    /**
     * Gets or sets the name of the app service to which you want to connect. 
     */
    appServiceName: string;

    /**
     * Closes the connection to the app service. 
     */
    close(): void;

    /**
     * Occurs when a message arrives from the other endpoint of the app service connection. 
     */
    onrequestreceived: undefined.TypedEventHandler<undefined.AppServiceConnection, undefined.AppServiceRequestReceivedEventArgs>;
    addEventListener(
        type: "requestreceived",
        listener: undefined.TypedEventHandler<undefined.AppServiceConnection, undefined.AppServiceRequestReceivedEventArgs>): void;
    removeEventListener(
        type: "requestreceived",
        listener: undefined.TypedEventHandler<undefined.AppServiceConnection, undefined.AppServiceRequestReceivedEventArgs>): void;

    /**
     * Occurs when the other endpoint closes the connection to the app service. 
     */
    onserviceclosed: undefined.TypedEventHandler<undefined.AppServiceConnection, undefined.AppServiceClosedEventArgs>;
    addEventListener(
        type: "serviceclosed",
        listener: undefined.TypedEventHandler<undefined.AppServiceConnection, undefined.AppServiceClosedEventArgs>): void;
    removeEventListener(
        type: "serviceclosed",
        listener: undefined.TypedEventHandler<undefined.AppServiceConnection, undefined.AppServiceClosedEventArgs>): void;

    /**
     * Opens a connection to the endpoint for the app service.
     * @return  An asynchronous operation to open a connection to the endpoint for the app service.
     */
    openAsync(): undefined.IPromiseWithIAsyncOperation<undefined.AppServiceConnectionStatus>;

    /**
     * Gets or sets the package family name for the package that contains the endpoint for the app service. 
     */
    packageFamilyName: string;

    /**
     * Sends a message to the other endpoint of the app service connection.
     * @param message The message that you want to send.
     * @return  An asynchronous operation to send the message that optionally returns a response message when complete.
     */
    sendMessageAsync(
        message: undefined.ValueSet): undefined.IPromiseWithIAsyncOperation<undefined.AppServiceResponse>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Enables the background task for an app service to get a deferral so that the app service can respond to subsequent requests. 
 */
declare class AppServiceDeferral {

    /**
     * Indicates that the content for an asynchronous handler for the AppServiceConnection.RequestReceived event is ready, or that an error occurred. 
     */
    complete(): void
}


/**
 * Represents a message that the endpoint for one app service sends to another app service. 
 */
declare class AppServiceRequest {

    /**
     * Gets the message that request from the app service contains. 
     */
    message: undefined.ValueSet;

    /**
     * Sends a response to a received request.
     * @param message The message that you want to include in the response.
     * @return  An asynchronous operation to send the response.
     */
    sendResponseAsync(
        message: undefined.ValueSet): undefined.IPromiseWithIAsyncOperation<undefined.AppServiceResponseStatus >
}


/**
 * Provides data for the AppServiceConnection.RequestReceived event that occurs when a message arrives from the other endpoint of the app service connection. 
 */
declare class AppServiceRequestReceivedEventArgs {

    /**
     * Informs the system that the event handler might continue to perform work after the event handler returns.
     * @return  The deferral.
     */
    getDeferral(): undefined.AppServiceDeferral;

    /**
     * Gets the request that was received from the app service. 
     */
    request: undefined.AppServiceRequest
}


/**
 * Represents the message that the app service sent in response to a request. 
 */
declare class AppServiceResponse {

    /**
     * Gets the message that the response from the app service contains. 
     */
    message: undefined.ValueSet;

    /**
     * Gets the status for the response from the app service. 
     */
    status: undefined.AppServiceResponseStatus
}


/**
 * Represents details associated with the background task for the app service. 
 */
declare class AppServiceTriggerDetails {

    /**
     * Gets the connection to the endpoint of the other app service. 
     */
    appServiceConnection: undefined.AppServiceConnection;

    /**
     * Gets the name of the package family for the client app that called the background task for the app service. 
     */
    callerPackageFamilyName: string;

    /**
     * Gets the name of the app service. 
     */
    name: string
}


/**
 * Represents an appointment in a calendar. This class is used when an app is activated using the AppointmentsProvider value for ActivationKind , as a value for AppointmentInformation properties. 
 */
declare class Appointment {

    /**
     * Initializes a new instance of the Appointment class. 
     */
    constructor(): this;

    /**
     * Gets or sets a Boolean value that indicates whether the appointment will last all day. The default is FALSE for won't last all day. 
     */
    allDay: boolean;

    /**
     * Gets or sets a value that indicates whether the appointment will allow users to propose a new time. 
     */
    allowNewTimeProposal: boolean;

    /**
     * Gets or sets a AppointmentBusyStatus -typed value that indicates the busy status for a participant of an appointment. 
     */
    busyStatus: undefined.AppointmentBusyStatus;

    /**
     * Gets the unique identifier for the calendar associated with the appointment. 
     */
    calendarId: string;

    /**
     * Gets the current change number of the local version of the Appointment . 
     */
    changeNumber: number;

    /**
     * Gets or sets a string value. The string contains extended details that describe the appointment. Details is of type String and a maximum of 1,073,741,823 characters in length, which is the maximum length of a JET database string. 
     */
    details: string;

    /**
     * Gets or sets the type of appointment details, plain text or HTML. 
     */
    detailsKind: undefined.AppointmentDetailsKind;

    /**
     * Gets or sets a time span that represents the time duration of the appointment. Duration is of type TimeSpan and must be non-negative. 
     */
    duration: number;

    /**
     * Gets a value that indicates whether the appointment has invitees. 
     */
    hasInvitees: boolean;

    /**
     * Gets the list of participants for the appointment. Invitees is of type IVector(AppointmentInvitee) . If an organizer is set and invitee length is greater than 0, a call to an AppointmentManager API fails with E_INVALIDARG. The number of invitees is unlimited. 
     */
    invitees: undefined.IVector<undefined.AppointmentInvitee>;

    /**
     * Gets or sets a value that indicates whether the appointment has been cancelled. 
     */
    isCanceledMeeting: boolean;

    /**
     * Gets or sets a value that indicates whether the appointment was organized by the current user. 
     */
    isOrganizedByUser: boolean;

    /**
     * Gets or sets a value that indicates whether a response to the appointment invitation is requested. 
     */
    isResponseRequested: boolean;

    /**
     * Gets a string that uniquely identifies the appointment on the local device. 
     */
    localId: string;

    /**
     * Gets or sets a string that communicates the physical location of the appointment. Location is of type String and a maximum of 32,768 characters in length. 
     */
    location: string;

    /**
     * Gets or sets a string value that is a URL used to join the online meeting for the appointment. 
     */
    onlineMeetingLink: string;

    /**
     * Gets or sets the organizer of the appointment. Organizer is of type AppointmentOrganizer . If an organizer is set and invitee length is greater than 0, a call to an AppointmentManager API fails with E_INVALIDARG. The number of invitees is unlimited. 
     */
    organizer: undefined.AppointmentOrganizer;

    /**
     * Gets the original starting time for a recurring appointment. 
     */
    originalStartTime: Date;

    /**
     * Gets or sets the object that describes when and how often the appointment occurs. Recurrence is of type AppointmentRecurrence . 
     */
    recurrence: undefined.AppointmentRecurrence;

    /**
     * Gets or sets a time span value. The value declares the amount of time to subtract from the StartTime , and that time used as the issue time for a reminder for an appointment. A null value indicates that the appointment will not issue a reminder. Reminder is of type IReference(TimeSpan) . 
     */
    reminder: number;

    /**
     * Gets or sets the current change number of the server version of the Appointment . 
     */
    remoteChangeNumber: number;

    /**
     * Gets or sets the date and time that the user responded to the appointment request. 
     */
    replyTime: Date;

    /**
     * Gets or sets a string that uniquely identifies an appointment across devices. 
     */
    roamingId: string;

    /**
     * Gets or sets a AppointmentSensitivity -typed value that indicates the sensitivity of the appointment. 
     */
    sensitivity: undefined.AppointmentSensitivity;

    /**
     * Gets or sets the starting time for the appointment. StartTime is of type DateTime . 
     */
    startTime: Date;

    /**
     * Gets or sets a string that communicates the subject of the appointment. Subject is of type String and a maximum of 255 characters in length. 
     */
    subject: string;

    /**
     * Gets the Uniform Resource Identifier ( Uri ) for the appointment. Allows the Calendar app to perform an association launch to go back to the source app or other URI that represents this appointment. 
     */
    uri: undefined.Uri;

    /**
     * Gets or sets the user's response to the appointment request. 
     */
    userResponse: undefined.AppointmentParticipantResponse
}


/**
 * Represents a calendar with appointments. 
 */
declare class AppointmentCalendar {

    /**
     * Gets or sets a Boolean value that indicates if the calendar supports cancelling meetings. 
     */
    canCancelMeetings: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the calendar supports creating or updating appointments. 
     */
    canCreateOrUpdateAppointments: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the calendar supports forwarding meetings. 
     */
    canForwardMeetings: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the calendar supports notifying attendees. 
     */
    canNotifyInvitees: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the calendar supports proposing new meeting times. 
     */
    canProposeNewTimeForMeetings: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the calendar supports updating meeting responses. 
     */
    canUpdateMeetingResponses: boolean;

    /**
     * Asynchronously deletes the appointment with the specified ID.
     * @param localId The LocalId of the appointment to be deleted.
     * @return  An asynchronous action.
     */
    deleteAppointmentAsync(localId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously deletes the appointment instance with the specified start time of a master appointment with the specified ID.
     * @param localId The LocalId of the master appointment associated with the appointment instance to be deleted.
     * @param instanceStartTime The start time of the appointment instance to be deleted.
     * @return  An asynchronous action.
     */
    deleteAppointmentInstanceAsync(localId: string, instanceStartTime: Date): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously deletes the appointment calendar.
     * @return  An asynchrounous action.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the color that the built-in calendar app uses for appointments associated with the calendar. 
     */
    displayColor: undefined.Color;

    /**
     * Gets a string representing the display name for the AppointmentCalendar . 
     */
    displayName: string;

    /**
     * Asynchronously retrieves a list of appointment instances of the specified master appointment that meet the specified criteria.
     * @param masterLocalId The LocalId of the master appointment for which appointment instances are retrieved.
     * @param rangeStart The start time of the time window for which appointment instances are retrieved.
     * @param rangeLength The length of the time window for which appointment instances are retrieved.
     * @param pOptions A FindAppointmentsOptions object that is used to specify more options for this operation.
     * @return  An asynchronous operation that returns IVectorView on successful completion.
     */
    findAllInstancesAsync(
        masterLocalId: string,
        rangeStart: Date,
        rangeLength: number,
        pOptions: undefined.FindAppointmentsOptions): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously retrieves a list of appointment instances of the specified master appointment that meet the specified criteria.
     * @param masterLocalId The LocalId of the master appointment for which appointment instances are retrieved.
     * @param rangeStart The start time of the time window for which appointment instances are retrieved.
     * @param rangeLength The length of the time window for which appointment instances are retrieved.
     * @return  An asynchronous operation that returns IVectorView on successful completion.
     */
    findAllInstancesAsync(
        masterLocalId: string,
        rangeStart: Date,
        rangeLength: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously retrieves a list of appointments belonging to the current AppointmentCalendar that meet the specified criteria.
     * @param rangeStart The start time of the time window for which appointments are retrieved.
     * @param rangeLength The length of the time window for which appointments are retrieved.
     * @return  An asynchronous operation that returns IVectorView on successful completion.
     */
    findAppointmentsAsync(
        rangeStart: Date,
        rangeLength: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously retrieves a list of appointments belonging to the current AppointmentCalendar that meet the specified criteria.
     * @param rangeStart The start time of the time window for which appointments are retrieved.
     * @param rangeLength The length of the time window for which appointments are retrieved.
     * @param options A FindAppointmentsOptions object that is used to specify more options for this operation.
     * @return  An asynchronous operation that returns IVectorView on successful completion.
     */
    findAppointmentsAsync(
        rangeStart: Date,
        rangeLength: number,
        options: undefined.FindAppointmentsOptions): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously retrieves a list of appointment instances that are exceptions from the specified master appointment.
     * @param masterLocalId The LocalId of the master appointment for which exceptional appointment instances are retrieved.
     * @return  An asynchronous operation that returns IVectorView on successful completion.
     */
    findExceptionsFromMasterAsync(
        masterLocalId: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously retrieves a list of appointments that meet the specified criteria.
     * @param options A FindAppointmentsOptions object that is used to specify more options for this operation.
     * @return  An asynchronous operation that returns IVectorView on successful completion.
     */
    findUnexpandedAppointmentsAsync(
        options: undefined.FindAppointmentsOptions): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously retrieves a list of appointments that meet the specified criteria.
     * @return  An asynchronous operation that returns IVectorView on successful completion.
     */
    findUnexpandedAppointmentsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously retrieves the Appointment with the specified ID.
     * @param localId The LocalId of the appointment to be retrieved.
     * @return  An asynchronous operation that returns Appointment on successful completion.
     */
    getAppointmentAsync(localId: string): undefined.IPromiseWithIAsyncOperation<undefined.Appointment>;

    /**
     * (Applies to Windows Phone only) Asynchronously retrieves the Appointment with the specified ID and includes data for the specified properties.
     * @param localId The LocalId of the appointment to be retrieved.
     * @param prefetchProperties A list of names of the properties for which data should be included when the appointment is retrieved.
     * @return  An asynchronous operation that returns Appointment on successful completion.
     */
    getAppointmentAsync(
        localId: string,
        prefetchProperties: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.Appointment>;

    /**
     * Asynchronously retrieves the appointment instance of the specified master appointment that has the specified start time.
     * @param localId The ID of the master appointment to which the retrieved appointment instance belongs.
     * @param instanceStartTime The start time of the appointment instance to be retrieved.
     * @return  An asynchronous operation that returns Appointment on successful completion.
     */
    getAppointmentInstanceAsync(
        localId: string,
        instanceStartTime: Date): undefined.IPromiseWithIAsyncOperation<undefined.Appointment>;

    /**
     * Gets whether the AppointmentCalendar is hidden in the device's built-in calendar UI. 
     */
    isHidden: boolean;

    /**
     * Gets a string that uniquely identifies the appointment calendar on the local device. 
     */
    localId: string;

    /**
     * Gets or sets a Boolean value that indicates if invitees must be sent notifications. 
     */
    mustNofityInvitees: boolean;

    /**
     * Gets or sets a boolean value indicating whether other apps on the device have read access to the appointment calendar. 
     */
    otherAppReadAccess: undefined.AppointmentCalendarOtherAppReadAccess;

    /**
     * Gets or sets a boolean value indicating whether other apps on the device have write access to the appointment calendar. 
     */
    otherAppWriteAccess: undefined.AppointmentCalendarOtherAppWriteAccess;

    /**
     * Gets the remote ID for the AppointmentCalendar . 
     */
    remoteId: string;

    /**
     * Asynchronously saves the provided appointment to the calendar.
     * @param pAppointment The appointment to be saved.
     * @return  An asynchronous action.
     */
    saveAppointmentAsync(pAppointment: undefined.Appointment): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously saves changes to the appointment calendar.
     * @return  An asynchronous action.
     */
    saveAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets a string that describes the provider for the appointment calendar. 
     */
    sourceDisplayName: string;

    /**
     * Gets or sets how the summary card for the calendar's appointments are displayed. 
     */
    summaryCardView: undefined.AppointmentSummaryCardView;

    /**
     * Gets the AppointmentCalendarSyncManager which can be used to sync with the remote server. 
     */
    syncManager: undefined.AppointmentCalendarSyncManager;

    /**
     * Asynchronously attempts to cancel a meeting.
     * @param meeting The meeting to cancel.
     * @param subject The subject for the cancellation notification.
     * @param comment The body of the cancellation notification.
     * @param notifyInvitees A Boolean value indicating if invitees should be notified.
     * @return  A Boolean value indicating if the operation was successful.
     */
    tryCancelMeetingAsync(
        meeting: undefined.Appointment,
        subject: string,
        comment: string,
        notifyInvitees: boolean): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to create or update a meeting.
     * @param appointment The meeting to create or update.
     * @param notifyInvitees A Boolean value indicating if invitees should be notified.
     * @return  A Boolean value indicating if the operation was successful.
     */
    tryCreateOrUpdateAppointmentAsync(
        appointment: undefined.Appointment,
        notifyInvitees: boolean): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to forward a meeting.
     * @param meeting The meeting to forward.
     * @param invitees A list of new invitees to receive the forwarded meeting.
     * @param subject The subject of the meeting invitation.
     * @param forwardHeader A new meeting header that includes the new invitees.
     * @param comment The body of the forwarded meeting invitation.
     * @return  A Boolean value indicating if the operation was successful.
     */
    tryForwardMeetingAsync(
        meeting: undefined.Appointment,
        invitees: undefined.IIterable<undefined.AppointmentInvitee>,
        subject: string,
        forwardHeader: string,
        comment: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to propose a new meeting time.
     * @param meeting The meeting to update.
     * @param newStartTime The proposed new start time.
     * @param newDuration A new duration for the meeting.
     * @param subject The subject of the meeting invitation.
     * @param comment The body of the meeting invitation.
     * @return  A Boolean value indicating if the operation was successful.
     */
    tryProposeNewTimeForMeetingAsync(
        meeting: undefined.Appointment,
        newStartTime: Date,
        newDuration: number,
        subject: string,
        comment: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to update the response to a meeting invitation.
     * @param meeting The meeting to update.
     * @param response The response to the meeting invitation, such as accept, tentative or decline.
     * @param subject The subject of the response.
     * @param comment The body of the response.
     * @param sendUpdate A Boolean value indicating whether or not to send the response to the meeting organizer.
     * @return  A Boolean value indicating if the operation was successful.
     */
    tryUpdateMeetingResponseAsync(
        meeting: undefined.Appointment,
        response: undefined.AppointmentParticipantResponse,
        subject: string,
        comment: string,
        sendUpdate: boolean): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Get the identifier of the user account data for the AppointmentCalendar . 
     */
    userDataAccountId: string
}


/**
 * Provides access to sync functionality for an AppointmentCalendar object. 
 */
declare class AppointmentCalendarSyncManager {

    /**
     * Gets the last date and time that a sync with the AppointmentCalendar server was attempted. 
     */
    lastAttemptedSyncTime: Date;

    /**
     * Gets the last date and time that a sync with the AppointmentCalendar server was successful. 
     */
    lastSuccessfulSyncTime: Date;

    /**
     * Occurs when the status of an AppointmentCalendar sync operation changes. 
     */
    onsyncstatuschanged: undefined.TypedEventHandler<undefined.AppointmentCalendarSyncManager, any>;
    addEventListener(
        type: "syncstatuschanged",
        listener: undefined.TypedEventHandler<undefined.AppointmentCalendarSyncManager, any>): void;
    removeEventListener(
        type: "syncstatuschanged",
        listener: undefined.TypedEventHandler<undefined.AppointmentCalendarSyncManager, any>): void;

    /**
     * Gets the current status of the AppointmentCalendarSyncManager . 
     */
    status: undefined.AppointmentCalendarSyncStatus;

    /**
     * Initiates a sync operation on the AppointmentCalendar .
     * @return  A Boolean value indicating if the sync was successfully initiated.
     */
    syncAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a conflict between appointments. 
 */
declare class AppointmentConflictResult {

    /**
     * Gets the date of the appointment conflict. 
     */
    date: Date;

    /**
     * Gets a value indicating the type of appointment conflict. 
     */
    type: undefined.AppointmentConflictType
}


/**
 * Represents an appointment instance that is an exception from the master appointment. 
 */
declare class AppointmentException {

    /**
     * Gets the appointment that is an exception from the master appointment. 
     */
    appointment: undefined.Appointment;

    /**
     * Gets a list of the names of the appointment properties for which an exception was found. 
     */
    exceptionProperties: undefined.IVectorView<string>;

    /**
     * Gets a value indicating whether the exception is that the appointment instance has been deleted. 
     */
    isDeleted: boolean
}


/**
 * Represents a participant of an appointment in a calendar. 
 */
declare class AppointmentInvitee {

    /**
     * Initializes a new instance of the AppointmentInvitee class. 
     */
    constructor(): this;

    /**
     * Gets or sets a string that communicates the address of a participant of an appointment. The address is inherited from IAppointmentParticipant and is a Simple Mail Transfer Protocol (SMTP) e-mail address. It is also of type String and between 1 and 321 characters in length (non-empty). 
     */
    address: string;

    /**
     * Gets or sets a string that communicates the display name of a participant of an appointment. The display name is inherited from IAppointmentParticipant , of type String , and a maximum of 256 characters in length. 
     */
    displayName: string;

    /**
     * Gets or sets a AppointmentParticipantResponse -typed value that indicates the response from a participant concerning an appointment invitation. 
     */
    response: undefined.AppointmentParticipantResponse;

    /**
     * Gets or sets a AppointmentParticipantRole -typed value that indicates the role of a participant concerning an appointment invitation. 
     */
    role: undefined.AppointmentParticipantRole
}


/**
 * Provides APIs to interact with the user’s Appointments provider app (for example, the Calendar app). Call static methods to display provider-specific UI so that the user can perform tasks. 
 */
declare class AppointmentManager {

    /**
     * Requests the AppointmentStore object associated with the calling application.
     * @param options An AppointmentStoreAccessType value indicating the level of access the returned appointment store will have.
     * @return  An asynchronous operation that returns an AppointmentStore upon successful completion.
     */
    requestStoreAsync(
        options: undefined.AppointmentStoreAccessType): undefined.IPromiseWithIAsyncOperation<undefined.AppointmentStore>;

    /**
     * Shows the Appointments provider Add Appointment UI, to enable the user to add an appointment.
     * @param appointment The object representing the information for the appointment to add.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Add Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Add Appointment UI displays around the button, not overlapping it.
     * @param preferredPlacement The Placement that describes the preferred placement of the Add Appointment UI.
     * @return  When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not added to the Appointments provider app.
     */
    showAddAppointmentAsync(
        appointment: undefined.Appointment,
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Shows the Appointments provider Add Appointment UI, to enable the user to add an appointment.
     * @param appointment The object representing the information for the appointment to add.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Add Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Add Appointment UI displays around the button, not overlapping it.
     * @return  When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not added to the Appointments provider app.
     */
    showAddAppointmentAsync(
        appointment: undefined.Appointment,
        selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
     * @param appointmentId The LocalId of the appointment to be displayed.
     * @return  An asynchronous action.
     */
    showAppointmentDetailsAsync(appointmentId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
     * @param appointmentId The LocalId of the appointment to be displayed.
     * @param instanceStartDate A DateTime object with the start time of the appointment instance to be displayed.
     * @return  An asynchronous action.
     */
    showAppointmentDetailsAsync(
        appointmentId: string,
        instanceStartDate: Date): undefined.IPromiseWithIAsyncAction;

    /**
     * Shows the Appointments provider Add Appointment UI including the full edit experience, to enable the user to add an appointment.
     * @param appointment The appointment to be added.
     * @return  An asynchronous operation that returns a string containing an appointment ID upon successful completion.
     */
    showEditNewAppointmentAsync(
        appointment: undefined.Appointment): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
     * @param appointmentId The appointment identifier. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync call.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
     * @return  When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
     */
    showRemoveAppointmentAsync(
        appointmentId: string,
        selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
     * @param appointmentId The appointment identifier. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync call.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
     * @param preferredPlacement The Placement that describes the preferred placement of the Remove Appointment UI.
     * @return  When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
     */
    showRemoveAppointmentAsync(
        appointmentId: string,
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
     * @param appointmentId The appointment identifier. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync call.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
     * @param preferredPlacement The Placement that describes the preferred placement of the Remove Appointment UI.
     * @param instanceStartDate The start date and time of the appointment instance to remove.
     * @return  When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
     */
    showRemoveAppointmentAsync(
        appointmentId: string,
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement,
        instanceStartDate: Date): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
     * @param appointmentId The appointment identifier of the current appointment. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync or ShowReplaceAppointmentAsync call.
     * @param appointment The object representing the information for the appointment to replace the current appointment.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
     * @return  When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not replaced in the Appointments provider app.
     */
    showReplaceAppointmentAsync(
        appointmentId: string,
        appointment: undefined.Appointment,
        selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
     * @param appointmentId The appointment identifier of the current appointment. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync or ShowReplaceAppointmentAsync call.
     * @param appointment The object representing the information for the appointment to replace the current appointment.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
     * @param preferredPlacement The Placement that describes the preferred placement of the Replace Appointment UI.
     * @param instanceStartDate The start date and time of the appointment instance to replace.
     * @return  When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not replaced in the Appointments provider app.
     */
    showReplaceAppointmentAsync(
        appointmentId: string,
        appointment: undefined.Appointment,
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement,
        instanceStartDate: Date): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
     * @param appointmentId The appointment identifier of the current appointment. This is typically obtained from the async return value of a previous ShowAddAppointmentAsync or ShowReplaceAppointmentAsync call.
     * @param appointment The object representing the information for the appointment to replace the current appointment.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
     * @param preferredPlacement The Placement that describes the preferred placement of the Replace Appointment UI.
     * @return  When this method completes, it returns a String object that represents the appointment. This serves as an appointment identifier for future reference when updating or removing. If the appointment identifier returned is an empty string, the appointment was not replaced in the Appointments provider app.
     */
    showReplaceAppointmentAsync(
        appointmentId: string,
        appointment: undefined.Appointment,
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Shows the Appointments provider app's primary UI. This typically displays a time frame from an appointments calendar.
     * @param timeToShow A date and time object that specifies the beginning of the time frame that the Appointments provider app should display.
     * @param duration A timespan that hints to the Appointments provider app how long the time frame shown should be.
     * @return  When this method returns, it does not return a result. On completion, the AsyncActionCompletedHandler specified by get_Completed / Completed is invoked.
     */
    showTimeFrameAsync(timeToShow: Date, duration: number): undefined.IPromiseWithIAsyncAction
}


/**
 * Represents the organizer of an appointment in a calendar. 
 */
declare class AppointmentOrganizer {

    /**
     * Initializes a new instance of the AppointmentOrganizer class. 
     */
    constructor(): this;

    /**
     * Gets or sets a string that communicates the address of the organizer of an appointment. The address is required, inherited from IAppointmentParticipant , and a Simple Mail Transfer Protocol (SMTP) e-mail address. It is also of type String and between 1 and 321 characters in length (non-empty). 
     */
    address: string;

    /**
     * Gets or sets a string that communicates the display name of the organizer of an appointment. The display name is optional, inherited from IAppointmentParticipant , of type String , and a maximum of 256 characters in length. 
     */
    displayName: string
}


/**
 * Provides strings that identify the properties of an appointment. 
 */
declare class AppointmentProperties {

    /**
     * Gets the name of the AllDay property. 
     */
    allDay: string;

    /**
     * Gets the name of AllowNewTimeProposal the property. 
     */
    allowNewTimeProposal: string;

    /**
     * Gets the name of the BusyStatus property. 
     */
    busyStatus: string;

    /**
     * Gets the current change number of the local version of the Appointment . 
     */
    changeNumber: string;

    /**
     * Gets a list of names for the default appointment properties. 
     */
    defaultProperties: undefined.IVector<string>;

    /**
     * Gets the name of the Details property. 
     */
    details: string;
    detailsKind: any;

    /**
     * Gets the name of the Duration property. 
     */
    duration: string;

    /**
     * Gets the name of the HasInvitees property. 
     */
    hasInvitees: string;

    /**
     * Gets the name of the Invitees property. 
     */
    invitees: string;

    /**
     * Gets the name of the IsCanceledMeeting property. 
     */
    isCanceledMeeting: string;

    /**
     * Gets the name of the IsOrganizedByUser property. 
     */
    isOrganizedByUser: string;

    /**
     * Gets the name of the IsResponseRequested property. 
     */
    isResponseRequested: string;

    /**
     * Gets the name of the Location property. 
     */
    location: string;

    /**
     * Gets the name of the OnlineMeetingLink property. 
     */
    onlineMeetingLink: string;

    /**
     * Gets the name of the Organizer property. 
     */
    organizer: string;

    /**
     * Gets the name of the OriginalStartTime property. 
     */
    originalStartTime: string;

    /**
     * Gets the name of the Recurrence property. 
     */
    recurrence: string;

    /**
     * Gets the name of the Reminder property. 
     */
    reminder: string;
    remoteChangeNumber: any;

    /**
     * Gets the name of the ReplyTime property. 
     */
    replyTime: string;

    /**
     * Gets the name of the Sensitivity property. 
     */
    sensitivity: string;

    /**
     * Gets the name of the StartTime property. 
     */
    startTime: string;

    /**
     * Gets the name of the Subject property. 
     */
    subject: string;

    /**
     * Gets the name of the Uri property. 
     */
    uri: string;

    /**
     * Gets the name of the UserResponse property. 
     */
    userResponse: string
}


/**
 * Represents when and how often an appointment occurs. 
 */
declare class AppointmentRecurrence {

    /**
     * Initializes a new instance of the AppointmentRecurrence class. 
     */
    constructor(): this;
    calendarIdentifier: any;

    /**
     * Gets or sets the day on which an appointment occurs. Day is of type UInt32 , has a default value of 1, and can be a value from 1 to 31. 
     */
    day: number;

    /**
     * Gets or sets a combination of AppointmentDaysOfWeek -typed values for all the days of the week on which an appointment occurs. 
     */
    daysOfWeek: undefined.AppointmentDaysOfWeek;

    /**
     * Gets or sets the interval between occurrences of an appointment. Interval is of type UInt32 and has a default value of 1. For daily, the interval is the number of days in between, for weekly, the number of weeks, and so on. 
     */
    interval: number;

    /**
     * Gets or sets the month on which an appointment occurs. Month is of type UInt32 , has a default value of 1, and can be a value from 1 to 12. 
     */
    month: number;

    /**
     * Gets or sets the number of times an appointment recurs. Occurrences is of type IReference(UInt32) and is NULL by default. Occurrences is mutually exclusive with Until . 
     */
    occurrences: number;

    /**
     * Gets a value indicating what type of recurrence applies to the associated appointment. 
     */
    recurrenceType: undefined.RecurrenceType;

    /**
     * Gets or sets the time zone for the recurrence. 
     */
    timeZone: string;

    /**
     * Gets or sets a AppointmentRecurrenceUnit -typed value that indicates the frequency for which the appointment occurs. 
     */
    unit: undefined.AppointmentRecurrenceUnit;

    /**
     * Gets or sets the date and time until which an appointment is valid. Until is of type IReference(DateTime) and is NULL by default. Until is mutually exclusive with Occurrences . 
     */
    until: Date;

    /**
     * Gets or sets a AppointmentWeekOfMonth -typed value that indicates the week of the month for which the appointment occurs. The first week is the default. 
     */
    weekOfMonth: undefined.AppointmentWeekOfMonth
}


/**
 * Represents a store that contains appointments. 
 */
declare class AppointmentStore {

    /**
     * Returns the AppointmentStoreChangeTracker associated with the appointment store. 
     */
    changeTracker: undefined.AppointmentStoreChangeTracker;

    /**
     * Asynchronously creates a new AppointmentCalendar within the appointment store using the specified parameters.
     * @param name The name for the new AppointmentCalendar .
     * @return  An async operation that provides access to the newly created AppointmentCalendar .
     */
    createAppointmentCalendarAsync(
        name: string): undefined.IPromiseWithIAsyncOperation<undefined.AppointmentCalendar>;

    /**
     * Asynchronously creates a new AppointmentCalendar within the appointment store with the specified name and user data account ID.
     * @param name The name for the new AppointmentCalendar .
     * @param userDataAccountId The identifier for the user data account used to create the AppointmentCalendar .
     * @return  An async operation that provides access to the newly created AppointmentCalendar .
     */
    createAppointmentCalendarAsync(
        name: string,
        userDataAccountId: string): undefined.IPromiseWithIAsyncOperation<undefined.AppointmentCalendar>;

    /**
     * Retrieves a list of appointment calendars in the appointment store that meet the criteria specified by the supplied FindAppointmentCalendarsOptions object..
     * @param options The object that specifies the criteria that determines which appointment calendars are returned.
     * @return  An asynchronous operation that returns an IVectorView upon successful completion.
     */
    findAppointmentCalendarsAsync(
        options: undefined.FindAppointmentCalendarsOptions): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a list of all of the appointment calendars in the appointment store.
     * @return  An asynchronous operation that returns an IVectorView upon successful completion.
     */
    findAppointmentCalendarsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a list of appointments in the appointment calendar that fall within the specified date range.
     * @param rangeStart The start of the date range for which appointments are retrieved.
     * @param rangeLength The length of the date range for which appointments are retrieved.
     * @return  An asynchronous operation that returns an IVectorView upon successful completion.
     */
    findAppointmentsAsync(
        rangeStart: Date,
        rangeLength: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a list of appointments in the appointment calendar that fall within the specified date range and meet the criteria specified by the supplied FindAppointmentsOptions object..
     * @param rangeStart The start of the date range for which appointments are retrieved.
     * @param rangeLength The length of the date range for which appointments are retrieved.
     * @param options The object that specifies the criteria that determines which appointments are returned.
     * @return  An asynchronous operation that returns an IVectorView upon successful completion.
     */
    findAppointmentsAsync(
        rangeStart: Date,
        rangeLength: number,
        options: undefined.FindAppointmentsOptions): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Returns an AppointmentConflictResult representing a conflict between the specified appointment and an existing appointment instance in the appointment store.
     * @param appointment The appointment for which a conflict is sought.
     * @param instanceStartTime The start time of the appointment instance for which a conflict is sought.
     * @return  An asynchronous operation that returns an AppointmentConflictResult upon successful completion.
     */
    findConflictAsync(
        appointment: undefined.Appointment,
        instanceStartTime: Date): undefined.IPromiseWithIAsyncOperation<undefined.AppointmentConflictResult>;

    /**
     * Returns an AppointmentConflictResult representing a conflict between the specified appointment and an existing appointment in the appointment store.
     * @param appointment The appointment for which a conflict is sought.
     * @return  An asynchronous operation that returns an AppointmentConflictResult upon successful completion.
     */
    findConflictAsync(
        appointment: undefined.Appointment): undefined.IPromiseWithIAsyncOperation<undefined.AppointmentConflictResult>;

    /**
     * Returns a list of LocalId values for appointment instances with the specified RoamingId value.
     * @param roamingId The RoamingId value for which local ID values are sought.
     * @return  An asynchronous operation that returns an IVectorView upon successful completion.
     */
    findLocalIdsFromRoamingIdAsync(
        roamingId: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves the Appointment with the specified LocalId .
     * @param localId The LocalId of the appointment to be retrieved.
     * @return  An asynchronous operation that returns an Appointment upon successful completion.
     */
    getAppointmentAsync(localId: string): undefined.IPromiseWithIAsyncOperation<undefined.Appointment>;

    /**
     * Retrieves the AppointmentCalendar with the specified LocalId or RemoteId .
     * @param calendarId The LocalId or RemoteId of the AppointmentCalendar to be retrieved.
     * @return  An asynchronous operation that returns an AppointmentCalendar upon successful completion.
     */
    getAppointmentCalendarAsync(
        calendarId: string): undefined.IPromiseWithIAsyncOperation<undefined.AppointmentCalendar>;

    /**
     * Retrieves the instance of the Appointment with the specified LocalId and the specified start time.
     * @param localId The LocalId of the appointment instance to be retrieved.
     * @param instanceStartTime The start time of the appointment instance to be retrieved.
     * @return  An asynchronous operation that returns an Appointment upon successful completion.
     */
    getAppointmentInstanceAsync(
        localId: string,
        instanceStartTime: Date): undefined.IPromiseWithIAsyncOperation<undefined.Appointment>;

    /**
     * Moves the specified Appointment object to the specified AppointmentCalendar .
     * @param appointment The appointment to be moved.
     * @param destinationCalendar The appointment calendar to which the appointment is moved.
     * @return  An asynchronous action.
     */
    moveAppointmentAsync(
        appointment: undefined.Appointment,
        destinationCalendar: undefined.AppointmentCalendar): undefined.IPromiseWithIAsyncAction;

    /**
     * Occurs when the AppointmentStore changes. 
     */
    onstorechanged: undefined.TypedEventHandler<undefined.AppointmentStore, undefined.AppointmentStoreChangedEventArgs>;
    addEventListener(
        type: "storechanged",
        listener: undefined.TypedEventHandler<undefined.AppointmentStore, undefined.AppointmentStoreChangedEventArgs>): void;
    removeEventListener(
        type: "storechanged",
        listener: undefined.TypedEventHandler<undefined.AppointmentStore, undefined.AppointmentStoreChangedEventArgs>): void;

    /**
     * Shows the Appointments provider Add Appointment UI, to enable the user to add an appointment.
     * @param appointment The object representing the information for the appointment to add.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Add Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Add Appointment UI displays around the button, not overlapping it.
     * @return  When this method completes, it returns a String object that represents the RoamingId of the appointment. If the appointment identifier returned is an empty string, the appointment was not added to the Appointments provider app.
     */
    showAddAppointmentAsync(
        appointment: undefined.Appointment,
        selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
     * @param localId The LocalId of the appointment to be displayed.
     * @return  An asynchronous action.
     */
    showAppointmentDetailsAsync(localId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Shows the Appointments provider Appointment Details UI, to enable the user to view the specified appointment.
     * @param localId The LocalId of the appointment to be displayed.
     * @param instanceStartDate A DateTime object with the start time of the appointment instance to be displayed.
     * @return  An asynchronous action.
     */
    showAppointmentDetailsAsync(localId: string, instanceStartDate: Date): undefined.IPromiseWithIAsyncAction;

    /**
     * Shows the Appointments provider Add Appointment UI including the full edit experience, to enable the user to add an appointment.
     * @param appointment The appointment to be added.
     * @return  When this method completes, it returns a String object that represents the RoamingId of the appointment. If the appointment identifier returned is an empty string, the appointment was not added to the Appointments provider app.
     */
    showEditNewAppointmentAsync(
        appointment: undefined.Appointment): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
     * @param localId The LocalId of the appointment to be removed.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
     * @return  When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
     */
    showRemoveAppointmentAsync(
        localId: string,
        selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Shows the Appointments provider Remove Appointment UI, to enable the user to remove an appointment.
     * @param localId The LocalId of the appointment to be removed.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Remove Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Remove Appointment UI displays around the button, not overlapping it.
     * @param preferredPlacement The Placement that describes the preferred placement of the Remove Appointment UI.
     * @param instanceStartDate The start date and time of the appointment instance to remove.
     * @return  When this method completes, it returns a Boolean value that indicates whether the Appointment provider app removed the appointment.
     */
    showRemoveAppointmentAsync(
        localId: string,
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement,
        instanceStartDate: Date): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
     * @param localId The LocalId of the appointment to be replaced.
     * @param appointment The object representing the appointment to replace the existing appointment.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
     * @return  When this method completes, it returns a String object that represents the RoamingId of the appointment that replaced the existing appointment.
     */
    showReplaceAppointmentAsync(
        localId: string,
        appointment: undefined.Appointment,
        selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Shows the Appointments provider Replace Appointment UI, to enable the user to replace an appointment.
     * @param localId The LocalId of the appointment to be replaced.
     * @param appointment The object representing the appointment to replace the existing appointment.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the Replace Appointment UI, not within that rectangular area. For example, if an app uses a button to show the Rect, pass the Rect of the button so the Replace Appointment UI displays around the button, not overlapping it.
     * @param preferredPlacement The Placement that describes the preferred placement of the Replace Appointment UI.
     * @param instanceStartDate The start date and time of the appointment instance to replace.
     * @return  When this method completes, it returns a String object that represents the RoamingId of the appointment that replaced the existing appointment.
     */
    showReplaceAppointmentAsync(
        localId: string,
        appointment: undefined.Appointment,
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement,
        instanceStartDate: Date): undefined.IPromiseWithIAsyncOperation<string>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a change that has occurred in an appointment store. 
 */
declare class AppointmentStoreChange {

    /**
     * Gets the Appointment associated with the change. 
     */
    appointment: undefined.Appointment;

    /**
     * Gets the AppointmentCalendar in which the change occurred. 
     */
    appointmentCalendar: undefined.AppointmentCalendar;

    /**
     * Gets an AppointmentStoreChangeType value indicating the type of change represented by the object. 
     */
    changeType: undefined.AppointmentStoreChangeType
}


/**
 * Enables the calling app to read through the changes to appointments in its appointment store. 
 */
declare class AppointmentStoreChangeReader {

    /**
     * Tells the system that all of the changes to appointments returned by the call to ReadBatchAsync have been addressed by the app. 
     */
    acceptChanges(): void;

    /**
     * Tells the system that all of the changes to appointments returned by the call to ReadBatchAsync , up to the specified AppointmentStoreChange , have been addressed by the app.
     * @param lastChangeToAccept The AppointmentStoreChange object indicating the latest change that has been addressed by the app.
     */
    acceptChangesThrough(lastChangeToAccept: undefined.AppointmentStoreChange): void;

    /**
     * Returns a list of the changes that have occurred in the appointment store that have not yet been accepted by the calling app.
     * @return  An asynchronous operation that returns an IVectorView upon successful completion.
     */
    readBatchAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >>
}


/**
 * Provides APIs for managing change tracking for appointments. 
 */
declare class AppointmentStoreChangeTracker {
    enable: any;
    getChangeReader: any;
    reset: any
}


/**
 * Represents a background task deferral returned by the AppointmentStoreChangedEventArgs.GetDeferral method. 
 */
declare class AppointmentStoreChangedDeferral {

    /**
     * Informs the system that an asynchronous operation associated with an AppointmentStore has finished. 
     */
    complete(): void
}


/**
 * Provides data for a StoreChanged event. 
 */
declare class AppointmentStoreChangedEventArgs {

    /**
     * Gets the deferral object for the StoreChanged event.
     * @return  The deferral object for the StoreChanged event.
     */
    getDeferral(): undefined.AppointmentStoreChangedDeferral
}


/**
 * Passed to a background task to indicate that the task was invoked by an AppointmentStore . 
 */
declare class AppointmentStoreNotificationTriggerDetails {}


/**
 * Represents the operation object associated with adding a new appointment. Appointments provider apps use this info to perform the operation. 
 */
declare class AddAppointmentOperation {

    /**
     * Gets the Appointment info from the activation request. 
     */
    appointmentInformation: undefined.Appointment;

    /**
     * Dismisses the UI for the operation that adds a new appointment. 
     */
    dismissUI(): void;

    /**
     * Call this method to inform the activating app that the operation was canceled by the user. 
     */
    reportCanceled(): void;

    /**
     * Call this method to inform the activating app that the operation was completed successfully. Provide a unique appointment ID as the itemID parameter.
     * @param itemId A unique appointment ID that the activating app can later use to remove this appointment if necessary.
     */
    reportCompleted(itemId: string): void;

    /**
     * Informs the activating app that the operation couldn't be completed because of a provider error.
     * @param value A string that contains info about the error.
     */
    reportError(value: string): void;

    /**
     * Gets the package family name of the app that is requesting the operation. 
     */
    sourcePackageFamilyName: string
}


/**
 * Represents the object associated with retrieving the operation of the appointments provider. 
 */
declare class AppointmentsProviderLaunchActionVerbs {

    /**
     * Gets the add-appointment action that the appointments provider performs. 
     */
    addAppointment: string;

    /**
     * Gets the remove-appointment action that the appointments provider performs. 
     */
    removeAppointment: string;

    /**
     * Gets the replace-appointment action that the appointments provider performs. 
     */
    replaceAppointment: string;

    /**
     * Gets the show-appointment-details action that the appointments provider performs. 
     */
    showAppointmentDetails: string;

    /**
     * Gets the show-time-frame action of an appointment that the appointments provider performs. 
     */
    showTimeFrame: string
}


/**
 * Represents the operation object associated with removing an appointment. Appointments provider apps use this info to perform the operation. 
 */
declare class RemoveAppointmentOperation {

    /**
     * Gets the unique identifier of the appointment to remove. 
     */
    appointmentId: string;

    /**
     * Dismisses the UI for the operation that removes an appointment. 
     */
    dismissUI(): void;

    /**
     * Gets the start date and time of the appointment instance to remove. 
     */
    instanceStartDate: Date;

    /**
     * Call this method to inform the activating app that the operation was canceled by the user. 
     */
    reportCanceled(): void;

    /**
     * Informs the activating app that the operation was completed successfully. 
     */
    reportCompleted(): void;

    /**
     * Informs the activating app that the operation couldn't be completed because of a provider error.
     * @param value A string that contains info about the error.
     */
    reportError(value: string): void;

    /**
     * Gets the package family name of the app that is requesting the operation. 
     */
    sourcePackageFamilyName: string
}


/**
 * Represents the operation object associated with replacing an appointment. Appointments provider apps use this info to perform the operation. 
 */
declare class ReplaceAppointmentOperation {

    /**
     * Gets the unique identifier of the appointment to replace. 
     */
    appointmentId: string;

    /**
     * Gets the Appointment info from the activation request. 
     */
    appointmentInformation: undefined.Appointment;

    /**
     * Dismisses the UI for the operation that replaces an appointment. 
     */
    dismissUI(): void;

    /**
     * Gets the start date and time of the appointment instance to replace. 
     */
    instanceStartDate: Date;

    /**
     * Informs the activating app that the operation was canceled by the user. 
     */
    reportCanceled(): void;

    /**
     * Informs the activating app that the operation was completed successfully.
     * @param itemId A unique appointment ID that the activating app can later use to remove this appointment if necessary or to replace it again.
     */
    reportCompleted(itemId: string): void;

    /**
     * Informs the activating app that the operation couldn't be completed because of a provider error.
     * @param value A string that contains info about the error.
     */
    reportError(value: string): void;

    /**
     * Gets the package family name of the app that is requesting the operation. 
     */
    sourcePackageFamilyName: string
}


/**
 * Represents a set of options that modifies a query for appointments. 
 */
declare class FindAppointmentsOptions {
    calendarIds: any;
    fetchProperties: any;
    includeHidden: any;
    maxCount: any
}


/**
 * Represents a trigger that is activated when the ActivitySensor receives input. This is used when your application needs to respond to the activity sensor. 
 */
declare class ActivitySensorTrigger {

    /**
     * Creates an instance of the ActivitySensorTrigger class with an initial MinimumReportInterval .
     * @param reportIntervalInMilliseconds The initial report interval to use for MinimumReportInterval .
     */
    constructor(reportIntervalInMilliseconds: number): this;

    /**
     * Gets the minimum supported report interval for the sensor trigger. 
     */
    minimumReportInterval: number;

    /**
     * Gets the report interval for the trigger. 
     */
    reportInterval: number;

    /**
     * Gets or sets the list of activities your trigger is subscribed to. 
     */
    subscribedActivities: undefined.IVector<undefined.ActivityType>;

    /**
     * Gets the list of supported activities you can subscribe to. 
     */
    supportedActivities: undefined.IVectorView<undefined.ActivityType >
}


/**
 * Requests permission from the user to set alarms, and retrieves the status of user permission for the app to set alarms. 
 */
declare class AlarmApplicationManager {

    /**
     * Retrieves the status of user permission for the app to set alarms.
     * @return  Indicates whether the user has granted permission to set alarms.
     */
    getAccessStatus(): undefined.AlarmAccessStatus;

    /**
     * Requests permission from the user to set alarms.
     * @return  This method returns an AlarmAccessStatus value when it completes.
     */
    requestAccessAsync(): undefined.IPromiseWithIAsyncOperation<undefined.AlarmAccessStatus >
}


/**
 * This is used to trigger background tasks. 
 */
declare class ApplicationTrigger {

    /**
     * Creates a new ApplicationTrigger class 
     */
    constructor(): this;

    /**
     * This method attempts to set the trigger and start the registered background task with specified arguments.
     * @param arguments The serialized arguments that are passed to the background task.
     * @return  Returns an ApplicationTriggerResult enumeration that indicates whether the user provided the necessary consent for the operation or the system policies didn't reject the request to trigger a background task.
     */
    requestAsync(
        args: undefined.ValueSet): undefined.IPromiseWithIAsyncOperation<undefined.ApplicationTriggerResult>;

    /**
     * This method attempts to set the trigger and start the registered background task.
     * @return  Returns an ApplicationTriggerResult enumeration that indicates whether the user provided the necessary consent for the operation or the system policies didn't reject the request to trigger a background task.
     */
    requestAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ApplicationTriggerResult >
}


/**
 * (Applies to Windows Phone only) The details of an ApplicationTrigger . 
 */
declare class ApplicationTriggerDetails {

    /**
     * The arguments that were passed to the background task using the ApplicationTrigger.RequestAsync(ValueSet) method. 
     */
    arguments: undefined.ValueSet
}


/**
 * Represents a trigger that launches a background task for processing changes to the appointment store. 
 */
declare class AppointmentStoreNotificationTrigger {

    /**
     * Initializes a new instance of the AppointmentStoreNotificationTrigger class. 
     */
    constructor(): this
}


/**
 * Provides methods that let an app ask to be added to the lock screen's apps list or query its current access to background activity and badge updates on the lock screen. 
 */
declare class BackgroundExecutionManager {

    /**
     * Gets the ability of the calling lock screen app to perform background activity and update its badge.
     * @return  One of the enumeration values that specify the app's capabilities on the lock screen.
     */
    getAccessStatus(): undefined.BackgroundAccessStatus;

    /**
     * Gets the ability of a specific lock screen app to perform background activity and update its badge.
     * @param applicationId The Package Relative Application ID (PRAID) of the app whose capabilities are being retrieved. The specified app must be in the same package as the calling app.
     * @return  One of the enumeration values that specify the app's capabilities on the lock screen.
     */
    getAccessStatus(applicationId: string): undefined.BackgroundAccessStatus;

    /**
     * Removes a specific app from the lock screen's apps list.
     * @param applicationId The Package Relative Application ID (PRAID) of the app to be removed from the lock screen. The specified app must be in the same package as the calling app.
     */
    removeAccess(applicationId: string): void;

    /**
     * Removes the calling app from the lock screen's apps list. 
     */
    removeAccess(): void;

    /**
     * Requests access for an app to run background tasks.
     * @param applicationId The Package Relative Application ID (PRAID) of the app to be added to the lock screen. The specified app must be in the same package as the calling app.
     * @return  The object, bound to the app specified by applicationId, that is used to request that the app be added to the lock screen's apps list. When the operation completes, it returns a member of the BackgroundAccessStatus enumeration that specifies the outcome.
     */
    requestAccessAsync(
        applicationId: string): undefined.IPromiseWithIAsyncOperation<undefined.BackgroundAccessStatus>;

    /**
     * Requests access for an app to run background tasks.
     * @return  The object, bound to the calling app, that is used to request that the app be added to the lock screen's apps list. When the operation completes, it returns a member of the BackgroundAccessStatus enumeration that specifies the outcome.
     */
    requestAccessAsync(): undefined.IPromiseWithIAsyncOperation<undefined.BackgroundAccessStatus >
}


/**
 * Represents a background task to be registered with the system. 
 */
declare class BackgroundTaskBuilder {

    /**
     * Creates an instance of the BackgroundTaskBuilder class. 
     */
    constructor(): this;

    /**
     * Adds a condition to a background task.
     * @param condition An instance of a SystemCondition object.
     */
    addCondition(condition: undefined.IBackgroundCondition): void;

    /**
     * Indicates whether the background task will be canceled if at least one of its required conditions is no longer met. 
     */
    cancelOnConditionLoss: boolean;

    /**
     * This API is not available to all Windows/Windows Phone apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    isNetworkRequested: boolean;

    /**
     * Gets or sets the name of a background task. 
     */
    name: string;

    /**
     * Registers a background task with the system.
     * @return  An instance of a BackgroundTaskRegistration object.
     */
    register(): undefined.BackgroundTaskRegistration;

    /**
     * Sets the event trigger for a background task.
     * @param trigger An instance of an event trigger object such as a SystemTrigger , TimeTrigger , or NetworkOperatorNotificationTrigger .
     */
    setTrigger(trigger: undefined.IBackgroundTrigger): void;

    /**
     * Gets or sets the class that performs the work of a background task. 
     */
    taskEntryPoint: string
}


/**
 * Represents completion information for a task at the time a completion notification is sent. 
 */
declare class BackgroundTaskCompletedEventArgs {

    /**
     * Throws an exception if the background task completed event has reported an error. 
     */
    checkResult(): void;

    /**
     * Gets the identifier of the background task instance for this completion status notification. 
     */
    instanceId: string
}


/**
 * Represents a background task deferral returned by the IBackgroundTaskInstance.GetDeferral method. 
 */
declare class BackgroundTaskDeferral {

    /**
     * Informs the system that an asynchronous operation associated with a background task has finished. 
     */
    complete(): void
}


/**
 * Represents progress information for a task at the time a progress update notification is sent. 
 */
declare class BackgroundTaskProgressEventArgs {

    /**
     * Gets the identifier of the background task instance for this progress status notification. 
     */
    instanceId: string;

    /**
     * Gets progress status for a background task instance. 
     */
    progress: number
}


/**
 * Represents a background task that has been registered with the system. 
 */
declare class BackgroundTaskRegistration {

    /**
     * Enumerates an application's registered background tasks. 
     */
    allTasks: undefined.IMapView<string, undefined.IBackgroundTaskRegistration>;

    /**
     * Gets the name of a registered background task. 
     */
    name: string;

    /**
     * Attaches a completed event handler to the registered background task. 
     */
    oncompleted: undefined.BackgroundTaskCompletedEventHandler;
    addEventListener(
        type: "completed",
        listener: undefined.BackgroundTaskCompletedEventHandler): void;
    removeEventListener(
        type: "completed",
        listener: undefined.BackgroundTaskCompletedEventHandler): void;

    /**
     * Attaches a progress event handler to the registered background task. 
     */
    onprogress: undefined.BackgroundTaskProgressEventHandler;
    addEventListener(type: "progress", listener: undefined.BackgroundTaskProgressEventHandler): void;
    removeEventListener(type: "progress", listener: undefined.BackgroundTaskProgressEventHandler): void;

    /**
     * Gets the identifier of a registered background task. 
     */
    taskId: string;

    /**
     * This is not intended for use in your code. For all unsupported trigger types, the value returned by this property is null. 
     */
    trigger: undefined.IBackgroundTrigger;

    /**
     * Cancels the registration of a registered background task.
     * @param cancelTask True if currently running instances of this background task should be canceled. If this parameter is false, currently running instances are allowed to finish. Canceled instances receive a Canceled event with a cancellation reason of Abort.
     */
    unregister(cancelTask: boolean): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Retrieves a hint about resource availability for background tasks. Background tasks can use this hint to decide how much work to do when they are activated. 
 */
declare class BackgroundWorkCost {

    /**
     * Retrieves a hint about resource availability for background tasks. 
     */
    currentBackgroundWorkCost: undefined.BackgroundWorkCostValue
}


/**
 * Represents a trigger that is registered to advertise a Bluetooth LE advertisement in the background. 
 */
declare class BluetoothLEAdvertisementPublisherTrigger {

    /**
     * Creates a new instance of the BluetoothLEAdvertisementPublisherTrigger class. 
     */
    constructor(): this;

    /**
     * Gets the Bluetooth LE advertisement to configure and publish in the background. 
     */
    advertisement: undefined.BluetoothLEAdvertisement
}


/**
 * Represents a trigger that is registered to scan for Bluetooth LE advertisement in the background. 
 */
declare class BluetoothLEAdvertisementWatcherTrigger {

    /**
     * Creates a new instance of the BluetoothLEAdvertisementWatcherTrigger class. 
     */
    constructor(): this;

    /**
     * Gets or sets the configuration of Bluetooth LE advertisement filtering that uses payload section-based filtering. 
     */
    advertisementFilter: undefined.BluetoothLEAdvertisementFilter;

    /**
     * Gets the maximum out of range timeout supported for the SignalStrengthFilter property of this trigger. 
     */
    maxOutOfRangeTimeout: number;

    /**
     * Gets the maximum sampling interval supported for the SignalStrengthFilter property of this trigger. The maximum sampling interval is used to deactivate the sampling filter and only trigger received events based on the device coming in and out of range. 
     */
    maxSamplingInterval: number;

    /**
     * Gets the minimum out of range timeout supported for the SignalStrengthFilter property of this trigger. 
     */
    minOutOfRangeTimeout: number;

    /**
     * Gets the minimum sampling interval supported for the SignalStrengthFilter property of this trigger. The minimum sampling interval for the background watcher cannot be zero unlike its foreground counterpart. 
     */
    minSamplingInterval: number;

    /**
     * Gets or sets the configuration of Bluetooth LE advertisement filtering that uses signal strength-based filtering. 
     */
    signalStrengthFilter: undefined.BluetoothSignalStrengthFilter
}


/**
 * Represents a trigger that launches a background task to enable the Cached File Updater contract. 
 */
declare class CachedFileUpdaterTrigger {

    /**
     * Initializes a new instance of the CachedFileUpdaterTrigger class. 
     */
    constructor(): this
}


/**
 * Provides details about the cached file operation that invoked the trigger. 
 */
declare class CachedFileUpdaterTriggerDetails {

    /**
     * Gets whether the system can display UI allowing the user to launch provider app in response to the cached file updater trigger. 
     */
    canRequestUserInput: boolean;

    /**
     * Gets the FileUpdateRequest object associated with the cached file update. 
     */
    updateRequest: undefined.FileUpdateRequest;

    /**
     * Gets the CachedFileTarget object associated with cached file update that indicates whether the local or remote file should be updated. 
     */
    updateTarget: undefined.CachedFileTarget
}


/**
 * Represents a trigger that is activated when there is a notification for a text message. 
 */
declare class ChatMessageNotificationTrigger {

    /**
     * Represents a trigger that is activated when there is a notification for a text message. 
     */
    constructor(): this
}


/**
 * Represents a trigger that launches a background task that handles any incoming message that might need to be filtered according to its content. For more information about filtering messages, see Windows.ApplicationModel.CommunicationBlocking . 
 */
declare class ChatMessageReceivedNotificationTrigger {

    /**
     * Initializes a new instance of the ChatMessageReceivedNotificationTrigger class. 
     */
    constructor(): this
}


/**
 * Represents a trigger that launches a background task for processing changes to the contacts store. 
 */
declare class ContactStoreNotificationTrigger {

    /**
     * Initializes a new instance of the ContactStoreNotificationTrigger class. 
     */
    constructor(): this
}


/**
 * Provides the ability to run custom handlers when prefetching web resources. 
 */
declare class ContentPrefetchTrigger {

    /**
     * Initializes a new instance of the ContentPrefetchTrigger class. 
     */
    constructor(): this;

    /**
     * Initializes a new instance of the ContentPrefetchTrigger class using a specified time interval.
     * @param waitInterval Interval before next allowed content prefetch.
     */
    constructor(waitInterval: number): this;

    /**
     * Retrieves the time interval for prefetching web content. 
     */
    waitInterval: number
}


/**
 * Represents a trigger that launches a background task when the connection status of a device changes. 
 */
declare class DeviceConnectionChangeTrigger {

    /**
     * Begins an asynchronous operation to get the DeviceConnectionChangeTrigger associated with the specified Id.
     * @param deviceId The device Id with which to find the associated trigger.
     * @return  The DeviceConnectionChangeTrigger object associated with the specified device Id.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.DeviceConnectionChangeTrigger>;

    /**
     * Gets whether the system can maintain a connection to the specified device. 
     */
    canMaintainConnection: boolean;

    /**
     * Gets the device Id associated with the device. 
     */
    deviceId: string;

    /**
     * Gets or sets whether the system should automatically attempt to keep the referenced device connected. 
     */
    maintainConnection: boolean
}


/**
 * Represents a trigger that launches a background task to enable device manufacturer operations. 
 */
declare class DeviceManufacturerNotificationTrigger {

    /**
     * Initializes a new instance of the DeviceManufacturerNotificationTrigger class.
     * @param triggerQualifier An app-defined string that qualifies the trigger.
     * @param oneShot Whether the trigger is used only once.
     */
    constructor(triggerQualifier: string, oneShot: boolean): this;

    /**
     * Gets whether the trigger is used only once. 
     */
    oneShot: boolean;

    /**
     * Gets an app-defined string that qualifies the trigger. 
     */
    triggerQualifier: string
}


/**
 * Represents an event that an application can trigger to initiate a long-running update (firmware or settings) of a device. 
 */
declare class DeviceServicingTrigger {

    /**
     * Constructor for DeviceServicingTrigger . Takes no parameters. 
     */
    constructor(): this;

    /**
     * Triggers the background task (settings or firmware update) and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID string and an optional estimated time the background task will run. If your app cannot determine an appropriate time estimate, provide zero as the estimated time.
     * @param deviceId The DeviceInformation.ID of the device the background task will access.
     * @param expectedDuration Optional value. The expected duration of the background settings update or background firmware update. Set this value to zero if an appropriate time estimate cannot be determined.
     * @return  This method returns a DeviceTriggerResult when it completes asynchronously.
     */
    requestAsync(
        deviceId: string,
        expectedDuration: number): undefined.IPromiseWithIAsyncOperation<undefined.DeviceTriggerResult>;

    /**
     * Triggers the background task (settings or firmware update) and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID string, an optional estimated time the background task will run, and an optional app-specific string passed to the background task identifying which device operation to perform. If your app cannot determine an appropriate time estimate, provide zero as the estimated time.
     * @param deviceId The DeviceInformation.ID of the device the background task will access.
     * @param expectedDuration Optional value. The expected duration of the background settings update or background firmware update. Set this value to zero if an appropriate time estimate cannot be determined.
     * @param arguments Optional value. An app-specific string passed to the background task identifying which device operation to perform.
     * @return  This method returns a DeviceTriggerResult when it completes asynchronously.
     */
    requestAsync(
        deviceId: string,
        expectedDuration: number,
        args: string): undefined.IPromiseWithIAsyncOperation<undefined.DeviceTriggerResult >
}


/**
 * Represents an event that a Windows Runtime app can trigger to initiate a long-running operation with a device or sensor. 
 */
declare class DeviceUseTrigger {

    /**
     * Constructor for DeviceUseTrigger . Takes no parameters. 
     */
    constructor(): this;

    /**
     * Triggers the background task and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID of the device or sensor that the background task will access, and an optional app-specific string passed to the background task identifying which operation to perform.
     * @param deviceId The DeviceInformation.ID of the device or sensor that the background task will access.
     * @param arguments Optional value. A string specified by your app and passed to the background task, identifying which operation to perform.
     * @return  This method returns a DeviceTriggerResult when it completes asynchronously.
     */
    requestAsync(
        deviceId: string,
        args: string): undefined.IPromiseWithIAsyncOperation<undefined.DeviceTriggerResult>;

    /**
     * Triggers the background task and returns a DeviceTriggerResult indicating success or failure of the trigger request. Takes the DeviceInformation.ID of the device or sensor that the background task will access.
     * @param deviceId The DeviceInformation.ID of the device or sensor that the background task will access.
     * @return  This method returns a DeviceTriggerResult when it completes asynchronously.
     */
    requestAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.DeviceTriggerResult >
}


/**
 * Represents an event that causes a background task to run when changes occur to the list of devices. 
 */
declare class DeviceWatcherTrigger {}


/**
 * Represents a trigger that enables notification of changes to the email store. 
 */
declare class EmailStoreNotificationTrigger {

    /**
     * Initializes a new instance of the EmailStoreNotificationTrigger class. 
     */
    constructor(): this
}


/**
 * Represents a trigger that launches a background task when an incoming change notification is received for a Bluetooth LE GATT characteristic. 
 */
declare class GattCharacteristicNotificationTrigger {

    /**
     * Initializes a new instance of the GattCharacteristicNotificationTrigger class.
     * @param characteristic The GATT characteristic for which value change notifications are desired.
     */
    constructor(characteristic: undefined.GattCharacteristic): this;

    /**
     * Gets the GATT characteristic for which value change notifications are desired. 
     */
    characteristic: undefined.GattCharacteristic
}


/**
 * Represents a location event that triggers a background task. This is used for Geofencing. 
 */
declare class LocationTrigger {

    /**
     * Initializes a new instance of a location event trigger.
     * @param triggerType The type of location event for this trigger.
     */
    constructor(triggerType: undefined.LocationTriggerType): this;

    /**
     * The type of location event for this trigger. 
     */
    triggerType: undefined.LocationTriggerType
}


/**
 * Represents a maintenance trigger. 
 */
declare class MaintenanceTrigger {

    /**
     * Initializes a new instance of a maintenance trigger.
     * @param freshnessTime The number of minutes to wait before scheduling the background task. The system schedules the task within 15 minutes after freshnessTime elapses.
     * @param oneShot True if the maintenance trigger is used once; false if it is used each time the freshnessTime interval elapses.
     */
    constructor(freshnessTime: number, oneShot: boolean): this;

    /**
     * Gets the interval of a maintenance trigger. 
     */
    freshnessTime: number;

    /**
     * Gets whether the maintenance trigger is used only once or each time the FreshnessTime interval elapses. 
     */
    oneShot: boolean
}


/**
 * Represents a trigger that launches a background task for performing media processing. 
 */
declare class MediaProcessingTrigger {

    /**
     * Initializes a new instance of the MediaProcessingTrigger class. 
     */
    constructor(): this;

    /**
     * Triggers the background task and returns a MediaProcessingTriggerResult indicating success or failure of the trigger request.
     * @return  An asynchronous operation that returns a MediaProcessingTriggerResult upon completion.
     */
    requestAsync(): undefined.IPromiseWithIAsyncOperation<undefined.MediaProcessingTriggerResult>;

    /**
     * Triggers the background task with the provided collection of arguments and returns a MediaProcessingTriggerResult indicating success or failure of the trigger request.
     * @param arguments A collection of arguments that will be passed to the media processing background task.
     * @return  An asynchronous operation that returns a MediaProcessingTriggerResult upon completion.
     */
    requestAsync(
        args: undefined.ValueSet): undefined.IPromiseWithIAsyncOperation<undefined.MediaProcessingTriggerResult >
}


/**
 * Represents a trigger that activates when the network sends SIM tool commands. Apps receiving this notification then process the SIM tool commands. 
 */
declare class MobileBroadbandDeviceServiceNotificationTrigger {

    /**
     * Constructs a MobileBroadbandDeviceServiceNotificationTrigger object. 
     */
    constructor(): this
}


/**
 * Represents a trigger that indicates when the SIM PIN lock state has changed. 
 */
declare class MobileBroadbandPinLockStateChangeTrigger {

    /**
     * Constructs a MobileBroadbandPinLockStateChangeTrigger object. 
     */
    constructor(): this
}


/**
 * Represents a trigger that indicates when mobile broadband radio state has changed. For example, this trigger activates when a mobile device transitions to or from airplane mode. 
 */
declare class MobileBroadbandRadioStateChangeTrigger {

    /**
     * Constructs a MobileBroadbandRadioStateChangeTrigger object. 
     */
    constructor(): this
}


/**
 * Represents a trigger that indicates when mobile broadband registration state has changed. For example, this trigger activates when a mobile device transitions to or from Roaming. 
 */
declare class MobileBroadbandRegistrationStateChangeTrigger {

    /**
     * Creates a MobileBroadbandRegistrationStateChangeTrigger object. 
     */
    constructor(): this
}


/**
 * Represents a mobile network operator hotspot authentication trigger. 
 */
declare class NetworkOperatorHotspotAuthenticationTrigger {

    /**
     * Initializes a new instance of a mobile network operator hotspot authentication trigger. 
     */
    constructor(): this
}


/**
 * Represents a mobile network operator notification trigger. 
 */
declare class NetworkOperatorNotificationTrigger {

    /**
     * Initializes a new instance of a mobile network operator notification.
     * @param networkAccountId Specifies the unique identifier of the mobile broadband account.
     */
    constructor(networkAccountId: string): this;

    /**
     * Gets the account identifier for the mobile network operator notification trigger. 
     */
    networkAccountId: string
}


/**
 * Represents a phone event that triggers a background task. 
 */
declare class PhoneTrigger {

    /**
     * Initializes a new instance of the PhoneTrigger class.
     * @param type Specifies the type of phone event.
     * @param oneShot Indicates if the trigger is a one-shot notification. If you weren't subscribed when a one-shot notification was sent, you get nothing. If you weren't connected when you fired a one-shot notification, nothing happens.
     */
    constructor(type: undefined.PhoneTriggerType, oneShot: boolean): this;

    /**
     * Gets a Boolean value indicating if the trigger is a one-shot notification. 
     */
    oneShot: boolean;

    /**
     * Gets the type of phone event indicated by the trigger. 
     */
    triggerType: undefined.PhoneTriggerType
}


/**
 * Represents an object that invokes a background work item on the app in response to the receipt of a raw notification . 
 */
declare class PushNotificationTrigger {

    /**
     * Invokes a background work item on the app in response to the receipt of a raw notification . 
     */
    constructor(): this;

    /**
     * Invokes a background work item on a specified app in response to the receipt of a raw notification .
     * @param applicationId The app's Package Relative Application ID (PRAID). The specified app must be in the same package as the calling app.
     */
    constructor(applicationId: string): this
}


/**
 * Represents a trigger that launches a background task when a new Rich Communication Services (RCS) message is available. 
 */
declare class RcsEndUserMessageAvailableTrigger {

    /**
     * Initializes a new instance of the RcsEndUserMessageAvailableTrigger class. 
     */
    constructor(): this
}


/**
 * Represents a trigger that launches a background task when an RFCOMM inbound or outbound connections are established. 
 */
declare class RfcommConnectionTrigger {

    /**
     * Initializes a new instance of the RfcommConnectionTrigger class. 
     */
    constructor(): this;

    /**
     * Gets or sets whether the app wants to handle multiple connections at a time. 
     */
    allowMultipleConnections: boolean;

    /**
     * Gets or sets the RfcommInboundConnectionInformation object that describes how the system will advertise and listen for inbound connections on behalf of the app. 
     */
    inboundConnection: undefined.RfcommInboundConnectionInformation;

    /**
     * Gets or sets the RfcommOutboundConnectionInformation object that describes how the system will create outgoing connections on behalf of the app. 
     */
    outboundConnection: undefined.RfcommOutboundConnectionInformation;

    /**
     * Gets or sets the minimum protection level required for connections that are created or accepted on behalf of the app. 
     */
    protectionLevel: undefined.SocketProtectionLevel;

    /**
     * Gets or sets specific remote Bluetooth device the system will connect to, or accept connections from, on behalf of the app. 
     */
    remoteHostName: undefined.HostName
}


/**
 * Represents a trigger that responds when a threshold limit for a sensor is crossed. 
 */
declare class SensorDataThresholdTrigger {

    /**
     * Initializes a new instance of the SensorDataThresholdTrigger class.
     * @param threshold The threshold for a sensor that indicates when it should be triggered.
     */
    constructor(threshold: undefined.ISensorDataThreshold): this
}


/**
 * Represents a trigger that is raised when an SMS message has arrived. 
 */
declare class SmsMessageReceivedTrigger {

    /**
     * Initializes a new instance of an SMS message received trigger.
     * @param filterRules Filter rules to be applied to incoming SMS messages. Only messages that pass through the filter rules raise the trigger.
     */
    constructor(filterRules: undefined.SmsFilterRules): this
}


/**
 * Represents a trigger that launches a background task for handling socket activity. 
 */
declare class SocketActivityTrigger {

    /**
     * Initializes a new instance of a socket activity trigger. 
     */
    constructor(): this
}


/**
 * Creates a trigger that will fire when a file is changed in a specified library. 
 */
declare class StorageLibraryContentChangedTrigger {

    /**
     * Creates a trigger that will fire when a file is changed in the specified library.
     * @param storageLibrary The location that the trigger monitors such as the music library or documents library.
     * @return  A trigger that monitors the specified location.
     */
    create(
        storageLibrary: undefined.StorageLibrary): undefined.StorageLibraryContentChangedTrigger;

    /**
     * Creates a trigger that will fire when a file is changed in any of the specified libraries.
     * @param storageLibraries The list of libraries that the trigger will monitor.
     * @return  A trigger that monitors the specified location(s).
     */
    createFromLibraries(
        storageLibraries: undefined.IIterable<undefined.StorageLibrary>): undefined.StorageLibraryContentChangedTrigger
}


/**
 * Represents a system condition that must be in effect for a background task to run. 
 */
declare class SystemCondition {

    /**
     * Initializes a new instance of a system condition.
     * @param conditionType Specifies the condition type.
     */
    constructor(conditionType: undefined.SystemConditionType): this;

    /**
     * Gets the condition type of a system condition. 
     */
    conditionType: undefined.SystemConditionType
}


/**
 * Represents a system event that triggers a background task to run. 
 */
declare class SystemTrigger {

    /**
     * Initializes a new instance of a system event trigger.
     * @param triggerType Specifies the system event type.
     * @param oneShot True if the system event trigger will be used once; false if it will be used every time the event occurs.
     */
    constructor(triggerType: undefined.SystemTriggerType, oneShot: boolean): this;

    /**
     * Gets whether a system event trigger will be used only once. 
     */
    oneShot: boolean;

    /**
     * Gets the system event type of a system event trigger. 
     */
    triggerType: undefined.SystemTriggerType
}


/**
 * Represents a time event that triggers a background task to run. 
 */
declare class TimeTrigger {

    /**
     * Initializes a new instance of a time event trigger.
     * @param freshnessTime Specifies the number of minutes to wait before scheduling the background task. The system schedules the task within 15 minutes after freshnessTime elapses. If the OneShot property is false, freshnessTime specifies the interval between recurring tasks.
     * @param oneShot True if the time event trigger will be used once; false if it will be used each time freshnessTime elapses.
     */
    constructor(freshnessTime: number, oneShot: boolean): this;

    /**
     * Gets the interval of a time event trigger. 
     */
    freshnessTime: number;

    /**
     * Gets whether the time event trigger will be used only once or each time the FreshnessTime interval elapses. 
     */
    oneShot: boolean
}


/**
 * Represents an event that causes a background task to run when the user performs an action on an interactive toast notification. 
 */
declare class ToastNotificationActionTrigger {

    /**
     * Creates and initializes a new instance of the ToastNotificationActionTrigger class. 
     */
    constructor(): this;

    /**
     * Creates and initializes a new instance of the ToastNotificationActionTrigger class for the app with the specified identifier.
     * @param applicationId The identifier of the app for which you want to create an instance of the ToastNotificationActionTrigger class.
     */
    constructor(applicationId: string): this
}


/**
 * Represents an event that causes a background task to run when the history of toast notifications for the app is cleared, when one or more toast notifications are added to or removed from the notification history for the app, or when one or more toast notifications for the app expire and are removed from the notification history. 
 */
declare class ToastNotificationHistoryChangedTrigger {

    /**
     * Creates and initializes a new instance of the ToastNotificationHistoryChangedTrigger class. 
     */
    constructor(): this;

    /**
     * Creates and initializes a new instance of the ToastNotificationHistoryChangedTrigger class for the app with the specified identifier.
     * @param applicationId The identifier of the app for which you want to create an instance of the ToastNotificationHistoryChangedTrigger class.
     */
    constructor(applicationId: string): this
}


/**
 * Used to enforce the system condition object type. 
 */
declare interface Background$IBackgroundCondition {}


/**
 * Represents the base interface for trigger events. 
 */
declare interface Background$IBackgroundTrigger {}


/**
 * Provides access to a registered background task. 
 */
declare interface Background$IBackgroundTaskRegistration {

    /**
     * Unregisters a registered background task.
     * @param cancelTask True if currently running instances of this background task should be canceled. If this parameter is false, currently running instances of this background task should be allowed to finish. Canceled instances receive a Canceled event with a BackgroundTaskCancellationReason of Abort.
     */
    unregister(cancelTask: boolean): void,

        /**
         * Gets the name of a registered background task. 
         */
        name: string,

        /**
         * Gets the identifier of a registered background task. 
         */
        taskId: string,

        /**
         * Gets the trigger associated with the background task. 
         */
        trigger: undefined.IBackgroundTrigger
}


/**
 * Represents a method that handles completion events for a background task. 
 */
declare type Background$BackgroundTaskCompletedEventHandler = (
    ev: undefined.BackgroundTaskCompletedEventArgs & Windows$WinRTEvent<undefined.BackgroundTaskRegistration>) => void;


/**
 * Represents a method that handles progress update events for a background task. 
 */
declare type Background$BackgroundTaskProgressEventHandler = (
    ev: undefined.BackgroundTaskProgressEventArgs & Windows$WinRTEvent<undefined.BackgroundTaskRegistration>) => void;


/**
 * Represents a method that handles the cancellation of a background task. 
 */
declare type Background$BackgroundTaskCanceledEventHandler = (
    ev: undefined.BackgroundTaskCancellationReason & Windows$WinRTEvent<undefined.IBackgroundTaskInstance>) => void;


/**
 * Provides access to a background task instance. 
 */
declare interface Background$IBackgroundTaskInstance {

    /**
     * Informs the system that the background task might continue to perform work after the IBackgroundTask.Run method returns.
     * @return  A background task deferral.
     */
    getDeferral(): undefined.BackgroundTaskDeferral,

        /**
         * Gets the instance ID of the background task instance. 
         */
        instanceId: string,

        /**
         * Gets or sets progress status for a background task instance. 
         */
        progress: number,

        /**
         * Gets the number of times resource management policy caused the background task to be suspended. 
         */
        suspendedCount: number,

        /**
         * Gets access to the registered background task for this background task instance. 
         */
        task: undefined.BackgroundTaskRegistration,

        /**
         * Gets additional information associated with a background task instance. 
         */
        triggerDetails: any,

        /**
         * Retrieves the number of times the background task has been suspended for using too many resources.
         * @param counter Indicates the type of resource to include in the throttle count: network, CPU, or both.
         * @return  This method returns the number of times the background task has been suspended for exceeding its quota of the indicated resource type.
         */
        getThrottleCount(counter: undefined.BackgroundTaskThrottleCounter): number
}


/**
 * Used to provide the details about a call that was just blocked. 
 */
declare class PhoneCallBlockedTriggerDetails {

    /**
     * Gets the reason why a phone call was blocked. 
     */
    callBlockedReason: undefined.PhoneCallBlockedReason;

    /**
     * Gets the ID of the phone call that was just blocked. 
     */
    lineId: string;

    /**
     * Gets the phone number of the blocked call. 
     */
    phoneNumber: string
}


/**
 * Used to provide the origin details of the phone call. 
 */
declare class PhoneCallOriginDataRequestTriggerDetails {

    /**
     * Gets the phone number for the origin of the phone call. 
     */
    phoneNumber: string;

    /**
     * Gets the unique identifier for this phone call. 
     */
    requestId: string
}


/**
 * Used to provide the details about a change to the properties of a phone line. 
 */
declare class PhoneLineChangedTriggerDetails {

    /**
     * Gets a PhoneLineChangeKind value that indicates if the phone line was added, removed, or changed. 
     */
    changeType: undefined.PhoneLineChangeKind;

    /**
     * Checks a phone line against a set of flags to see if any of the specified properties of the phone line have changed.
     * @param lineProperty A set of flags which indicate the phone line properties to query for changes.
     * @return  Returns true if any of the properties indicated by the lineProperty parameter have changed on the phone line.
     */
    hasLinePropertyChanged(lineProperty: undefined.PhoneLineProperties): boolean;

    /**
     * Gets the ID of the phone line that was added, removed, or changed. 
     */
    lineId: string
}


/**
 * Used to provide the details about a new voice mail message on a phone line. 
 */
declare class PhoneNewVoicemailMessageTriggerDetails {

    /**
     * Gets the ID of the phone line for which the new voice mail arrived. 
     */
    lineId: string;

    /**
     * Gets the optional voice mail changed message set by an operator when they send a voice mail changed SMS. 
     */
    operatorMessage: string;

    /**
     * Gets the new count of voice mail messages for the phone line. 
     */
    voicemailCount: number
}


/**
 * The LockScreenCallEndCallDeferral object signals when the app no longer needs to defer the removal of itself from the lock screen. 
 */
declare class LockScreenCallEndCallDeferral {

    /**
     * Completes the deferral of the removal of the app from the lock screen, which causes the app to be removed from the lock screen if it hasn't already been removed by other means. 
     */
    complete(): void
}


/**
 * Controls the removal of an app from the lock screen. 
 */
declare class LockScreenCallEndRequestedEventArgs {

    /**
     * Gets the deadline by which the app must complete the deferral. 
     */
    deadline: Date;

    /**
     * Requests to defer the default behavior of removing the app from the lock screen.
     * @return  When this method completes, it returns a LockScreenCallEndCallDeferral object that signals when the app no longer needs to defer the removal of itself from the lock screen.
     */
    getDeferral(): undefined.LockScreenCallEndCallDeferral
}


/**
 * Handles communication to and from the lock screen. 
 */
declare class LockScreenCallUI {

    /**
     * Gets and sets a brief description of the nature of the call. This brief description is also called the call's accessible name; its form is "Video call with Jane Doe." 
     */
    callTitle: string;

    /**
     * Removes the app from the lock screen UI. 
     */
    dismiss(): void;

    /**
     * Occurs when the lock screen interaction is complete. 
     */
    onclosed: undefined.TypedEventHandler<undefined.LockScreenCallUI, any>;
    addEventListener(
        type: "closed",
        listener: undefined.TypedEventHandler<undefined.LockScreenCallUI, any>): void;
    removeEventListener(
        type: "closed",
        listener: undefined.TypedEventHandler<undefined.LockScreenCallUI, any>): void;

    /**
     * Occurs when the lock screen wants to end the call. 
     */
    onendrequested: undefined.TypedEventHandler<undefined.LockScreenCallUI, undefined.LockScreenCallEndRequestedEventArgs>;
    addEventListener(
        type: "endrequested",
        listener: undefined.TypedEventHandler<undefined.LockScreenCallUI, undefined.LockScreenCallEndRequestedEventArgs>): void;
    removeEventListener(
        type: "endrequested",
        listener: undefined.TypedEventHandler<undefined.LockScreenCallUI, undefined.LockScreenCallEndRequestedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * A collection of information about a phone call for the call history. 
 */
declare class PhoneCallHistoryEntry {

    /**
     * Creates a new PhoneCallHistoryEntry object. 
     */
    constructor(): this;

    /**
     * Gets or sets the address book information for this phone call. 
     */
    address: undefined.PhoneCallHistoryEntryAddress;

    /**
     * Gets or sets the duration of the call. 
     */
    duration: number;

    /**
     * Gets the unique identifier for this log entry. 
     */
    id: string;

    /**
     * Gets or sets a value determining whether the caller ID is blocked for this phone call. 
     */
    isCallerIdBlocked: boolean;

    /**
     * Gets or sets a value that determines whether the call is classified as an emergency. 
     */
    isEmergency: boolean;

    /**
     * Gets or sets whether a call is an incoming call. 
     */
    isIncoming: boolean;

    /**
     * Gets or sets whether a phone call was missed. 
     */
    isMissed: boolean;

    /**
     * Gets or sets whether a call is currently ringing. 
     */
    isRinging: boolean;

    /**
     * Gets or sets a whether a phone call is seen. 
     */
    isSeen: boolean;

    /**
     * Gets or sets whether this entry is suppressed. 
     */
    isSuppressed: boolean;

    /**
     * Gets or sets whether the phone call entry is a voicemail message. 
     */
    isVoicemail: boolean;

    /**
     * Gets or sets the type of media associated with a call. 
     */
    media: undefined.PhoneCallHistoryEntryMedia;

    /**
     * Gets or sets the level of access provided to other applications. 
     */
    otherAppReadAccess: undefined.PhoneCallHistoryEntryOtherAppReadAccess;

    /**
     * Gets or sets the remote id for the entry. 
     */
    remoteId: string;

    /**
     * Gets the display name for the source of the phone call. 
     */
    sourceDisplayName: string;

    /**
     * Gets or sets the identifier for the source of the phone call. 
     */
    sourceId: string;

    /**
     * Gets or sets a value that indicates what type of identifier the SourceId is. 
     */
    sourceIdKind: undefined.PhoneCallHistorySourceIdKind;

    /**
     * Gets or sets the start time for this history entry. 
     */
    startTime: Date
}


/**
 * Address book information for a contact used by PhoneCallHistoryEntry objects. 
 */
declare class PhoneCallHistoryEntryAddress {

    /**
     * Creates a new empty PhoneCallHistoryEntryAddress object. 
     */
    constructor(): this;

    /**
     * Creates a new PhoneCallHistoryEntryAddress object with an initial address.
     * @param rawAddress The address to initiailize to the RawAddress property.
     * @param rawAddressKind The type of address represented by rawAddress.
     */
    constructor(rawAddress: string, rawAddressKind: undefined.PhoneCallHistoryEntryRawAddressKind): this;

    /**
     * Gets or sets the unique identifier for this contact. 
     */
    contactId: string;

    /**
     * Get or sets the display name for this entry. 
     */
    displayName: string;

    /**
     * Gets or sets the address information for this contact. 
     */
    rawAddress: string;

    /**
     * Gets or sets the type of address indicated by RawAddress . 
     */
    rawAddressKind: undefined.PhoneCallHistoryEntryRawAddressKind
}


/**
 * Options for querying the phone call entries. 
 */
declare class PhoneCallHistoryEntryQueryOptions {

    /**
     * Creates a new PhoneCallHistoryEntryQueryOptions object. 
     */
    constructor(): this;

    /**
     * Gets or sets the query filter based on the type of media. 
     */
    desiredMedia: undefined.PhoneCallHistoryEntryQueryDesiredMedia;

    /**
     * Get the query filter based on the source ID of the phone call entry. 
     */
    sourceIds: undefined.IVector<string >
}


/**
 * Enables the calling app to read through the phone call history entries. 
 */
declare class PhoneCallHistoryEntryReader {

    /**
     * Returns a list of the PhoneCallHistoryEntry objects.
     * @return  An asynchronous operation that returns an IVectorView upon successful completion.
     */
    readBatchAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >>
}


/**
 * Provides APIs for the application to get access to the PhoneCallHistoryStore . 
 */
declare class PhoneCallHistoryManager {

    /**
     * Requests the PhoneCallHistoryStore associated with the calling application.
     * @param accessType The type of access requested for the PhoneCallHistoryStore object.
     * @return  An asynchronous operation that returns a PhoneCallHistoryStore object on successful completion.
     */
    requestStoreAsync(
        accessType: undefined.PhoneCallHistoryStoreAccessType): undefined.IPromiseWithIAsyncOperation<undefined.PhoneCallHistoryStore >
}


/**
 * A collection of phone call history entries. 
 */
declare class PhoneCallHistoryStore {

    /**
     * Deletes entries in the store.
     * @param callHistoryEntries The entries to delete.
     */
    deleteEntriesAsync(callHistoryEntries: undefined.IIterable<undefined.PhoneCallHistoryEntry>): any;

    /**
     * Delete an entry from the store.
     * @param callHistoryEntry The entry to delete.
     */
    deleteEntryAsync(callHistoryEntry: undefined.PhoneCallHistoryEntry): any;

    /**
     * Gets an entry from the store based on the entry id.
     * @param callHistoryEntryId The PhoneCallHistoryEntryt.Id of the relevant entry.
     */
    getEntryAsync(callHistoryEntryId: string): any;

    /**
     * Retrieves an entry reader based on provided filters.
     * @param queryOptions The options used to create a filtered entry reader.
     * @return  A reader that can be used to go through the phone call log entries.
     */
    getEntryReader(
        queryOptions: undefined.PhoneCallHistoryEntryQueryOptions): undefined.PhoneCallHistoryEntryReader;

    /**
     * Retrieves a default phone call history entry that reads all entries.
     * @return  A reader that can be used to go through the phone call log entries.
     */
    getEntryReader(): undefined.PhoneCallHistoryEntryReader;

    /**
     * Gets the number of unseen log entries for the provided sources.
     * @param sourceIds The identifiers that need to match PhoneCallHistoryEntry.SourceId in order for that entry to be considered.
     * @return  The total number of unseen entries matching all of the identifiers provided by sourceIds.
     */
    getSourcesUnseenCountAsync(
        sourceIds: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Gets the number of unseen entries.
     * @return  The number of unseen entries.
     */
    getUnseenCountAsync(): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Update all the entries to indicate they have all been seen by the user.
     */
    markAllAsSeenAsync(): any;

    /**
     * Updates entries to indicate they have been seen by the user.
     * @param callHistoryEntries The entries to mark as seen. This updates the PhoneCallHistoryEntry.IsSeen property.
     */
    markEntriesAsSeenAsync(callHistoryEntries: undefined.IIterable<undefined.PhoneCallHistoryEntry>): any;

    /**
     * Updates an entry to indicate it has been seen.
     * @param callHistoryEntry The entry to update.
     */
    markEntryAsSeenAsync(callHistoryEntry: undefined.PhoneCallHistoryEntry): any;

    /**
     * Marks all entries from the specified sources as seen.
     * @param sourceIds The list of source identifiers to mark as seen. Only entries that match PhoneCallHistoryEntry.SourceId will be updated.
     */
    markSourcesAsSeenAsync(sourceIds: undefined.IIterable<string>): any;

    /**
     * Saves an entry to the store.
     * @param callHistoryEntry The entry to save.
     */
    saveEntryAsync(callHistoryEntry: undefined.PhoneCallHistoryEntry): any
}


/**
 * Represents the Rich Communication Services (RCS) chat capabilities of a phone number. 
 */
declare class ChatCapabilities {

    /**
     * Gets a Boolean value indicating if a phone number supports Rich Communication Services (RCS) chat. 
     */
    isChatCapable: boolean;

    /**
     * Gets a Boolean value indicating if a phone number supports Rich Communication Services (RCS) file transfer. 
     */
    isFileTransferCapable: boolean;

    /**
     * Gets a Boolean value indicating if a phone number is capable of pushing Rich Communication Services (RCS) geolocation. 
     */
    isGeoLocationPushCapable: boolean;

    /**
     * Gets a Boolean value indicating if a phone number supports Rich Communication Services (RCS) integrated messaging. 
     */
    isIntegratedMessagingCapable: boolean;

    /**
     * Gets a Boolean value indicating if an Rich Communication Services (RCS) capable phone number is online. 
     */
    isOnline: boolean
}


/**
 * Provides functionality for getting chat capabilities. 
 */
declare class ChatCapabilitiesManager {

    /**
     * Asynchronously gets the locally cached Rich Communication Services (RCS) chat capabilities for the specified phone number.
     * @param address The phone number for which to get the RCS chat capabilites
     * @return  The locally cached RCS chat capabilities.
     */
    getCachedCapabilitiesAsync(
        address: string): undefined.IPromiseWithIAsyncOperation<undefined.ChatCapabilities>;

    /**
     * Asynchronously gets the Rich Communication Services (RCS) chat capabilities for the specified phone number from the service provider.
     * @param address The phone number for which to get the RCS chat capabilities.
     * @return  The RCS chat capabilities from the service provider.
     */
    getCapabilitiesFromNetworkAsync(
        address: string): undefined.IPromiseWithIAsyncOperation<undefined.ChatCapabilities >
}


/**
 * Represents a conversation in a chat client. 
 */
declare class ChatConversation {

    /**
     * Gets or sets a boolean that indicates whether participants can be modified or not. 
     */
    canModifyParticipants: boolean;

    /**
     * Asynchronously deletes all of the messages in the ChatConversation and the conversation itself.
     * @return  An async action that indicates when the delete has completed.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the ChatMessageReader for this ChatConversation .
     * @return  The ChatMessageReader for this ChatConversation .
     */
    getMessageReader(): undefined.ChatMessageReader;

    /**
     * Gets a Boolean value indicating if there are unread messages in the ChatConversation . 
     */
    hasUnreadMessages: boolean;

    /**
     * Gets the unique identifier for the ChatConversation . 
     */
    id: string;

    /**
     * Gets or sets a Boolean value indicating if the ChatConversation is muted. 
     */
    isConversationMuted: boolean;

    /**
     * Asynchronously marks all the messages in the conversation before the specified DateTime as read.
     * @param value Mark all messages before this DateTime as read.
     * @return  An async action indicating that the operation has completed.
     */
    markMessagesAsReadAsync(value: Date): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously marks all the messages in the conversation as read.
     * @return  An async action indicating that the operation has completed.
     */
    markMessagesAsReadAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the ID of the most recent message in the conversation. 
     */
    mostRecentMessageId: string;

    /**
     * Call this to indicate that the local participant has started or has completed typing.
     * @param transportId Specifies the ChatMessageTransport to use.
     * @param participantAddress The address of the remote participant.
     * @param isComposing TRUE if the local participant is typing, otherwise FALSE.
     */
    notifyLocalParticipantComposing(transportId: string, participantAddress: string, isComposing: boolean): void;

    /**
     * Locally triggers the event that indicates that a remote participant is typing.
     * @param transportId Specifies the ChatMessageTransport to use.
     * @param participantAddress The address of the remote participant.
     * @param isComposing TRUE if the remote participant is typing, otherwise FALSE.
     */
    notifyRemoteParticipantComposing(transportId: string, participantAddress: string, isComposing: boolean): void;

    /**
     * Occurs when the remote user has started or finished typing. 
     */
    onremoteparticipantcomposingchanged: undefined.TypedEventHandler<undefined.ChatConversation, undefined.RemoteParticipantComposingChangedEventArgs>;
    addEventListener(
        type: "remoteparticipantcomposingchanged",
        listener: undefined.TypedEventHandler<undefined.ChatConversation, undefined.RemoteParticipantComposingChangedEventArgs>): void;
    removeEventListener(
        type: "remoteparticipantcomposingchanged",
        listener: undefined.TypedEventHandler<undefined.ChatConversation, undefined.RemoteParticipantComposingChangedEventArgs>): void;

    /**
     * Gets a list of all the participants in the conversation. 
     */
    participants: undefined.IVector<string>;

    /**
     * Asynchronously saves the ChatConversation .
     * @return  An async action indicating that the operation has completed.
     */
    saveAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets the subject of a group conversation. 
     */
    subject: string;

    /**
     * Gets the threading info for the ChatConversation . 
     */
    threadingInfo: undefined.ChatConversationThreadingInfo;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides functionality for reading batches of conversations from the ChatMessageStore . 
 */
declare class ChatConversationReader {

    /**
     * Asynchronously reads batches of conversations from the ChatMessageStore .
     * @param count Specifies the size of the batch to read.
     * @return  The list of conversations.
     */
    readBatchAsync(
        count: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously reads batches of conversations from the ChatMessageStore .
     * @return  The list of conversations.
     */
    readBatchAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >>
}


/**
 * Provides threading info for a ChatConversation . 
 */
declare class ChatConversationThreadingInfo {

    /**
     * Initializes a new instance of the ChatConversationThreadingInfo class. 
     */
    constructor(): this;

    /**
     * Gets or sets the Contact.Id for the remote participant. 
     */
    contactId: string;

    /**
     * Gets or sets the ID of the ChatConversation . 
     */
    conversationId: string;

    /**
     * Gets or sets a string where you can store your own custom threading info. 
     */
    custom: string;

    /**
     * Gets or sets a value that indicates the type of threading info, such as participant, contact ID, conversation ID, and so on. 
     */
    kind: undefined.ChatConversationThreadingKind;

    /**
     * Gets the list of participants in the ChatConversation . 
     */
    participants: undefined.IVector<string >
}


/**
 * Represents a chat message. 
 */
declare class ChatMessage {

    /**
     * Creates a new instance of the ChatMessage class. 
     */
    constructor(): this;

    /**
     * Gets a list of chat message attachments. 
     */
    attachments: undefined.IVector<undefined.ChatMessageAttachment>;

    /**
     * Gets or sets the body of the chat message. 
     */
    body: string;

    /**
     * Gets or sets the estimated size of a file to be sent or received. 
     */
    estimatedDownloadSize: number;

    /**
     * Gets the identifier or address of the sender of the message. 
     */
    from: string;

    /**
     * Gets the identifier of the message. 
     */
    id: string;

    /**
     * Gets or sets a Boolean value indicating if the message is an auto-reply. 
     */
    isAutoReply: boolean;

    /**
     * Gets a Boolean value indicating if forwarding is disabled. 
     */
    isForwardingDisabled: boolean;

    /**
     * Gets Boolean a value indicating if the message is incoming or outgoing. 
     */
    isIncoming: boolean;

    /**
     * Gets a Boolean value indicating if the message has been read. 
     */
    isRead: boolean;

    /**
     * Gets or sets a Boolean value indicating if the message was received during user specified quiet hours. 
     */
    isReceivedDuringQuietHours: boolean;

    /**
     * Gets a Boolean value indicating if reply is disabled on the ChatMessage . 
     */
    isReplyDisabled: boolean;

    /**
     * Gets or sets a Boolean value indicating if the message has been seen. 
     */
    isSeen: boolean;

    /**
     * Gets a Boolean value indicating if the message is stored on a SIM card. 
     */
    isSimMessage: boolean;

    /**
     * Gets the local timestamp of the message. 
     */
    localTimestamp: Date;

    /**
     * Gets or sets the type of the ChatMessage . 
     */
    messageKind: undefined.ChatMessageKind;

    /**
     * Gets or sets a value indicating the type of message operator, such as SMS, MMS, or RCS. 
     */
    messageOperatorKind: undefined.ChatMessageOperatorKind;

    /**
     * Gets the network timestamp of the message. 
     */
    networkTimestamp: Date;

    /**
     * Gets the list of send statuses for the message. 
     */
    recipientSendStatuses: undefined.IMapView<string, undefined.ChatMessageStatus>;

    /**
     * Gets the list of recipients of the message. 
     */
    recipients: undefined.IVector<string>;

    /**
     * Gets the delivery info for each of the recipients of the ChatMessage . 
     */
    recipientsDeliveryInfos: undefined.IVector<undefined.ChatRecipientDeliveryInfo>;

    /**
     * Gets or sets the remote ID for the ChatMessage . 
     */
    remoteId: string;

    /**
     * Gets or sets a Boolean value indicating if notification of receiving the ChatMessage should be suppressed. 
     */
    shouldSuppressNotification: boolean;

    /**
     * Gets the status of the message. Typical states include draft, sent, received, deleted, etc. 
     */
    status: undefined.ChatMessageStatus;

    /**
     * Gets the subject of the message. 
     */
    subject: string;

    /**
     * Gets or sets the conversation threading info for the ChatMessage . 
     */
    threadingInfo: undefined.ChatConversationThreadingInfo;

    /**
     * Gets the transport friendly name of the message. 
     */
    transportFriendlyName: string;

    /**
     * Gets or sets the transport ID of the message. 
     */
    transportId: string
}


/**
 * Represents an attachment to a chat message. 
 */
declare class ChatMessageAttachment {

    /**
     * Initializes a new instance of the ChatMessageAttachment class.
     * @param mimeType The MIME type of the attachment.
     * @param dataStreamReference A stream containing the attachment data.
     */
    constructor(mimeType: string, dataStreamReference: undefined.IRandomAccessStreamReference): this;

    /**
     * Gets or sets a stream reference for a message attachment. 
     */
    dataStreamReference: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the identifier for the attachment group to which this attachment belongs. 
     */
    groupId: number;

    /**
     * Gets or sets the MIME type of the attachment. 
     */
    mimeType: string;

    /**
     * Gets or sets the original file name of the attachment. 
     */
    originalFileName: string;

    /**
     * Gets or sets the text encoded representation of the attachment object. 
     */
    text: string;

    /**
     * Gets or sets the thumbnail image for the attachment. 
     */
    thumbnail: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the progress of transferring the attachment. 
     */
    transferProgress: number
}


/**
 * Provides functionality for blocking messages. 
 */
declare class ChatMessageBlocking {

    /**
     * Asynchronously marks a message as blocked or unblocked.
     * @param localChatMessageId The ID of the message to block.
     * @param blocked TRUE if the message should be blocked, FALSE if it should be unblocked.
     * @return  An async action indicating that the operation has completed.
     */
    markMessageAsBlockedAsync(
        localChatMessageId: string,
        blocked: boolean): undefined.IPromiseWithIAsyncAction
}


/**
 * Represents a revision to a chat message. 
 */
declare class ChatMessageChange {

    /**
     * Gets the type of change made to a chat message, such as created, modified, etc. 
     */
    changeType: undefined.ChatMessageChangeType;

    /**
     * Gets the updated message text. 
     */
    message: undefined.ChatMessage
}


/**
 * Provides methods for reading and accepting message change revisions. 
 */
declare class ChatMessageChangeReader {

    /**
     * Accepts all the changes up to and including the latest change to the message. 
     */
    acceptChanges(): void;

    /**
     * Accepts all the changes up to a specified change.
     * @param lastChangeToAcknowledge The last change to acknowledge.
     */
    acceptChangesThrough(lastChangeToAcknowledge: undefined.ChatMessageChange): void;

    /**
     * Returns a batch list of chat message change objects from the message store’s change tracker.
     * @return  An asynchronous operation that returns a list of changes.
     */
    readBatchAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >>
}


/**
 * Provides methods to enable and retrieve message change revisions. 
 */
declare class ChatMessageChangeTracker {

    /**
     * Enables change tracking for the messages in the message store. 
     */
    enable(): void;

    /**
     * Returns a ChatMessageChangeReader class object which provides a collection of message revisions from the message store.
     * @return  The change reader associated with the change tracker.
     */
    getChangeReader(): undefined.ChatMessageChangeReader;

    /**
     * Resets change tracking for the messages in the message store. The first revision begins with the next message change. 
     */
    reset(): void
}


/**
 * Represents a deferred asynchronous change request. 
 */
declare class ChatMessageChangedDeferral {

    /**
     * Fires to indicate that the deferred change request has completed. 
     */
    complete(): void
}


/**
 * Represents event parameters used by the event handler that processes message change events. 
 */
declare class ChatMessageChangedEventArgs {

    /**
     * The message changed event handler that an application registers with the message store receives a deferral object in the event parameters. The GetDeferral method registers a change deferral and allows an application to take action related to the change before the message store completes the change.
     * @return  Gets a deferral for the MessageChanged event.
     */
    getDeferral(): undefined.ChatMessageChangedDeferral
}


/**
 * Provides access to message transports and the message store. Also provides a method to display the UI to compose messages. 
 */
declare class ChatMessageManager {

    /**
     * Asynchronously gets the ChatMessageTransport .
     * @param transportId The locally unique identifier for the message transport.
     * @return  The message transport.
     */
    getTransportAsync(
        transportId: string): undefined.IPromiseWithIAsyncOperation<undefined.ChatMessageTransport>;

    /**
     * Asynchronously gets the chat message transports available on the device.
     * @return  An asynchronous operation that returns a list of transports on successful completion.
     */
    getTransportsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously registers the app as a ChatMessageTransport in order to post messages to the ChatMessageStore .
     * @return  The transport ID for the newly registered ChatMessageTransport .
     */
    registerTransportAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Returns the SMS messaging store for the phone.
     * @return  An asynchronous operation that returns a ChatMessageStore on successful completion.
     */
    requestStoreAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ChatMessageStore>;

    /**
     * Shows the compose SMS dialog, pre-populated with data from the supplied ChatMessage object, allowing the user to send an SMS message.
     * @param message The chat message.
     * @return  An asynchronous action.
     */
    showComposeSmsMessageAsync(message: undefined.ChatMessage): undefined.IPromiseWithIAsyncAction;

    /**
     * Launches the device's SMS settings app. 
     */
    showSmsSettings(): void
}


/**
 * Represents the message notification triggered from a registered background task. A chat app can receive notifications of incoming messages or send events by setting a task trigger and task entry point. 
 */
declare class ChatMessageNotificationTriggerDetails {

    /**
     * Gets the message associated with the notification. This is either an incoming message or an outgoing message with a send status event. 
     */
    chatMessage: undefined.ChatMessage;

    /**
     * Gets a Boolean value indicating if the background task should issue a toast notification for the message. 
     */
    shouldDisplayToast: boolean;

    /**
     * Gets a Boolean value indicating if the Windows Action Center should be updated with the message. 
     */
    shouldUpdateActionCenter: boolean;

    /**
     * Gets a Boolean value indicating if the background task should update the app’s lock screen count. 
     */
    shouldUpdateBadge: boolean;

    /**
     * Gets a Boolean value indicating that the background task should update the app's tile count for the message. 
     */
    shouldUpdateDetailText: boolean
}


/**
 * Provides methods for reading messages from the message store. 
 */
declare class ChatMessageReader {

    /**
     * Returns a batch list of chat messages from the message store.
     * @return  An asynchronous operation that returns a list of chat messages upon successful completion.
     */
    readBatchAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Returns a batch list of chat messages from the message store limited to the specified size.
     * @param count The size of the batch to read.
     * @return  An asynchronous operation that returns a list of chat messages upon successful completion.
     */
    readBatchAsync(
        count: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >>
}


/**
 * Provides the methods and properties to read, manage and send messages. An application gets access to the message store using the static ChatMessageManager class . 
 */
declare class ChatMessageStore {

    /**
     * Gets a ChatMessageChangeTracker class object for the message store. A message change tracker allows an application to monitor changes to messages in the message store. 
     */
    changeTracker: undefined.ChatMessageChangeTracker;

    /**
     * Deletes a message from the chat message store.
     * @param localMessageId The local ID of the message to be deleted.
     * @return  An asynchronous action.
     */
    deleteMessageAsync(localMessageId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Downloads a message specified by the identifier to the message store.
     * @param localChatMessageId The local ID of the message to be downloaded.
     * @return  An asynchronous action.
     */
    downloadMessageAsync(localChatMessageId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously forwards the specified message to new recipients.
     * @param localChatMessageId The ID of the message to forward.
     * @param addresses The addresses of the new recipients of the forwarded message.
     * @return  A copy of the forwarded message.
     */
    forwardMessageAsync(
        localChatMessageId: string,
        addresses: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.ChatMessage>;

    /**
     * Asynchronously gets a ChatConversation by ID using the specified transports.
     * @param conversationId The ID of the conversation to retrieve.
     * @param transportIds The IDs of the transports to use to retrieve the ChatConversation .
     * @return  The ChatConversation specified by the conversationId parameter.
     */
    getConversationAsync(
        conversationId: string,
        transportIds: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.ChatConversation>;

    /**
     * Asynchronously gets a ChatConversation by ID.
     * @param conversationId The ID of the conversation to retrieve.
     * @return  The ChatConversation specified by the conversationId parameter.
     */
    getConversationAsync(
        conversationId: string): undefined.IPromiseWithIAsyncOperation<undefined.ChatConversation>;

    /**
     * Asynchronously gets a conversation based on a threading info object.
     * @param threadingInfo The threading info that identifies the conversation.
     * @return  The conversation identified by the threadingInfo parameter.
     */
    getConversationFromThreadingInfoAsync(
        threadingInfo: undefined.ChatConversationThreadingInfo): undefined.IPromiseWithIAsyncOperation<undefined.ChatConversation>;

    /**
     * Gets a new or existing ChatConversationReader for the message store.
     * @return  The new or existing ChatConversationReader .
     */
    getConversationReader(): undefined.ChatConversationReader;

    /**
     * Gets a new or existing ChatConversationReader for the message store using the specified transports.
     * @param transportIds The IDs for the transports to use to retrieve the ChatConversationReader .
     * @return  The new or existing ChatConversationReader .
     */
    getConversationReader(transportIds: undefined.IIterable<string>): undefined.ChatConversationReader;

    /**
     * Retrieves a message specified by an identifier from the message store.
     * @param localChatMessageId The local ID of the chat message to be retrieved.
     * @return  An asynchronous operation that returns a chat message upon successful completion.
     */
    getMessageAsync(
        localChatMessageId: string): undefined.IPromiseWithIAsyncOperation<undefined.ChatMessage>;

    /**
     * Gets a message by its remote ID.
     * @param transportId The TransportId to use to get the ChatMessage .
     * @param remoteId The RemoteId of the ChatMessage to retrieve.
     * @return  The message.
     */
    getMessageByRemoteIdAsync(
        transportId: string,
        remoteId: string): undefined.IPromiseWithIAsyncOperation<undefined.ChatMessage>;

    /**
     * Gets a ChatMessageReader class object which provides a message collection from the message store.
     * @return  The chat message reader.
     */
    getMessageReader(): undefined.ChatMessageReader;

    /**
     * Gets a ChatMessageReader class object which provides a message collection from the message store. The collection of messages is limited to the time span provided.
     * @param recentTimeLimit The time window for the retrieved reader.
     * @return  The chat message reader.
     */
    getMessageReader(recentTimeLimit: number): undefined.ChatMessageReader;

    /**
     * Gets a new or existing ChatSearchReader to be used to search for messages.
     * @param value The query options that the search reader will use when looking for matching messages.
     * @return  The new or existing search reader.
     */
    getSearchReader(value: undefined.ChatQueryOptions): undefined.ChatSearchReader;

    /**
     * Asynchronously gets the number of unread chat messages using the specified transports.
     * @param transportIds The IDs of the chat transports to use to get the unseen messages count.
     * @return  The number of unread chat messages.
     */
    getUnseenCountAsync(
        transportIds: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Asynchronously gets the number of unread chat messages.
     * @return  The number of unread chat messages.
     */
    getUnseenCountAsync(): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Asynchronously marks all transport messages as seen.
     * @param transportIds The IDs of the transports for which to mark all messages as seen.
     * @return  An async action indicating that the operation has finished.
     */
    markAsSeenAsync(transportIds: undefined.IIterable<string>): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously marks all transport messages as seen.
     * @return  An async action indicating that the operation has finished.
     */
    markAsSeenAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Marks a specified message in the store as already read.
     * @param localChatMessageId The local ID of the message to be marked as read.
     * @return  An asynchronous action.
     */
    markMessageReadAsync(localChatMessageId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * An event that occurs when a message in the message store is changed. 
     */
    onmessagechanged: undefined.TypedEventHandler<undefined.ChatMessageStore, undefined.ChatMessageChangedEventArgs>;
    addEventListener(
        type: "messagechanged",
        listener: undefined.TypedEventHandler<undefined.ChatMessageStore, undefined.ChatMessageChangedEventArgs>): void;
    removeEventListener(
        type: "messagechanged",
        listener: undefined.TypedEventHandler<undefined.ChatMessageStore, undefined.ChatMessageChangedEventArgs>): void;

    /**
     * Occurs when something in the ChatMessageStore has changed. 
     */
    onstorechanged: undefined.TypedEventHandler<undefined.ChatMessageStore, undefined.ChatMessageStoreChangedEventArgs>;
    addEventListener(
        type: "storechanged",
        listener: undefined.TypedEventHandler<undefined.ChatMessageStore, undefined.ChatMessageStoreChangedEventArgs>): void;
    removeEventListener(
        type: "storechanged",
        listener: undefined.TypedEventHandler<undefined.ChatMessageStore, undefined.ChatMessageStoreChangedEventArgs>): void;

    /**
     * Attempts a retry of sending a specified message from the message store.
     * @param localChatMessageId The local ID of the message to be retried.
     * @return  An asynchronous action.
     */
    retrySendMessageAsync(localChatMessageId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously saves a message to the ChatMessageStore .
     * @param chatMessage The message to save.
     * @return  An async action indicating that the operation has finished.
     */
    saveMessageAsync(chatMessage: undefined.ChatMessage): undefined.IPromiseWithIAsyncAction;

    /**
     * Attempts to send a chat message. The message is saved to the message store as part of the send operation.
     * @param chatMessage The chat message to be sent.
     * @return  An asynchronous action.
     */
    sendMessageAsync(chatMessage: undefined.ChatMessage): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously attempts to cancel downloading the specified message.
     * @param localChatMessageId The ID of the message to stop downloading.
     * @return  An async action indicating that the operation has completed.
     */
    tryCancelDownloadMessageAsync(localChatMessageId: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to cancel sending the specified message.
     * @param localChatMessageId The ID of the message to stop sending.
     * @return  An async action indicating that the operation has completed.
     */
    tryCancelSendMessageAsync(localChatMessageId: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Checks if a chat message is valid and returns the validation result.
     * @param chatMessage The chat message to validate.
     * @return  The validation result.
     */
    validateMessage(chatMessage: undefined.ChatMessage): undefined.ChatMessageValidationResult;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides the data for the ChatMessageStoreChanged event. 
 */
declare class ChatMessageStoreChangedEventArgs {

    /**
     * Gets the ID of the object that changed. 
     */
    id: string;

    /**
     * Gets the type of change that happened. 
     */
    kind: undefined.ChatStoreChangedEventKind
}


/**
 * Represents the identity of a transport for sending and receiving messages. Physically, a chat message transport is a SIM slot on the phone. 
 */
declare class ChatMessageTransport {

    /**
     * Gets the configuration of the message transport. 
     */
    configuration: undefined.ChatMessageTransportConfiguration;

    /**
     * Gets a Boolean value that indicates whether the messaging transport is active. 
     */
    isActive: boolean;

    /**
     * Gets a Boolean value that indicates whether the current application is set as the messaging notification provider. 
     */
    isAppSetAsNotificationProvider: boolean;

    /**
     * Sets the current application to handle messaging notifications.
     * @return  An asynchronous action.
     */
    requestSetAsNotificationProviderAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets a descriptive name identifying the messaging transport. 
     */
    transportFriendlyName: string;

    /**
     * Gets the messaging transport’s identifier. 
     */
    transportId: string;

    /**
     * Gets the type of the message transport. 
     */
    transportKind: undefined.ChatMessageTransportKind
}


/**
 * Represents data about the chat message transport. 
 */
declare class ChatMessageTransportConfiguration {

    /**
     * Gets the extended properties of the transport. 
     */
    extendedProperties: undefined.IMapView<string, any>;

    /**
     * Gets the maximum attachment limit for a message on the transport. 
     */
    maxAttachmentCount: number;

    /**
     * Gets the maximum size of an attachment for the transport. 
     */
    maxMessageSizeInKilobytes: number;

    /**
     * Gets the maximum number of recipients for the transport. 
     */
    maxRecipientCount: number;

    /**
     * Gets the supported video encoding format for the transport. 
     */
    supportedVideoFormat: undefined.MediaEncodingProfile
}


/**
 * Provides results for validation of chat messages. 
 */
declare class ChatMessageValidationResult {

    /**
     * Gets the maximum number of text fragments allowed for a message. This value has meaning when the SMS text portion of a message is validated. 
     */
    maxPartCount: number;

    /**
     * Gets the total number of text fragments needed for this message. This value has meaning when the SMS text portion of a message is validated. 
     */
    partCount: number;

    /**
     * Gets the number of characters not used in the final message fragments. This value has meaning when the SMS text portion of a message is validated. 
     */
    remainingCharacterCountInPart: number;

    /**
     * Gets the message validation status code. 
     */
    status: undefined.ChatMessageValidationStatus
}


/**
 * Represents the criteria for finding chat messages. 
 */
declare class ChatQueryOptions {

    /**
     * Initializes a new instance of the ChatQueryOptions class. 
     */
    constructor(): this;

    /**
     * Gets or sets the string to search for the in ChatMessageStore . 
     */
    searchString: string
}


/**
 * Represent the delivery info about a chat recipient. 
 */
declare class ChatRecipientDeliveryInfo {

    /**
     * Initializes a new instance of the ChatRecipientDeliveryInfo class. 
     */
    constructor(): this;

    /**
     * Gets or sets the time the message was sent to the recipient. 
     */
    deliveryTime: Date;

    /**
     * Gets a Boolean value indicating whether the error for the message that was sent to the recipient is permanent. 
     */
    isErrorPermanent: boolean;

    /**
     * Gets or sets the time the recipient read the message. 
     */
    readTime: Date;

    /**
     * Gets the status of the message. 
     */
    status: undefined.ChatMessageStatus;

    /**
     * Gets or sets the transport address of the recipient. 
     */
    transportAddress: string;

    /**
     * Get the transport error code. 
     */
    transportErrorCode: number;

    /**
     * Gets the category for the TransportErrorCode . 
     */
    transportErrorCodeCategory: undefined.ChatTransportErrorCodeCategory;

    /**
     * Gets the interpreted error code for the transport. 
     */
    transportInterpretedErrorCode: undefined.ChatTransportInterpretedErrorCode
}


/**
 * Provides functionality to search for chat messages in the ChatMessageStore . 
 */
declare class ChatSearchReader {

    /**
     * Returns a batch of found items matching the search criteria.
     * @param count The maximum number of items to return.
     * @return  A list of items matching the search criteria.
     */
    readBatchAsync(
        count: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Returns a batch of found items matching the search criteria.
     * @return  A list of items matching the search criteria.
     */
    readBatchAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >>
}


/**
 * Represents a Rich Communication Services (RCS) end user message. 
 */
declare class RcsEndUserMessage {

    /**
     * Gets the actions to which the user can respond. 
     */
    actions: undefined.IVectorView<undefined.RcsEndUserMessageAction>;

    /**
     * Gets a Boolean value that specifies whether a PIN is required to be sent back with the response. 
     */
    isPinRequired: boolean;

    /**
     * Asynchronously sends the user's selection back.
     * @param action Specifies the label of the action.
     * @return  An async action indicating that the operation has completed.
     */
    sendResponseAsync(action: undefined.RcsEndUserMessageAction): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously sends the user's selection back with the specified PIN.
     * @param action Specifies the label of the action.
     * @param pin The PIN to send.
     * @return  An async action indicating that the operation has completed.
     */
    sendResponseWithPinAsync(
        action: undefined.RcsEndUserMessageAction,
        pin: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the contents of the message. 
     */
    text: string;

    /**
     * Gets the title of the message. 
     */
    title: string;

    /**
     * Gets the ID of the transport where this message originated. 
     */
    transportId: string
}


/**
 * Represents the actions to which the user can respond. 
 */
declare class RcsEndUserMessageAction {

    /**
     * Gets the label of the action. 
     */
    label: string
}


/**
 * Provides the data for a MessageAvailableChanged event. 
 */
declare class RcsEndUserMessageAvailableEventArgs {

    /**
     * Gets a Boolean value indicating if a new message is available. 
     */
    isMessageAvailable: boolean;

    /**
     * Gets the actual message to display, or empty if IsMessageAvailable is FALSE. 
     */
    message: undefined.RcsEndUserMessage
}


/**
 * Provides data to the background task about a new message. 
 */
declare class RcsEndUserMessageAvailableTriggerDetails {

    /**
     * Gets the text of the new message. 
     */
    text: string;

    /**
     * Gets the title of the new message. 
     */
    title: string
}


/**
 * Provides functionality for handling message events. 
 */
declare class RcsEndUserMessageManager {

    /**
     * Occurs when a new message is available. 
     */
    onmessageavailablechanged: undefined.TypedEventHandler<undefined.RcsEndUserMessageManager, undefined.RcsEndUserMessageAvailableEventArgs>;
    addEventListener(
        type: "messageavailablechanged",
        listener: undefined.TypedEventHandler<undefined.RcsEndUserMessageManager, undefined.RcsEndUserMessageAvailableEventArgs>): void;
    removeEventListener(
        type: "messageavailablechanged",
        listener: undefined.TypedEventHandler<undefined.RcsEndUserMessageManager, undefined.RcsEndUserMessageAvailableEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides access to APIs for handling Rich Communication Services (RCS) messages. 
 */
declare class RcsManager {

    /**
     * Gets the RcsEndUserMessageManager .
     * @return  The end user message manager.
     */
    getEndUserMessageManager(): undefined.RcsEndUserMessageManager;

    /**
     * Gets an instance of RcsTransport for the specified transport ID.
     * @param transportId The ID of the transport to retrieve.
     * @return  An instance of the transport specified by the transportId parameter.
     */
    getTransportAsync(
        transportId: string): undefined.IPromiseWithIAsyncOperation<undefined.RcsTransport>;

    /**
     * Gets all instances of RcsTransport .
     * @return  A list of RcsTransport instances.
     */
    getTransportsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously allows a user to leave a particular conversation.
     * @param conversation The conversation to leave.
     * @return  An async action indicating that the operation has completed.
     */
    leaveConversationAsync(conversation: undefined.ChatConversation): undefined.IPromiseWithIAsyncAction
}


/**
 * Provides data for the ServiceKindSupportedChanged event. 
 */
declare class RcsServiceKindSupportedChangedEventArgs {

    /**
     * Gets the type of the Rich Communication Services (RCS) service. 
     */
    serviceKind: undefined.RcsServiceKind
}


/**
 * Provides functionality for accessing the Rich Communication Services (RCS) transport. 
 */
declare class RcsTransport {

    /**
     * Gets a configuration object that describes the transport settings. 
     */
    configuration: undefined.RcsTransportConfiguration;

    /**
     * Gets a name-value pair for extensibility of service provider configuration values. 
     */
    extendedProperties: undefined.IMapView<string, any>;

    /**
     * Gets a Boolean value indicating if the transport is active. 
     */
    isActive: boolean;

    /**
     * Gets a Boolean value indicating if the specified service kind is supported, such as chat, group chat, file transfer, and so on.
     * @param serviceKind The service kind to verify.
     * @return  TRUE if the RcsServiceKind specified in the serviceKind parameter is supported.
     */
    isServiceKindSupported(serviceKind: undefined.RcsServiceKind): boolean;

    /**
     * Gets a Boolean value indicating if the specified service kind supports store and forward functionality.
     * @param serviceKind The service kind to check for store and forward functionality.
     * @return  A Boolean value indicating if the serviceKind supports store and forward.
     */
    isStoreAndForwardEnabled(serviceKind: undefined.RcsServiceKind): boolean;

    /**
     * Occurs when the service capabilities change. 
     */
    onservicekindsupportedchanged: undefined.TypedEventHandler<undefined.RcsTransport, undefined.RcsServiceKindSupportedChangedEventArgs>;
    addEventListener(
        type: "servicekindsupportedchanged",
        listener: undefined.TypedEventHandler<undefined.RcsTransport, undefined.RcsServiceKindSupportedChangedEventArgs>): void;
    removeEventListener(
        type: "servicekindsupportedchanged",
        listener: undefined.TypedEventHandler<undefined.RcsTransport, undefined.RcsServiceKindSupportedChangedEventArgs>): void;

    /**
     * Gets the friendly name of the transport. 
     */
    transportFriendlyName: string;

    /**
     * Gets the ID for the transport that is unique on the device. 
     */
    transportId: string;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data about the configuration of a Rich Communication Services (RCS) transport. 
 */
declare class RcsTransportConfiguration {

    /**
     * Gets the maximum number of attachments supported by the transport. 
     */
    maxAttachmentCount: number;

    /**
     * Gets the maximum size of a file that can be sent using the transport. 
     */
    maxFileSizeInKilobytes: number;

    /**
     * Gets the maximum size of a group chat message supported by the transport. 
     */
    maxGroupMessageSizeInKilobytes: number;

    /**
     * Gets the maximum size of a chat message supported by the transport. 
     */
    maxMessageSizeInKilobytes: number;

    /**
     * Gets the maximum number of recipients supported for a group chat. 
     */
    maxRecipientCount: number;

    /**
     * Gets the size at which the user should be warned that they are attaching a large file for the transport. 
     */
    warningFileSizeInKilobytes: number
}


/**
 * Provides data to the RemoteParticipantComposingChanged event. 
 */
declare class RemoteParticipantComposingChangedEventArgs {

    /**
     * Gets a Boolean value indicating if the remote participant is currently composing a message. 
     */
    isComposing: boolean;

    /**
     * Gets the address of the remote chat participant. 
     */
    participantAddress: string;

    /**
     * Gets the ID for the message transport. 
     */
    transportId: string
}


/**
 * Provides functionality for linking individual (raw) contacts across services together into a single aggregate contact. 
 */
declare class AggregateContactManager {

    /**
     * Returns the list of individual (raw) contacts from the specified aggregate contact.
     * @param contact The aggregate contact from which to extract the list of raw contacts.
     * @return  The list of individual (raw) contacts from the specified aggregate contact.
     */
    findRawContactsAsync(
        contact: undefined.Contact): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously attempts to link contacts together to make an aggregate contact.
     * @param primaryContact The first contact to link.
     * @param secondaryContact The second contact to link to the primaryContact.
     * @return  The newly created aggregate contact.
     */
    tryLinkContactsAsync(
        primaryContact: undefined.Contact,
        secondaryContact: undefined.Contact): undefined.IPromiseWithIAsyncOperation<undefined.Contact>;

    /**
     * Chooses which of the raw contacts provides the main display picture for the aggregate.
     * @param aggregateContact The aggregate contact on which to set the picture.
     * @param rawContact The raw contact that provides the picture for the aggregate.
     * @return  True if successful, otherwise false.
     */
    trySetPreferredSourceForPictureAsync(
        aggregateContact: undefined.Contact,
        rawContact: undefined.Contact): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously unlinks a raw contact from the parent aggregate contact.
     * @param contact The raw contact to remove from the aggregate.
     * @return  An async action that indicates the operation is complete.
     */
    unlinkRawContactAsync(contact: undefined.Contact): undefined.IPromiseWithIAsyncAction
}


/**
 * Represents a contact. 
 */
declare class Contact {

    /**
     * Creates a new instance of the Contact class. 
     */
    constructor(): this;

    /**
     * Gets the contact addresses for a contact. 
     */
    addresses: undefined.IVector<undefined.ContactAddress>;

    /**
     * If this is a raw contact that is part of an aggregate contact, then this property identifies the parent aggregate. 
     */
    aggregateId: string;

    /**
     * Gets the connected service accounts for a contact. 
     */
    connectedServiceAccounts: undefined.IVector<undefined.ContactConnectedServiceAccount>;

    /**
     * Gets a string that identifies the ContactList to which this contact is a member. 
     */
    contactListId: string;

    /**
     * Gets the data suppliers for a contact. The maximum string length for each data supplier is 50 characters. 
     */
    dataSuppliers: undefined.IVector<string>;

    /**
     * Gets the display name for a contact. 
     */
    displayName: string;

    /**
     * Gets or sets the display that was manually entered by the user. 
     */
    displayNameOverride: string;

    /**
     * Gets or sets the last time the user updated their display picture. 
     */
    displayPictureUserUpdateTime: Date;

    /**
     * Gets the email addresses for a contact. 
     */
    emails: undefined.IVector<undefined.ContactEmail>;

    /**
     * Sets the fields that contain information about a contact. 
     */
    fields: undefined.IVector<undefined.IContactField>;

    /**
     * Gets and sets the first name for a contact. The maximum string length for the first name is 64 characters. 
     */
    firstName: string;

    /**
     * Gets the full name of the Contact . 
     */
    fullName: string;

    /**
     * Gets and sets the honorific prefix for the name for a contact. The maximum string length for the honorific prefix is 32 characters. 
     */
    honorificNamePrefix: string;

    /**
     * Gets and sets the honorific suffix for the name for a contact. The maximum string length for the honorific suffix is 32 characters. 
     */
    honorificNameSuffix: string;

    /**
     * Gets and sets the identifier for a contact. The maximum string length for the identifier is 256 characters. 
     */
    id: string;

    /**
     * Gets the important dates for a contact. 
     */
    importantDates: undefined.IVector<undefined.ContactDate>;

    /**
     * Gets a Boolean value indicating of this is an aggregate Contact . 
     */
    isAggregate: boolean;

    /**
     * Gets a Boolean value indicating if the user manually set the picture for the Contact . 
     */
    isDisplayPictureManuallySet: boolean;

    /**
     * Gets a Boolean value indicating if this Contact represents the user logged into the device. 
     */
    isMe: boolean;

    /**
     * Gets the job info items for a contact. 
     */
    jobInfo: undefined.IVector<undefined.ContactJobInfo>;

    /**
     * Gets a large version of the display picture for the Contact . 
     */
    largeDisplayPicture: undefined.IRandomAccessStreamReference;

    /**
     * Gets and sets the last name for a contact. The maximum string length for the last name is 64 characters. 
     */
    lastName: string;

    /**
     * Gets and sets the middle name for a contact. The maximum string length for the middle name is 64 characters. 
     */
    middleName: string;

    /**
     * Sets and gets the name of the contact. 
     */
    name: string;

    /**
     * Gets or sets the nickname for the Contact . 
     */
    nickname: string;

    /**
     * Gets and sets notes for a contact. The maximum string length for notes is 4096 characters. 
     */
    notes: string;

    /**
     * Gets info about the phones for a contact. 
     */
    phones: undefined.IVector<undefined.ContactPhone>;

    /**
     * Gets the property set object for the contact. 
     */
    providerProperties: undefined.IPropertySet;

    /**
     * Gets or sets an ID that can be used by a service provider to access the Contact in their remote system. 
     */
    remoteId: string;

    /**
     * Gets or puts the path to the ringtone file for the Contact . 
     */
    ringToneToken: string;

    /**
     * Gets the significant others for a contact. 
     */
    significantOthers: undefined.IVector<undefined.ContactSignificantOther>;

    /**
     * Gets a small version of the display picture for the Contact . 
     */
    smallDisplayPicture: undefined.IRandomAccessStreamReference;

    /**
     * Gets the name used to sort the contact. 
     */
    sortName: string;

    /**
     * Gets or sets the display picture for the Contact in its original size. 
     */
    sourceDisplayPicture: undefined.IRandomAccessStreamReference;

    /**
     * Gets or puts the path to the audio file to play when an SMS/MMS message is received from the Contact . 
     */
    textToneToken: string;
    thumbnail: any;

    /**
     * Gets the Web sites for a contact. 
     */
    websites: undefined.IVector<undefined.ContactWebsite>;

    /**
     * Gets the Yomi (phonetic Japanese equivalent) display name for a contact. 
     */
    yomiDisplayName: string;

    /**
     * Gets the Yomi (phonetic Japanese equivalent) family name for a contact. The maximum string length for the Yomi family name is 120 characters. 
     */
    yomiFamilyName: string;

    /**
     * Gets the Yomi (phonetic Japanese equivalent) given name for a contact. The maximum string length for the Yomi given name is 120 characters. 
     */
    yomiGivenName: string
}


/**
 * Represents the address of a contact. 
 */
declare class ContactAddress {

    /**
     * Initializes a new instance of a ContactAddress class. 
     */
    constructor(): this;

    /**
     * Gets and sets the country of a contact address. The maximum string length for the country is 1024 characters. 
     */
    country: string;

    /**
     * Gets and sets the description of a contact address. The maximum string length for the description is 512 characters. 
     */
    description: string;

    /**
     * Gets and sets the kind of contact address. 
     */
    kind: undefined.ContactAddressKind;

    /**
     * Gets and sets the locality of a contact address. The maximum string length for the locality is 1024 characters. 
     */
    locality: string;

    /**
     * Gets and sets the postal code of a contact address. The maximum string length for the postal code is 1024 characters. 
     */
    postalCode: string;

    /**
     * Gets and sets the region of a contact address. The maximum string length for the region is 1024 characters. 
     */
    region: string;

    /**
     * Gets and sets the street address of a contact address. The maximum string length for the street address is 1024 characters. 
     */
    streetAddress: string
}


/**
 * Provides a way to tag existing user contacts with additional information, specifying that your app can perform some SupportedOperations for this particular contact. 
 */
declare class ContactAnnotation {

    /**
     * Initializes a new instance of the ContactAnnotation class. 
     */
    constructor(): this;

    /**
     * Gets the ID for the parent ContactAnnotationList that this ContactAnnotation is contained within. 
     */
    annotationListId: string;

    /**
     * Gets or set the ID for the Contact to which this ContactAnnotation applies. 
     */
    contactId: string;

    /**
     * Gets the ID for this ContactAnnotation . 
     */
    id: string;

    /**
     * Gets a Boolean value indicating if this ContactAnnotation has been disabled by the user. 
     */
    isDisabled: boolean;

    /**
     * Provides a place to store data to be used by the app when interacting with a service provider. 
     */
    providerProperties: undefined.ValueSet;

    /**
     * Gets or sets an ID that can be used by a service provider to access the corresponding entity in their remote system. 
     */
    remoteId: string;

    /**
     * Gets or sets the group of ContactAnnotationOperations supported by this ContactAnnotation . 
     */
    supportedOperations: undefined.ContactAnnotationOperations
}


/**
 * Represents a list of ContactAnnotation objects. 
 */
declare class ContactAnnotationList {

    /**
     * Asynchronously deletes the specified ContactAnnotation from the list.
     * @param annotation The annotation to delete from the list.
     * @return  An async action indicating that the operation has completed.
     */
    deleteAnnotationAsync(annotation: undefined.ContactAnnotation): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously deletes this ContactAnnotationList from the ContactAnnotationStore .
     * @return  An async action indicating that the operation has completed.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously gets the list of ContactAnnotation objects.
     * @return  The list of ContactAnnotation objects.
     */
    findAnnotationsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the list of ContactAnnotation objects containing the specified remote ID property.
     * @param remoteId The remote ID used to find the ContactAnnotation objects.
     * @return  The list of ContactAnnotation objects containing the specified remote ID property.
     */
    findAnnotationsByRemoteIdAsync(
        remoteId: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the ContactAnnotation with the specified Id .
     * @param annotationId The ContactAnnotation.Id used to identify the ContactAnnotation .
     * @return  The ContactAnnotation with the specified ID.
     */
    getAnnotationAsync(
        annotationId: string): undefined.IPromiseWithIAsyncOperation<undefined.ContactAnnotation>;

    /**
     * Gets the ID for this ContactAnnotationList . 
     */
    id: string;

    /**
     * Gets the unique identifier for the app package that created the ContactAnnotationList . 
     */
    providerPackageFamilyName: string;

    /**
     * Asynchronously attempts to save the ContactAnnotation to the ContactAnnotationList .
     * @param annotation The annotation to save to the list.
     * @return  True if the save was successful, otherwise false.
     */
    trySaveAnnotationAsync(
        annotation: undefined.ContactAnnotation): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets the ID for the UserDataAccount used by the app. 
     */
    userDataAccountId: string
}


/**
 * Represents a data store that contains contact annotations. 
 */
declare class ContactAnnotationStore {

    /**
     * Asynchronously creates a ContactAnnotationList and associates it with the specified user data account ID.
     * @param userDataAccountId The ID for the user data account with which to associate the new ContactAnnotationList . The user data account must be owned by this app.
     * @return  The newly created ContactAnnotationList .
     */
    createAnnotationListAsync(
        userDataAccountId: string): undefined.IPromiseWithIAsyncOperation<undefined.ContactAnnotationList>;

    /**
     * Asynchronously creates a ContactAnnotationList .
     * @return  The newly created ContactAnnotationList .
     */
    createAnnotationListAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ContactAnnotationList>;

    /**
     * Asynchronously disables the specified ContactAnnotation , usually as a result of user input.
     * @param annotation The annotation to disable.
     * @return  An async action indicating that the operation has completed.
     */
    disableAnnotationAsync(annotation: undefined.ContactAnnotation): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously gets the list of ContactAnnotationList objects for the app.
     * @return  The list of ContactAnnotationList objects.
     */
    findAnnotationListsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Get the annotations for the specified Contact .
     * @param contact The Contact for which to retrieve annotations.
     * @return  The list of ContactAnnotation objects.
     */
    findAnnotationsForContactAsync(
        contact: undefined.Contact): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets a list of Id values based on Contact objects with a specified email address.
     * @param emailAddress The email address used to find the contact Id values.
     * @return  The list of Contact objects containing the specified emailAddress.
     */
    findContactIdsByEmailAsync(
        emailAddress: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets a list of Id values based on Contact objects with a specified phone number.
     * @param phoneNumber The phone number used to find the contact Id values.
     * @return  The list of Contact objects containing the specified phoneNumber.
     */
    findContactIdsByPhoneNumberAsync(
        phoneNumber: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously gets the ContactAnnotationList with the specified ID.
     * @param annotationListId The ID of the ContactAnnotationList to get.
     * @return  The ContactAnnotationList with the ID specified in annotationListId.
     */
    getAnnotationListAsync(
        annotationListId: string): undefined.IPromiseWithIAsyncOperation<undefined.ContactAnnotationList >
}


/**
 * Represents a group of Contact objects and server search status. 
 */
declare class ContactBatch {

    /**
     * Gets the list of Contact objects returned by a search operation. 
     */
    contacts: undefined.IVectorView<undefined.Contact>;

    /**
     * Gets a ContactBatchStatus value that indicates if a search was successful or if there was a server error. 
     */
    status: undefined.ContactBatchStatus
}


/**
 * Represents a delayed data loader for a contact card. 
 */
declare class ContactCardDelayedDataLoader {

    /**
     * Closes the delayed data loader. This informs the contact card to complete the UI (for example, remove any progress indications, like the progress bar) because no more updates to the contact card UI will be requested. The user then can determine that the contact data shown in the UI is complete. 
     */
    close(): void;

    /**
     * Updates the contact card with the Contact object and completes the contact card UI.
     * @param contact The contact to update the contact card with.
     */
    setData(contact: undefined.Contact): void
}


/**
 * Represents data about how to display a mini contact card. 
 */
declare class ContactCardOptions {

    /**
     * Initializes a new instance of the ContactCardOptions class. 
     */
    constructor(): this;

    /**
     * Gets or sets a value that specifies the type of header to display on the contact card. 
     */
    headerKind: undefined.ContactCardHeaderKind;

    /**
     * Gets or sets a value that indicates which tab to display first on a mini contact card. 
     */
    initialTabKind: undefined.ContactCardTabKind;

    /**
     * Gets a list to which you can add ContactList.Id values to search for on the server. 
     */
    serverSearchContactListIds: undefined.IVector<string >
}


/**
 * Represents a change to a Contact . 
 */
declare class ContactChange {

    /**
     * Gets a value that indicates the type of change that occurred. 
     */
    changeType: undefined.ContactChangeType;

    /**
     * Gets the Contact object that changed. 
     */
    contact: undefined.Contact
}


/**
 * Provides a way to monitor and react to changes to contacts. 
 */
declare class ContactChangeReader {

    /**
     * Call this method to indicate that you have processed and accepted all changes and you don't want the system to show them to you again. 
     */
    acceptChanges(): void;

    /**
     * Call this method to indicate that you have processed and accepted up through the specified change.
     * @param lastChangeToAccept The last change that you want to system to track as accepted by your app.
     */
    acceptChangesThrough(lastChangeToAccept: undefined.ContactChange): void;

    /**
     * Asynchronously gets a list of ContactChange objects.
     * @return  A list of ContactChange objects.
     */
    readBatchAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >>
}


/**
 * Provides functionality for monitoring changes to Contact objects in the ContactStore . 
 */
declare class ContactChangeTracker {

    /**
     * Call this method to enable change tracking. 
     */
    enable(): void;

    /**
     * Gets a ContactChangeReader that can be used to process changes.
     * @return  A ContactChangeReader that can be used to process changes.
     */
    getChangeReader(): undefined.ContactChangeReader;

    /**
     * Call this method to reset the change tracker if your app receives ContactChangeType.ChangeTrackingLost . 
     */
    reset(): void
}


/**
 * The deferral object to use while asynchronously processing ContactChanged events. 
 */
declare class ContactChangedDeferral {

    /**
     * Call this method in order to release the deferral object when all asynchronous processing has finished. 
     */
    complete(): void
}


/**
 * Provides data for the ContactChanged event. 
 */
declare class ContactChangedEventArgs {

    /**
     * Gets the ContactChangedDeferral object to use for asynchronous operations.
     * @return  The deferral object to use for asynchronous operations.
     */
    getDeferral(): undefined.ContactChangedDeferral
}


/**
 * Represents a connected service account for a contact. 
 */
declare class ContactConnectedServiceAccount {

    /**
     * Initializes a new instance of a ContactConnectedServiceAccount class. 
     */
    constructor(): this;

    /**
     * Gets and sets the identifier of a connected service account for a contact. The maximum string length for the identifier is 321 characters. 
     */
    id: string;

    /**
     * Gets and sets the service name of a connected service account for a contact. The maximum string length for the service name is 256 characters. 
     */
    serviceName: string
}


/**
 * Represents an important date for a contact. 
 */
declare class ContactDate {

    /**
     * Initializes a new instance of a ContactDate class. 
     */
    constructor(): this;

    /**
     * Gets and sets the day for an important date for a contact. 
     */
    day: number;

    /**
     * Gets and sets the description for an important date for a contact. The maximum string length for the description is 512 characters. 
     */
    description: string;

    /**
     * Gets and sets the kind of important date for a contact. 
     */
    kind: undefined.ContactDateKind;

    /**
     * Gets and sets the month for an important date for a contact. 
     */
    month: number;

    /**
     * Gets and sets the year for an important date for a contact. 
     */
    year: number
}


/**
 * Represents an email address of a contact. 
 */
declare class ContactEmail {

    /**
     * Initializes a new instance of a ContactEmail class. 
     */
    constructor(): this;

    /**
     * Gets and sets the email address of a contact. The maximum string length for the description is 321 characters. 
     */
    address: string;

    /**
     * Gets and sets the description of an email address of a contact. The maximum string length for the description is 512 characters. 
     */
    description: string;

    /**
     * Gets and sets the kind of email address of a contact. 
     */
    kind: undefined.ContactEmailKind
}


/**
 * Describes a piece of contact data. 
 */
declare class ContactField {

    /**
     * Creates a new ContactField object.
     * @param name The name of the field.
     * @param value The value the field contains.
     * @param type The type of field.
     * @param category The category the field belongs to.
     */
    constructor(name: string, value: string, type: undefined.ContactFieldType, category: undefined.ContactFieldCategory): this;

    /**
     * Creates a new ContactField object.
     * @param value The value for the contact field.
     * @param type The type of contact data.
     * @param category The category that the contact belongs to.
     */
    constructor(value: string, type: undefined.ContactFieldType, category: undefined.ContactFieldCategory): this;

    /**
     * Creates a new ContactField object.
     * @param value The value that the field contains.
     * @param type The type of contact data.
     */
    constructor(value: string, type: undefined.ContactFieldType): this;

    /**
     * Gets the category for the contact data. 
     */
    category: undefined.ContactFieldCategory;

    /**
     * Gets the name of the field. 
     */
    name: string;

    /**
     * Gets the contact field type for the data. 
     */
    type: undefined.ContactFieldType;

    /**
     * Gets the value of the contact data. 
     */
    value: string
}


/**
 * Creates fields that contain information about a contact. You can then add these fields to a Contact object to create the contact. This class is available only to apps that support the Contact contract. 
 */
declare class ContactFieldFactory {

    /**
     * Creates an instance of the ContactFieldFactory class. 
     */
    constructor(): this;

    /**
     * Creates a field to contain information about a contact.
     * @param value The value for the field.
     * @param type The type of field.
     * @param category The category the field belongs to.
     * @return  Contains a field that you can add to a Contact object.
     */
    createField(
        value: string,
        type: undefined.ContactFieldType,
        category: undefined.ContactFieldCategory): undefined.ContactField;

    /**
     * Creates a field to contain information about a contact.
     * @param name The name of the field.
     * @param value The value of the field.
     * @param type The type of field.
     * @param category The category the field belongs to.
     * @return  Contains a field that you can add to a Contact object.
     */
    createField(
        name: string,
        value: string,
        type: undefined.ContactFieldType,
        category: undefined.ContactFieldCategory): undefined.ContactField;

    /**
     * Creates a field to contain information about a contact.
     * @param value The value for the field.
     * @param type The type of field.
     * @return  Contains a field that you can add to a Contact object.
     */
    createField(value: string, type: undefined.ContactFieldType): undefined.ContactField;

    /**
     * Creates a field to contain information about a contact's instant messaging account.
     * @param userName The user name for the instant messaging account.
     * @param category The category the field belongs to.
     * @return  Contains an instant messaging field that you can add to a Contact object.
     */
    createInstantMessage(
        userName: string,
        category: undefined.ContactFieldCategory): undefined.ContactInstantMessageField;

    /**
     * Creates a field to contain information about a contact's instant messaging account.
     * @param userName The user name of the instant messaging account.
     * @param category The category the field belongs to.
     * @param service The name of the instant messaging service.
     * @param displayText The text to display to prompt an instant messaging conversation.
     * @param verb The URI that starts an instant messaging conversation.
     * @return  Contains an instant messaging field that you can add to a Contact object.
     */
    createInstantMessage(
        userName: string,
        category: undefined.ContactFieldCategory,
        service: string,
        displayText: string,
        verb: undefined.Uri): undefined.ContactInstantMessageField;

    /**
     * Creates a field to contain information about a contact's instant messaging account.
     * @param userName The user name for the instant messaging account.
     * @return  Contains an instant messaging field that you can add to a Contact object.
     */
    createInstantMessage(userName: string): undefined.ContactInstantMessageField;

    /**
     * Creates a field to contain information about a contact's location.
     * @param unstructuredAddress The address of the contact in an unstructured format.
     * @param category The category the field belongs to.
     * @param street The street address for the address.
     * @param city The name of the city for the address.
     * @param region The name of the region for the address.
     * @param country The name of the country for the address.
     * @param postalCode The postal code for the address.
     * @return  Contains a location field that you can add to a Contact object.
     */
    createLocation(
        unstructuredAddress: string,
        category: undefined.ContactFieldCategory,
        street: string,
        city: string,
        region: string,
        country: string,
        postalCode: string): undefined.ContactLocationField;

    /**
     * Creates a field to contain information about a contact's location.
     * @param unstructuredAddress The address of the contact in an unstructured format.
     * @param category The category the field belongs to.
     * @return  Contains a location field that you can add to a Contact object.
     */
    createLocation(
        unstructuredAddress: string,
        category: undefined.ContactFieldCategory): undefined.ContactLocationField;

    /**
     * Creates a field to contain information about a contact's location.
     * @param unstructuredAddress The address of the contact in an unstructured format.
     * @return  Contains a location field that you can add to a Contact object.
     */
    createLocation(unstructuredAddress: string): undefined.ContactLocationField
}


/**
 * Contains the information about a contact. 
 */
declare class ContactInformation {

    /**
     * A read-only list of the custom fields stored with the contact. 
     */
    customFields: undefined.IVectorView<undefined.ContactField>;

    /**
     * A read-only list of email addresses stored with the contact. 
     */
    emails: undefined.IVectorView<undefined.ContactField>;

    /**
     * Gets the thumbnail image for the contact.
     * @return  An object that provides access to the thumbnail image.
     */
    getThumbnailAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStreamWithContentType>;

    /**
     * A read-only list of instant messaging accounts stored with the contact. 
     */
    instantMessages: undefined.IVectorView<undefined.ContactInstantMessageField>;

    /**
     * A read-only list of locations stored with the contact. 
     */
    locations: undefined.IVectorView<undefined.ContactLocationField>;

    /**
     * The name of the contact. 
     */
    name: string;

    /**
     * A read-only list of phone numbers stored with the contact. 
     */
    phoneNumbers: undefined.IVectorView<undefined.ContactField>;

    /**
     * Enables you to get the value for a custom field that is stored with a contact.
     * @param customName The name of the field.
     * @return  The value of the field.
     */
    queryCustomFields(customName: string): undefined.IVectorView<undefined.ContactField >
}


/**
 * Defines a field that is an instant messaging (IM) address. 
 */
declare class ContactInstantMessageField {

    /**
     * Creates a new ContactInstantMessageField object.
     * @param userName The user's name.
     */
    constructor(userName: string): this;

    /**
     * Creates a new ContactInstantMessageField object.
     * @param userName The user's name.
     * @param category The category of contact data.
     */
    constructor(userName: string, category: undefined.ContactFieldCategory): this;

    /**
     * Creates a new ContactInstantMessageField object.
     * @param userName The user's name.
     * @param category The category of the contact data.
     * @param service The name of the instant messaging service.
     * @param displayText The display text used with the instant messaging URI.
     * @param verb The URI that starts an instant message.
     */
    constructor(userName: string, category: undefined.ContactFieldCategory, service: string, displayText: string, verb: undefined.Uri): this;

    /**
     * Gets the category for the contact data. 
     */
    category: undefined.ContactFieldCategory;

    /**
     * Gets the display text for the Uniform Resource Identifier (URI) that starts an instant message. 
     */
    displayText: string;

    /**
     * Gets the Uniform Resource Identifier (URI) that can start an instant message. 
     */
    launchUri: undefined.Uri;

    /**
     * Gets the name of the field. 
     */
    name: string;

    /**
     * Gets the name of the service used for sending instant messages. 
     */
    service: string;

    /**
     * Gets the contact field type for the data. 
     */
    type: undefined.ContactFieldType;

    /**
     * Gets the user's name. 
     */
    userName: string;

    /**
     * Gets the value of the contact data. 
     */
    value: string
}


/**
 * Represents job info for a contact. 
 */
declare class ContactJobInfo {

    /**
     * Initializes a new instance of a ContactJobInfo class. 
     */
    constructor(): this;

    /**
     * Gets and sets the company address of the job info for a contact. The maximum string length for the company address is 1024 characters. 
     */
    companyAddress: string;

    /**
     * Gets and sets the company name of the job info for a contact. The maximum string length for the company name is 64 characters. 
     */
    companyName: string;

    /**
     * Gets and sets the company Yomi (phonetic Japanese equivalent) name of the job info for a contact. The maximum string length for the company Yomi name is 200 characters. 
     */
    companyYomiName: string;

    /**
     * Gets and sets the department of the job info for a contact. The maximum string length for the department is 100 characters. 
     */
    department: string;

    /**
     * Gets and sets the description of the job info for a contact. The maximum string length for the description is 512 characters. 
     */
    description: string;

    /**
     * Gets and sets the manager of the job info for a contact. The maximum string length for the manager is 1024 characters. 
     */
    manager: string;

    /**
     * Gets and sets the office of the job info for a contact. The maximum string length for the office is 40 characters. 
     */
    office: string;

    /**
     * Gets and sets the title of the job info for a contact. The maximum string length for the title is 1024 characters. 
     */
    title: string
}


/**
 * Provides data when an app is launched to perform an action to a contact. 
 */
declare class ContactLaunchActionVerbs {

    /**
     * Gets the call contact action. 
     */
    call: string;

    /**
     * Gets the map contact action. 
     */
    map: string;

    /**
     * Gets the send message to a contact action. 
     */
    message: string;

    /**
     * Gets the post to a contact action. 
     */
    post: string;

    /**
     * Gets the video call contact action. 
     */
    videoCall: string
}


/**
 * Represents a list of Contact objects. 
 */
declare class ContactList {

    /**
     * Gets the app's ContactChangeTracker for this ContactList . 
     */
    changeTracker: undefined.ContactChangeTracker;

    /**
     * Asynchronously deletes this ContactList , including all Contact objects in the ContactStore .
     * @return  An async action indicating that the method is complete.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously deletes and individual Contact from this ContactList and the ContactStore .
     * @param contact The Contact to delete.
     * @return  An async action indicating that the method is complete.
     */
    deleteContactAsync(contact: undefined.Contact): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or puts the name of the ContactList , suitable for display in the user interface. 
     */
    displayName: string;

    /**
     * Asynchronously retrieves the specified Contact object from the ContactList .
     * @param contactId The string that identifies the Contact to return.
     * @return  The Contact identified by the contactId parameter.
     */
    getContactAsync(contactId: string): undefined.IPromiseWithIAsyncOperation<undefined.Contact>;

    /**
     * Asynchronously gets the Contact identified by the specified RemoteId .
     * @param remoteId An ID that can be used by a service provider to access the Contact in their remote system.
     * @return  The Contact identified by the remoteId parameter.
     */
    getContactFromRemoteIdAsync(remoteId: string): undefined.IPromiseWithIAsyncOperation<undefined.Contact>;

    /**
     * Gets a ContactReader object associated with this ContactList and using the specified ContactQueryOptions .
     * @param options The ContactQueryOptions to use when creating the ContactReader .
     * @return  A ContactReader object associated with this ContactList .
     */
    getContactReader(options: undefined.ContactQueryOptions): undefined.ContactReader;

    /**
     * Gets a ContactReader object associated with this ContactList .
     * @return  A ContactReader object associated with this ContactList .
     */
    getContactReader(): undefined.ContactReader;

    /**
     * Asynchronously gets the Contact object for the current user.
     * @return  The Contact object for the current user.
     */
    getMeContactAsync(): undefined.IPromiseWithIAsyncOperation<undefined.Contact>;

    /**
     * Gets the locally unique identifier for this ContactList . 
     */
    id: string;

    /**
     * Gets or puts a Boolean value indicating of the ContactList is hidden in the user interface. 
     */
    isHidden: boolean;

    /**
     * Occurs when a Contact in this ContactList has been changed. 
     */
    oncontactchanged: undefined.TypedEventHandler<undefined.ContactList, undefined.ContactChangedEventArgs>;
    addEventListener(
        type: "contactchanged",
        listener: undefined.TypedEventHandler<undefined.ContactList, undefined.ContactChangedEventArgs>): void;
    removeEventListener(
        type: "contactchanged",
        listener: undefined.TypedEventHandler<undefined.ContactList, undefined.ContactChangedEventArgs>): void;

    /**
     * Gets or puts a value indicating the read access level to this ContactList for other apps on the system. 
     */
    otherAppReadAccess: undefined.ContactListOtherAppReadAccess;

    /**
     * Gets or puts a value indicating the write access level to this ContactList for other apps on the system. 
     */
    otherAppWriteAccess: undefined.ContactListOtherAppWriteAccess;

    /**
     * Asynchronously saves this ContactList .
     * @return  An async action indicating that the method has completed.
     */
    saveAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously saves the specified Contact to the ContactStore .
     * @param contact The contact to save.
     * @return  An async action indicating that the method has completed.
     */
    saveContactAsync(contact: undefined.Contact): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the name of the source of the ContactList , suitable for display in the user interface. 
     */
    sourceDisplayName: string;

    /**
     * Gets a Boolean value indicating if you can search the remote server with this ContactList . 
     */
    supportsServerSearch: boolean;

    /**
     * Gets the ContactListSyncManager used to communicate with the server. 
     */
    syncManager: undefined.ContactListSyncManager;

    /**
     * Gets a string that represents the ID of the user data account for this ContactList . 
     */
    userDataAccountId: string;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides functionality for syncing contact information with the server. 
 */
declare class ContactListSyncManager {

    /**
     * Gets the last time a sync was attempted with the server. 
     */
    lastAttemptedSyncTime: Date;

    /**
     * Gets the last time the ContactList was successfully synced with the server. 
     */
    lastSuccessfulSyncTime: Date;

    /**
     * Occurs when the sync status with the server has changed. 
     */
    onsyncstatuschanged: undefined.TypedEventHandler<undefined.ContactListSyncManager, any>;
    addEventListener(
        type: "syncstatuschanged",
        listener: undefined.TypedEventHandler<undefined.ContactListSyncManager, any>): void;
    removeEventListener(
        type: "syncstatuschanged",
        listener: undefined.TypedEventHandler<undefined.ContactListSyncManager, any>): void;

    /**
     * Gets the ContactListSyncStatus . 
     */
    status: undefined.ContactListSyncStatus;

    /**
     * Asynchronously attempts to sync with the contacts server.
     * @return  A Boolean value indicating if the sync was successful.
     */
    syncAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains information about a user's location and address. 
 */
declare class ContactLocationField {

    /**
     * Creates a new ContactLocationField object.
     * @param unstructuredAddress The address of the contact in an unstructured format.
     * @param category The category the field belongs to.
     */
    constructor(unstructuredAddress: string, category: undefined.ContactFieldCategory): this;

    /**
     * Creates a new ContactLocationField object.
     * @param unstructuredAddress The address of the contact in an unstructured format.
     */
    constructor(unstructuredAddress: string): this;

    /**
     * Creates a new ContactLocationField object.
     * @param unstructuredAddress The address of the contact in an unstructured format.
     * @param category The category for the contact data.
     * @param street The street address of the contact.
     * @param city The name of the city for this contact's address.
     * @param region The name of the region for this contact's address.
     * @param country The name of the country for this contact's address.
     * @param postalCode The postal code for this contact's address.
     */
    constructor(unstructuredAddress: string, category: undefined.ContactFieldCategory, street: string, city: string, region: string, country: string, postalCode: string): this;

    /**
     * Gets the category for the contact data. 
     */
    category: undefined.ContactFieldCategory;

    /**
     * Gets the contact's city. 
     */
    city: string;

    /**
     * Gets the contact's country. 
     */
    country: string;

    /**
     * Gets the name of the field. 
     */
    name: string;

    /**
     * Gets the contact's postal code. 
     */
    postalCode: string;

    /**
     * Gets the contact's region. 
     */
    region: string;

    /**
     * Gets the contact's street. 
     */
    street: string;

    /**
     * Gets the contact field type for the data. 
     */
    type: undefined.ContactFieldType;

    /**
     * Gets a string that represents an unstructured address. 
     */
    unstructuredAddress: string;

    /**
     * Gets the value of the contact data. 
     */
    value: string
}


/**
 * Represents a service that source apps can call to access contact data. 
 */
declare class ContactManager {

    /**
     * Asynchronously converts a Contact to a vCard.
     * @param contact The Contact to convert.
     * @return  A stream containing the vCard data.
     */
    convertContactToVCardAsync(
        contact: undefined.Contact): undefined.IPromiseWithIAsyncOperation<undefined.RandomAccessStreamReference>;

    /**
     * Asynchronously converts a Contact to a vCard.
     * @param contact The Contact to convert.
     * @param maxBytes The maximum size for the vCard in bytes.
     * @return  A stream containing the vCard data.
     */
    convertContactToVCardAsync(
        contact: undefined.Contact,
        maxBytes: number): undefined.IPromiseWithIAsyncOperation<undefined.RandomAccessStreamReference>;

    /**
     * Asynchronously converts a vCard to a Contact .
     * @param vCard A stream containing the vCard data.
     * @return  The converted Contact .
     */
    convertVCardToContactAsync(
        vCard: undefined.IRandomAccessStreamReference): undefined.IPromiseWithIAsyncOperation<undefined.Contact>;

    /**
     * Gets a Boolean value indicating if the ShowContactCard method is supported on the current platform.
     * @return  A Boolean value indicating if the ShowContactCard method is supported on the current platform.
     */
    isShowContactCardSupported(): boolean;

    /**
     * Gets a Boolean value indicating if the ShowDelayLoadedContactCard method is supported on the current platform.
     * @return  A Boolean value indicating if the ShowDelayLoadedContactCard method is supported on the current platform.
     */
    isShowDelayLoadedContactCardSupported(): boolean;

    /**
     * Asynchronously requests access to the ContactAnnotationStore .
     * @param accessType Specifies the type of access request, app contact annotations or all annotations.
     * @return  The requested ContactAnnotationStore .
     */
    requestAnnotationStoreAsync(
        accessType: undefined.ContactAnnotationStoreAccessType): undefined.IPromiseWithIAsyncOperation<undefined.ContactAnnotationStore>;

    /**
     * Retrieves a ContactStore object that enables searching or retrieving contacts on the device.
     * @return  An asynchronous operation that returns a ContactStore object on successful completion.
     */
    requestStoreAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ContactStore>;

    /**
     * Retrieves a ContactStore object that enables searching or retrieving contacts on the device.
     * @param accessType Specifies the type of read/write access requested.
     * @return  An asynchronous operation that returns a ContactStore object on successful completion.
     */
    requestStoreAsync(
        accessType: undefined.ContactStoreAccessType): undefined.IPromiseWithIAsyncOperation<undefined.ContactStore>;

    /**
     * Queries the operating system for a user’s contact and shows the contact data in a contact card.
     * @param contact The object that represents the contact that the app wants to display the contact card for.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
     */
    showContactCard(contact: undefined.Contact, selection: undefined.Rect): void;

    /**
     * Queries the operating system for a user’s contact and shows the contact data in a contact card.
     * @param contact The object that represents the contact that the app wants to display the contact card for.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
     * @param preferredPlacement The Placement that describes the preferred placement of the contact card.
     */
    showContactCard(
        contact: undefined.Contact,
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement): void;

    /**
     * Shows a contact card with the specified parameters.
     * @param contact The object that represents the contact that the app wants to display the contact card for.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
     * @param preferredPlacement The Placement that describes the preferred placement of the contact card.
     * @param contactCardOptions Specifies how to display the contact card, such as which tab to start on when displaying a mini contact card.
     */
    showContactCard(
        contact: undefined.Contact,
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement,
        contactCardOptions: undefined.ContactCardOptions): void;

    /**
     * Shows a contact card that can be updated later if the contact does not exist in the user’s contact database.
     * @param contact The object that represents the contact that the app wants to display the contact card for.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
     * @param preferredPlacement The Placement that describes the preferred placement of the contact card.
     * @return  Returns the ContactCardDelayedDataLoader object that can be used to update the contact card.
     */
    showDelayLoadedContactCard(
        contact: undefined.Contact,
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement): undefined.ContactCardDelayedDataLoader;

    /**
     * Shows a contact card that can be updated later if the contact does not exist in the user’s contact database.
     * @param contact The object that represents the contact that the app wants to display the contact card for.
     * @param selection The Rect is the rectangular area of user selection (for example, pressing a button), around which the operating system displays the contact card, not within that rectangular area. For example, if an app uses a button to show the contact card, pass the Rect of the button so the contact card displays around the button, not overlapping it.
     * @param preferredPlacement The Placement that describes the preferred placement of the contact card.
     * @param contactCardOptions Specifies how to display the contact card, such as which tab to start on if you are displaying a mini contact card, or what header type to use if you are showing a full contact card.
     * @return  Returns the ContactCardDelayedDataLoader object that can be used to update the contact card.
     */
    showDelayLoadedContactCard(
        contact: undefined.Contact,
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement,
        contactCardOptions: undefined.ContactCardOptions): undefined.ContactCardDelayedDataLoader;

    /**
     * Queries the operating system for a user’s contact and shows the contact data in a full contact card.
     * @param contact The object that represents the contact that the app wants to display the contact card for.
     * @param fullContactCardOptions Specifies how to display the full contact card.
     */
    showFullContactCard(
        contact: undefined.Contact,
        fullContactCardOptions: undefined.FullContactCardOptions): void;

    /**
     * Gets or puts the display name order. 
     */
    systemDisplayNameOrder: undefined.ContactNameOrder;

    /**
     * Gets or puts the sort order. 
     */
    systemSortOrder: undefined.ContactNameOrder
}


/**
 * Provides details about why search results matched the query parameters. 
 */
declare class ContactMatchReason {

    /**
     * Gets the contact field type that matched the search, such as name, phone number, email address and so on. 
     */
    field: undefined.ContactMatchReasonKind;

    /**
     * Gets a list of matching TextSegment objects which tells you what to highlight in your view as the result of a contact search. 
     */
    segments: undefined.IVectorView<undefined.TextSegment>;

    /**
     * Gets the matching text result from a contact search. 
     */
    text: string
}


/**
 * Represents info about the phone for a contact. 
 */
declare class ContactPhone {

    /**
     * Initializes a new instance of a ContactPhone class. 
     */
    constructor(): this;

    /**
     * Gets and sets the description of the phone for a contact. The maximum string length for the description is 512 characters. 
     */
    description: string;

    /**
     * Gets and sets the kind of phone for a contact. 
     */
    kind: undefined.ContactPhoneKind;

    /**
     * Gets and sets the phone number of a phone for a contact. The maximum string length for the phone number is 50 characters. 
     */
    number: string
}


/**
 * Controls how the Contact Picker user interface opens and what information it shows. 
 */
declare class ContactPicker {

    /**
     * Creates a new instance of the ContactPicker class. 
     */
    constructor(): this;

    /**
     * Sets the text for the confirmation button in the Contact Picker user interface. 
     */
    commitButtonText: string;

    /**
     * Sets the contact fields your app is interested in. 
     */
    desiredFields: undefined.IVector<string>;

    /**
     * Gets the ways to connect with a contact. 
     */
    desiredFieldsWithContactFieldType: undefined.IVector<undefined.ContactFieldType>;

    /**
     * Launches the Contact Picker to select a single contact.
     * @return  The operation that launches the Contact Picker.
     */
    pickContactAsync(): undefined.IPromiseWithIAsyncOperation<undefined.Contact>;

    /**
     * Launches the Contact Picker for selecting multiple contacts.
     * @return  The operation that launches the contact picker.
     */
    pickContactsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVector<any >> ;

    /**
     * Launches the Contact Picker for selecting multiple contacts.
     * @return  The operation that launches the contact picker.
     */
    pickMultipleContactsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Launches the Contact Picker for selecting a single contact.
     * @return  The operation that launches the Contact Picker.
     */
    pickSingleContactAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ContactInformation>;

    /**
     * Controls whether the Contact Picker shows contacts as a complete entity or as a collection of fields. 
     */
    selectionMode: undefined.ContactSelectionMode
}


/**
 * Used to specify the query options when searching for contacts. 
 */
declare class ContactQueryOptions {

    /**
     * Initializes a new instance of the ContactQueryOptions class. 
     */
    constructor(): this;

    /**
     * Initializes a new instance of the ContactQueryOptions class.
     * @param text The text to match in the search operation.
     * @param fields Specifies which contact fields to search for a match.
     */
    constructor(text: string, fields: undefined.ContactQuerySearchFields): this;

    /**
     * Initializes a new instance of the ContactQueryOptions class.
     * @param text The text to match in the search operation.
     */
    constructor(text: string): this;

    /**
     * Gets a list to which you can add ContactAnnotationList.Id values for which to search. 
     */
    annotationListIds: undefined.IVector<string>;

    /**
     * Gets a list to which you can add ContactList.Id values for which to search. 
     */
    contactListIds: undefined.IVector<string>;

    /**
     * Gets or sets the desired fields a contact must have to match the query. 
     */
    desiredFields: undefined.ContactQueryDesiredFields;

    /**
     * Gets or sets the desired annotation operations a contact must have to match the query. 
     */
    desiredOperations: undefined.ContactAnnotationOperations;

    /**
     * Gets or sets a Boolean value indicating if the query results should include contacts from lists that are not shown in the user interface. 
     */
    includeContactsFromHiddenLists: boolean;

    /**
     * Gets a ContactQueryTextSearch object that can be used for text searches. 
     */
    textSearch: undefined.ContactQueryTextSearch
}


/**
 * Specifies parameters to use in a text search of Contact objects. 
 */
declare class ContactQueryTextSearch {

    /**
     * Gets or sets which contact fields to search for a text match. 
     */
    fields: undefined.ContactQuerySearchFields;

    /**
     * Gets or sets a value that specifies either a local or server search. 
     */
    searchScope: undefined.ContactQuerySearchScope;

    /**
     * Gets or sets the text for which to search. 
     */
    text: string
}


/**
 * Used to read Contact objects in batches from the ContactStore which may be local or remotely located. 
 */
declare class ContactReader {

    /**
     * Gets the reason a Contact matched the search query. Returns the properties and substrings that match.
     * @param contact The Contact for which to get the matching properties.
     * @return  The list of matching properties and match reasons.
     */
    getMatchingPropertiesWithMatchReason(
        contact: undefined.Contact): undefined.IVectorView<undefined.ContactMatchReason>;

    /**
     * Asynchronously reads a batch of Contact objects from the ContactStore .
     * @return  The batch of contacts read from the ContactStore .
     */
    readBatchAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ContactBatch >
}


/**
 * Represents the info about a significant other for a contact. 
 */
declare class ContactSignificantOther {

    /**
     * Initializes a new instance of a ContactSignificantOther class. 
     */
    constructor(): this;

    /**
     * Gets and sets the description of a significant other for a contact. The maximum string length for the description is 512 characters. 
     */
    description: string;

    /**
     * Gets and sets the name of a significant other for a contact. The maximum string length for the name is 256 characters. 
     */
    name: string;

    /**
     * Gets or puts a value that indicates the nature of the relationship, such as spouse, partner, sibling, parent and so on. 
     */
    relationship: undefined.ContactRelationship
}


/**
 * Represents a database that contains contacts. 
 */
declare class ContactStore {

    /**
     * Gets a contact manager that provides functionality for linking individual (raw) contacts across services together into a single aggregate contact. 
     */
    aggregateContactManager: undefined.AggregateContactManager;

    /**
     * Gets the ContactChangeTracker which provides functionality for monitoring changes to Contact objects in the ContactStore . 
     */
    changeTracker: undefined.ContactChangeTracker;

    /**
     * Asynchronously creates a ContactList with the specified display name and user account.
     * @param displayName A name for the new ContactList , suitable for displaying in the user interface.
     * @param userDataAccountId The ID for the UserDataAccount to use when creating the ContactList .
     * @return  The newly created ContactList .
     */
    createContactListAsync(
        displayName: string,
        userDataAccountId: string): undefined.IPromiseWithIAsyncOperation<undefined.ContactList>;

    /**
     * Asynchronously creates a ContactList with the specified display name.
     * @param displayName A name for the new ContactList , suitable for displaying in the user interface.
     * @return  The newly created ContactList .
     */
    createContactListAsync(
        displayName: string): undefined.IPromiseWithIAsyncOperation<undefined.ContactList>;

    /**
     * Asynchronously returns the list of ContactList objects.
     * @return  The list of ContactList objects.
     */
    findContactListsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a list of Contact objects based on the supplied search text.
     * @param searchText The search string for the operation. The query will attempt to match the name ( Name ), email address ( Emails values), or phone number ( Phones values) of a contact.
     * @return  An asynchronous operation that returns a search-filtered list of contacts on successful completion. If you use Asynchronous programming, the result type is a read-only list/vector of Contact items. (You can use APIs of IVectorView<Contact> for C++ or JavaScript, APIs of IReadOnlyList<Contact> for .NET.)
     */
    findContactsAsync(
        searchText: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<undefined.Contact >> ;

    /**
     * Retrieves the list of all contacts in the contact store.
     * @return  An asynchronous operation that returns a list of all Contact objects in the contact store. If you use Asynchronous programming, the result type is a read-only list/vector of Contact items. (You can use APIs of IVectorView<Contact> for C++ or JavaScript, APIs of IReadOnlyList<Contact> for .NET.)
     */
    findContactsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<undefined.Contact >> ;

    /**
     * Retrieves a Contact object representing the contact with the specified Id value.
     * @param contactId The Id of the contact to be retrieved.
     * @return  An asynchronous operation that returns a Contact object on successful completion. If you use Asynchronous programming, the result type is a single Contact object.
     */
    getContactAsync(contactId: string): undefined.IPromiseWithIAsyncOperation<undefined.Contact>;

    /**
     * Asynchronously gets the ContactList with the specified ID.
     * @param contactListId The ID of the ContactList to retrieve.
     * @return  The ContactList with the specified ID or null if the list is not found.
     */
    getContactListAsync(
        contactListId: string): undefined.IPromiseWithIAsyncOperation<undefined.ContactList>;

    /**
     * Creates and returns a ContactReader for the ContactStore with the specified ContactQueryOptions .
     * @param options The query options to use when creating the new ContactReader .
     * @return  The newly created ContactReader for the ContactStore .
     */
    getContactReader(options: undefined.ContactQueryOptions): undefined.ContactReader;

    /**
     * Creates and returns a ContactReader for the ContactStore .
     * @return  The newly created ContactReader for the ContactStore .
     */
    getContactReader(): undefined.ContactReader;

    /**
     * Get the Contact object for the current user.
     * @return  The Contact object for the current user.
     */
    getMeContactAsync(): undefined.IPromiseWithIAsyncOperation<undefined.Contact>;

    /**
     * Occurs when a Contact in the ContactStore has been changed. 
     */
    oncontactchanged: undefined.TypedEventHandler<undefined.ContactStore, undefined.ContactChangedEventArgs>;
    addEventListener(
        type: "contactchanged",
        listener: undefined.TypedEventHandler<undefined.ContactStore, undefined.ContactChangedEventArgs>): void;
    removeEventListener(
        type: "contactchanged",
        listener: undefined.TypedEventHandler<undefined.ContactStore, undefined.ContactChangedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Reserved for future use. 
 */
declare class ContactStoreNotificationTriggerDetails {}


/**
 * Represents the info about a Web site for a contact. 
 */
declare class ContactWebsite {

    /**
     * Initializes a new instance of a ContactWebsite class. 
     */
    constructor(): this;

    /**
     * Gets and sets the description of a Web site for a contact. The maximum string length for the description is 512 characters. 
     */
    description: string;
    rawValue: any;

    /**
     * Gets and sets the Uniform Resource Identifier (URI) of a Web site for a contact. 
     */
    uri: undefined.Uri
}


/**
 * Specifies the options for displaying the full contact card. 
 */
declare class FullContactCardOptions {

    /**
     * Initializes a new instance of the FullContactCardOptions class. 
     */
    constructor(): this;

    /**
     * Gets or sets a value that describes the desired view size for the full contact card. 
     */
    desiredRemainingView: undefined.ViewSizePreference
}


/**
 * A static class that contains the names of contact fields for storing commonly requested information like email address and phone numbers. 
 */
declare class KnownContactField {

    /**
     * Converts a string representing the name of a field to its corresponding type.
     * @param name The name of the field.
     * @return  The type of field.
     */
    convertNameToType(name: string): undefined.ContactFieldType;

    /**
     * Converts the type of a field to its corresponding string name.
     * @param type The type of field.
     * @return  The name of the field.
     */
    convertTypeToName(type: undefined.ContactFieldType): string;

    /**
     * Contains the name of the field used for email addresses. 
     */
    email: string;

    /**
     * Contains the name of the field used for instant messaging accounts. 
     */
    instantMessage: string;

    /**
     * Contains the name of the field used for the contact's location. 
     */
    location: string;

    /**
     * Contains the name of the field used for phone numbers. 
     */
    phoneNumber: string
}


/**
 * Allows you to call the contact picker UI so you can select one or more contacts. 
 */
declare class ContactPickerUI {

    /**
     * Adds a Contact .
     * @param id The ID for the contact.
     * @param contact An object that contains the contact's information.
     * @return  An AddContactResult -typed value that indicates whether the contact was added successfully.
     */
    addContact(id: string, contact: undefined.Contact): undefined.AddContactResult;

    /**
     * Adds a Contact .
     * @param contact An object that contains the contact's information.
     * @return  An AddContactResult -typed value that indicates whether the contact was added successfully.
     */
    addContact(contact: undefined.Contact): undefined.AddContactResult;

    /**
     * Checks to see whether the contact was already selected by the user.
     * @param id The ID of the contact.
     * @return  True if the contact has already been selected; otherwise, false.
     */
    containsContact(id: string): boolean;

    /**
     * Specifies the fields that you want returned after the user selects one or more contacts. 
     */
    desiredFields: undefined.IVectorView<string>;

    /**
     * Gets the fields with contact field type that you want returned after the user selects one or more contacts. 
     */
    desiredFieldsWithContactFieldType: undefined.IVector<undefined.ContactFieldType>;

    /**
     * Occurs when the user deselects or removes the contact. 
     */
    oncontactremoved: undefined.TypedEventHandler<undefined.ContactPickerUI, undefined.ContactRemovedEventArgs>;
    addEventListener(
        type: "contactremoved",
        listener: undefined.TypedEventHandler<undefined.ContactPickerUI, undefined.ContactRemovedEventArgs>): void;
    removeEventListener(
        type: "contactremoved",
        listener: undefined.TypedEventHandler<undefined.ContactPickerUI, undefined.ContactRemovedEventArgs>): void;

    /**
     * Removes a contact.
     * @param id The ID of the contact to remove.
     */
    removeContact(id: string): void;

    /**
     * Determines the selection mode for the contact picker. The most common options are PickSingleContactAsync or PickMultipleContactsAsync . 
     */
    selectionMode: undefined.ContactSelectionMode;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains info about a removed contact. Returned when a ContactRemoved event occurs. 
 */
declare class ContactRemovedEventArgs {

    /**
     * Contains a unique identifier for the contact. 
     */
    id: string
}


/**
 * Specifies an object that describes a piece of contact data. 
 */
declare interface Contacts$IContactField {

    /**
     * Gets the category for the contact data. 
     */
    category: undefined.ContactFieldCategory,

        /**
         * Gets the name of the field. 
         */
        name: string,

        /**
         * Gets the contact field type for the data. 
         */
        type: undefined.ContactFieldType,

        /**
         * Gets the value of the contact data. 
         */
        value: string
}


/**
 * Provides an app's display info such as its display name and description, and a method to launch the app. 
 */
declare class AppListEntry {

    /**
     * Provides an app's display name, description, and logo. 
     */
    displayInfo: undefined.AppDisplayInfo;

    /**
     * Launches the app associated with this AppListEntry
     * @return  If the launch fails for any reason, the Boolean value is false
     */
    launchAsync(): undefined.IPromiseWithIAsyncOperation<boolean >
}


/**
 * Gets and sets information from the clipboard object. 
 */
declare class Clipboard {

    /**
     * Removes all data from the Clipboard. 
     */
    clear(): void;

    /**
     * Adds the content to the Clipboard and releases the DataPackage object from the source app. This method allows the content to remain available after the application shuts down. 
     */
    flush(): void;

    /**
     * Gets the current content that is stored in the clipboard object.
     * @return  Contains the content of the Clipboard.
     */
    getContent(): undefined.DataPackageView;

    /**
     * Occurs when the data stored in the Clipboard changes. 
     */
    oncontentchanged: undefined.EventHandler<any>;
    addEventListener(type: "contentchanged", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "contentchanged", listener: undefined.EventHandler<any>): void;

    /**
     * Sets the current content that is stored in the clipboard object.
     * @param content Contains the content of the clipboard. If NULL, the clipboard is emptied.
     */
    setContent(content: undefined.DataPackage): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains the data that a user wants to exchange with another app. 
 */
declare class DataPackage {

    /**
     * Constructor that creates a new DataPackage . 
     */
    constructor(): this;

    /**
     * Returns a DataPackageView object. This object is a read-only copy of the DataPackage object.
     * @return  The object that is a read-only copy of the DataPackage object.
     */
    getView(): undefined.DataPackageView;

    /**
     * Occurs when the DataPackage is destroyed. 
     */
    ondestroyed: undefined.TypedEventHandler<undefined.DataPackage, any>;
    addEventListener(
        type: "destroyed",
        listener: undefined.TypedEventHandler<undefined.DataPackage, any>): void;
    removeEventListener(
        type: "destroyed",
        listener: undefined.TypedEventHandler<undefined.DataPackage, any>): void;

    /**
     * Occurs when a paste operation is completed. 
     */
    onoperationcompleted: undefined.TypedEventHandler<undefined.DataPackage, undefined.OperationCompletedEventArgs>;
    addEventListener(
        type: "operationcompleted",
        listener: undefined.TypedEventHandler<undefined.DataPackage, undefined.OperationCompletedEventArgs>): void;
    removeEventListener(
        type: "operationcompleted",
        listener: undefined.TypedEventHandler<undefined.DataPackage, undefined.OperationCompletedEventArgs>): void;

    /**
     * Allows you to get and set properties like the title of the content being shared. 
     */
    properties: undefined.DataPackagePropertySet;

    /**
     * Specifies the DataPackageOperation (none, move, copy, or link) for the operation. 
     */
    requestedOperation: undefined.DataPackageOperation;

    /**
     * Maps a URI to a file. Used to ensure that referenced content (such as an image) in HTML content is added to the DataPackage . 
     */
    resourceMap: undefined.IMap<string, undefined.RandomAccessStreamReference>;

    /**
     * Sets the application link that a DataPackage contains.
     * @param value A URI with a scheme that isn't http or https that's handled by the source app.
     */
    setApplicationLink(value: undefined.Uri): void;

    /**
     * Sets the bitmap image contained in the DataPackage .
     * @param value A stream that contains the bitmap image.
     */
    setBitmap(value: undefined.RandomAccessStreamReference): void;

    /**
     * Sets the data contained in the DataPackage in a RandomAccessStream format.
     * @param formatId Specifies the format of the data. We recommend that you set this value by using the StandardDataFormats class.
     * @param value Specifies the content that the DataPackage contains.
     */
    setData(formatId: string, value: any): void;

    /**
     * Sets a delegate to handle requests from the target app.
     * @param formatId Specifies the format of the data. We recommend that you set this value by using the StandardDataFormats class.
     * @param delayRenderer A delegate that is responsible for processing requests from a target app.
     */
    setDataProvider(formatId: string, delayRenderer: undefined.DataProviderHandler): void;

    /**
     * Adds HTML content to the DataPackage .
     * @param value The HTML content.
     */
    setHtmlFormat(value: string): void;

    /**
     * Sets the Rich Text Format (RTF) content that is contained in a DataPackage .
     * @param value Specifies the RTF content for the DataPackage .
     */
    setRtf(value: string): void;

    /**
     * Sets the files and folders contained in a DataPackage .
     * @param value The files and folders to be added to the DataPackage .
     */
    setStorageItems(value: undefined.IIterable<undefined.IStorageItem>): void;

    /**
     * Adds files and folders to a DataPackage .
     * @param value The files and folders to be added to the DataPackage .
     * @param readOnly Specify true if the files are read-only; false otherwise.
     */
    setStorageItems(value: undefined.IIterable<undefined.IStorageItem>, readOnly: boolean): void;

    /**
     * Sets the text that a DataPackage contains.
     * @param value The text.
     */
    setText(value: string): void;

    /**
     * Sets the Uniform Resource Identifier (URI) that is contained in the DataPackage .
     * @param value The URI that is contained in the DataPackage .
     */
    setUri(value: undefined.Uri): void;

    /**
     * Sets the web link that a DataPackage contains.
     * @param value A URI with an http or https scheme that corresponds to the content being displayed to the user.
     */
    setWebLink(value: undefined.Uri): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Defines a set of properties to use with a DataPackage object. 
 */
declare class DataPackagePropertySet {

    /**
     * Gets or sets the Uniform Resource Identifier (URI) of the app's location in the Windows Store. 
     */
    applicationListingUri: undefined.Uri;

    /**
     * Gets or sets the name of the app that created the DataPackage object. 
     */
    applicationName: string;

    /**
     * Removes all items from the property set. 
     */
    clear(): void;

    /**
     * Gets or sets the application link to the content from the source app. 
     */
    contentSourceApplicationLink: undefined.Uri;

    /**
     * Provides a web link to shared content that's currently displayed in the app. 
     */
    contentSourceWebLink: undefined.Uri;

    /**
     * Gets or sets text that describes the contents of the DataPackage . 
     */
    description: string;

    /**
     * Gets or sets the enterprise identity (see Enterprise data protection). 
     */
    enterpriseId: string;

    /**
     * Specifies a vector object that contains the types of files stored in the DataPackage object. 
     */
    fileTypes: undefined.IVector<string>;

    /**
     * Returns an iterator to enumerate the items in the property set.
     * @return  The first item in the DataPackage object.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Gets an immutable view of the property set.
     * @return  The immutable view.
     */
    getView(): undefined.IMapView<string, any>;

    /**
     * Indicates whether the DataPackagePropertySet object contains a specific property.
     * @param key The key.
     * @return  True if the property set has an item with the specified key; otherwise false.
     */
    hasKey(key: string): boolean;

    /**
     * Adds a property to the DataPackagePropertySet object.
     * @param key The key to insert.
     * @param value The value to insert.
     * @return  True if the method replaced a value that already existed for the key; false if this is a new key.
     */
    insert(key: string, value: any): boolean;

    /**
     * Gets or sets a background color for the sharing app's Square30x30Logo . 
     */
    logoBackgroundColor: undefined.Color;

    /**
     * Retrieves the value of a specific property.
     * @param key The key.
     * @return  The value, if an item with the specified key exists. Otherwise, an error code.
     */
    lookup(key: string): any;

    /**
     * Gets or sets the package family name of the source app. 
     */
    packageFamilyName: string;

    /**
     * Removes an item from the property set.
     * @param key The key.
     */
    remove(key: string): void;

    /**
     * Gets the number of items that are contained in the property set. 
     */
    size: number;

    /**
     * Gets or sets the source app's logo. 
     */
    square30x30Logo: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets a thumbnail image for the DataPackage . 
     */
    thumbnail: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the text that displays as a title for the contents of the DataPackage object. 
     */
    title: string
}


/**
 * Gets the set of properties of a DataPackageView object. 
 */
declare class DataPackagePropertySetView {

    /**
     * Gets the Uniform Resource Identifier (URI) of the app's location in the Windows Store. 
     */
    applicationListingUri: undefined.Uri;

    /**
     * Gets the name of the app that created the DataPackage object. 
     */
    applicationName: string;

    /**
     * Gets the application link to the content from the source app. 
     */
    contentSourceApplicationLink: undefined.Uri;

    /**
     * Gets a web link to shared content that's currently displayed in the app. 
     */
    contentSourceWebLink: undefined.Uri;

    /**
     * Gets the text that describes the contents of the DataPackage . 
     */
    description: string;

    /**
     * Gets or sets the enterprise Id. 
     */
    enterpriseId: string;

    /**
     * Gets a vector object that contains the types of files stored in the DataPackage object. 
     */
    fileTypes: undefined.IVectorView<string>;

    /**
     * Returns an iterator to enumerate the items in the property set.
     * @return  The first item in the DataPackage object.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Indicates whether the DataPackagePropertySetView object contains a specific property.
     * @param key The key.
     * @return  True if the property set has an item with the specified key; otherwise false.
     */
    hasKey(key: string): boolean;

    /**
     * Gets a background color for the sharing app's Square30x30Logo . 
     */
    logoBackgroundColor: undefined.Color;

    /**
     * Retrieves the value of a specific property.
     * @param key The key.
     * @return  The value, if an item with the specified key exists. Otherwise, an error code.
     */
    lookup(key: string): any;

    /**
     * Gets the package family name of the source app. 
     */
    packageFamilyName: string;

    /**
     * Gets the number of items that are contained in the property set. 
     */
    size: number;

    /**
     * Divides the object into two views
     */
    split(): {
        first: undefined.IMapView<string,
        any>,
        second: undefined.IMapView<string,
        any >
    };

    /**
     * Gets the source app's logo. 
     */
    square30x30Logo: undefined.IRandomAccessStreamReference;

    /**
     * Gets the thumbnail image for the DataPackageView . 
     */
    thumbnail: undefined.RandomAccessStreamReference;

    /**
     * Gets the text that displays as a title for the contents of the DataPackagePropertySetView object. 
     */
    title: string
}


/**
 * A read-only version of a DataPackage . Apps that receive shared content get this object when acquiring content. 
 */
declare class DataPackageView {

    /**
     * Returns the formats the DataPackageView contains. 
     */
    availableFormats: undefined.IVectorView<string>;

    /**
     * Checks to see if the DataPackageView contains a specific data format.
     * @param formatId The name of the format.
     * @return  True if the DataPackageView contains the format; false otherwise.
     */
    contains(formatId: string): boolean;

    /**
     * Gets the application link in the DataPackageView object.
     * @return  The application link.
     */
    getApplicationLinkAsync(): undefined.IPromiseWithIAsyncOperation<undefined.Uri>;

    /**
     * Gets the bitmap image contained in the DataPackageView
     * @return  A stream containing the bitmap image.
     */
    getBitmapAsync(): undefined.IPromiseWithIAsyncOperation<undefined.RandomAccessStreamReference>;

    /**
     * Gets the data contained in the DataPackageView .
     * @param formatId Specifies the format of the data. We recommend that you set this value by using the StandardDataFormats class.
     * @return  The data.
     */
    getDataAsync(formatId: string): undefined.IPromiseWithIAsyncOperation<any>;

    /**
     * Gets the HTML stored in the DataPackageView object.
     * @return  The HTML.
     */
    getHtmlFormatAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Gets the data (such as an image) referenced in HTML content.
     * @return  The data referenced in the HTML content.
     */
    getResourceMapAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IMapView<any, any >> ;

    /**
     * Gets the rich text formatted (RTF) content contained in a DataPackageView .
     * @return  The rich text formatted content for the DataPackage.
     */
    getRtfAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Gets the files and folders stored in a DataPackageView object.
     * @return  An array of files and folders stored in a DataPackageView .
     */
    getStorageItemsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the text in the DataPackageView object.
     * @return  The text.
     */
    getTextAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Gets the text in the DataPackageView object.
     * @param formatId A string that represents the data format. Usually StandardDataFormats.text .
     * @return  The text.
     */
    getTextAsync(formatId: string): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Gets the URI contained in the DataPackageView .
     * @return  The Uri.
     */
    getUriAsync(): undefined.IPromiseWithIAsyncOperation<undefined.Uri>;

    /**
     * Gets the web link in the DataPackageView object.
     * @return  The web link.
     */
    getWebLinkAsync(): undefined.IPromiseWithIAsyncOperation<undefined.Uri>;

    /**
     * Gets a DataPackagePropertySetView object, which contains a read-only set of properties for the data in the DataPackageView object. 
     */
    properties: undefined.DataPackagePropertySetView;

    /**
     * Informs the system that your app is finished using the DataPackageView object. Primarily used for Clipboard operations.
     * @param value An enumeration that states what operation (such as copy or move) was completed. At most one operation flag can be set.
     */
    reportOperationCompleted(value: undefined.DataPackageOperation): void;

    /**
     * Requests permission to unlock and access a data package that is secured with a protection policy.
     * @param enterpriseId The enterprise Id.
     * @return  When this method completes, it returns the results of the protection policy evaluation, which indicates whether or not the data is accessible.
     */
    requestAccessAsync(
        enterpriseId: string): undefined.IPromiseWithIAsyncOperation<undefined.ProtectionPolicyEvaluationResult>;

    /**
     * Requests permission to unlock and access a data package that is secured with a protection policy.
     * @return  When this method completes, it returns the results of the protection policy evaluation, which indicates whether or not the data is accessible.
     */
    requestAccessAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ProtectionPolicyEvaluationResult>;

    /**
     * Gets the requested operation (such as copy or move). Primarily used for Clipboard actions. 
     */
    requestedOperation: undefined.DataPackageOperation;

    /**
     * Sets the accepted format Id.
     * @param formatId The format Id.
     */
    setAcceptedFormatId(formatId: string): void;

    /**
     * Unlocks a data package and assumes an enterprise identity for it.
     * @return  When this method completes, it returns the results of the protection policy evaluation.
     */
    unlockAndAssumeEnterpriseIdentity(): undefined.ProtectionPolicyEvaluationResult
}


/**
 * Used by a source app's deferral delegate to notify a DataPackage object that the source app will produce data from another asynchronous function. 
 */
declare class DataProviderDeferral {

    /**
     * Informs a DataPackage that it is ready for processing. 
     */
    complete(): void
}


/**
 * An object of this type is passed to the DataProviderHandler delegate. 
 */
declare class DataProviderRequest {

    /**
     * Gets the deadline for finishing a delayed rendering operation. If execution goes beyond that deadline, the results of delayed rendering are ignored. 
     */
    deadline: Date;

    /**
     * Specifies the format id. 
     */
    formatId: string;

    /**
     * Returns a DataProviderDeferral object.
     * @return  An data provider deferral object.
     */
    getDeferral(): undefined.DataProviderDeferral;

    /**
     * Sets the content of the DataPackage to be shared with a target app.
     * @param value The object associated with a particular format in the DataPackage .
     */
    setData(value: any): void
}


/**
 * Lets your app supply the content the user wants to share or specify a message, if an error occurs. 
 */
declare class DataRequest {

    /**
     * Sets or gets a DataPackage object that contains the content a user wants to share. 
     */
    data: undefined.DataPackage;

    /**
     * Gets the deadline for finishing a delayed rendering operation. If execution goes beyond that deadline, the results of delayed rendering are ignored. 
     */
    deadline: Date;

    /**
     * Cancels the sharing operation and supplies an error string to display to the user.
     * @param value The text to display to the user.
     */
    failWithDisplayText(value: string): void;

    /**
     * Supports asynchronous sharing operations by creating and returning a DataRequestDeferral object.
     * @return  An object that allows you to share or send content asynchronously.
     */
    getDeferral(): undefined.DataRequestDeferral
}


/**
 * Enables you to exchange content with a target app asynchronously. 
 */
declare class DataRequestDeferral {

    /**
     * Indicates that the content for an asynchronous share is ready for a target app, or that an error in the sharing operation occurred. 
     */
    complete(): void
}


/**
 * Contains information about the DataRequested event. The system fires this event when the user invokes the Share UI. 
 */
declare class DataRequestedEventArgs {

    /**
     * Enables you to get the DataRequest object and either give it data or a failure message. 
     */
    request: undefined.DataRequest
}


/**
 * Programmatically initiates an exchange of content with other apps. 
 */
declare class DataTransferManager {

    /**
     * Returns the DataTransferManager object associated with the current window.
     * @return  The DataTransferManager object associated with the current window.
     */
    getForCurrentView(): undefined.DataTransferManager;

    /**
     * Programmatically initiates the user interface for sharing content with another app. 
     */
    showShareUI(): void;

    /**
     * Occurs when a share operation starts. 
     */
    ondatarequested: undefined.TypedEventHandler<undefined.DataTransferManager, undefined.DataRequestedEventArgs>;
    addEventListener(
        type: "datarequested",
        listener: undefined.TypedEventHandler<undefined.DataTransferManager, undefined.DataRequestedEventArgs>): void;
    removeEventListener(
        type: "datarequested",
        listener: undefined.TypedEventHandler<undefined.DataTransferManager, undefined.DataRequestedEventArgs>): void;

    /**
     * Occurs when the user chooses a target app in the Share charm. 
     */
    ontargetapplicationchosen: undefined.TypedEventHandler<undefined.DataTransferManager, undefined.TargetApplicationChosenEventArgs>;
    addEventListener(
        type: "targetapplicationchosen",
        listener: undefined.TypedEventHandler<undefined.DataTransferManager, undefined.TargetApplicationChosenEventArgs>): void;
    removeEventListener(
        type: "targetapplicationchosen",
        listener: undefined.TypedEventHandler<undefined.DataTransferManager, undefined.TargetApplicationChosenEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}




/**
 * Responsible for formatting HTML content that you want to share or add to the Clipboard. Also allows you to get HTML fragments from the content. 
 */
declare class HtmlFormatHelper {

    /**
     * Takes a string that represents HTML content and adds the necessary headers to ensure it is formatted correctly for share and Clipboard operations.
     * @param htmlFragment A string representing the HTML content.
     * @return  A string representing the formatted HTML.
     */
    createHtmlFormat(htmlFragment: string): string;

    /**
     * Gets a string that represents an HTML fragment.
     * @param htmlFormat The formatted HTML.
     * @return  An HTML fragment based on the formatted HTML.
     */
    getStaticFragment(htmlFormat: string): string
}


/**
 * Contains info about the action that a target app completed during a paste operation. 
 */
declare class OperationCompletedEventArgs {
    acceptedFormatId: any;

    /**
     * Specifies the operation that the target app completed. 
     */
    operation: undefined.DataPackageOperation
}


/**
 * Represents shortcuts that help users share content with the apps they use most. 
 */
declare class QuickLink {

    /**
     * Creates a new instance of a QuickLink object. 
     */
    constructor(): this;

    /**
     * Specifies an ID for the QuickLink. Your app receives this ID when the user selects its QuickLink. You can use this ID to further customize the sharing process for the user. 
     */
    id: string;

    /**
     * An array of strings that specify the data formats supported by the QuickLink app. The system shows the QuickLink only when the data that a user wants to share matches a format in this array. 
     */
    supportedDataFormats: undefined.IVector<string>;

    /**
     * An array of strings that specify the file types supported by a QuickLink app. The system shows the QuickLink only when the data that a user wants to share contains file items, and the file extensions for those file items match a file type in this array. 
     */
    supportedFileTypes: undefined.IVector<string>;

    /**
     * Specifies a thumbnail image for the QuickLink. The system displays this image when the user is presented with a list of possible apps to share content with. 
     */
    thumbnail: undefined.RandomAccessStreamReference;

    /**
     * Specifies the title of a QuickLink. The system displays this info when the user is presented with a list of possible apps to share content with. 
     */
    title: string
}


/**
 * Handles the bulk of the work during a share operation. This includes the data that the user wants to share, setting or removing QuickLinks, and informing the system about the status of the operation. 
 */
declare class ShareOperation {

    /**
     * Contains a DataPackage object with the data that the user wants to share. 
     */
    data: undefined.DataPackageView;

    /**
     * Closes the share pane. 
     */
    dismissUI(): void;

    /**
     * A string that contains the ID of a QuickLink. 
     */
    quickLinkId: string;

    /**
     * Removes the QuickLink from the list of QuickLinks that are available to the user. 
     */
    removeThisQuickLink(): void;

    /**
     * Specifies that the sharing operation is complete. 
     */
    reportCompleted(): void;

    /**
     * Specifies that the sharing operation is complete. A QuickLink that the system can save as a shortcut for future sharing operations is included.
     * @param quicklink A QuickLink object that the system saves as a shortcut for future sharing operations.
     */
    reportCompleted(quicklink: undefined.QuickLink): void;

    /**
     * Specifies that the app has acquired the content that the user wants to share. 
     */
    reportDataRetrieved(): void;

    /**
     * Specifies that an error occurred during the sharing operation.
     * @param value Specifies the error message. The system displays this message to the user.
     */
    reportError(value: string): void;

    /**
     * Specifies that the app has started to acquire the content that the user wants to share. 
     */
    reportStarted(): void;

    /**
     * Specifies that the app has requested that the system allow the sharing operation to run as a background task. 
     */
    reportSubmittedBackgroundTask(): void
}


/**
 * Enables an app to share a file with another app by passing a token as part of a Uri activation. The target app redeems the token to get the file shared by the source app. 
 */
declare class SharedStorageAccessManager {

    /**
     * Gets the sharing token that enables an app to share the specified file with another app.
     * @param file The file to share with the target app.
     * @return  The sharing token to provide to the target app as part of a Uri activation.
     */
    addFile(file: undefined.IStorageFile): string;

    /**
     * Gets a file shared by another app by providing the sharing token received from the source app.
     * @param token The sharing token for the shared file.
     * @return  A wrapper object that contains the shared file.
     */
    redeemTokenForFileAsync(token: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Revokes an existing sharing token.
     * @param token The sharing token to revoke.
     */
    removeFile(token: string): void
}


/**
 * Contains static properties that return string values. Each string corresponds to a known format ID. Use this class to avoid errors in using string constants to specify data formats. 
 */
declare class StandardDataFormats {

    /**
     * A read-only property that returns the format ID string value corresponding to the activation link format. 
     */
    applicationLink: string;

    /**
     * A read-only property that returns the format ID string value corresponding to the Bitmap format. 
     */
    bitmap: string;

    /**
     * A read-only property that returns the format ID string value corresponding to the HTML format. 
     */
    html: string;

    /**
     * A read-only property that returns the format ID string value corresponding to the Rich Text Format (RTF). 
     */
    rtf: string;

    /**
     * A read-only property that returns the format ID string value corresponding to the StorageItem format. 
     */
    storageItems: string;

    /**
     * A read-only property that returns the format ID string value corresponding to the Text format. 
     */
    text: string;

    /**
     * A read-only property that returns the format ID string value corresponding to the Uniform Resource Identifier (URI) format. 
     */
    uri: string;

    /**
     * A read-only property that returns the format ID string value corresponding to the web link format. 
     */
    webLink: string
}


/**
 * Contains information about the target app the user chose to share content with. To get this object, you must handle the TargetApplicationChosen event. 
 */
declare class TargetApplicationChosenEventArgs {

    /**
     * Contains the name of the app that the user chose to share content with. 
     */
    applicationName: string
}


/**
 * Provides data when the target app requests it, instead of including the data in the DataPackage ahead of time. DataProviderHandler is used when the source app wants to avoid unnecessary work that is resource intensive, such as performing format conversions. 
 */
declare type DataTransfer$DataProviderHandler = (request: undefined.DataProviderRequest) => void;


/**
 * Enables you to detect whether your app is in design mode in a visual designer. 
 */
declare class DesignMode {

    /**
     * Gets a value that indicates whether the process is running in design mode. 
     */
    designModeEnabled: boolean
}


/**
 * Represents an email attachment. 
 */
declare class EmailAttachment {

    /**
     * Initializes a new instance of the EmailAttachment class. 
     */
    constructor(): this;

    /**
     * Initializes a new instance of the EmailAttachment class with the specified random access stream.
     * @param filename The file name to use for the attachment.
     * @param data A random access stream containing the data for the attachment.
     */
    constructor(filename: string, data: undefined.IRandomAccessStreamReference): this;

    /**
     * Initializes a new instance of the EmailAttachment class.
     * @param fileName The filename of the attachment.
     * @param data The stream to use to download the attachment.
     * @param mimeType The MIME type of the attachment.
     */
    constructor(fileName: string, data: undefined.IRandomAccessStreamReference, mimeType: string): this;

    /**
     * Gets or sets a value that identifies the content of the attachment on a remote system. 
     */
    contentId: string;

    /**
     * Gets or sets the location of an email attachment as a Uniform Resource Identifier (URI). 
     */
    contentLocation: string;

    /**
     * Gets or sets the email attachment's data. 
     */
    data: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the download state of the email attachment. 
     */
    downloadState: undefined.EmailAttachmentDownloadState;

    /**
     * Gets or sets the estimated download size of the attachment. 
     */
    estimatedDownloadSizeInBytes: number;

    /**
     * Gets or sets the displayed file name for the email attachment. 
     */
    fileName: string;

    /**
     * Gets the locally unique ID for the email attachment. 
     */
    id: string;

    /**
     * Gets a Boolean value indicating if the attachment came from the base message. 
     */
    isFromBaseMessage: boolean;

    /**
     * Gets or sets a Boolean property indicating if the attachment is included inline, in the body of the message. 
     */
    isInline: boolean;

    /**
     * Gets or sets the MIME type of the attachment. 
     */
    mimeType: string
}

declare
var success: any;

declare
var noMatch: any;

declare
var invalidUsage: any;

declare
var invalidCertificate: any;

declare
var revoked: any;

declare
var chainRevoked: any;

declare
var revocationServerFailure: any;

declare
var expired: any;

declare
var untrusted: any;

declare
var serverError: any;

declare
var unknownFailure: any;


/**
 * Represents an email conversation. 
 */
declare class EmailConversation {

    /**
     * Asynchronously gets a batch of messages in the conversation.
     * @param count The size of the batch of messages to retrieve.
     * @return  The batch of messages.
     */
    findMessagesAsync(
        count: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously gets a batch of messages in the conversation.
     * @return  The batch of messages.
     */
    findMessagesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the EmailFlagState for the conversation. 
     */
    flagState: undefined.EmailFlagState;

    /**
     * Gets a Boolean value indicating if the conversation has an attachment. 
     */
    hasAttachment: boolean;

    /**
     * Gets the unique identifier for the EmailConversation . 
     */
    id: string;

    /**
     * Gets the value that specifies the importance of the conversation; normal, high or low. 
     */
    importance: undefined.EmailImportance;

    /**
     * Gets the last EmailMessageResponseKind for the conversation. 
     */
    lastEmailResponseKind: undefined.EmailMessageResponseKind;

    /**
     * Gets the latest sender in the conversation. 
     */
    latestSender: undefined.EmailRecipient;

    /**
     * Gets the ID for the mailbox. 
     */
    mailboxId: string;

    /**
     * Gets the number of messages in the conversation. 
     */
    messageCount: number;

    /**
     * Gets the ID of the most recent message in the conversation. 
     */
    mostRecentMessageId: string;

    /**
     * Gets the time of the most recent message in the conversation. 
     */
    mostRecentMessageTime: Date;

    /**
     * Gets a preview of the latest message in the conversation. 
     */
    preview: string;

    /**
     * Gets the subject of the latest message in the conversation. 
     */
    subject: string;

    /**
     * Gets the number of unread messages in the conversation. 
     */
    unreadMessageCount: number
}


/**
 * Represents a group of EmailConversation objects for batch processing. 
 */
declare class EmailConversationBatch {

    /**
     * Gets a list of EmailConversation objects to use for batch processing. 
     */
    conversations: undefined.IVectorView<undefined.EmailConversation>;

    /**
     * Gets the status of the last batch processing operation. 
     */
    status: undefined.EmailBatchStatus
}


/**
 * Reads a batch of email conversations. 
 */
declare class EmailConversationReader {

    /**
     * Asynchronously reads a batch of email conversations.
     * @return  Returns a batch of email conversations.
     */
    readBatchAsync(): undefined.IPromiseWithIAsyncOperation<undefined.EmailConversationBatch >
}


/**
 * Represents and email folder. 
 */
declare class EmailFolder {

    /**
     * Asynchronously creates a new folder.
     * @param name The name for the new folder.
     * @return  Returns the newly created folder.
     */
    createFolderAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailFolder>;

    /**
     * Asynchronously deletes this folder.
     * @return  An async action indicating that the operation has completed.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets the display name for the folder. 
     */
    displayName: string;

    /**
     * Asynchronously finds the child folders of this folder.
     * @return  The list of child folders.
     */
    findChildFoldersAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets an instance of the EmailConversationReader class.
     * @return  The conversation reader.
     */
    getConversationReader(): undefined.EmailConversationReader;

    /**
     * Gets an instance of the EmailConversationReader class using the specified query options.
     * @param options The query options to use when finding the conversation reader.
     * @return  The conversation reader that matches the query options.
     */
    getConversationReader(options: undefined.EmailQueryOptions): undefined.EmailConversationReader;

    /**
     * Asynchronously gets the specified message from the folder.
     * @param id The ID of the message to retrieve.
     * @return  The message specified in the id parameter.
     */
    getMessageAsync(id: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailMessage>;

    /**
     * Asynchronously gets the counts of email items such as flagged emails, important emails, unread emails, total emails, and so on.
     * @return  An EmailItemCounts object containing the counts of email items such as flagged emails, important emails, unread emails, total emails, and so on.
     */
    getMessageCountsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.EmailItemCounts>;

    /**
     * Gets an instance of the EmailMessageReader class.
     * @return  The message reader.
     */
    getMessageReader(): undefined.EmailMessageReader;

    /**
     * Gets an instance of the EmailMessageReader class using the specified query options.
     * @param options The query options to use when finding the message reader.
     * @return  The message reader that matches the query options.
     */
    getMessageReader(options: undefined.EmailQueryOptions): undefined.EmailMessageReader;

    /**
     * Gets the ID of the email folder. 
     */
    id: string;

    /**
     * Gets or sets a Boolean value indicating if the folder is sync enabled. 
     */
    isSyncEnabled: boolean;

    /**
     * Gets the type of the folder such as inbox, outbox, drafts, sent, and so on. 
     */
    kind: undefined.EmailSpecialFolderKind;

    /**
     * Gets or sets the last time the folder was successfully synced with the server. 
     */
    lastSuccessfulSyncTime: Date;

    /**
     * Gets the ID of the mailbox that contains this folder. 
     */
    mailboxId: string;

    /**
     * Gets the ID of this folder's parent folder. 
     */
    parentFolderId: string;

    /**
     * Gets or sets the remote ID of the corresponding folder on the server. 
     */
    remoteId: string;

    /**
     * Asynchronously saves the specified email message to the folder.
     * @param message The email message to save.
     * @return  An async action indicating that the operation has completed.
     */
    saveMessageAsync(message: undefined.EmailMessage): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously attempts to move this folder to the specified folder.
     * @param newParentFolder The new location for this folder.
     * @return  A Boolean value indicating if the move was successful.
     */
    tryMoveAsync(
        newParentFolder: undefined.EmailFolder): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to move this folder to the specified folder and rename it in the process.
     * @param newParentFolder The new location for this folder.
     * @param newFolderName The name for the folder in the new location.
     * @return  A Boolean value indicating if the move was successful.
     */
    tryMoveAsync(
        newParentFolder: undefined.EmailFolder,
        newFolderName: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to save changes to the folder.
     * @return  A Boolean value indicating if the save was successful.
     */
    trySaveAsync(): undefined.IPromiseWithIAsyncOperation<boolean >
}


/**
 * Represents email information rights management (IRM) info. 
 */
declare class EmailIrmInfo {

    /**
     * Initializes a new instance of the EmailIrmInfo class. 
     */
    constructor(): this;

    /**
     * Initializes a new instance of the EmailIrmInfo class using the specified IRM expiration time and template.
     * @param expiration The time when the information rights management (IRM) permissions expire.
     * @param irmTemplate The IRM template to apply to the message.
     */
    constructor(expiration: Date, irmTemplate: undefined.EmailIrmTemplate): this;

    /**
     * Gets or sets a Boolean value that indicates if an email message is allowed to be edited. 
     */
    canEdit: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the user can copy the contents of an email message to the clipboard. 
     */
    canExtractData: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the email message is allowed to be forwarded. 
     */
    canForward: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the user is allowed to change any of the email recipients when responding. 
     */
    canModifyRecipientsOnResponse: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the user is allowed to print the contents of the email message or any attachments. 
     */
    canPrintData: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the recipient is allowed to remove information rights management (IRM) when responding. 
     */
    canRemoveIrmOnResponse: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the recipient is allowed to reply to the email message. 
     */
    canReply: boolean;

    /**
     * Gets or sets a Boolean value that indicates if the recipient is allowed to reply all to the email message. 
     */
    canReplyAll: boolean;

    /**
     * Gets or sets the expiration date for the information rights management (IRM) permissions. 
     */
    expirationDate: Date;

    /**
     * Gets or sets a Boolean value that indicates if the sender is the information rights management (IRM) originator. 
     */
    isIrmOriginator: boolean;

    /**
     * Gets or sets a Boolean value that indicates if programmatic access to the message is allowed. 
     */
    isProgramaticAccessAllowed: boolean;

    /**
     * Gets or sets the EmailIrmTemplate used to create the information rights management (IRM) info. 
     */
    template: undefined.EmailIrmTemplate
}


/**
 * Represents a template that can be used to create new EmailIrmInfo objects. 
 */
declare class EmailIrmTemplate {

    /**
     * Creates a new instance of the EmailIrmTemplate class with the specified ID, name and description.
     * @param id The ID for the new template.
     * @param name The name of the new template.
     * @param description The description of the new template.
     */
    constructor(id: string, name: string, description: string): this;

    /**
     * Creates a new instance of the EmailIrmTemplate class. 
     */
    constructor(): this;

    /**
     * Gets or sets the description of the template. 
     */
    description: string;

    /**
     * Gets or sets the ID for the template. 
     */
    id: string;

    /**
     * Gets or sets the name for the template. 
     */
    name: string
}


/**
 * Represents the counts for various email message attributes such as flagged, important, unread, and so on. 
 */
declare class EmailItemCounts {

    /**
     * Gets the number of flagged email messages. 
     */
    flagged: number;

    /**
     * Gets the number of important email messages. 
     */
    important: number;

    /**
     * Gets the total number of email messages 
     */
    total: number;

    /**
     * Gets the number of unread email messages. 
     */
    unread: number
}


/**
 * Represents an email mailbox located on a remote email server. 
 */
declare class EmailMailbox {

    /**
     * Gets the capabilities associated with the mailbox. 
     */
    capabilities: undefined.EmailMailboxCapabilities;

    /**
     * Asynchronously changes the flag state of an email message.
     * @param messageId The ID of the email message to change.
     * @param flagState The new email flag state.
     * @return  An async action indicating that the operation has completed.
     */
    changeMessageFlagStateAsync(
        messageId: string,
        flagState: undefined.EmailFlagState): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the EmailMailboxChangeTracker for this mailbox. 
     */
    changeTracker: undefined.EmailMailboxChangeTracker;

    /**
     * Creates a new response email such as Reply, Reply All, Forward, and so on.
     * @param messageId The ID of the message to which to respond.
     * @param responseType The type of response such as Reply, Reply All, Forward, and so on.
     * @param subject The subject for the response message.
     * @param responseHeaderType The format of the email body such as plain text or HTML.
     * @param responseHeader The header for the response message.
     * @return  The newly created response email message.
     */
    createResponseMessageAsync(
        messageId: string,
        responseType: undefined.EmailMessageResponseKind,
        subject: string,
        responseHeaderType: undefined.EmailMessageBodyKind,
        responseHeader: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailMessage>;

    /**
     * Asynchronously deletes the mailbox.
     * @return  An async action indicating that the operation has completed.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously deletes an email message from the mailbox.
     * @param messageId The ID of the email message to delete.
     * @return  An async action indicating that the operation has completed.
     */
    deleteMessageAsync(messageId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets the name for this mailbox that is suitable for displaying. 
     */
    displayName: string;

    /**
     * Asynchronously downloads an email attachment.
     * @param attachmentId The ID of the attachment to download.
     * @return  An async action indicating that the operation has completed.
     */
    downloadAttachmentAsync(attachmentId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously downloads the specified email message.
     * @param messageId The ID of the message to download.
     * @return  An async action indicating that the operation has completed.
     */
    downloadMessageAsync(messageId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously gets the specified email conversation.
     * @param id The ID of the email conversation to retrieve.
     * @return  Returns the email conversation specified by the id parameter.
     */
    getConversationAsync(id: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailConversation>;

    /**
     * Gets or creates an email conversation reader for this mailbox if one does not already exist.
     * @return  The email conversation reader.
     */
    getConversationReader(): undefined.EmailConversationReader;

    /**
     * Gets or creates an email conversation reader for this mailbox using the specified query options.
     * @param options The email query options to use when creating the conversation reader.
     * @return  The new or existing conversation reader.
     */
    getConversationReader(options: undefined.EmailQueryOptions): undefined.EmailConversationReader;

    /**
     * Asynchronously gets the specified email folder.
     * @param id The ID of the folder to retrieve.
     * @return  The email folder specified in the id parameter.
     */
    getFolderAsync(id: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailFolder>;

    /**
     * Asynchronously gets the specified email message.
     * @param id The ID of the message to retrieve.
     * @return  The email message specified in the id parameter.
     */
    getMessageAsync(id: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailMessage>;

    /**
     * Gets or creates an email message reader for this mailbox if one does not already exist.
     * @return  The new or existing email message reader.
     */
    getMessageReader(): undefined.EmailMessageReader;

    /**
     * Gets or creates an email conversation reader for this mailbox using the specified query options.
     * @param options The email query options to use when creating the message reader.
     * @return  The new or existing email message reader.
     */
    getMessageReader(options: undefined.EmailQueryOptions): undefined.EmailMessageReader;

    /**
     * Asynchronously get a special email folder such as Inbox, Outbox, Drafts and so on.
     * @param folderType The type of folder to retrieve.
     * @return  The matching special email folder in this mailbox.
     */
    getSpecialFolderAsync(
        folderType: undefined.EmailSpecialFolderKind): undefined.IPromiseWithIAsyncOperation<undefined.EmailFolder>;

    /**
     * Gets the ID for this mailbox. 
     */
    id: string;

    /**
     * Gets a Boolean value that indicates if email data is encrypted when the device is locked. 
     */
    isDataEncryptedUnderLock: boolean;

    /**
     * Gets a Boolean value that indicates if this mailbox is owned by the current app. 
     */
    isOwnedByCurrentApp: boolean;

    /**
     * Gets the identifier for a mailbox linked to this one. 
     */
    linkedMailboxId: string;

    /**
     * Gets or sets the email address for the mailbox. 
     */
    mailAddress: string;

    /**
     * Gets the list of email aliases associated with this mailbox. 
     */
    mailAddressAliases: undefined.IVector<string>;

    /**
     * Asynchronously marks all the messages in a folder as seen.
     * @param folderId The ID of the folder to mark as seen.
     * @return  An async action indicating that the operation has completed.
     */
    markFolderAsSeenAsync(folderId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously marks a folder as sync enabled or disabled.
     * @param folderId The ID of the folder to mark.
     * @param isSyncEnabled True to enable to syncing with the server, false to disable syncing.
     * @return  An async action indicating that the operation has completed.
     */
    markFolderSyncEnabledAsync(folderId: string, isSyncEnabled: boolean): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously marks an email message as seen.
     * @param messageId The ID of the message to mark as seen.
     * @return  An async action indicating that the operation has completed.
     */
    markMessageAsSeenAsync(messageId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously marks an email message as read or unread.
     * @param messageId The ID of the message to mark.
     * @param isRead True to mark the message as read, false to mark it as unread.
     * @return  An async action indicating that the operation has completed.
     */
    markMessageReadAsync(messageId: string, isRead: boolean): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the identifier of the email mailbox account within its network. 
     */
    networkAccountId: string;

    /**
     * Gets the identifier of the network associated with this email mailbox. 
     */
    networkId: string;

    /**
     * Occurs when the mailbox has changed. 
     */
    onmailboxchanged: undefined.TypedEventHandler<undefined.EmailMailbox, undefined.EmailMailboxChangedEventArgs>;
    addEventListener(
        type: "mailboxchanged",
        listener: undefined.TypedEventHandler<undefined.EmailMailbox, undefined.EmailMailboxChangedEventArgs>): void;
    removeEventListener(
        type: "mailboxchanged",
        listener: undefined.TypedEventHandler<undefined.EmailMailbox, undefined.EmailMailboxChangedEventArgs>): void;

    /**
     * Gets or sets the read access level to this mailbox for other apps. 
     */
    otherAppReadAccess: undefined.EmailMailboxOtherAppReadAccess;

    /**
     * Gets or sets the write access level to this mailbox for other apps. 
     */
    otherAppWriteAccess: undefined.EmailMailboxOtherAppWriteAccess;

    /**
     * Gets the security policies for attachments in this mailbox. 
     */
    policies: undefined.EmailMailboxPolicies;

    /**
     * Resolves a list of one or more email addresses.
     * @param recipients The list of email addresses.
     * @return  A list of resolution results. The result list will be in the same order as the input list. See EmailRecipientResolutionResult for more information.
     */
    resolveRecipientsAsync(
        recipients: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously saves the mailbox to the email store.
     * @return  An async action indicating that the operation has completed.
     */
    saveAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously saves a draft email message.
     * @param message The draft email message to save.
     * @return  An async action indicating that the operation has completed.
     */
    saveDraftAsync(message: undefined.EmailMessage): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously sends the specified email message.
     * @param message The email message to send.
     * @return  An async action indicating that the operation has completed.
     */
    sendMessageAsync(message: undefined.EmailMessage): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously sends the specified email message.
     * @param message The email message to send.
     * @param smartSend True to send only the updated text, false to include the full message thread.
     * @return  An async action indicating that the operation has completed.
     */
    sendMessageAsync(
        message: undefined.EmailMessage,
        smartSend: boolean): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the display name of the source mailbox. 
     */
    sourceDisplayName: string;

    /**
     * Gets the sync manager for the mailbox. 
     */
    syncManager: undefined.EmailMailboxSyncManager;

    /**
     * Asynchronously attempts to create a new email folder.
     * @param parentFolderId The Id of the parent email folder.
     * @param name The name for the new folder.
     * @return  An async operation with an EmailMailboxCreateFolderResult containing the newly created folder and the status of the create operation.
     */
    tryCreateFolderAsync(
        parentFolderId: string,
        name: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailMailboxCreateFolderResult>;

    /**
     * Asynchronously attempts to delete an email folder.
     * @param folderId The Id of the folder to delete.
     * @return  An async operation with an EmailMailboxDeleteFolderStatus value representing the status of the delete operation.
     */
    tryDeleteFolderAsync(
        folderId: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailMailboxDeleteFolderStatus>;

    /**
     * Asynchronously attempt to delete the contents of an email folder.
     * @param folderId The Id of the folder to empty.
     * @return  An async operation with an EmailMailboxEmptyFolderStatus value representing the status of the delete operation.
     */
    tryEmptyFolderAsync(
        folderId: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailMailboxEmptyFolderStatus>;

    /**
     * Asynchronously attempts to forward a meeting request.
     * @param meeting The meeting to forward.
     * @param recipients The list of new recipients.
     * @param subject The subject of the email.
     * @param forwardHeaderType The email message format, HTML or plain text.
     * @param forwardHeader The email forward header.
     * @param comment The body of the message.
     * @return  A Boolean value indicating if the meeting was successfully forwarded.
     */
    tryForwardMeetingAsync(
        meeting: undefined.EmailMessage,
        recipients: undefined.IIterable<undefined.EmailRecipient>,
        subject: string,
        forwardHeaderType: undefined.EmailMessageBodyKind,
        forwardHeader: string,
        comment: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to get the auto-reply settings for the mailbox.
     * @param requestedFormat The requested text format of the auto-reply message, HTML or plain text.
     * @return  The auto-reply settings.
     */
    tryGetAutoReplySettingsAsync(
        requestedFormat: undefined.EmailMailboxAutoReplyMessageResponseKind): undefined.IPromiseWithIAsyncOperation<undefined.EmailMailboxAutoReplySettings>;

    /**
     * Asynchronously attempts to move the specified email folder.
     * @param folderId The folder to move.
     * @param newParentFolderId The new parent for the folder specified in the folderId parameter.
     * @return  A Boolean value indicating if the move was successful.
     */
    tryMoveFolderAsync(
        folderId: string,
        newParentFolderId: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to move the specified email folder and rename it in the process.
     * @param folderId The folder to move.
     * @param newParentFolderId The new parent for the folder specified in the folderId parameter.
     * @param newFolderName The name for the folder in the new location.
     * @return  A Boolean value indicating if the move was successful.
     */
    tryMoveFolderAsync(
        folderId: string,
        newParentFolderId: string,
        newFolderName: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to move the specified email message.
     * @param messageId The ID of the email message to move.
     * @param newParentFolderId The ID of the new folder where the email message should reside.
     * @return  A Boolean value indicating if the move was successful.
     */
    tryMoveMessageAsync(
        messageId: string,
        newParentFolderId: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to send a meeting request proposing a new time.
     * @param meeting The meeting for which to propose a new time.
     * @param newStartTime The proposed new time for the meeting to start.
     * @param newDuration The proposed duration of the meeting.
     * @param subject The subject of the meeting email.
     * @param comment The body of the message.
     * @return  A Boolean value indicating if the proposed meeting message was successfully sent.
     */
    tryProposeNewTimeForMeetingAsync(
        meeting: undefined.EmailMessage,
        newStartTime: Date,
        newDuration: number,
        subject: string,
        comment: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to set the auto-reply settings for the mailbox.
     * @param autoReplySettings The new auto-reply settings.
     * @return  A Boolean value indicating if the operation was successful.
     */
    trySetAutoReplySettingsAsync(
        autoReplySettings: undefined.EmailMailboxAutoReplySettings): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously attempts to respond to a meeting request.
     * @param meeting The meeting request.
     * @param response The response to the meeting request, accept, decline, or tentative.
     * @param subject The subject of the response email message.
     * @param comment The body of the response email message.
     * @param sendUpdate A Boolean indicating whether or not to send a response to the meeting originator.
     * @return  A Boolean value indicating if the response was sent successfully.
     */
    tryUpdateMeetingResponseAsync(
        meeting: undefined.EmailMessage,
        response: undefined.EmailMeetingResponseType,
        subject: string,
        comment: string,
        sendUpdate: boolean): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets the ID of the user data account for the mailbox. 
     */
    userDataAccountId: string;

    /**
     * Validates the certificate against the sync provider service.
     * @param certificates The certificate to validate.
     * @return  The confirmation that the certificate is valid.
     */
    validateCertificatesAsync(
        certificates: undefined.IIterable<undefined.Certificate>): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data about a change that occurred to a mailbox. 
 */
declare class EmailMailboxAction {

    /**
     * Gets the number that identifies the change that happened to the mailbox. 
     */
    changeNumber: number;

    /**
     * Gets the value that represents the kind of change that happened to the mailbox. 
     */
    kind: undefined.EmailMailboxActionKind
}


/**
 * Represents an auto-reply message set on a mailbox. 
 */
declare class EmailMailboxAutoReply {

    /**
     * Gets or sets a Boolean value that indicates if the auto-reply message is enabled. 
     */
    isEnabled: boolean;

    /**
     * Gets or sets the auto-reply response text. 
     */
    response: string
}


/**
 * Represents the settings for the automatic reply functionality of an email account. 
 */
declare class EmailMailboxAutoReplySettings {

    /**
     * Initializes a new instance of an EmailMailboxAutoReplySettings object. 
     */
    constructor(): this;

    /**
     * Represents the end time for the automated reply period. 
     */
    endTime: Date;

    /**
     * Gets the automatic reply message intended for an email message from an internal sender. 
     */
    internalReply: undefined.EmailMailboxAutoReply;

    /**
     * Gets a Boolean value indicating whether automatic replies are enabled. 
     */
    isEnabled: boolean;

    /**
     * Gets the automatic reply message intended for an email message from a known external sender. 
     */
    knownExternalReply: undefined.EmailMailboxAutoReply;

    /**
     * Gets or sets whether the automated response email message is encoded as HTML or plain text. 
     */
    responseKind: undefined.EmailMailboxAutoReplyMessageResponseKind;

    /**
     * Represents the start time for the automated reply period. 
     */
    startTime: Date;

    /**
     * Gets the automatic reply message intended for an email message from an unknown external sender. 
     */
    unknownExternalReply: undefined.EmailMailboxAutoReply
}


/**
 * Represents the capabilities associated with an email mailbox. 
 */
declare class EmailMailboxCapabilities {

    /**
     * Gets a Boolean value indicating if folders can be created in the mailbox. 
     */
    canCreateFolder: boolean;

    /**
     * Gets a Boolean value indicating if folders can be deleted from the mailbox. 
     */
    canDeleteFolder: boolean;

    /**
     * Gets a Boolean value indicating if folders in the mailbox can be emptied. 
     */
    canEmptyFolder: boolean;
    canForwardMeetings: any;
    canGetAndSetExternalAutoReplies: any;
    canGetAndSetInternalAutoReplies: any;

    /**
     * Gets a Boolean value indicating if folders in the mailbox can be moved. 
     */
    canMoveFolder: boolean;
    canProposeNewTimeForMeetings: any;

    /**
     * Gets a Boolean value that indicates whether the email mailbox is capable of resolving recipients. 
     */
    canResolveRecipients: boolean;
    canServerSearchFolders: any;
    canServerSearchMailbox: any;
    canSmartSend: any;
    canUpdateMeetingResponses: any;

    /**
     * Gets a Boolean value that indicates whether the email mailbox is capable of validating certificates. 
     */
    canValidateCertificates: boolean
}


/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime. 
 */
declare class EmailMailboxChange {

    /**
     * Gets the type of change that was made to the mailbox. This includes whether it was a folder or message that was changed and whether the item was created, deleted, or modified, or if change tracking was lost for this change. 
     */
    changeType: undefined.EmailMailboxChangeType;

    /**
     * Gets the folder to which the change applies. 
     */
    folder: undefined.EmailFolder;

    /**
     * Gets the flags that indicate what actions have been affected on the mailbox. 
     */
    mailboxActions: undefined.IVector<undefined.EmailMailboxAction>;

    /**
     * Gets the message to which the change applies. 
     */
    message: undefined.EmailMessage
}


/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime. 
 */
declare class EmailMailboxChangeReader {

    /**
     * Accepts all changes. 
     */
    acceptChanges(): void;

    /**
     * Accepts all changes through the current change.
     * @param lastChangeToAcknowledge The current change.
     */
    acceptChangesThrough(lastChangeToAcknowledge: undefined.EmailMailboxChange): void;

    /**
     * Reads a collection of changes.
     * @return  A batch of changes.
     */
    readBatchAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >>
}


/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime. 
 */
declare class EmailMailboxChangeTracker {

    /**
     * Enables change tracking on a mailbox. 
     */
    enable(): void;

    /**
     * Gets a reader that will read a batch of changes.
     * @return  A reader that will read a batch of changes.
     */
    getChangeReader(): undefined.EmailMailboxChangeReader;

    /**
     * Gets a Boolean value indicating whether change tracking is active. 
     */
    isTracking: boolean;

    /**
     * Moves the change tracking cursor to now. 
     */
    reset(): void
}


/**
 * Represents a deferred process that will halt a thread until the deferral is complete. 
 */
declare class EmailMailboxChangedDeferral {

    /**
     * Indicates to waiting processes that the deferral is complete. 
     */
    complete(): void
}


/**
 * Represents the deferral process. 
 */
declare class EmailMailboxChangedEventArgs {

    /**
     * Gets the deferral object.
     * @return  The deferral object.
     */
    getDeferral(): undefined.EmailMailboxChangedDeferral
}


/**
 * Represents the result of a TryCreateFolderAsync operation. 
 */
declare class EmailMailboxCreateFolderResult {

    /**
     * Get the newly created folder after a TryCreateFolderAsync operation. 
     */
    folder: undefined.EmailFolder;

    /**
     * Gets the status of a TryCreateFolderAsync operation. 
     */
    status: undefined.EmailMailboxCreateFolderStatus
}


/**
 * Represents the encryption and signing policies associates with an email mailbox. 
 */
declare class EmailMailboxPolicies {

    /**
     * Gets a Boolean value that indicates whether software certificates are allowed. 
     */
    allowSmimeSoftCertificates: boolean;

    /**
     * Gets the allowable SMIME encryption algorithms for the purpose of negotiating with an app. 
     */
    allowedSmimeEncryptionAlgorithmNegotiation: undefined.EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation;

    /**
     * Gets a Boolean value that indicates whether the sync provider that represents the email mailbox only accepts encrypted messages. 
     */
    mustEncryptSmimeMessages: boolean;

    /**
     * Gets a Boolean value that indicates whether the sync provider that represents the email mailbox only accepts signed messages. 
     */
    mustSignSmimeMessages: boolean;

    /**
     * Gets the required SMIME encryption algorithm. 
     */
    requiredSmimeEncryptionAlgorithm: undefined.EmailMailboxSmimeEncryptionAlgorithm;

    /**
     * Gets the required SMIME signing algorithm. 
     */
    requiredSmimeSigningAlgorithm: undefined.EmailMailboxSmimeSigningAlgorithm
}


/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime. 
 */
declare class EmailMailboxSyncManager {

    /**
     * Gets the last time the mailbox attempted to sync. 
     */
    lastAttemptedSyncTime: Date;

    /**
     * Gets the last time the mailbox was successfully synced. 
     */
    lastSuccessfulSyncTime: Date;

    /**
     * Fires whenever a mailbox's sync status changes. 
     */
    onsyncstatuschanged: undefined.TypedEventHandler<undefined.EmailMailboxSyncManager, any>;
    addEventListener(
        type: "syncstatuschanged",
        listener: undefined.TypedEventHandler<undefined.EmailMailboxSyncManager, any>): void;
    removeEventListener(
        type: "syncstatuschanged",
        listener: undefined.TypedEventHandler<undefined.EmailMailboxSyncManager, any>): void;

    /**
     * Gets the sync state of the mailbox. 
     */
    status: undefined.EmailMailboxSyncStatus;

    /**
     * Initiates a sync of this mailbox.
     * @return  A Boolean value indicating success.
     */
    syncAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Allows an application to launch the email application with a new message displayed. Use this to allow users to send email from your application. 
 */
declare class EmailManager {

    /**
     * Gets an email store that is within the specified scope.
     * @param accessType The enumerator of scope.
     * @return  The requested email store.
     */
    requestStoreAsync(
        accessType: undefined.EmailStoreAccessType): undefined.IPromiseWithIAsyncOperation<undefined.EmailStore>;

    /**
     * Launches the email application with a new message displayed.
     * @param message The email message that is displayed when the email application is launched.
     * @return  An asynchronous action.
     */
    showComposeNewEmailAsync(message: undefined.EmailMessage): undefined.IPromiseWithIAsyncAction
}


/**
 * Represents the information associated with a meeting. 
 */
declare class EmailMeetingInfo {

    /**
     * Initializes a new instance of the EmailMeetingInfo class. 
     */
    constructor(): this;

    /**
     * Gets or sets a Boolean value indicating whether the proposal of a new time is allowed. 
     */
    allowNewTimeProposal: boolean;

    /**
     * Gets or sets the start time for a meeting. 
     */
    appointmentOriginalStartTime: Date;

    /**
     * Gets or sets the server identifier for the appointment associated with an email message. 
     */
    appointmentRoamingId: string;

    /**
     * Gets or sets the duration of the meeting. 
     */
    duration: number;

    /**
     * Gets or sets a Boolean value indicating whether the meeting is an all day event. 
     */
    isAllDay: boolean;

    /**
     * Gets a Boolean value indicating if the meeting is reported as out of date by the server. 
     */
    isReportedOutOfDateByServer: boolean;

    /**
     * Gets or sets a Boolean value indicating whether a response to the meeting request is required. 
     */
    isResponseRequested: boolean;

    /**
     * Gets or sets the meeting location. 
     */
    location: string;

    /**
     * Gets or sets the proposed duration for the proposed meeting change. 
     */
    proposedDuration: number;

    /**
     * Gets or sets the proposed start time for the proposed meeting change. 
     */
    proposedStartTime: Date;

    /**
     * Gets or sets the recurrence parameters. 
     */
    recurrence: undefined.AppointmentRecurrence;

    /**
     * Gets or sets the first instance of the recurrence pattern. 
     */
    recurrenceStartTime: Date;

    /**
     * Gets or sets the change number on the server that identifies the meeting email change number. 
     */
    remoteChangeNumber: number;

    /**
     * Gets or sets the start time for the meeting. 
     */
    startTime: Date
}


/**
 * Represents an email message. 
 */
declare class EmailMessage {

    /**
     * Creates an instance of the EmailMessage class. 
     */
    constructor(): this;

    /**
     * Gets or sets a Boolean value indicating whether images may be embedded in the html encoded email message. 
     */
    allowInternetImages: boolean;

    /**
     * Gets the attachments of the email message. 
     */
    attachments: undefined.IVector<undefined.EmailAttachment>;

    /**
     * Gets the recipients BCC'd to the email message. 
     */
    bcc: undefined.IVector<undefined.EmailRecipient>;

    /**
     * Gets or sets the body of the email message. 
     */
    body: string;

    /**
     * Gets the recipients CC'd to the email message. 
     */
    cc: undefined.IVector<undefined.EmailRecipient>;

    /**
     * Gets the current change number which is incremented for each change made to an email message. 
     */
    changeNumber: number;

    /**
     * Gets the identifier for a conversation. 
     */
    conversationId: string;

    /**
     * Gets or sets the download status of an email message. 
     */
    downloadState: undefined.EmailMessageDownloadState;

    /**
     * Gets or sets the estimated size, in bytes, of an email message download. 
     */
    estimatedDownloadSizeInBytes: number;

    /**
     * Represents the flag status of an email message. 
     */
    flagState: undefined.EmailFlagState;

    /**
     * Gets the identifier of a folder in the inbox. 
     */
    folderId: string;

    /**
     * Gets the requested email stream such as plain text or HTML.
     * @param type The kind of message body; plain text or HTML.
     * @return  The selected body stream.
     */
    getBodyStream(type: undefined.EmailMessageBodyKind): undefined.IRandomAccessStreamReference;

    /**
     * Gets a Boolean value indicating whether this email message contains partial bodies. 
     */
    hasPartialBodies: boolean;

    /**
     * Gets the identifier of an email message. 
     */
    id: string;

    /**
     * Gets the importance of an email message. 
     */
    importance: undefined.EmailImportance;

    /**
     * Gets the identifier for the email message to which this message is a response. 
     */
    inResponseToMessageId: string;

    /**
     * Gets or sets the Information Rights Management (IRM) information for this email message. 
     */
    irmInfo: undefined.EmailIrmInfo;

    /**
     * Gets a Boolean value indicating whether this message is a draft. 
     */
    isDraftMessage: boolean;

    /**
     * Gets a Boolean value indicating whether the email message has been read. 
     */
    isRead: boolean;

    /**
     * Gets a Boolean value indicating whether the email message has been seen. 
     */
    isSeen: boolean;

    /**
     * Gets a Boolean value indicating whether the email message is a temporary server search message. 
     */
    isServerSearchMessage: boolean;

    /**
     * Gets a Boolean value indicating whether the response email message is allowed to attempt a smart send, only sending that portion of the email message that has changed. 
     */
    isSmartSendable: boolean;

    /**
     * Gets the last kind of response sent in reference to this email message. 
     */
    lastResponseKind: undefined.EmailMessageResponseKind;

    /**
     * Gets the identifier of the mailbox. 
     */
    mailboxId: string;

    /**
     * Gets the information associated with this meeting. 
     */
    meetingInfo: undefined.EmailMeetingInfo;

    /**
     * Gets or sets a string that indicates the class of the message. 
     */
    messageClass: string;

    /**
     * Gets the subject line of an email message stripped of additional prefixes such as fwd: and re: 
     */
    normalizedSubject: string;

    /**
     * Gets or sets the integer that identifies the original flavor of the character set used so that when the email message is condensed from wide character format (16-bit) to ASCII or other 8-bit encoding, in cases of later encoding questions, this integer can be used to recreate the original character set. 
     */
    originalCodePage: number;

    /**
     * Gets or sets the short preview string that represents the longer email message in the list view of emails. 
     */
    preview: string;

    /**
     * Gets or sets the identifier that can be used by a service provider to access the email message on the client machine. 
     */
    remoteId: string;

    /**
     * Gets or sets the mailbox from which the email message was sent. 
     */
    sender: undefined.EmailRecipient;

    /**
     * Gets or sets the time an email was sent. 
     */
    sentTime: Date;

    /**
     * Sets the value of the specified body stream in an email message.
     * @param type Indicates which body stream, plain text or HTML.
     * @param stream The message for the specified body stream.
     */
    setBodyStream(
        type: undefined.EmailMessageBodyKind,
        stream: undefined.IRandomAccessStreamReference): void;

    /**
     * Gets or sets the S/MIME data associated with an email message. For more information, see the Certificate class. 
     */
    smimeData: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the type of S/MIME encryption/signature for the email message. 
     */
    smimeKind: undefined.EmailMessageSmimeKind;

    /**
     * Gets or sets the subject of the email message. 
     */
    subject: string;

    /**
     * Gets the direct recipients of the email message. 
     */
    to: undefined.IVector<undefined.EmailRecipient >
}


/**
 * Represents a collection of email messages. 
 */
declare class EmailMessageBatch {

    /**
     * Gets a batch of email messages. 
     */
    messages: undefined.IVectorView<undefined.EmailMessage>;

    /**
     * Gets the status of the email batch read. 
     */
    status: undefined.EmailBatchStatus
}


/**
 * Gets a batch of email messages. 
 */
declare class EmailMessageReader {

    /**
     * Reads a collection of email messages.
     * @return  A batch of email messages.
     */
    readBatchAsync(): undefined.IPromiseWithIAsyncOperation<undefined.EmailMessageBatch >
}


/**
 * Represents the options selected for an email mailbox query. 
 */
declare class EmailQueryOptions {

    /**
     * Instantiates a new instance of the EmailQueryOptions class. 
     */
    constructor(): this;

    /**
     * Instantiates a new instance of the EmailQueryOptions class.
     * @param text The text for which to search.
     * @param fields The fields against which to search.
     */
    constructor(text: string, fields: undefined.EmailQuerySearchFields): this;

    /**
     * Instantiates a new instance of the EmailQueryOptions class.
     * @param text The text for which to search.
     */
    constructor(text: string): this;

    /**
     * Gets the identifiers for the folders in which to search. 
     */
    folderIds: undefined.IVector<string>;

    /**
     * Gets or sets the kind of emails for which to query. 
     */
    kind: undefined.EmailQueryKind;

    /**
     * Gets or sets the direction of the sort for the query results. 
     */
    sortDirection: undefined.EmailQuerySortDirection;

    /**
     * Gets or sets a Boolean value indicating whether the query results should be sorted. 
     */
    sortProperty: undefined.EmailQuerySortProperty;

    /**
     * Gets the text to search for. 
     */
    textSearch: undefined.EmailQueryTextSearch
}


/**
 * Represents a text search query in an email mailbox. 
 */
declare class EmailQueryTextSearch {

    /**
     * Gets or sets the fields for an email text search query. 
     */
    fields: undefined.EmailQuerySearchFields;

    /**
     * Gets or sets the scope for an email text search query. 
     */
    searchScope: undefined.EmailQuerySearchScope;

    /**
     * Gets or sets the text string for an email text search query. 
     */
    text: string
}


/**
 * Represents an email recipient. 
 */
declare class EmailRecipient {

    /**
     * Initializes an instance of the EmailRecipient class. 
     */
    constructor(): this;

    /**
     * Initializes an instance of the EmailRecipient class.
     * @param address The address of the recipient.
     * @param name The name of the recipient.
     */
    constructor(address: string, name: string): this;

    /**
     * Initializes an instance of the EmailRecipient class.
     * @param address The address of the recipient.
     */
    constructor(address: string): this;

    /**
     * Gets or sets the address of the email recipient. 
     */
    address: string;

    /**
     * Gets or sets the name of the email recipient. 
     */
    name: string
}


/**
 * Represents the result of an attempt to resolve an email recipient. 
 */
declare class EmailRecipientResolutionResult {

    /**
     * Gets the public key for an email recipient. 
     */
    publicKeys: undefined.IVectorView<undefined.Certificate>;

    /**
     * Gets the state of an attempt to resolve an email recipient. 
     */
    status: undefined.EmailRecipientResolutionStatus
}


/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime. 
 */
declare class EmailStore {

    /**
     * Allows an app to create an email account from an account name and an email address.
     * @param accountName The name of the account.
     * @param accountAddress The email address associated with the account.
     * @return  An email mailbox.
     */
    createMailboxAsync(
        accountName: string,
        accountAddress: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailMailbox>;

    /**
     * Allows an app to create an email account from an account name, an email address, and the user data account in which the mailbox will reside.
     * @param accountName The name of the account.
     * @param accountAddress The email address associated with the account.
     * @param userDataAccountId The user data account identifier associated with this user.
     * @return  An email mailbox.
     */
    createMailboxAsync(
        accountName: string,
        accountAddress: string,
        userDataAccountId: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailMailbox>;

    /**
     * Gets all mailboxes within the current scope.
     * @return  A collection of mailboxes.
     */
    findMailboxesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets an email conversation from the provided identifier.
     * @param id The identifier of the conversation.
     * @return  An email conversation.
     */
    getConversationAsync(id: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailConversation>;

    /**
     * Gets a batch of email conversations.
     * @return  A batch of email conversations.
     */
    getConversationReader(): undefined.EmailConversationReader;

    /**
     * Gets a batch of email conversations using the specified email query options.
     * @param options The email query options.
     * @return  A batch of email conversations.
     */
    getConversationReader(options: undefined.EmailQueryOptions): undefined.EmailConversationReader;

    /**
     * Gets an email folder from an identifier.
     * @param id The identifier for the email folder.
     * @return  The folder described by the identifier.
     */
    getFolderAsync(id: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailFolder>;

    /**
     * Gets a mailbox from an identifier.
     * @param id The identifier for the mailbox.
     * @return  The mailbox described by the identifier.
     */
    getMailboxAsync(id: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailMailbox>;

    /**
     * Gets the specified email message.
     * @param id The identifier for the email message.
     * @return  The specified email message.
     */
    getMessageAsync(id: string): undefined.IPromiseWithIAsyncOperation<undefined.EmailMessage>;

    /**
     * Gets a message reader.
     * @return  The email message reader.
     */
    getMessageReader(): undefined.EmailMessageReader;

    /**
     * Gets a message reader using the specified query options.
     * @param options Specified query options.
     * @return  An email message reader.
     */
    getMessageReader(options: undefined.EmailQueryOptions): undefined.EmailMessageReader
}


/**
 * The functionality described in this topic is not available to all Windows and Windows Phone apps. For your code to call these APIs, Microsoft must approve your use of them and provision your developer account. Otherwise the calls will fail at runtime. 
 */
declare class EmailStoreNotificationTriggerDetails {}


/**
 * Represents the object that is passed as a parameter to the event handler that is invoked when the system revokes background execution. 
 */
declare class ExtendedExecutionRevokedEventArgs {

    /**
     * Gets the reason background execution was revoked. 
     */
    reason: undefined.ExtendedExecutionRevokedReason
}


/**
 * Supports managing a request for background execution. 
 */
declare class ExtendedExecutionSession {

    /**
     * Creates an ExtendedExecutionSession object. 
     */
    constructor(): this;

    /**
     * Closes the session and removes the application's capability to run in the background. 
     */
    close(): void;

    /**
     * Gets or sets a string to display in the shell. 
     */
    description: string;

    /**
     * The Revoked event occurs when the system revokes background execution. 
     */
    onrevoked: undefined.TypedEventHandler<any, undefined.ExtendedExecutionRevokedEventArgs>;
    addEventListener(
        type: "revoked",
        listener: undefined.TypedEventHandler<any, undefined.ExtendedExecutionRevokedEventArgs>): void;
    removeEventListener(
        type: "revoked",
        listener: undefined.TypedEventHandler<any, undefined.ExtendedExecutionRevokedEventArgs>): void;

    /**
     * Gets or sets a value to show progress in the shell. 
     */
    percentProgress: number;

    /**
     * Gets or sets the reason for the for the background execution request. 
     */
    reason: undefined.ExtendedExecutionReason;

    /**
     * Requests background execution.
     * @return  The result of the request.
     */
    requestExtensionAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ExtendedExecutionResult>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Passed to the event handler that is invoked when the system revokes extended execution. 
 */
declare class ExtendedExecutionForegroundRevokedEventArgs {

    /**
     * Gets the reason extended execution was revoked. 
     */
    reason: undefined.ExtendedExecutionForegroundRevokedReason
}


/**
 * Supports managing a request for extended foreground execution. 
 */
declare class ExtendedExecutionForegroundSession {

    /**
     * Creates an ExtendedExecutionForegroundSession object 
     */
    constructor(): this;

    /**
     * Closes the session and removes the application's extended execution capability. 
     */
    close(): void;

    /**
     * Gets or sets a string to display in the shell. 
     */
    description: string;

    /**
     * This event occurs when the system revokes extended execution. 
     */
    onrevoked: undefined.TypedEventHandler<any, undefined.ExtendedExecutionForegroundRevokedEventArgs>;
    addEventListener(
        type: "revoked",
        listener: undefined.TypedEventHandler<any, undefined.ExtendedExecutionForegroundRevokedEventArgs>): void;
    removeEventListener(
        type: "revoked",
        listener: undefined.TypedEventHandler<any, undefined.ExtendedExecutionForegroundRevokedEventArgs>): void;

    /**
     * Gets or sets the reason for the extended execution request. 
     */
    reason: undefined.ExtendedExecutionForegroundReason;

    /**
     * Requests extended execution
     * @return  The result of the request.
     */
    requestExtensionAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ExtendedExecutionForegroundResult>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Allows the lock screen app to request that the device unlocks, and allows the app to register to be notified when the device begins to unlock. 
 */
declare class LockApplicationHost {

    /**
     * Gets a LockApplicationHost object.
     * @return  A LockApplicationHost object.
     */
    getForCurrentView(): undefined.LockApplicationHost;

    /**
     * Indicates the device is unlocking. 
     */
    onunlocking: undefined.TypedEventHandler<undefined.LockApplicationHost, undefined.LockScreenUnlockingEventArgs>;
    addEventListener(
        type: "unlocking",
        listener: undefined.TypedEventHandler<undefined.LockApplicationHost, undefined.LockScreenUnlockingEventArgs>): void;
    removeEventListener(
        type: "unlocking",
        listener: undefined.TypedEventHandler<undefined.LockApplicationHost, undefined.LockScreenUnlockingEventArgs>): void;

    /**
     * Requests that the device unlocks. 
     */
    requestUnlock(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a lock screen badge for an app. 
 */
declare class LockScreenBadge {

    /**
     * Gets the name. 
     */
    automationName: string;

    /**
     * Gets the glyph to display. 
     */
    glyph: undefined.IRandomAccessStream;

    /**
     * Launches the app corresponding to the badge. 
     */
    launchApp(): void;

    /**
     * Gets the logo to display with the badge. 
     */
    logo: undefined.IRandomAccessStream;

    /**
     * Gets the number to display with the badge. 
     */
    number: number
}


/**
 * Provides access to the same data that the default lock screen has access to, such as wallpaper, badges, and so on. 
 */
declare class LockScreenInfo {

    /**
     * Gets the alarm icon to display. 
     */
    alarmIcon: undefined.IRandomAccessStream;

    /**
     * Gets the badges to display. 
     */
    badges: undefined.IVectorView<undefined.LockScreenBadge>;

    /**
     * Gets the detail text to display. 
     */
    detailText: undefined.IVectorView<string>;

    /**
     * Gets the image to display on the lock screen. 
     */
    lockScreenImage: undefined.IRandomAccessStream;

    /**
     * Indicates the alarm icon has changed. 
     */
    onalarmiconchanged: undefined.TypedEventHandler<undefined.LockScreenInfo, any>;
    addEventListener(
        type: "alarmiconchanged",
        listener: undefined.TypedEventHandler<undefined.LockScreenInfo, any>): void;
    removeEventListener(
        type: "alarmiconchanged",
        listener: undefined.TypedEventHandler<undefined.LockScreenInfo, any>): void;

    /**
     * Indicates the badges have changed. 
     */
    onbadgeschanged: undefined.TypedEventHandler<undefined.LockScreenInfo, any>;
    addEventListener(
        type: "badgeschanged",
        listener: undefined.TypedEventHandler<undefined.LockScreenInfo, any>): void;
    removeEventListener(
        type: "badgeschanged",
        listener: undefined.TypedEventHandler<undefined.LockScreenInfo, any>): void;

    /**
     * Indicates the detail text has changed. 
     */
    ondetailtextchanged: undefined.TypedEventHandler<undefined.LockScreenInfo, any>;
    addEventListener(
        type: "detailtextchanged",
        listener: undefined.TypedEventHandler<undefined.LockScreenInfo, any>): void;
    removeEventListener(
        type: "detailtextchanged",
        listener: undefined.TypedEventHandler<undefined.LockScreenInfo, any>): void;

    /**
     * Indicates the lock screen image has changed. 
     */
    onlockscreenimagechanged: undefined.TypedEventHandler<undefined.LockScreenInfo, any>;
    addEventListener(
        type: "lockscreenimagechanged",
        listener: undefined.TypedEventHandler<undefined.LockScreenInfo, any>): void;
    removeEventListener(
        type: "lockscreenimagechanged",
        listener: undefined.TypedEventHandler<undefined.LockScreenInfo, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an unlock deferral. 
 */
declare class LockScreenUnlockingDeferral {

    /**
     * Notifies the system that your deferral is complete. If your deferral takes too long to complete, your lock screen app will be terminated by the system and potentially removed as the user’s default lock app. 
     */
    complete(): void
}


/**
 * Represents the lock screen unlocking events. 
 */
declare class LockScreenUnlockingEventArgs {

    /**
     * Gets the deadline by which the lock screen app must unlock the device. If your unlocking deferral takes too long, your lock screen app will be terminated by the system and potentially removed as the user’s default lock app. 
     */
    deadline: Date;

    /**
     * Gets a LockScreenUnlockingDeferral , which defers the unlocking of the device.
     * @return  An unlock deferral.
     */
    getDeferral(): undefined.LockScreenUnlockingDeferral
}


/**
 * Provides information about a package. 
 */
declare class Package {

    /**
     * Gets the package for the current app. 
     */
    current: undefined.Package;

    /**
     * Gets the packages on which the current package depends. 
     */
    dependencies: undefined.IVectorView<undefined.Package>;

    /**
     * Gets the description of the package. 
     */
    description: string;

    /**
     * Gets the display name of the package. 
     */
    displayName: string;
    getAppListEntriesAsync: any;

    /**
     * Windows Phone only. Returns a token that can be used to retrieve the thumbnail image associated with this application package.
     * @return  A token that can be used to retrieve the thumbnail image associated with this application package.
     */
    getThumbnailToken(): string;

    /**
     * Gets the package identity of the current package. 
     */
    id: undefined.PackageId;

    /**
     * Windows Phone only. Gets the date the application package was installed on the user's phone. 
     */
    installDate: Date;

    /**
     * Gets the date on which the application package was installed or last updated. 
     */
    installedDate: Date;

    /**
     * Gets the location of the installed package. 
     */
    installedLocation: undefined.StorageFolder;

    /**
     * Indicates whether the package is a bundle package. 
     */
    isBundle: boolean;

    /**
     * Indicates whether the package is installed in development mode. 
     */
    isDevelopmentMode: boolean;

    /**
     * Indicates whether other packages can declare a dependency on this package. 
     */
    isFramework: boolean;

    /**
     * Indicates whether the package is a resource package. 
     */
    isResourcePackage: boolean;

    /**
     * Windows Phone only. Launches the specified application.
     * @param parameters The navigation URI that specifies the page to launch and optional parameters. Use an empty string to specify the default page for the app.
     */
    launch(parameters: string): void;

    /**
     * Gets the logo of the package. 
     */
    logo: undefined.Uri;

    /**
     * Gets the publisher display name of the package. 
     */
    publisherDisplayName: string;
    status: any
}


/**
 * Provides package identification info, such as name, version, and publisher. 
 */
declare class PackageId {

    /**
     * Gets the processor architecture for which the package was created. 
     */
    architecture: undefined.ProcessorArchitecture;

    /**
     * Windows Phone only. Gets the value of the Author attribute for the specified application package. 
     */
    author: string;

    /**
     * Gets the family name of the package. 
     */
    familyName: string;

    /**
     * Gets the full name of the package. 
     */
    fullName: string;

    /**
     * Gets the name of the package. 
     */
    name: string;

    /**
     * Windows Phone only. Gets the value of the ProductID attribute associated with this application package. 
     */
    productId: string;

    /**
     * Gets the publisher of the package. 
     */
    publisher: string;

    /**
     * Gets the publisher ID of the package. 
     */
    publisherId: string;

    /**
     * Gets the resource ID of the package. 
     */
    resourceId: string;

    /**
     * Gets the package version info. 
     */
    version: undefined.PackageVersion
}


/**
 * Provides the status of the package. 
 */
declare class PackageStatus {

    /**
     * Indicates whether the data for the package is offline. 
     */
    dataOffline: boolean;

    /**
     * Indicates whether this package depends on a package that can't be used. 
     */
    dependencyIssue: boolean;

    /**
     * Indicates whether the package is being serviced. 
     */
    deploymentInProgress: boolean;

    /**
     * Indicates whether the package has been disabled. 
     */
    disabled: boolean;

    /**
     * Indicates whether there is a problem with the license for this package. 
     */
    licenseIssue: boolean;

    /**
     * Indicates whether the package is missing files, system information, etc. 
     */
    modified: boolean;

    /**
     * Indicates whether the package is unusable. 
     */
    needsRemediation: boolean;

    /**
     * Indicates whether the package is available. 
     */
    notAvailable: boolean;

    /**
     * Indicates whether the package is offline and cannot be used. 
     */
    packageOffline: boolean;

    /**
     * Indicates whether the package is being serviced. 
     */
    servicing: boolean;

    /**
     * Indicates whether the package may have been tampered with. 
     */
    tampered: boolean;

    /**
     * Indicates whether the package is in good condition and may be used.
     * @return  TRUE indicates that the package is in good condition; otherwise FALSE.
     */
    verifyIsOK(): boolean
}


/**
 * Represents a single logical, named resource, such as a string resource named 'Header1'. 
 */
declare class NamedResource {

    /**
     * Gets all possible candidate values for this named resource. 
     */
    candidates: undefined.IVectorView<undefined.ResourceCandidate>;

    /**
     * Resolves this NamedResource object against a supplied context and returns the most appropriate candidate.
     * @param resourceContext The context against which the NamedResource should be resolved.
     * @return  The most appropriate candidate for the specified context.
     */
    resolve(resourceContext: undefined.ResourceContext): undefined.ResourceCandidate;

    /**
     * Resolves this NamedResource object against the default context and returns the most appropriate candidate.
     * @return  The most appropriate candidate for the default context.
     */
    resolve(): undefined.ResourceCandidate;

    /**
     * Resolves this NamedResource object against a supplied context and returns a list of all possible candidates in preference order.
     * @param resourceContext The context against which the NamedResource should be resolved.
     * @return  A list of ResourceCandidate objects, in order of preference. The object in first position in the list is the most appropriate candidate for the corresponding context, and the object in last position is the least appropriate.
     */
    resolveAll(
        resourceContext: undefined.ResourceContext): undefined.IVectorView<undefined.ResourceCandidate>;

    /**
     * Resolves this NamedResource object against the default context and returns a list of all possible candidates in preference order.
     * @return  A list of ResourceCandidate objects, in order of preference. The object in first position in the list is the most appropriate candidate for the corresponding context, and the object in last position is the least appropriate.
     */
    resolveAll(): undefined.IVectorView<undefined.ResourceCandidate>;

    /**
     * Gets a URI that can be used to refer to this named resource. 
     */
    uri: undefined.Uri
}


/**
 * Represents a single possible value for a given NamedResource , the qualifiers associated with that resource, and how well those qualifiers match the context against which it was resolved. 
 */
declare class ResourceCandidate {

    /**
     * Returns the value of a qualifier, given its name.
     * @param qualifierName The name of the qualifier.
     * @return  The value of the qualifier.
     */
    getQualifierValue(qualifierName: string): string;

    /**
     * Asynchronously returns a StorageFile that accesses the value of this ResourceCandidate . This only works on certain types of ResourceCandidates that are files.
     * @return  An asynchronous operation to return the requested StorageFile .
     */
    getValueAsFileAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Asynchronously returns an IRandomAccessStream that accesses the value of this ResourceCandidate .
     * @return  An asynchronous operation to return the requested IRandomAccessStream .
     */
    getValueAsStreamAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStream>;

    /**
     * Indicates whether this ResourceCandidate can be used as a default fallback value for any context. 
     */
    isDefault: boolean;

    /**
     * Indicates whether this ResourceCandidate matched the ResourceContext against which it was evaluated. 
     */
    isMatch: boolean;

    /**
     * Indicates whether this ResourceCandidate matched the ResourceContext against which it was evaluated as a result of being a true match, a default fallback value, or a mixed match with default fallback (that is, a match in relation to some qualifiers but using default fallback values for other qualifiers). 
     */
    isMatchAsDefault: boolean;

    /**
     * Gets the qualifiers associated with this ResourceCandidate . 
     */
    qualifiers: undefined.IVectorView<undefined.ResourceQualifier>;

    /**
     * Gets the value of this ResourceCandidate , expressed as a string. 
     */
    valueAsString: string
}


/**
 * Represents a collection of ResourceCandidate objects. 
 */
declare class ResourceCandidateVectorView mixins Array<undefined.ResourceCandidate>{

    /**
     * Returns an iterator to enumerate the items in the set of ResourceCandidate objects.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the set if the set is empty.
     */
    first(): undefined.IIterator<undefined.ResourceCandidate>;

    /**
     * Returns the ResourceCandidate at the specified index in the set.
     * @param index The zero-based index of the ResourceCandidate in the set to return.
     * @return  The ResourceCandidate at the specified index.
     */
    getAt(index: number): undefined.ResourceCandidate;

    /**
     * Returns the ResourceCandidate objects that start at the specified index in the set.
     * @param startIndex The zero-based index of the start of the ResourceCandidate objects in the set to return.
     */
    getMany(
        startIndex: number): {
        items: undefined.ResourceCandidate,
        returnValue: number
    };

    /**
     * Returns the index of a specified ResourceCandidate in the set.
     * @param value The ResourceCandidate to find in the set.
     */
    indexOf(value: undefined.ResourceCandidate): {
        index: number,
        returnValue: boolean
    };

    /**
     * Gets the number of ResourceCandidate objects in the set. 
     */
    size: number;
    indexOf(
        value: undefined.ResourceCandidate,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.ResourceCandidate, fromIndex?: number): number
}


/**
 * Encapsulates all of the factors ( ResourceQualifier s) that might affect resource selection. 
 */
declare class ResourceContext {

    /**
     * Creates a new ResourceContext that matches a supplied set of qualifiers.
     * @param result The list of qualifiers to be matched.
     * @return  The new ResourceContext .
     */
    createMatchingContext(
        result: undefined.IIterable<undefined.ResourceQualifier>): undefined.ResourceContext;

    /**
     * Gets a default ResourceContext associated with the current view for the currently running application.
     * @return  The default context associated with the current view.
     */
    getForCurrentView(): undefined.ResourceContext;

    /**
     * Gets a default ResourceContext not associated with any view.
     * @return  A default ResourceContext not associated with any view.
     */
    getForViewIndependentUse(): undefined.ResourceContext;

    /**
     * Removes any qualifier overrides from default contexts of all views across the app. 
     */
    resetGlobalQualifierValues(): void;

    /**
     * Removes qualifier overrides for the specified qualifiers from default contexts of all views across the app.
     * @param qualifierNames The names of the qualifiers to be reset.
     */
    resetGlobalQualifierValues(qualifierNames: undefined.IIterable<string>): void;

    /**
     * Applies a single qualifier value override to default contexts of all views for the current app.
     * @param key The name of the qualifier to override.
     * @param value The override value to set.
     */
    setGlobalQualifierValue(key: string, value: string): void;

    /**
     * Applies a single qualifier value override to default contexts of all views for the current app, and specifies the persistence of the override.
     * @param key The name of the qualifier to override.
     * @param value The override value to set.
     * @param persistence The persistence of the override value.
     */
    setGlobalQualifierValue(
        key: string,
        value: string,
        persistence: undefined.ResourceQualifierPersistence): void;

    /**
     * Creates a cloned ResourceContext object. 
     */
    constructor(): this;

    /**
     * Creates a clone of this ResourceContext , with identical qualifiers.
     * @return  A new, cloned ResourceContext .
     */
    clone(): undefined.ResourceContext;

    /**
     * Gets or sets the language qualifier for this context. 
     */
    languages: undefined.IVectorView<string>;

    /**
     * Overrides the qualifier values supplied by this context to match a specified list of resolved ResourceQualifier s. Typically the resolved ResourceQualifiers are associated with a resource that was looked up earlier.
     * @param result The ResourceQualifier s to be applied to the context.
     */
    overrideToMatch(result: undefined.IIterable<undefined.ResourceQualifier>): void;

    /**
     * Gets a writable, observable map of all supported qualifiers, indexed by name. 
     */
    qualifierValues: undefined.IObservableMap<string, string>;

    /**
     * Resets the overridden values for the specified qualifiers on the given ResourceContext instance.
     * @param qualifierNames The names of the qualifiers to be reset.
     */
    reset(qualifierNames: undefined.IIterable<string>): void;

    /**
     * Resets the overridden values for all qualifiers on the given ResourceContext instance. 
     */
    reset(): void
}


/**
 * Represents a collection of ResourceContext language qualifiers. 
 */
declare class ResourceContextLanguagesVectorView mixins Array<string>{

    /**
     * Returns an iterator to enumerate the items in the set of ResourceContext language qualifiers.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the set if the set is empty.
     */
    first(): undefined.IIterator<string>;

    /**
     * Returns the ResourceContext language qualifier at the specified index in the set.
     * @param index The zero-based index of the ResourceContext language qualifier in the set to return.
     * @return  The ResourceContext language qualifier at the specified index.
     */
    getAt(index: number): string;

    /**
     * Returns the ResourceContext language qualifiers that start at the specified index in the set.
     * @param startIndex The zero-based index of the start of the ResourceContext language qualifiers in the set to return.
     */
    getMany(startIndex: number): {
        items: string[],
        returnValue: number
    };

    /**
     * Returns the index of a specified ResourceContext language qualifier in the set.
     * @param value The ResourceContext language qualifier to find in the set.
     */
    indexOf(value: string): {
        index: number,
        returnValue: boolean
    };

    /**
     * Gets the number of ResourceContext language qualifiers in the set. 
     */
    size: number;
    indexOf(value: string, ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: string, fromIndex?: number): number
}


/**
 * Provides access to application resource maps and more advanced resource functionality. 
 */
declare class ResourceManager {

    /**
     * Gets the ResourceManager for the currently running application. 
     */
    current: undefined.ResourceManager;

    /**
     * Determines whether a supplied string matches the resource reference format (an ms-resource string URI identifier).
     * @param resourceReference The string you want to match.
     * @return  TRUE if the string matches.
     */
    isResourceReference(resourceReference: string): boolean;

    /**
     * Gets a map of ResourceMap objects typically associated with the app packages, indexed by package name. 
     */
    allResourceMaps: undefined.IMapView<string, undefined.ResourceMap>;

    /**
     * Gets the default ResourceContext for the currently running application. Unless explicitly overridden, the default ResourceContext is used to determine the most appropriate representation of any given named resource. 
     */
    defaultContext: undefined.ResourceContext;

    /**
     * Gets a list of all named resources for an app package.
     * @param packageName The name of the app package.
     * @param resourceLayoutInfo Specifies the resource version and the named resource count.
     * @return  A list of NamedResource objects.
     */
    getAllNamedResourcesForPackage(
        packageName: string,
        resourceLayoutInfo: undefined.ResourceLayoutInfo): undefined.IVectorView<undefined.NamedResource>;

    /**
     * Gets a list of all collections of resource subtrees for an app package.
     * @param packageName The name of the app package.
     * @param resourceLayoutInfo Specifies the resource version and the resource subtree count.
     * @return  A list of resource subtrees ( ResourceMap objects).
     */
    getAllSubtreesForPackage(
        packageName: string,
        resourceLayoutInfo: undefined.ResourceLayoutInfo): undefined.IVectorView<undefined.ResourceMap>;

    /**
     * Loads one or more PRI files and adds their contents to the default resource manager.
     * @param files The files you want to add.
     */
    loadPriFiles(files: undefined.IIterable<undefined.IStorageFile>): void;

    /**
     * Gets the ResourceMap that is associated with the main package of the currently running application. 
     */
    mainResourceMap: undefined.ResourceMap;

    /**
     * Unloads one or more PRI files.
     * @param files The files you want unloaded.
     */
    unloadPriFiles(files: undefined.IIterable<undefined.IStorageFile>): void
}


/**
 * A collection of related resources, typically either for a particular app package, or a resource file for a particular package. 
 */
declare class ResourceMap {

    /**
     * Returns an iterator to enumerate the items in the map.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the set if the map is empty.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Returns a ResourceMap that represents a subtree of another ResourceMap, typically used to access a particular resource file within an app package.
     * @param reference A resource map identifier that identifies the root of the new subtree.
     * @return  The subtree ResourceMap .
     */
    getSubtree(reference: string): undefined.ResourceMap;

    /**
     * Returns the most appropriate candidate for a resource that is specified by a resource identifier for the supplied context.
     * @param resource A resource specified as a name or reference.
     * @param context The context for which to select the most appropriate candidate.
     * @return  A ResourceCandidate that describes the most appropriate candidate.
     */
    getValue(
        resource: string,
        context: undefined.ResourceContext): undefined.ResourceCandidate;

    /**
     * Returns the most appropriate candidate for a resource that is specified by a resource identifier within the default context.
     * @param resource A resource identifier specified as a name or reference.
     * @return  A ResourceCandidate that describes the most appropriate candidate.
     */
    getValue(resource: string): undefined.ResourceCandidate;

    /**
     * Determines whether the map can retrieve a resource with the specified resource identifier.
     * @param key The resource identifier to locate in the map.
     * @return  TRUE if the key is found, otherwise FALSE.
     */
    hasKey(key: string): boolean;

    /**
     * Returns the NamedResource at the specified resource identifier in the map.
     * @param key The resource identifier to use to locate the resource in the map.
     * @return  The NamedResource associated with the specified key.
     */
    lookup(key: string): undefined.NamedResource;

    /**
     * Gets the number of resources in the map. 
     */
    size: number;

    /**
     * Splits the map view into two views.
     */
    split(): {
        first: undefined.IMapView<string,
        undefined.NamedResource>,
        second: undefined.IMapView<string,
        undefined.NamedResource >
    };

    /**
     * Gets a URI that can be used to refer to this ResourceMap . 
     */
    uri: undefined.Uri
}


/**
 * Supports iteration over a ResourceMap . 
 */
declare class ResourceMapIterator {

    /**
     * Gets the current item in the ResourceMap . 
     */
    current: undefined.IKeyValuePair<string, undefined.NamedResource>;

    /**
     * Returns all the items in the ResourceMap .
     */
    getMany(): {
        items: undefined.IKeyValuePair<any,
        any>,
        returnValue: number
    };

    /**
     * Gets a value that indicates whether there is a current item, or whether the iterator is at the end of the ResourceMap . 
     */
    hasCurrent: boolean;

    /**
     * Moves the iterator forward to the next item and returns HasCurrent .
     * @return  TRUE if the iterator refers to a valid item that is in the map, and otherwise FALSE.
     */
    moveNext(): boolean
}


/**
 * An unchangeable view into a map of ResourceMap objects. 
 */
declare class ResourceMapMapView {

    /**
     * Returns an iterator to enumerate the items in the map view.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the map if the map is empty.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Determines whether the map view contains the specified key.
     * @param key The key to locate in the map view.
     * @return  TRUE if the key is found, otherwise FALSE if it is not found.
     */
    hasKey(key: string): boolean;

    /**
     * Returns the ResourceMap at the specified key in the map view.
     * @param key The key to locate in the map view.
     * @return  The ResourceMap associated with the specified key.
     */
    lookup(key: string): undefined.ResourceMap;

    /**
     * Gets the number of ResourceMap objects in the map. 
     */
    size: number;

    /**
     * Splits the map view into two views.
     */
    split(): {
        first: undefined.IMapView<string,
        undefined.ResourceMap>,
        second: undefined.IMapView<string,
        undefined.ResourceMap >
    }
}


/**
 * Supports iteration over a ResourceMapMapView object. 
 */
declare class ResourceMapMapViewIterator {

    /**
     * Gets the current item in the ResourceMapMapView . 
     */
    current: undefined.IKeyValuePair<string, undefined.ResourceMap>;

    /**
     * Returns all the items in the ResourceMapMapView .
     */
    getMany(): {
        items: undefined.IKeyValuePair<any,
        any>,
        returnValue: number
    };

    /**
     * Gets a value that indicates whether there is a current item, or whether the iterator is at the end of the ResourceMapMapView . 
     */
    hasCurrent: boolean;

    /**
     * Moves the iterator forward to the next item and returns HasCurrent .
     * @return  TRUE if the iterator refers to a valid item that is in the map view, and otherwise FALSE.
     */
    moveNext(): boolean
}


/**
 * Defines the qualifiers associated with a ResourceCandidate . 
 */
declare class ResourceQualifier {

    /**
     * Indicates whether this qualifier should be considered as a default match when no match is found. 
     */
    isDefault: boolean;

    /**
     * Indicates whether a given qualifier for a given candidate matched the context when a named resource is resolved to a candidate for some given context. 
     */
    isMatch: boolean;

    /**
     * The name of the qualifier. 
     */
    qualifierName: string;

    /**
     * The value of the qualifier. 
     */
    qualifierValue: string;

    /**
     * A score that indicates how well the qualifier matched the context against which it was resolved. 
     */
    score: number
}


/**
 * An unchangeable view into a map of ResourceQualifier objects. 
 */
declare class ResourceQualifierMapView {

    /**
     * Returns an iterator to enumerate the items in the map view.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the map view if the map view is empty.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Determines whether the map view contains the specified key.
     * @param key The key to locate in the map view.
     * @return  TRUE if the key is found, otherwise FALSE if it is not found.
     */
    hasKey(key: string): boolean;

    /**
     * Returns the qualifier name at the specified key in the map view.
     * @param key The key to locate in the map view.
     * @return  The qualifier name associated with the specified key.
     */
    lookup(key: string): string;

    /**
     * Gets the number of ResourceQualifier objects in the map. 
     */
    size: number;

    /**
     * Splits the map view into two views.
     */
    split(): {
        first: undefined.IMapView<string,
        string>,
        second: undefined.IMapView<string,
        string >
    }
}


/**
 * Notifies listeners of dynamic changes to a map of ResourceQualifier objects, such as when items get added or removed, and allows qualifier values to change. 
 */
declare class ResourceQualifierObservableMap {

    /**
     * Removes all items from the observable map. 
     */
    clear(): void;

    /**
     * Returns an iterator to enumerate the items in the observable map.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the observable map if the observable map is empty.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Returns an unchangeable view of the observable map.
     * @return  The view of the map.
     */
    getView(): undefined.IMapView<string, string>;

    /**
     * Determines whether the observable map contains the specified key.
     * @param key The key to locate in the observable map.
     * @return  TRUE if the key is found, otherwise FALSE if it is not found.
     */
    hasKey(key: string): boolean;

    /**
     * Inserts or replaces an item in the observable map.
     * @param key The key associated with the item to insert.
     * @param value The item to insert.
     * @return  TRUE if an item with the specified key is an existing item and was replaced, otherwise FALSE.
     */
    insert(key: string, value: string): boolean;

    /**
     * Returns the qualifier name at the specified key in the observable map.
     * @param key The key to locate in the observable map.
     * @return  The qualifier name associated with the specified key.
     */
    lookup(key: string): string;

    /**
     * Occurs when the map changes. 
     */
    onmapchanged: undefined.MapChangedEventHandler<string, string>;
    addEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, string>): void;
    removeEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, string>): void;

    /**
     * Removes an item from the observable map.
     * @param key The key associated with the item to remove.
     */
    remove(key: string): void;

    /**
     * Gets the number of ResourceQualifier objects in the observable map. 
     */
    size: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * An unchangeable view into a vector of ResourceQualifier objects. 
 */
declare class ResourceQualifierVectorView mixins Array<undefined.ResourceQualifier>{

    /**
     * Returns an iterator to enumerate the items in the view.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the view if the view is empty.
     */
    first(): undefined.IIterator<undefined.ResourceQualifier>;

    /**
     * Returns the ResourceQualifier at the specified index in the view.
     * @param index The zero-based index of the ResourceQualifier in the view to return.
     * @return  The ResourceQualifier at the specified index.
     */
    getAt(index: number): undefined.ResourceQualifier;

    /**
     * Returns the ResourceQualifier objects that start at the specified index in the view.
     * @param startIndex The zero-based index of the start of the objects in the view to return.
     */
    getMany(
        startIndex: number): {
        items: undefined.ResourceQualifier,
        returnValue: number
    };

    /**
     * Returns the index of a specified ResourceQualifier in the view.
     * @param value The ResourceQualifier to find in the set.
     */
    indexOf(value: undefined.ResourceQualifier): {
        index: number,
        returnValue: boolean
    };

    /**
     * Gets the number of ResourceQualifier objects in the view. 
     */
    size: number;
    indexOf(
        value: undefined.ResourceQualifier,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.ResourceQualifier, fromIndex?: number): number
}


/**
 * Structure that determines version and counts of resources returned for the app package. 
 */
declare interface Core$ResourceLayoutInfo {

    /**
     * Framework-generated checksum. 
     */
    checksum: number,

        /**
         * Major version of resources to be returned. 
         */
        majorVersion: number,

        /**
         * Minor version of resources to be returned. 
         */
        minorVersion: number,

        /**
         * Number of named resources to be returned. 
         */
        namedResourceCount: number,

        /**
         * Number of resource subtrees to be returned. 
         */
        resourceSubtreeCount: number
}




/**
 * Provides simplified access to app resources such as app UI strings. 
 */
declare class ResourceLoader {

    /**
     * Gets a ResourceLoader object for the Resources subtree of the currently running app's main ResourceMap . This ResourceLoader uses a default context associated with the current view.
     * @return  A resource loader for the Resources subtree of the currently running app's main ResourceMap .
     */
    getForCurrentView(): undefined.ResourceLoader;

    /**
     * Gets a ResourceLoader object for the specified ResourceMap . This ResourceLoader uses a default context associated with the current view.
     * @param name The resource identifier of the ResourceMap that the new resource loader uses for unqualified resource references. The loader can then retrieve resources relative to those references.
     * @return  A resource loader for the specified ResourceMap .
     */
    getForCurrentView(name: string): undefined.ResourceLoader;

    /**
     * Gets a ResourceLoader object for the specified ResourceMap . This ResourceLoader uses a default context that's not associated with any view.
     * @param name The resource identifier of the ResourceMap that the new resource loader uses for unqualified resource references. The loader can then retrieve resources relative to those references.
     * @return  A resource loader for the Resources subtree of the currently running app's main ResourceMap . This ResourceLoader uses a default context that's not associated with any view. You can't use this ResourceLoader to retrieve any resource that has resource candidates qualified for scale.
     */
    getForViewIndependentUse(name: string): undefined.ResourceLoader;

    /**
     * Gets a ResourceLoader object for the Resources subtree of the currently running app's main ResourceMap . This ResourceLoader uses a default context that's not associated with any view.
     * @return  A resource loader for the Resources subtree of the currently running app's main ResourceMap . This ResourceLoader uses a default context that's not associated with any view. You can't use this ResourceLoader to retrieve any resource that has resource candidates qualified for scale.
     */
    getForViewIndependentUse(): undefined.ResourceLoader;

    /**
     * Returns the most appropriate string value of a resource, specified as a Uri for a resource identifier, for the default ResourceContext of the currently running app.
     * @param uri A Uri that represents the resource to be retrieved.
     * @return  The most appropriate string value of the specified resource for the default ResourceContext .
     */
    getStringForReference(uri: undefined.Uri): string;

    /**
     * Constructs a new ResourceLoader object for the specified ResourceMap .
     * @param name The resource identifier of the ResourceMap that the new resource loader uses for unqualified resource references. It can then retrieve resources relative to those references.
     */
    constructor(name: string): this;

    /**
     * Constructs a new ResourceLoader object for the "Resources" subtree of the currently running app's main ResourceMap . 
     */
    constructor(): this;

    /**
     * Returns the most appropriate string value of a resource, specified by resource identifier, for the default ResourceContext of the view in which the ResourceLoader was obtained using ResourceLoader.GetForCurrentView .
     * @param resource The resource identifier of the resource to be resolved.
     * @return  The most appropriate string value of the specified resource for the default ResourceContext .
     */
    getString(resource: string): string;

    /**
     * Returns the most appropriate string value of a resource, specified by a Uniform Resource Identifier (URI) resource identifier, for the default ResourceContext of the currently running app.
     * @param uri A URI that represents the resource to be retrieved.
     * @return  The most appropriate string value of the specified resource for the default ResourceContext .
     */
    getStringForUri(uri: undefined.Uri): string
}


/**
 * Provides data for the RequestingFocusOnKeyboardInput event. 
 */
declare class RequestingFocusOnKeyboardInputEventArgs {}


/**
 * Enables access to the search suggestions that the SearchSuggestionManager provides. 
 */
declare class SearchSuggestion {

    /**
     * Gets the value that was passed to the detailText parameter of the AppendResultSuggestion method. 
     */
    detailText: string;

    /**
     * Gets the value that was passed to the image parameter of the AppendResultSuggestion method. 
     */
    image: undefined.IRandomAccessStreamReference;

    /**
     * Gets the value that was passed to the imageAlternateText parameter of the AppendResultSuggestion method. 
     */
    imageAlternateText: string;

    /**
     * Gets the type of suggestion. 
     */
    kind: undefined.SearchSuggestionKind;

    /**
     * Gets the value that was passed to the tag parameter of the AppendResultSuggestion method. 
     */
    tag: string;

    /**
     * Gets the localized text of the suggestion for display in the search suggestions UI. 
     */
    text: string
}


/**
 * Manages access to search suggestions for the in-app SearchBox control. 
 */
declare class SearchSuggestionManager {

    /**
     * Initializes a new instance of the SearchSuggestionManager class. 
     */
    constructor(): this;

    /**
     * Stores the specified query and input language in the search history.
     * @param queryText The query.
     * @param language The input language. The input language ensures that the query string is displayed in the search history for the correct language.
     */
    addToHistory(queryText: string, language: string): void;

    /**
     * Stores the specified query in the search history.
     * @param queryText The query.
     */
    addToHistory(queryText: string): void;

    /**
     * Clears all search history contexts for the current app. 
     */
    clearHistory(): void;

    /**
     * Raised when the user presses a key that initiates type-to-search. 
     */
    onrequestingfocusonkeyboardinput: undefined.TypedEventHandler<undefined.SearchSuggestionManager, undefined.RequestingFocusOnKeyboardInputEventArgs>;
    addEventListener(
        type: "requestingfocusonkeyboardinput",
        listener: undefined.TypedEventHandler<undefined.SearchSuggestionManager, undefined.RequestingFocusOnKeyboardInputEventArgs>): void;
    removeEventListener(
        type: "requestingfocusonkeyboardinput",
        listener: undefined.TypedEventHandler<undefined.SearchSuggestionManager, undefined.RequestingFocusOnKeyboardInputEventArgs>): void;

    /**
     * Raised when the user's query text changes and the app needs to provide new suggestions to display in the search box. 
     */
    onsuggestionsrequested: undefined.TypedEventHandler<undefined.SearchSuggestionManager, undefined.SearchSuggestionsRequestedEventArgs>;
    addEventListener(
        type: "suggestionsrequested",
        listener: undefined.TypedEventHandler<undefined.SearchSuggestionManager, undefined.SearchSuggestionsRequestedEventArgs>): void;
    removeEventListener(
        type: "suggestionsrequested",
        listener: undefined.TypedEventHandler<undefined.SearchSuggestionManager, undefined.SearchSuggestionsRequestedEventArgs>): void;

    /**
     * Identifies the context of the search and is used to store the user's search history with the app. 
     */
    searchHistoryContext: string;

    /**
     * Indicates whether the user's previous searches with the app are automatically tracked and used to provide suggestions. 
     */
    searchHistoryEnabled: boolean;

    /**
     * Specifies whether suggestions based on local files are added automatically to the Suggestions collection, and defines the criteria that Windows uses to locate and filter these suggestions.
     * @param settings The new settings for local content suggestions.
     */
    setLocalContentSuggestionSettings(settings: undefined.LocalContentSuggestionSettings): void;

    /**
     * Assigns the current search query with the specified input language and Input Method Editor (IME) info.
     * @param queryText The query.
     * @param language The input language.
     * @param linguisticDetails Info about the query text that the user enters through an IME.
     */
    setQuery(
        queryText: string,
        language: string,
        linguisticDetails: undefined.SearchQueryLinguisticDetails): void;

    /**
     * Assigns the current search query.
     * @param queryText The query.
     */
    setQuery(queryText: string): void;

    /**
     * Assigns the current search query with the specified input language.
     * @param queryText The query.
     * @param language The input language.
     */
    setQuery(queryText: string, language: string): void;

    /**
     * Gets the search suggestions for the current search query. 
     */
    suggestions: undefined.IObservableVector<undefined.SearchSuggestion>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the SuggestionsRequested event. 
 */
declare class SearchSuggestionsRequestedEventArgs {

    /**
     * Gets the Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device. 
     */
    language: string;

    /**
     * Gets an object that provides linguistic information about query text that the user is entering through an Input Method Editor (IME). 
     */
    linguisticDetails: undefined.SearchQueryLinguisticDetails;

    /**
     * The text that the app should provide suggestions for and that was in the search box when the SuggestionsRequested event was raised. 
     */
    queryText: string;

    /**
     * Gets an object that stores suggestions and information about the request. 
     */
    request: undefined.SearchSuggestionsRequest
}


/**
 * Stores settings that determine whether the app provides suggestions based on local files, and that define the criteria used to locate and filter these suggestions. 
 */
declare class LocalContentSuggestionSettings {

    /**
     * Creates a new instance of the localContentSuggestionSettings class. 
     */
    constructor(): this;

    /**
     * An Advanced Query Syntax (AQS) string that limits the types and kinds of files that are used to provide suggestions. If no AQS string is specified, suggestions are provided from all local files in locations specified by the locations property. 
     */
    aqsFilter: string;

    /**
     * Indicates whether suggestions based on local files are displayed in the search pane. 
     */
    enabled: boolean;

    /**
     * A list of the storageFolder objects that contain files that are used to provide suggestions. If the list is empty, suggestions are provided from files in all of the local libraries for which the app declared capabilities. 
     */
    locations: undefined.IVector<undefined.StorageFolder>;

    /**
     * A list of the file properties whose values are used to provide suggestions from local files. If the list is empty, all of the file properties that are available for suggestions are used. 
     */
    propertiesToMatch: undefined.IVector<string >
}


/**
 * Represents and manages the search pane that opens when a user activates the Search charm. The search pane provides a consistent, touch-friendly search box and optional search suggestions. 
 */
declare class SearchPane {

    /**
     * Retrieves an instance of the search pane from which users can search within the app.
     * @return  An instance of the search pane, which provides a consistent, touch-friendly search box and optional search suggestions for searching within the current application.
     */
    getForCurrentView(): undefined.SearchPane;

    /**
     * Hides the current app's UI. 
     */
    hideThisApplication(): void;

    /**
     * The Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device. 
     */
    language: string;

    /**
     * Fires when the user changes the text in the search box. 
     */
    onquerychanged: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneQueryChangedEventArgs>;
    addEventListener(
        type: "querychanged",
        listener: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneQueryChangedEventArgs>): void;
    removeEventListener(
        type: "querychanged",
        listener: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneQueryChangedEventArgs>): void;

    /**
     * Fires when the user submits the text in the search box and the app needs to display search results. 
     */
    onquerysubmitted: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneQuerySubmittedEventArgs>;
    addEventListener(
        type: "querysubmitted",
        listener: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneQuerySubmittedEventArgs>): void;
    removeEventListener(
        type: "querysubmitted",
        listener: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneQuerySubmittedEventArgs>): void;

    /**
     * Fires when the user selects one of the suggested results that was provided by the app and displayed in the search pane. 
     */
    onresultsuggestionchosen: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneResultSuggestionChosenEventArgs>;
    addEventListener(
        type: "resultsuggestionchosen",
        listener: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneResultSuggestionChosenEventArgs>): void;
    removeEventListener(
        type: "resultsuggestionchosen",
        listener: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneResultSuggestionChosenEventArgs>): void;

    /**
     * Fires when the user's query text changes and the app needs to provide new suggestions to display in the search pane. 
     */
    onsuggestionsrequested: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneSuggestionsRequestedEventArgs>;
    addEventListener(
        type: "suggestionsrequested",
        listener: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneSuggestionsRequestedEventArgs>): void;
    removeEventListener(
        type: "suggestionsrequested",
        listener: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneSuggestionsRequestedEventArgs>): void;

    /**
     * Fires when the user opens or closes the search pane. 
     */
    onvisibilitychanged: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneVisibilityChangedEventArgs>;
    addEventListener(
        type: "visibilitychanged",
        listener: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneVisibilityChangedEventArgs>): void;
    removeEventListener(
        type: "visibilitychanged",
        listener: undefined.TypedEventHandler<undefined.SearchPane, undefined.SearchPaneVisibilityChangedEventArgs>): void;

    /**
     * The placeholder text in the search box when the user hasn't entered any characters. 
     */
    placeholderText: string;

    /**
     * The current text in the search box of the search pane. 
     */
    queryText: string;

    /**
     * A string that identifies the context of the search and is used to store the user's search history with the app. 
     */
    searchHistoryContext: string;

    /**
     * Indicates whether the user's previous searches with the app are automatically tracked and used to provide suggestions. 
     */
    searchHistoryEnabled: boolean;

    /**
     * Specifies whether suggestions based on local files are automatically displayed in the search pane, and defines the criteria that Windows uses to locate and filter these suggestions.
     * @param settings The new settings for local content suggestions.
     */
    setLocalContentSuggestionSettings(settings: undefined.LocalContentSuggestionSettings): void;

    /**
     * Shows the search pane. 
     */
    show(): void;

    /**
     * Shows the search pane with the specified initial query string.
     * @param query The initial query string.
     */
    show(query: string): void;

    /**
     * Gets or sets whether the user can open the search pane by typing. 
     */
    showOnKeyboardInput: boolean;

    /**
     * Attempts to set the text in the search box of the search pane.
     * @param query The query text to show in the search pane's search box.
     * @return  True if the search box text was set successfully. Otherwise, false.
     */
    trySetQueryText(query: string): boolean;

    /**
     * Indicates whether the search pane is open. 
     */
    visible: boolean;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for a querychanged event that is associated with a searchPane object. 
 */
declare class SearchPaneQueryChangedEventArgs {

    /**
     * The Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device. 
     */
    language: string;

    /**
     * An object that provides linguistic information about query text that the user is entering through an Input Method Editor (IME). 
     */
    linguisticDetails: undefined.SearchPaneQueryLinguisticDetails;

    /**
     * The text in the search box when the querychanged event fired. 
     */
    queryText: string
}


/**
 * Provides information about query text that the user enters through an Input Method Editor (IME). 
 */
declare class SearchPaneQueryLinguisticDetails {

    /**
     * A list of the text alternatives for the current query text. These alternatives account for uncomposed text the user is entering in an IME. 
     */
    queryTextAlternatives: undefined.IVectorView<string>;

    /**
     * The length of the portion of the query text that the user is composing with an Input Method Editor (IME). 
     */
    queryTextCompositionLength: number;

    /**
     * The starting location of the text that the user is composing with an Input Method Editor (IME). 
     */
    queryTextCompositionStart: number
}


/**
 * Provides data for a querysubmitted event that is associated with a searchPane instance. 
 */
declare class SearchPaneQuerySubmittedEventArgs {

    /**
     * The Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device. 
     */
    language: string;

    /**
     * An object that provides linguistic information about query text that the user is entering through an Input Method Editor (IME). 
     */
    linguisticDetails: undefined.SearchPaneQueryLinguisticDetails;

    /**
     * The text that was submitted through the search pane. 
     */
    queryText: string
}


/**
 * Provides data for a resultsuggestionchosen event that is associated with a searchPane object. 
 */
declare class SearchPaneResultSuggestionChosenEventArgs {

    /**
     * The tag for the suggested result that the user selected. 
     */
    tag: string
}


/**
 * Stores suggestions and information about the request for suggestions. 
 */
declare class SearchPaneSuggestionsRequest {

    /**
     * Retrieves an object that lets an app respond to a request for suggestions asynchronously.
     * @return  An object that lets an app signal when it has fulfilled the request for search suggestions.
     */
    getDeferral(): undefined.SearchPaneSuggestionsRequestDeferral;

    /**
     * Indicates whether the request for suggestions to display is canceled. 
     */
    isCanceled: boolean;

    /**
     * The suggestions to display in the search pane for the current query. Apps provide suggestions to display by appending them to this searchSuggestionCollection object. 
     */
    searchSuggestionCollection: undefined.SearchSuggestionCollection
}


/**
 * Enables the app to signal when it has finished populating a searchSuggestionCollection object while handling the suggestionsrequested event. Apps should use a deferral if and only if they need to respond to a request for suggestions asynchronously. 
 */
declare class SearchPaneSuggestionsRequestDeferral {

    /**
     * Signals that the app has finished populating a searchSuggestionCollection object while handling the suggestionsrequested event. 
     */
    complete(): void
}


/**
 * Provides data for a suggestionsrequested event that is associated with a searchPane object. 
 */
declare class SearchPaneSuggestionsRequestedEventArgs {

    /**
     * The Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device. 
     */
    language: string;

    /**
     * An object that provides linguistic information about query text that the user is entering through an Input Method Editor (IME). 
     */
    linguisticDetails: undefined.SearchPaneQueryLinguisticDetails;

    /**
     * The text that the app should provide suggestions for and that was in the search box when the suggestionsrequested event fired. 
     */
    queryText: string;

    /**
     * An object that stores suggestions and information about the request. 
     */
    request: undefined.SearchPaneSuggestionsRequest
}


/**
 * Provides data for a visibilitychanged event that is associated with a searchPane object. 
 */
declare class SearchPaneVisibilityChangedEventArgs {

    /**
     * Indicates whether the search pane is open. 
     */
    visible: boolean
}


/**
 * Provides information about query text that the user enters through an Input Method Editor (IME). 
 */
declare class SearchQueryLinguisticDetails {

    /**
     * Initializes a new instance of the SearchQueryLinguisticDetails class.
     * @param queryTextAlternatives A list of the text alternatives for the current query text.
     * @param queryTextCompositionStart The starting location of the text that the user is composing with an IME.
     * @param queryTextCompositionLength The length of the portion of the query text that the user is composing with an IME.
     */
    constructor(queryTextAlternatives: undefined.IIterable<string>, queryTextCompositionStart: number, queryTextCompositionLength: number): this;

    /**
     * A list of the text alternatives for the current query text. These alternatives account for uncomposed text the user is entering in an IME. 
     */
    queryTextAlternatives: undefined.IVectorView<string>;

    /**
     * The length of the portion of the query text that the user is composing with an Input Method Editor (IME). 
     */
    queryTextCompositionLength: number;

    /**
     * The starting location of the text that the user is composing with an Input Method Editor (IME). 
     */
    queryTextCompositionStart: number
}


/**
 * Represents a collection of search suggestions to be displayed in the search pane in response to a suggestionsrequested event. 
 */
declare class SearchSuggestionCollection {

    /**
     * Appends a query suggestion to the list of search suggestions for the search pane.
     * @param text The text of the query suggestion.
     */
    appendQuerySuggestion(text: string): void;

    /**
     * Appends a list of query suggestions to the list of search suggestions for the search pane.
     * @param suggestions The list of query suggestions.
     */
    appendQuerySuggestions(suggestions: undefined.IIterable<string>): void;

    /**
     * Appends a suggested search result to the list of suggestions to display in the search pane.
     * @param text The text of the suggested result.
     * @param detailText The detail text for the suggested result.
     * @param tag The unique tag that identifies this suggested result.
     * @param image The image to accompany the results suggestion.
     * @param imageAlternateText The alternate text for the image.
     */
    appendResultSuggestion(
        text: string,
        detailText: string,
        tag: string,
        image: undefined.IRandomAccessStreamReference,
        imageAlternateText: string): void;

    /**
     * Appends a text label that is used to separate groups of suggestions in the search pane.
     * @param label The text to use as a separator. This text should be descriptive of any suggestions that are appended after it.
     */
    appendSearchSeparator(label: string): void;

    /**
     * The number of suggestions in the collection. 
     */
    size: number
}


/**
 * Stores suggestions and information about the request for suggestions. 
 */
declare class SearchSuggestionsRequest {

    /**
     * Gets an object that lets an app respond to a request for suggestions asynchronously.
     * @return  An object that lets an app signal when it has fulfilled the request for search suggestions.
     */
    getDeferral(): undefined.SearchSuggestionsRequestDeferral;

    /**
     * Indicates whether the request for suggestions to display is canceled. 
     */
    isCanceled: boolean;

    /**
     * The suggestions to display in the search pane or in-app search box for the current query. Apps provide suggestions to display by appending them to this SearchSuggestionCollection object. 
     */
    searchSuggestionCollection: undefined.SearchSuggestionCollection
}


/**
 * Enables the app to signal when it has finished populating a SearchSuggestionCollection object while handling the SuggestionsRequested event. Use a deferral if and only if your app needs to respond to a request for suggestions asynchronously. 
 */
declare class SearchSuggestionsRequestDeferral {

    /**
     * Signals that the app has finished populating a SearchSuggestionCollection object while handling the SuggestionsRequested event. 
     */
    complete(): void
}


/**
 * Defines methods and properties you can use to get license and listing info about the current app and perform in-app product purchases. 
 */
declare class CurrentApp {

    /**
     * Gets the GUID generated by the Windows Store when your app has been certified for listing in the Windows Store. 
     */
    appId: string;

    /**
     * Retrieves the promotion campaign ID for the current app.
     * @return  The advertising campaign ID for your app.
     */
    getAppPurchaseCampaignIdAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Requests all receipts for the purchase of the app and any in-app products. For examples of how receipt information can be used, see Using receipts to verify product purchases.
     * @return  An XML-formatted string that contains all receipt information for the purchase of the app and any in-app products.
     */
    getAppReceiptAsync(): undefined.IPromiseWithIAsyncOperation<string>;
    getCustomerCollectionsIdAsync: any;
    getCustomerPurchaseIdAsync: any;

    /**
     * Requests the receipt for the productId specified. For examples of how receipt information can be used, see Using receipts to verify product purchases.
     * @param productId The unique identifier for the product that you specified this identifier when you submitted the app to the Windows Store
     * @return  An XML-formatted string that contains the receipt for the specified productId.
     */
    getProductReceiptAsync(productId: string): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Returns a list of purchased consumable in-app products that have not been reported to the Windows Store as fulfilled.
     * @return  When the operation completes, a list of consumable in-app products not yet reported as fulfilled is returned ( UnfulfilledConsumable objects). Each item of this list provides the product ID, offer ID, and transaction ID associated with a product.
     */
    getUnfulfilledConsumablesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the license metadata for the current app. 
     */
    licenseInformation: undefined.LicenseInformation;

    /**
     * Gets the Uniform Resource Identifier (URI) of the app's listing page in the web catalog of the Windows Store. 
     */
    linkUri: undefined.Uri;

    /**
     * Loads the app's listing information asynchronously. Implements the IAsyncInfo interface.
     * @return  The apps' listing information. If the method fails, it returns an HRESULT error code.
     */
    loadListingInformationAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ListingInformation>;

    /**
     * Windows Phone only. Loads the app listing information asynchronously, returning features and products in the ProductListings collection that match all supplied keywords. Implements the IAsyncInfo interface.
     * @param keywords The list of keywords by which to filter the ProductListings collection that is returned in the ListingInformation object.
     * @return  The app's listing information, with ProductListings collection filtered by keywords. If the method fails, it returns an HRESULT error code. If no products or features are found that match all of the given keywords, the ProductListings collection will be empty.
     */
    loadListingInformationByKeywordsAsync(
        keywords: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.ListingInformation>;

    /**
     * Windows Phone only. Loads the app listing information asynchronously, returning features and products in the ProductListings collection that match any of the given products IDs. Implements the IAsyncInfo interface.
     * @param productIds The list of product IDs by which to filter the ProductListings collection.
     * @return  The app's listing information, with ProductListings collection filtered by product IDs. If the method fails, it returns an HRESULT error code. If no products or features are found that match the given product IDs, the ProductListings collection will be empty.
     */
    loadListingInformationByProductIdsAsync(
        productIds: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.ListingInformation>;

    /**
     * Notifies the Windows Store that the purchase of a consumable is fulfilled and that the user has the right to access the content.
     * @param productId Identifies the consumable.
     * @param transactionId Identifies a transaction that includes the purchase of the consumable ( productId).
     * @return  A value that indicates the status of fulfillment for a consumable in-app product. Possible values are defined by the FulfillmentResult enumeration.
     */
    reportConsumableFulfillmentAsync(
        productId: string,
        transactionId: string): undefined.IPromiseWithIAsyncOperation<undefined.FulfillmentResult>;

    /**
     * Notifies the Windows Store that the application has fulfilled the in-app product. This product cannot be re-purchased until the app has confirmed fulfillment using this method.
     * @param productId The ID of the product that has been delivered to the user.
     */
    reportProductFulfillment(productId: string): void;

    /**
     * Requests the purchase of a full app license.
     * @param includeReceipt Determines if this method should return the receipts for this app.
     * @return  If the includeReceipt parameter is set to true, this string contains XML that represents all receipts for the app and any in-app purchases. If includeReceipt is set to false, this string is empty.
     */
    requestAppPurchaseAsync(includeReceipt: boolean): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Requests the purchase of an in-app product. Additionally, calling this method displays the UI that is used to complete the transaction via the Windows Store.
     * @param productId Specifies the id of the in-app product.
     * @return  The results of the in-app product purchase request.
     */
    requestProductPurchaseAsync(
        productId: string): undefined.IPromiseWithIAsyncOperation<undefined.PurchaseResults>;

    /**
     * Requests the purchase of an in-app product. Additionally, calling this method displays the UI that is used to complete the transaction via the Windows Store.
     * @param productId Specifies the id of the in-app product.
     * @param offerId The specific in-app feature or content within the large purchase catalog represented on the Windows Store by the productId. This value correlates with the content your app is responsible for fulfilling. The Windows Store only uses this value to itemize the PurchaseResults .
     * @param displayProperties The name of the app feature or content offer that is displayed to the user at time of purchase.
     * @return  The results of the in-app product purchase request.
     */
    requestProductPurchaseAsync(
        productId: string,
        offerId: string,
        displayProperties: undefined.ProductPurchaseDisplayProperties): undefined.IPromiseWithIAsyncOperation<undefined.PurchaseResults>;

    /**
     * Requests the purchase of an in-app product. Additionally, calling this method displays the UI that is used to complete the transaction via the Windows Store.
     * @param productId Specifies the id of the in-app product.
     * @param includeReceipt Determines if the method should return the receipts for the specified productId.
     * @return  A string providing in-app transaction details for the provided productId. If includeReceipt is set true, the returned string will include a full receipt xml.
     */
    requestProductPurchaseAsync(
        productId: string,
        includeReceipt: boolean): undefined.IPromiseWithIAsyncOperation<string >
}


/**
 * Defines methods and properties used to instantiate an object that you can use to get simulated license info during testing. 
 */
declare class CurrentAppSimulator {

    /**
     * Gets a simulated app ID. Since CurrentAppSimulator is intended only for testing during app development, the returned CurrentAppSimulator.AppId will contain only 0's. 
     */
    appId: string;

    /**
     * Retrieves the promotion campaign ID for the current app.
     * @return  The advertising campaign ID for your app.
     */
    getAppPurchaseCampaignIdAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Creates the async operation that the user can use to simulate requesting all receipts for this app and any in-app product purchases. For examples of how receipt information can be used, see Using receipts to verify product purchases.
     * @return  An XML-formatted string that contains all receipts for this app and any in-app product purchases.
     */
    getAppReceiptAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Creates the async operation that the user can use to simulate requesting the receipt for the specified productId. For examples of how receipt information can be used, see Using receipts to verify product purchases.
     * @param productId The unique identifier for the product. This ID is that was specified when the product was submitted for the app to the Store.
     * @return  An XML-formatted string that contains the receipt for the specified productId.
     */
    getProductReceiptAsync(productId: string): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Returns a list of purchased consumable in-app products that have not been fulfilled locally.
     * @return  When the operation completes, a list of unfulfilled consumable in-app products ( UnfulfilledConsumable objects) is returned. Each item in this list provides the product ID, offer ID, and transaction ID associated with a product.
     */
    getUnfulfilledConsumablesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the simulated license metadata for the current app as provided by the simulation. 
     */
    licenseInformation: undefined.LicenseInformation;

    /**
     * Gets the simulated Uniform Resource Identifier (URI) that represents a Windows Store listing page for the current app. 
     */
    linkUri: undefined.Uri;

    /**
     * Loads the simulated app listing information asynchronously. Implements the IAsyncInfo interface.
     * @return  The app listing information as defined by the simulation. If the method fails, it returns an HRESULT error code.
     */
    loadListingInformationAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ListingInformation>;

    /**
     * Windows Phone only. Loads the simulated app listing information asynchronously, returning in-app products in the ProductListings collection that match all supplied keywords. Implements the IAsyncInfo interface.
     * @param keywords The list of keywords by which to filter the ProductListings collection that is returned in the ListingInformation object.
     * @return  The simulated app listing information, with ProductListings collection filtered by keywords. If the method fails, it returns an HRESULT error code. If no in-app products are found that match all of the given keywords, the ProductListings collection will be empty.
     */
    loadListingInformationByKeywordsAsync(
        keywords: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.ListingInformation>;

    /**
     * Windows Phone only. Loads the simulated app listing information asynchronously, returning available in-app products in the ProductListings collection that match any of the given products IDs. This method implements the IAsyncInfo interface.
     * @param productIds The list of product IDs by which to filter the ProductListings collection.
     * @return  The simulated app listing information, with ProductListings collection filtered by product IDs. If the method fails, it returns an HRESULT error code. If no in-app products are found that match the given product IDs, the ProductListings collection will be empty.
     */
    loadListingInformationByProductIdsAsync(
        productIds: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.ListingInformation>;

    /**
     * Reloads the simulator using a StorageFile containing the WindowsStoreProxy.xml file.
     * @param simulatorSettingsFile The WindowsStoreProxy.xml file that the simulator uses. For more information, see CurrentAppSimulator .
     * @return  The async operation that reloads the simulator.
     */
    reloadSimulatorAsync(
        simulatorSettingsFile: undefined.StorageFile): undefined.IPromiseWithIAsyncAction;

    /**
     * Simulates notifying the Windows Store that the purchase of a consumable in-app product is fulfilled and that the user has the right to access the content.
     * @param productId Identifies the consumable in-app product.
     * @param transactionId Identifies a simulated transaction that includes the purchase of the consumable in-app product ( productId).
     * @return  A value that indicates the status of fulfillment for a simulated consumable in-app product purchase.
     */
    reportConsumableFulfillmentAsync(
        productId: string,
        transactionId: string): undefined.IPromiseWithIAsyncOperation<undefined.FulfillmentResult>;

    /**
     * Creates the async operation that simulates a user request to buy a full license for the current app.
     * @param includeReceipt Determines if the method should return the receipts for this app.
     * @return  If the includeReceipt parameter is set to true, this string contains XML that represents all receipts for the app and any in-app product purchases. If includeReceipt is set to false, this string is empty.
     */
    requestAppPurchaseAsync(includeReceipt: boolean): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Creates the async operation that displays the UI that is used to simulate the purchase of in-app product from the Windows Store.
     * @param productId Specifies the id, as defined by the simulation, of the in-app product to buy.
     * @return  A PurchaseResults object containing transaction details for the provided productId.
     */
    requestProductPurchaseAsync(
        productId: string): undefined.IPromiseWithIAsyncOperation<undefined.PurchaseResults>;

    /**
     * Creates the async operation that displays the UI that is used to simulate the purchase of an in-app product from the Windows Store.
     * @param productId The product ID used for listing in the Windows Store.
     * @param offerId The specific in-app product within the large purchase catalog represented on the Windows Store by the productId. This value correlates with the content your app is responsible for fulfilling. The Windows Store only uses this parameter value to itemize the PurchaseResults .
     * @param displayProperties The name of the in-app product that is displayed to the user at time of purchase.
     * @return  The results of the in-app product purchase.
     */
    requestProductPurchaseAsync(
        productId: string,
        offerId: string,
        displayProperties: undefined.ProductPurchaseDisplayProperties): undefined.IPromiseWithIAsyncOperation<undefined.PurchaseResults>;

    /**
     * Creates the async operation that displays the UI that is used to simulate the purchase of an in-app product from the Windows Store.
     * @param productId Specifies the id, as defined by the simulation, of the in-app product to buy.
     * @param includeReceipt Determines if the method should return the receipts for the specified productId.
     * @return  A string providing in-app product purchase details for the provided productId. If includeReceipt is set true, the returned string will include a full receipt xml.
     */
    requestProductPurchaseAsync(
        productId: string,
        includeReceipt: boolean): undefined.IPromiseWithIAsyncOperation<string >
}


/**
 * Provides access to the current app's license metadata. 
 */
declare class LicenseInformation {

    /**
     * Gets the license expiration date and time relative to the system clock. 
     */
    expirationDate: Date;

    /**
     * Gets a value that indicates whether the license is active. 
     */
    isActive: boolean;

    /**
     * Gets a value that indicates whether the license is a trial license. 
     */
    isTrial: boolean;

    /**
     * Raises a notification event when the status of the app's license changes. 
     */
    onlicensechanged: undefined.LicenseChangedEventHandler;
    addEventListener(type: "licensechanged", listener: undefined.LicenseChangedEventHandler): void;
    removeEventListener(type: "licensechanged", listener: undefined.LicenseChangedEventHandler): void;

    /**
     * Gets the associative list of licenses for in-app products that a user is currently entitled to. 
     */
    productLicenses: undefined.IMapView<string, undefined.ProductLicense>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides the listing info that describes the app in the Windows Store. 
 */
declare class ListingInformation {

    /**
     * Gets the age rating for the app. 
     */
    ageRating: number;
    currencyCode: any;

    /**
     * Gets the country code associated with the user's location, such as US or CA, that is used to identify their market for transactions in the current session. 
     */
    currentMarket: string;

    /**
     * Gets the app's description in the current market. 
     */
    description: string;
    formattedBasePrice: any;

    /**
     * Gets the app's purchase price formatted for the current market and currency. 
     */
    formattedPrice: string;
    isOnSale: any;

    /**
     * Gets the app's name in the current market. 
     */
    name: string;

    /**
     * Gets information about in-app products available for purchase. 
     */
    productListings: undefined.IMapView<string, undefined.ProductListing>;
    saleEndDate: any
}


/**
 * Represents an app that is in the installation queue. 
 */
declare class AppInstallItem {

    /**
     * Cancels the installation of the current app. 
     */
    cancel(): void;

    /**
     * Cancels the installation of the current app, with the option to generate telemetry data.
     * @param correlationVector A correlation vector string that can be used to generate telemetry data.
     */
    cancel(correlationVector: string): void;

    /**
     * Gets the installation status of the current app.
     * @return  A value that specifies the installation status of the current app.
     */
    getCurrentStatus(): undefined.AppInstallStatus;

    /**
     * Gets the type of the current app install. 
     */
    installType: undefined.AppInstallType;

    /**
     * Indicates whether the current app install was initiated by the user. 
     */
    isUserInitiated: boolean;

    /**
     * Occurs when the installation of the current app has finished. 
     */
    oncompleted: undefined.TypedEventHandler<undefined.AppInstallItem, any>;
    addEventListener(
        type: "completed",
        listener: undefined.TypedEventHandler<undefined.AppInstallItem, any>): void;
    removeEventListener(
        type: "completed",
        listener: undefined.TypedEventHandler<undefined.AppInstallItem, any>): void;

    /**
     * Occurs when the installation status of the current app has changed. 
     */
    onstatuschanged: undefined.TypedEventHandler<undefined.AppInstallItem, any>;
    addEventListener(
        type: "statuschanged",
        listener: undefined.TypedEventHandler<undefined.AppInstallItem, any>): void;
    removeEventListener(
        type: "statuschanged",
        listener: undefined.TypedEventHandler<undefined.AppInstallItem, any>): void;

    /**
     * Gets the package family name for the current app. 
     */
    packageFamilyName: string;

    /**
     * Pauses the installation of the current app. 
     */
    pause(): void;

    /**
     * Pauses the installation of the current app, with the option to generate telemetry data.
     * @param correlationVector A correlation vector string that can be used to generate telemetry data.
     */
    pause(correlationVector: string): void;

    /**
     * Gets the product ID for the current app. 
     */
    productId: string;

    /**
     * Restarts the installation of the current app. 
     */
    restart(): void;

    /**
     * Restarts the installation of the current app, with the option to generate telemetry data.
     * @param correlationVector A correlation vector string that can be used to generate telemetry data.
     */
    restart(correlationVector: string): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides members for programmatically installing apps, including the ability to start an app install and get a list of app installs currently in progress. 
 */
declare class AppInstallManager {

    /**
     * Creates and initializes a new instance of the AppInstallManager class 
     */
    constructor(): this;

    /**
     * Gets or sets the user identity associated with the app installs. 
     */
    acquisitionIdentity: string;

    /**
     * Retrieves information about all apps that are currently in the installation queue. 
     */
    appInstallItems: undefined.IVectorView<undefined.AppInstallItem>;

    /**
     * Gets or sets the auto update setting for apps on the current computer or device. 
     */
    autoUpdateSetting: undefined.AutoUpdateSetting;

    /**
     * Cancels the installation of the specified app.
     * @param productId The product ID of the app whose installation should be canceled.
     */
    cancel(productId: string): void;

    /**
     * Cancels the installation of the specified app, with the option to generate telemetry data.
     * @param productId The product ID of the app whose installation should be canceled.
     * @param correlationVector A correlation vector string that can be used to generate telemetry data.
     */
    cancel(productId: string, correlationVector: string): void;

    /**
     * Determines whether the specified app has permission to install on the current computer or device.
     * @param productId The product ID of the app that this method will check to determine if it has permission to be installed.
     * @return  An asynchronous operation that, on successful completion, returns true if the app has permission to be installed; otherwise false.
     */
    getIsAppAllowedToInstallAsync(productId: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Determines whether the specified app has permission to install on the current computer or device, with the option to generate telemetry data.
     * @param productId The product ID of the app that this method will check to determine if it has permission to be installed.
     * @param skuId The SKU ID of the app that this method will check to determine if it has permission to be installed.
     * @param catalogId The catalog ID of the app that this method will check to determine if it has permission to be installed.
     * @param correlationVector A correlation vector string that can be used to generate telemetry data.
     * @return  An asynchronous operation that, on successful completion, returns true if the app has permission to be installed; otherwise false.
     */
    getIsAppAllowedToInstallAsync(
        productId: string,
        skuId: string,
        catalogId: string,
        correlationVector: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Determines whether the specified app can be installed on the current computer or device.
     * @param productId The product ID of the app that this method will check to determine if it can be installed.
     * @param skuId The SKU ID of the app that this method will check to determine if it can be installed.
     * @return  An asynchronous operation that, on successful completion, returns true if the app can be installed; otherwise false.
     */
    getIsApplicableAsync(
        productId: string,
        skuId: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Determines whether the specified app is blocked by policy on the current computer or device.
     * @param storeClientName The name of the app that this method will check to determine if is blocked by policy.
     * @param storeClientPublisher The publisher name of the app that this method will check to determine if is blocked by policy.
     * @return  An asynchronous operation that, on successful completion, returns true if the app can be installed; otherwise false.
     */
    isStoreBlockedByPolicyAsync(
        storeClientName: string,
        storeClientPublisher: string): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Occurs when an app has finished installing. 
     */
    onitemcompleted: undefined.TypedEventHandler<undefined.AppInstallManager, undefined.AppInstallManagerItemEventArgs>;
    addEventListener(
        type: "itemcompleted",
        listener: undefined.TypedEventHandler<undefined.AppInstallManager, undefined.AppInstallManagerItemEventArgs>): void;
    removeEventListener(
        type: "itemcompleted",
        listener: undefined.TypedEventHandler<undefined.AppInstallManager, undefined.AppInstallManagerItemEventArgs>): void;

    /**
     * Occurs when the status of an app in the installation queue has changed. 
     */
    onitemstatuschanged: undefined.TypedEventHandler<undefined.AppInstallManager, undefined.AppInstallManagerItemEventArgs>;
    addEventListener(
        type: "itemstatuschanged",
        listener: undefined.TypedEventHandler<undefined.AppInstallManager, undefined.AppInstallManagerItemEventArgs>): void;
    removeEventListener(
        type: "itemstatuschanged",
        listener: undefined.TypedEventHandler<undefined.AppInstallManager, undefined.AppInstallManagerItemEventArgs>): void;

    /**
     * Pauses the installation of the specified app.
     * @param productId The product ID of the app whose installation should be paused.
     */
    pause(productId: string): void;

    /**
     * Pauses the installation of the specified app, with the option to generate telemetry data.
     * @param productId The product ID of the app whose installation should be paused.
     * @param correlationVector A correlation vector string that can be used to generate telemetry data.
     */
    pause(productId: string, correlationVector: string): void;

    /**
     * Restarts the installation of the specified app.
     * @param productId The product ID of the app whose installation should be restarted.
     */
    restart(productId: string): void;

    /**
     * Restarts the installation of the specified app, with the option to generate telemetry data.
     * @param productId The product ID of the app whose installation should be restarted.
     * @param correlationVector A correlation vector string that can be used to generate telemetry data.
     */
    restart(productId: string, correlationVector: string): void;

    /**
     * Searches for all available updates to apps installed on the current computer or device.
     * @return  An asynchronous operation that, on successful completion, returns the collection of apps that have available updates. If you use Asynchronous programming, the result type is a read-only list/vector of AppInstallItem items. (You can use APIs of IVectorView<AppInstallItem> for C++ or JavaScript, APIs of IReadOnlyList<AppInstallItem> for .NET.)
     */
    searchForAllUpdatesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Searches for all available updates to apps installed on the current computer or device, with the option to generate telemetry data.
     * @param correlationVector A correlation vector string that can be used to generate telemetry data.
     * @return  An asynchronous operation that, on successful completion, returns the collection of apps that have available updates. If you use Asynchronous programming, the result type is a read-only list/vector of AppInstallItem items. (You can use APIs of IVectorView<AppInstallItem> for C++ or JavaScript, APIs of IReadOnlyList<AppInstallItem> for .NET.)
     */
    searchForAllUpdatesAsync(
        correlationVector: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Searches for updates for the specified app.
     * @param productId The product ID of the app to be queried for updates.
     * @param skuId The SKU to be queried for updates.
     * @return  An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the available update.
     */
    searchForUpdatesAsync(
        productId: string,
        skuId: string): undefined.IPromiseWithIAsyncOperation<undefined.AppInstallItem>;

    /**
     * Searches for updates for the specified app, with the option to generate telemetry data.
     * @param productId The product ID of the app to be queried for updates.
     * @param skuId The SKU ID of the app to be queried for updates.
     * @param catalogId The catalog ID of the app to be queried for updates.
     * @param correlationVector A correlation vector string that can be used to generate telemetry data.
     * @return  An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the available update.
     */
    searchForUpdatesAsync(
        productId: string,
        skuId: string,
        catalogId: string,
        correlationVector: string): undefined.IPromiseWithIAsyncOperation<undefined.AppInstallItem>;

    /**
     * Starts the installation of the specified app.
     * @param productId The product ID of the app to install.
     * @param skuId The SKU ID of the app to install.
     * @param repair True to attempt to repair the installation of an app that is already installed; otherwise, false.
     * @param forceUseOfNonRemovableStorage True to install the app to non-removable storage even if the user has configured apps to install to SD card; false to install the app to non-removable storage or SD card according to the user's settings.
     * @return  An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the app that was added to the installation queue.
     */
    startAppInstallAsync(
        productId: string,
        skuId: string,
        repair: boolean,
        forceUseOfNonRemovableStorage: boolean): undefined.IPromiseWithIAsyncOperation<undefined.AppInstallItem>;

    /**
     * Starts the installation of the specified app, with the option to generate telemetry data.
     * @param productId The product ID of the app to install.
     * @param skuId The SKU ID of the app to install.
     * @param repair True to attempt to repair the installation of an app that is already installed; otherwise, false.
     * @param forceUseOfNonRemovableStorage True to install the app to non-removable storage even if the user has configured apps to install to SD card; false to install the app to non-removable storage or SD card according to the user's settings.
     * @param catalogId The catalog ID of the app to install.
     * @param bundleId The bundle ID of the app to install.
     * @param correlationVector A correlation vector string that can be used to generate telemetry data.
     * @return  An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the app that was added to the installation queue.
     */
    startAppInstallAsync(
        productId: string,
        skuId: string,
        repair: boolean,
        forceUseOfNonRemovableStorage: boolean,
        catalogId: string,
        bundleId: string,
        correlationVector: string): undefined.IPromiseWithIAsyncOperation<undefined.AppInstallItem>;

    /**
     * Starts the update of an app specified by the package family name.
     * @param packageFamilyName The package family name of the app to update.
     * @return  An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the app update that was added to the installation queue.
     */
    updateAppByPackageFamilyNameAsync(
        packageFamilyName: string): undefined.IPromiseWithIAsyncOperation<undefined.AppInstallItem>;

    /**
     * Starts the update of an app specified by the package family name, with the option to generate telemetry data.
     * @param packageFamilyName The package family name of the app to update.
     * @param correlationVector A correlation vector string that can be used to generate telemetry data.
     * @return  An asynchronous operation that, on successful completion, returns an AppInstallItem that represents the app update that was added to the installation queue.
     */
    updateAppByPackageFamilyNameAsync(
        packageFamilyName: string,
        correlationVector: string): undefined.IPromiseWithIAsyncOperation<undefined.AppInstallItem>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the ItemCompleted and ItemStatusChanged events. 
 */
declare class AppInstallManagerItemEventArgs {

    /**
     * Gets an object that describes the app that has finished installing (for the ItemCompleted event) or whose installation status has changed (for the ItemStatusChanged event). 
     */
    item: undefined.AppInstallItem
}


/**
 * Describes the status of an app that is in the installation queue. 
 */
declare class AppInstallStatus {

    /**
     * Gets the number of bytes that have been downloaded for the current app. 
     */
    bytesDownloaded: number;

    /**
     * Gets the download size in bytes for the current app. 
     */
    downloadSizeInBytes: number;

    /**
     * Gets the error code for an app that has encountered an installation failure. 
     */
    errorCode: Windows$WinRTError;

    /**
     * Gets the installation state of the current app. 
     */
    installState: undefined.AppInstallState;

    /**
     * Gets the completion percentage for the installation of the current app. 
     */
    percentComplete: number
}


/**
 * Defines static methods and properties for accessing information about the device hardware and configuring information about the system, the mobile operator, and the active user account. These members are used in various Windows Store scenarios. 
 */
declare class StoreConfiguration {

    /**
     * Given a list of hardware features, this method returns a modified list that contains only the hardware features that are supported on the current device.
     * @param systemFeatures A list of StoreSystemFeature objects that represent the hardware features to be queried on the current device.
     * @return  An asynchronous operation that, on successful completion, returns a list of hardware features that are supported on the current device. If you use Asynchronous programming, the result type is a read-only list/vector of StoreSystemFeature items. (You can use APIs of IVectorView<StoreSystemFeature> for C++ or JavaScript, APIs of IReadOnlyList<StoreSystemFeature> for .NET.)
     */
    filterUnsupportedSystemFeaturesAsync(
        systemFeatures: undefined.IIterable<undefined.StoreSystemFeature>): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets hardware manufacturer information for the current device. 
     */
    hardwareManufacturerInfo: undefined.StoreHardwareManufacturerInfo;

    /**
     * Determines whether a given user ID is also being used to sign in to the Windows Store. Typically, this method is used to determine whether a user ID that is currently signed in to an app is also signed in to the Windows Store.
     * @param webAccountId The user ID (typically obtained from the WebAccount.Id property) to check.
     * @return  True if the user account specified by webAccountId is the same account that is signed in to the Windows Store; otherwise false.
     */
    isStoreWebAccountId(webAccountId: string): boolean;

    /**
     * Gets or sets a value that indicates whether the Windows Store prompts the user before making a purchase. 
     */
    purchasePromptingPolicy: number;

    /**
     * Configures mobile operator information for the device.
     * @param mobileOperatorId The mobile operator ID.
     * @param appDownloadLimitInMegabytes The maximum app download size defined by the mobile operator, in MB.
     * @param updateDownloadLimitInMegabytes The maximum OS update download size defined by the mobile operator, in MB.
     */
    setMobileOperatorConfiguration(
        mobileOperatorId: string,
        appDownloadLimitInMegabytes: number,
        updateDownloadLimitInMegabytes: number): void;

    /**
     * Sets the ID of the user account that is signed in to the Windows Store so that other apps can query against this ID.
     * @param webAccountId The user account ID (typically obtained from the WebAccount.Id property) that is signed in to the Windows Store.
     */
    setStoreWebAccountId(webAccountId: string): void;

    /**
     * Configures miscellaneous system information for the device.
     * @param catalogHardwareManufacturerId The ID of the hardware manufacturer.
     * @param catalogStoreContentModifierId The ID of the Windows Store content modifier.
     * @param systemConfigurationExpiration The expiration date for the system configuration.
     * @param catalogHardwareDescriptor A descriptor string that specifies the hardware components supported by the device.
     */
    setSystemConfiguration(
        catalogHardwareManufacturerId: string,
        catalogStoreContentModifierId: string,
        systemConfigurationExpiration: Date,
        catalogHardwareDescriptor: string): void
}


/**
 * Provides information about the manufacturer for the current device. 
 */
declare class StoreHardwareManufacturerInfo {

    /**
     * Gets the hardware manufacture ID for the current device. 
     */
    hardwareManufacturerId: string;

    /**
     * Gets the name of the hardware manufacturer for the current device. 
     */
    manufacturerName: string;

    /**
     * Gets the model name for the current device. 
     */
    modelName: string;

    /**
     * Gets the ID of the Windows Store content modifier. 
     */
    storeContentModifierId: string
}


/**
 * Defines static methods for retrieving the in-app product SKUs available for the current app and requesting the purchase of an in-app product SKU for the app. 
 */
declare class StorePreview {

    /**
     * Retrieves the in-app products available for the current app asynchronously, including the available SKUs for each product.
     * @return  An asynchronous operation that, on successful completion, returns the collection of in-app products for the current app (including the available SKUs for each product). If you use Asynchronous programming, the result type is a read-only list/vector of StorePreviewProductInfo items. (You can use APIs of IVectorView<StorePreviewProductInfo> for C++ or JavaScript, APIs of IReadOnlyList<StorePreviewProductInfo> for .NET.)
     */
    loadAddOnProductInfosAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Requests the purchase of a SKU for an in-app product that is associated with the current app. Calling this method displays the UI that is used to complete the transaction via the Windows Store.
     * @param productId Specifies the ID of the in-app product. This corresponds to the StorePreviewProductInfo.ProductId value and the StorePreviewSkuInfo.ProductId values for all SKUs of the in-app product.
     * @param skuId Specifies the ID of the SKU for the in-app product. This corresponds to the StorePreviewSkuInfo.SkuId value.
     * @return  An asynchronous operation that, on successful completion, returns a StorePreviewPurchaseResults that contains the results of the in-app product purchase request.
     */
    requestProductPurchaseByProductIdAndSkuIdAsync(
        productId: string,
        skuId: string): undefined.IPromiseWithIAsyncOperation<undefined.StorePreviewPurchaseResults >
}


/**
 * Provides information about an in-app product, including details about available SKUs. 
 */
declare class StorePreviewProductInfo {

    /**
     * Gets the description of the in-app product. 
     */
    description: string;

    /**
     * Gets the ID of the in-app product. 
     */
    productId: string;

    /**
     * Gets the type of the in-app product. 
     */
    productType: string;

    /**
     * Gets information about the available SKUs for the in-app product. 
     */
    skuInfoList: undefined.IVectorView<undefined.StorePreviewSkuInfo>;

    /**
     * Gets the name of the in-app product that is displayed to customers. 
     */
    title: string
}


/**
 * Contains information about the results of a purchase transaction for an in-app product SKU that was purchased by using the RequestProductPurchaseByProductIdAndSkuIdAsync method. 
 */
declare class StorePreviewPurchaseResults {

    /**
     * Gets the current state of the purchase transaction for an in-app product SKU that was purchased by using the RequestProductPurchaseByProductIdAndSkuIdAsync method. 
     */
    productPurchaseStatus: undefined.StorePreviewProductPurchaseStatus
}


/**
 * Provides information about the available SKUs for an in-app product. 
 */
declare class StorePreviewSkuInfo {

    /**
     * Gets the currency code for the current market. 
     */
    currencyCode: string;

    /**
     * Gets custom developer data for the current SKU. 
     */
    customDeveloperData: string;

    /**
     * Gets the description for the current SKU. 
     */
    description: string;

    /**
     * Gets extended data for the current SKU. 
     */
    extendedData: string;

    /**
     * Gets the current SKU's purchase price with the appropriate formatting for the current market. 
     */
    formattedListPrice: string;

    /**
     * Gets the ID of the product that this SKU is associated with. 
     */
    productId: string;

    /**
     * Gets the ID of this SKU. 
     */
    skuId: string;

    /**
     * Gets a string that specifies the type of the in-app product SKU. 
     */
    skuType: string;

    /**
     * Gets the name of the in-app product SKU that is displayed to customers. 
     */
    title: string
}


/**
 * Provides info about a license that is associated with an in-app product. 
 */
declare class ProductLicense {

    /**
     * Gets the current expiration date and time of the in-app product license. 
     */
    expirationDate: Date;

    /**
     * Indicates if the in-app product license is currently active. 
     */
    isActive: boolean;

    /**
     * Indicates if the in-app product is consumable. A consumable product is a product that can be purchased, used, and purchased again. 
     */
    isConsumable: boolean;

    /**
     * Gets the ID of an in-app product. This ID is used by the app to get info about the product or feature that is enabled when the customer buys it through an in-app purchase. 
     */
    productId: string
}


/**
 * Provides localized information that details an in-app product. 
 */
declare class ProductListing {
    currencyCode: any;

    /**
     * Gets the description for the in-app product. 
     */
    description: string;
    formattedBasePrice: any;

    /**
     * Gets the purchase price for the in-app product with the appropriate formatting for the current market. 
     */
    formattedPrice: string;

    /**
     * Gets the URI of the image associated with the in-app product. 
     */
    imageUri: undefined.Uri;
    isOnSale: any;

    /**
     * Gets the list of keywords associated with the in-app product. These keywords are useful for filtering product lists by keyword, for example, when calling LoadListingInformationByKeywordsAsync . 
     */
    keywords: undefined.IIterable<string>;

    /**
     * Gets the descriptive name of the in-app product that is displayed customers in the current market. 
     */
    name: string;

    /**
     * Gets the in-app product ID. 
     */
    productId: string;

    /**
     * Gets the type of this in-app product. Possible values are defined by ProductType . 
     */
    productType: undefined.ProductType;

    /**
     * Gets the end date of the sale period for the in-app product. 
     */
    saleEndDate: Date;

    /**
     * Gets the tag string that contains custom information about an in-app product. 
     */
    tag: string
}


/**
 * Used to provide the product name that is displayed to the user at time of purchase. 
 */
declare class ProductPurchaseDisplayProperties {

    /**
     * Creates an instance of ProductPurchaseDisplayProperties . 
     */
    constructor(): this;

    /**
     * Creates an instance of ProductPurchaseDisplayProperties that includes the specified product name to display to the user.
     * @param name The product name displayed to the user.
     */
    constructor(name: string): this;

    /**
     * Windows Phone only. This is an internal product description. 
     */
    description: string;

    /**
     * Windows Phone only. Gets or sets the location of an image used to represent the product at time of purchase. 
     */
    image: undefined.Uri;

    /**
     * Gets or sets the product name that is displayed to the user at time of purchase. 
     */
    name: string
}


/**
 * Contains information detailing the results of an in-app product purchase transaction. 
 */
declare class PurchaseResults {

    /**
     * A unique ID used to identify a specific in-app product within a large catalog. 
     */
    offerId: string;

    /**
     * A full receipt that provides a transaction history for the purchase of an in-app product 
     */
    receiptXml: string;

    /**
     * The current state of the purchase transaction for an in-app product. 
     */
    status: undefined.ProductPurchaseStatus;

    /**
     * A unique transaction ID associated with the purchase of a consumable in-app product. 
     */
    transactionId: string
}


/**
 * Contains purchase and product information for an unfulfilled consumable in-app product. 
 */
declare class UnfulfilledConsumable {

    /**
     * A unique ID used to identify a consumable in-app product within a large purchase catalog. 
     */
    offerId: string;

    /**
     * A unique ID used to identify a consumable in-app product. This ID is used by the app to get info about the product or feature that is enabled when the customer buys it through an in-app purchase. 
     */
    productId: string;

    /**
     * A unique ID used to identify the transaction that included the purchase of a consumable in-app product. 
     */
    transactionId: string
}


/**
 * Represents the method that will handle the LicenseChanged event. 
 */
declare type Store$LicenseChangedEventHandler = (ev: Windows$WinRTEvent<void>) => void;


/**
 * Manages a delayed app suspending operation. 
 */
declare class SuspendingDeferral {

    /**
     * Notifies the operating system that the app has saved its data and is ready to be suspended. 
     */
    complete(): void
}


/**
 * Provides data for an app suspending event. 
 */
declare class SuspendingEventArgs {

    /**
     * Gets the app suspending operation. 
     */
    suspendingOperation: undefined.SuspendingOperation
}


/**
 * Provides info about an app suspending operation. 
 */
declare class SuspendingOperation {

    /**
     * Gets the time remaining before a delayed app suspending operation continues. 
     */
    deadline: Date;

    /**
     * Requests that the app suspending operation be delayed.
     * @return  The suspension deferral.
     */
    getDeferral(): undefined.SuspendingDeferral
}


/**
 * Represents device settings for app sync relationships. 
 */
declare class DeviceAccountConfiguration {

    /**
     * Initializes a new instance of the DeviceAccountConfiguration class. 
     */
    constructor(): this;

    /**
     * Gets or sets the name that identifies the device account. 
     */
    accountName: string;

    /**
     * Gets or sets a Boolean value indicating if calendar syncing is enabled. 
     */
    calendarSyncEnabled: boolean;

    /**
     * Gets or sets a Boolean value indicating if contacts syncing is enabled. 
     */
    contactsSyncEnabled: boolean;

    /**
     * Gets or sets the value that identifies the device account type. 
     */
    deviceAccountTypeId: string;

    /**
     * Gets or sets the network domain of the device. 
     */
    domain: string;

    /**
     * Gets or sets the email address of the current user. 
     */
    emailAddress: string;

    /**
     * Gets or sets a Boolean value indicating if email syncing is enabled. 
     */
    emailSyncEnabled: boolean;

    /**
     * Gets or sets the incoming email server address. 
     */
    incomingServerAddress: string;

    /**
     * Gets or sets the port number to use to connect to the incoming email server. 
     */
    incomingServerPort: number;

    /**
     * Gets or sets a Boolean value indicating if Secure Sockets Layer (SSL) should be used when connecting to the incoming email server. 
     */
    incomingServerRequiresSsl: boolean;

    /**
     * Gets or sets the username to use when connecting to the incoming email server. 
     */
    incomingServerUsername: string;

    /**
     * Gets or sets the outgoing email server address. 
     */
    outgoingServerAddress: string;

    /**
     * Gets or sets the port number to use to connect to the outgoing email server. 
     */
    outgoingServerPort: number;

    /**
     * Gets or sets a Boolean value indicating if Secure Sockets Layer (SSL) should be used when connecting to the outgoing email server. 
     */
    outgoingServerRequiresSsl: boolean;

    /**
     * Gets or sets the username to use when connecting to the outgoing email server. 
     */
    outgoingServerUsername: string;

    /**
     * Gets or sets a value indicating the type of the server. 
     */
    serverType: undefined.DeviceAccountServerType
}


/**
 * Provides the ability to display the system UI for managing sync relationships. 
 */
declare class UserDataAccountSystemAccessManager {

    /**
     * Asynchronously displays the system UI to manage the sync relationships for the specified accounts.
     * @param accounts The list of accounts to manage in the system UI.
     * @return  Returns an updated list of accounts.
     */
    addAndShowDeviceAccountsAsync(
        accounts: undefined.IIterable<undefined.DeviceAccountConfiguration>): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >>
}


/**
 * Represents a user data account used to access email, contacts, calendars, and so on. 
 */
declare class UserDataAccount {

    /**
     * Asynchronously deletes all the contact, calendar and email data associated with the account.
     * @return  An async action indicating success or failure.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the unique identifier for the type of the account. 
     */
    deviceAccountTypeId: string;

    /**
     * Gets the enterprise identity associated with the user account. 
     */
    enterpriseId: string;

    /**
     * Returns a collection of AppointmentCalendar instances associated with the UserDataAccount .
     * @return  A collection of AppointmentCalendar instances associated with the UserDataAccount .
     */
    findAppointmentCalendarsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Returns a collection of ContactAnnotationList instances associated with the UserDataAccount .
     * @return  A collection of ContactAnnotationList instances associated with the UserDataAccount .
     */
    findContactAnnotationListsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Returns a collection of ContactList instances associated with the UserDataAccount .
     * @return  A collection of ContactList instances associated with the UserDataAccount .
     */
    findContactListsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Returns a collection of EmailMailbox instances associated with the UserDataAccount .
     * @return  A collection of EmailMailbox instances associated with the UserDataAccount .
     */
    findEmailMailboxesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the icon associated with the UserDataAccount . 
     */
    icon: undefined.IRandomAccessStreamReference;

    /**
     * Gets a string that uniquely identifies the UserDataAccount on the local device. 
     */
    id: string;

    /**
     * Gets a Boolean value indicating if the user account data is encrypted when the device becomes locked. 
     */
    isProtectedUnderLock: boolean;

    /**
     * Gets or sets a value indicating whether other apps on the device have read access to the UserDataAccount . 
     */
    otherAppReadAccess: undefined.UserDataAccountOtherAppReadAccess;

    /**
     * Gets the unique identifier for the app package that created the UserDataAccount . 
     */
    packageFamilyName: string;

    /**
     * Asynchronously persists the UserDataAccount to the database.
     * @return  Async action that indicates completion of the save operation.
     */
    saveAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets a user name associated with the UserDataAccount that is suitable for displaying. 
     */
    userDisplayName: string
}


/**
 * Provides APIs to interact with the user’s data accounts including those implemented by the operating system. 
 */
declare class UserDataAccountManager {

    /**
     * Asynchronously returns the UserDataAccountStore from the system.
     * @param storeAccessType Specifies the access type, such as read-only for all accounts or read/write for the calling app's accounts.
     * @return  Returns the UserDataAccountStore .
     */
    requestStoreAsync(
        storeAccessType: undefined.UserDataAccountStoreAccessType): undefined.IPromiseWithIAsyncOperation<undefined.UserDataAccountStore>;

    /**
     * This method shows the resolve message for an account error.
     * @param id The user data account ID.
     * @return  An async action indicating success or failure.
     */
    showAccountErrorResolverAsync(id: string): undefined.IPromiseWithIAsyncAction;

    /**
     * This method shows the account settings.
     * @param id The user data account ID.
     * @return  An async action indicating success or failure.
     */
    showAccountSettingsAsync(id: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Shows the add account UI.
     * @param contentKinds The type of user data content.
     * @return  Returns the newly added or already existing account.
     */
    showAddAccountAsync(
        contentKinds: undefined.UserDataAccountContentKinds): undefined.IPromiseWithIAsyncOperation<string >
}


/**
 * Represents a data store that contains user accounts. 
 */
declare class UserDataAccountStore {

    /**
     * Asynchronously creates a user data account.
     * @param userDisplayName A string containing the user name that is suitable for display.
     * @return  Returns the newly created UserDataAccount .
     */
    createAccountAsync(
        userDisplayName: string): undefined.IPromiseWithIAsyncOperation<undefined.UserDataAccount>;

    /**
     * Returns a collection of UserDataAccount objects from the store based on the UserDataAccountStoreAccessType value passed into RequestStoreAsync .
     * @return  Returns the collection of user data accounts, scoped by access request.
     */
    findAccountsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously gets the specified account.
     * @param id The Id string identifying the account.
     * @return  Returns the UserDataAccount identified by the id parameter.
     */
    getAccountAsync(id: string): undefined.IPromiseWithIAsyncOperation<undefined.UserDataAccount >
}


/**
 * The command given to Cortana, using either speech or text, and routed to a background app. 
 */
declare class VoiceCommand {

    /**
     * Gets the value of the Name attribute for the Command element declared in the Voice Command Definition (VCD) file. 
     */
    commandName: string;

    /**
     * Gets a dictionary containing the semantic properties of the recognized phrase in the voice command. 
     */
    properties: undefined.IMapView<string, undefined.IVectorView<any >> ;

    /**
     * Gets the SpeechRecognitionResult object representing the results returned by the voice command. 
     */
    speechRecognitionResult: undefined.SpeechRecognitionResult
}


/**
 * Contains event data for the VoiceCommandCompleted event. 
 */
declare class VoiceCommandCompletedEventArgs {

    /**
     * The reason the voice command completed. 
     */
    reason: undefined.VoiceCommandCompletionReason
}


/**
 * The response to the question specified by the background app and shown on the Cortana confirmation screen. This screen is displayed when the background app service calls RequestConfirmationAsync . 
 */
declare class VoiceCommandConfirmationResult {

    /**
     * Gets the response to the question specified by the background app and shown on the Cortana confirmation screen. 
     */
    confirmed: boolean
}


/**
 * An asset, containing image, text, and link data, provided by the background app service for display on the Cortana canvas. 
 */
declare class VoiceCommandContentTile {

    /**
     * Creates an instance of the VoiceCommandContentTile class. 
     */
    constructor(): this;

    /**
     * Gets or sets supplementary information the background app service can associate with the content tile. This information is not used by Cortana. 
     */
    appContext: any;

    /**
     * Gets or sets a string as a launch parameter that can be associated with the response by the background app service. 
     */
    appLaunchArgument: string;

    /**
     * Gets or sets the layout template used to display the content tile on the Cortana canvas. 
     */
    contentTileType: undefined.VoiceCommandContentTileType;

    /**
     * Gets or sets an image the background app service can associate with the content tile. 
     */
    image: undefined.IStorageFile;

    /**
     * Gets or sets the first line of text the background app service can associate with the content tile. 
     */
    textLine1: string;

    /**
     * Gets or sets the second line of text the background app service can associate with the content tile. 
     */
    textLine2: string;

    /**
     * Gets or sets the third line of text the background app service can associate with the content tile. 
     */
    textLine3: string;

    /**
     * Gets or sets the title the background app service can associate with the content tile. 
     */
    title: string
}


/**
 * Enables operations on a specific installed command set. 
 */
declare class VoiceCommandDefinition {

    /**
     * Gets the language ( xml:lang ) value of the CommandSet element in the Voice Command Definition (VCD) file. 
     */
    language: string;

    /**
     * Gets the Name attribute value of the CommandSet element in the Voice Command Definition (VCD) file. 
     */
    name: string;

    /**
     * Populates a PhraseList element with an array of Item elements.
     * @param phraseListName The string that corresponds to the label attribute of the PhraseList element.
     * @param phraseList A string array of values that will be added to the PhraseList element as Item elements.
     * @return  A string array of values that will be added to the PhraseList element as Item elements.
     */
    setPhraseListAsync(
        phraseListName: string,
        phraseList: undefined.IIterable<string>): undefined.IPromiseWithIAsyncAction
}


/**
 * A static class that enables installing command sets from a Voice Command Definition (VCD) file, and getting installed command sets. 
 */
declare class VoiceCommandDefinitionManager {

    /**
     * Installs the CommandSet elements in a Voice Command Definition (VCD) file.
     * @param file An object representing a VCD file.
     * @return  An asynchronous handler called when the operation is complete.
     */
    installCommandDefinitionsFromStorageFileAsync(file: undefined.StorageFile): undefined.IPromiseWithIAsyncAction;

    /**
     * A dictionary that contains all installed command sets that have a Name attribute set in the Voice Command Definition (VCD) file. 
     */
    installedCommandDefinitions: undefined.IMapView<string, undefined.VoiceCommandDefinition >
}


/**
 * The result obtained from the disambiguation screen displayed on the Cortana canvas. 
 */
declare class VoiceCommandDisambiguationResult {

    /**
     * The item selected from the list of items displayed on the Cortana disambiguation screen. 
     */
    selectedItem: undefined.VoiceCommandContentTile
}


/**
 * The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas. 
 */
declare class VoiceCommandResponse {

    /**
     * Creates a VoiceCommandResponse object used in calls to ReportProgressAsync , ReportSuccessAsync or ReportFailureAsync .
     * @param message The message that is spoken by Cortana and shown on the Cortana canvas.
     * @param contentTiles The collection of assets, containing image and text data, shown on the Cortana canvas.
     * @return  The response from the background app service for progress, completion, confirmation, or disambiguation screens displayed on the Cortana canvas.
     */
    createResponse(
        message: undefined.VoiceCommandUserMessage,
        contentTiles: undefined.IIterable<undefined.VoiceCommandContentTile>): undefined.VoiceCommandResponse;

    /**
     * Creates a VoiceCommandResponse object used in calls to ReportProgressAsync , ReportSuccessAsync or ReportFailureAsync .
     * @param userMessage The message that is spoken by Cortana and shown on the Cortana canvas.
     * @return  The response from the background app service for progress, completion, confirmation, or disambiguation screens displayed on the Cortana canvas.
     */
    createResponse(userMessage: undefined.VoiceCommandUserMessage): undefined.VoiceCommandResponse;

    /**
     * Creates a VoiceCommandResponse object used in calls to RequestConfirmationAsync or RequestDisambiguationAsync .
     * @param message The initial message that is spoken by Cortana and shown on the Cortana canvas.
     * @param repeatMessage The secondary message that is spoken by Cortana and shown on the Cortana canvas, if a response was not understood.
     * @param contentTiles The collection of assets, containing image and text data, shown on the Cortana canvas.
     * @return  The response from the background app service for progress, completion, confirmation, or disambiguation screens displayed on the Cortana canvas.
     */
    createResponseForPrompt(
        message: undefined.VoiceCommandUserMessage,
        repeatMessage: undefined.VoiceCommandUserMessage,
        contentTiles: undefined.IIterable<undefined.VoiceCommandContentTile>): undefined.VoiceCommandResponse;

    /**
     * Creates a VoiceCommandResponse object used in calls to RequestConfirmationAsync or RequestDisambiguationAsync .
     * @param message The initial message that is spoken by Cortana and shown on the Cortana canvas.
     * @param repeatMessage The secondary message that is spoken by Cortana and shown on the Cortana canvas, if a response was not understood.
     * @return  The response from the background app service for progress, completion, confirmation, or disambiguation screens displayed on the Cortana canvas.
     */
    createResponseForPrompt(
        message: undefined.VoiceCommandUserMessage,
        repeatMessage: undefined.VoiceCommandUserMessage): undefined.VoiceCommandResponse;

    /**
     * Gets the maximum number of content tiles the background app service can display on the Cortana canvas. 
     */
    maxSupportedVoiceCommandContentTiles: number;

    /**
     * Gets or sets a string as a launch parameter that can be associated with the response by the background app service. 
     */
    appLaunchArgument: string;

    /**
     * The initial message that is spoken by Cortana and shown on the Cortana canvas. 
     */
    message: undefined.VoiceCommandUserMessage;

    /**
     * The secondary message (for disambiguation and confirmation screens only) that is spoken by Cortana and shown on the Cortana canvas, if a response was not understood. 
     */
    repeatMessage: undefined.VoiceCommandUserMessage;

    /**
     * The collection of assets, containing image and text data, provided by the background app service for display on the Cortana canvas. 
     */
    voiceCommandContentTiles: undefined.IVector<undefined.VoiceCommandContentTile >
}


/**
 * The background app service connection to Cortana. 
 */
declare class VoiceCommandServiceConnection {

    /**
     * Retrieves a VoiceCommandServiceConnection object from the AppServiceTriggerDetails that contains info associated with the background task for the app service.
     * @param triggerDetails Contains info associated with the background task for the app service.
     * @return  The background app service connection to Cortana.
     */
    fromAppServiceTriggerDetails(
        triggerDetails: undefined.AppServiceTriggerDetails): undefined.VoiceCommandServiceConnection;

    /**
     * Retrieves the voice command that the user submitted to Cortana by voice or text.
     * @return  The VoiceCommand .
     */
    getVoiceCommandAsync(): undefined.IPromiseWithIAsyncOperation<undefined.VoiceCommand>;

    /**
     * Gets the locale for the voice command. 
     */
    language: undefined.Language;

    /**
     * Event raised when the voice command is completed and the background app service is about to be terminated. 
     */
    onvoicecommandcompleted: undefined.TypedEventHandler<undefined.VoiceCommandServiceConnection, undefined.VoiceCommandCompletedEventArgs>;
    addEventListener(
        type: "voicecommandcompleted",
        listener: undefined.TypedEventHandler<undefined.VoiceCommandServiceConnection, undefined.VoiceCommandCompletedEventArgs>): void;
    removeEventListener(
        type: "voicecommandcompleted",
        listener: undefined.TypedEventHandler<undefined.VoiceCommandServiceConnection, undefined.VoiceCommandCompletedEventArgs>): void;

    /**
     * Sends a response to Cortana indicating the voice command has failed.
     * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
     * @return  An asynchronous handler called when the operation is complete.
     */
    reportFailureAsync(response: undefined.VoiceCommandResponse): undefined.IPromiseWithIAsyncAction;

    /**
     * Sends a response to Cortana indicating voice command is being processed.
     * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
     * @return  An asynchronous handler called when the operation is complete.
     */
    reportProgressAsync(response: undefined.VoiceCommandResponse): undefined.IPromiseWithIAsyncAction;

    /**
     * Sends a response to Cortana indicating the voice command has succeeded.
     * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
     * @return  An asynchronous handler called when the operation is complete.
     */
    reportSuccessAsync(response: undefined.VoiceCommandResponse): undefined.IPromiseWithIAsyncAction;

    /**
     * Sends a response to Cortana indicating the command should be handled by the app in the foreground.
     * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
     * @return  An asynchronous handler called when the operation is complete.
     */
    requestAppLaunchAsync(response: undefined.VoiceCommandResponse): undefined.IPromiseWithIAsyncAction;

    /**
     * Sends a response to Cortana indicating the voice command requires confirmation.
     * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
     * @return  The VoiceCommandConfirmationResult object with the user's response.
     */
    requestConfirmationAsync(
        response: undefined.VoiceCommandResponse): undefined.IPromiseWithIAsyncOperation<undefined.VoiceCommandConfirmationResult>;

    /**
     * Sends a response to Cortana indicating the voice command returned more than one result and requires the user to select one.
     * @param response The response from a background app service for progress, confirmation, disambiguation, completion, or failure screens displayed on the Cortana canvas.
     * @return  The VoiceCommandDisambiguationResult object with the user's response.
     */
    requestDisambiguationAsync(
        response: undefined.VoiceCommandResponse): undefined.IPromiseWithIAsyncOperation<undefined.VoiceCommandDisambiguationResult>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * The message that is spoken by Cortana and shown on the Cortana canvas. 
 */
declare class VoiceCommandUserMessage {

    /**
     * Creates an instance of the VoiceCommandUserMessage class. 
     */
    constructor(): this;

    /**
     * Gets or sets the message that is shown on the Cortana canvas. 
     */
    displayMessage: string;

    /**
     * The message that is spoken by Cortana. 
     */
    spokenMessage: string
}


/**
 * Defines a set of asynchronous actions and operations that manage the wallet items in the system wallet database. These can be used to read the existing items, or to add and remove items. 
 */
declare class WalletItemSystemStore {

    /**
     * Asynchronously removes a specific wallet item with the given ID from the wallet system data store.
     * @param item The ID of the wallet item to remove from the system data store.
     * @return  An asynchronous action. If you use Asynchronous programming, the result type is void.
     */
    deleteAsync(item: undefined.WalletItem): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets a WalletItemAppAssociation value indicating if an app is installed for the specified WalletItem .
     * @param item The item for which to retrieve the status.
     * @return  The WalletItemAppAssociation value indicating if an app is installed for the specified WalletItem specified by the item parameter.
     */
    getAppStatusForItem(item: undefined.WalletItem): undefined.WalletItemAppAssociation;

    /**
     * Returns the collection of all system wallet items owned by this app.
     * @return  An asynchronous operation that, on successful completion, returns the collection of wallet items accessible by this app. If you use Asynchronous programming, the result type is a read-only list/vector of WalletItem items. (You can use APIs of IVectorView<WalletItem> for C++ or JavaScript, APIs of IReadOnlyList<WalletItem> for .NET.)
     */
    getItemsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Imports data from a ".mswallet" XML file into the system wallet store.
     * @param stream The ".mswallet" file to import.
     * @return  An asynchronous operation that, on successful completion, returns the wallet item that was imported into the wallet. If you use Asynchronous programming, the result type on successful completion is a single WalletItem .
     */
    importItemAsync(
        stream: undefined.IRandomAccessStreamReference): undefined.IPromiseWithIAsyncOperation<undefined.WalletItem>;

    /**
     * Launches the app that is associated with the given wallet item.
     * @param item The wallet item to launch an app for.
     * @return  An async action indicating that the operation has completed.
     */
    launchAppForItemAsync(item: undefined.WalletItem): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Occurs when items in the WalletItemSystemStore have changed. 
     */
    onitemschanged: undefined.TypedEventHandler<undefined.WalletItemSystemStore, any>;
    addEventListener(
        type: "itemschanged",
        listener: undefined.TypedEventHandler<undefined.WalletItemSystemStore, any>): void;
    removeEventListener(
        type: "itemschanged",
        listener: undefined.TypedEventHandler<undefined.WalletItemSystemStore, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides a static method to get an instance of the system wallet store for this app. 
 */
declare class WalletManagerSystem {

    /**
     * Requests an instance of the system wallet store for the app.
     * @return  An asynchronous operation that, on successful completion, returns an instance of the default wallet store. If you use Asynchronous programming, the result type is a single WalletItemSystemStore object.
     */
    requestStoreAsync(): undefined.IPromiseWithIAsyncOperation<undefined.WalletItemSystemStore >
}


/**
 * Represents a bar code assigned to a wallet item. 
 */
declare class WalletBarcode {

    /**
     * Initializes a new instance of the WalletBarcode class.
     * @param streamToBarcodeImage A stream representing the bar code image.
     */
    constructor(streamToBarcodeImage: undefined.IRandomAccessStreamReference): this;

    /**
     * Initializes a new instance of the WalletBarcode class.
     * @param symbology The symbology type for this barcode. Use one of the supported symbologies, such as Upca. Don't set to Invalid or Custom.
     * @param value The message ( Value ) that the barcode represents.
     */
    constructor(symbology: undefined.WalletBarcodeSymbology, value: string): this;

    /**
     * Creates and returns a bitmap image stream for the barcode (or returns the custom image used during instantiation).
     * @return  An asynchronous operation. If you use Asynchronous programming, the result type on successful completion is an IRandomAccessStreamReference instance. This can be assigned as the source for an image (with some additional code).
     */
    getImageAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStreamReference>;

    /**
     * Gets the symbology used by the bar code. 
     */
    symbology: undefined.WalletBarcodeSymbology;

    /**
     * Gets a string representation of the barcode (its message). 
     */
    value: string
}


/**
 * Represents an item (data) that is stored in the wallet. 
 */
declare class WalletItem {

    /**
     * Initializes a new instance of the WalletItem class.
     * @param kind The type of wallet item.
     * @param displayName The display name of the item.
     */
    constructor(kind: undefined.WalletItemKind, displayName: string): this;

    /**
     * Gets or sets the barcode that's representative of the wallet item. 
     */
    barcode: undefined.WalletBarcode;

    /**
     * Gets or sets the background image of the body of the wallet item (uses a stream). 
     */
    bodyBackgroundImage: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the body color of the wallet item. 
     */
    bodyColor: undefined.Color;

    /**
     * Gets or sets the body font color of the wallet item. 
     */
    bodyFontColor: undefined.Color;

    /**
     * Gets or sets a string that appears next to the app name in About info. 
     */
    displayMessage: string;

    /**
     * Gets or sets the name or title to be displayed to the user. 
     */
    displayName: string;

    /**
     * Gets the collection of WalletItemCustomProperty objects associated with the wallet item. 
     */
    displayProperties: undefined.IMap<string, undefined.WalletItemCustomProperty>;

    /**
     * Gets or sets the expiration date of the wallet item. 
     */
    expirationDate: Date;

    /**
     * Gets or sets the header background image of the wallet item. 
     */
    headerBackgroundImage: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the header color of the wallet item. 
     */
    headerColor: undefined.Color;

    /**
     * Gets or sets the header font color of the wallet item. 
     */
    headerFontColor: undefined.Color;

    /**
     * Gets the unique identifier of the wallet item. 
     */
    id: string;

    /**
     * Gets or sets whether this item is acknowledged by the app. 
     */
    isAcknowledged: boolean;

    /**
     * Gets or sets whether to launch your app when the user taps on the DisplayMessage . 
     */
    isDisplayMessageLaunchable: boolean;

    /**
     * Gets or sets whether your app should be launched when the user taps "see more transaction history". 
     */
    isMoreTransactionHistoryLaunchable: boolean;

    /**
     * Gets or sets the issuer name of the wallet item. 
     */
    issuerDisplayName: string;

    /**
     * Gets the type of the wallet item. 
     */
    kind: undefined.WalletItemKind;

    /**
     * Gets or sets the date and time the data for this item was last updated. 
     */
    lastUpdated: Date;

    /**
     * Gets or sets the medium (159 x 159) logo image of the wallet item. 
     */
    logo159x159: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the large (336 x 336) logo image of the wallet item. 
     */
    logo336x336: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the small (99 x 99) logo image of the wallet item. 
     */
    logo99x99: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the logo image of the wallet item. 
     */
    logoImage: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the logo text of the wallet item. 
     */
    logoText: string;

    /**
     * Gets or sets the promotional image of the wallet item. 
     */
    promotionalImage: undefined.IRandomAccessStreamReference;

    /**
     * Gets or sets the date on which the item is valid. 
     */
    relevantDate: Date;

    /**
     * Gets or sets the description of the relevant date of the wallet item. 
     */
    relevantDateDisplayMessage: string;

    /**
     * Gets a collection of all relevant locations for the wallet item. 
     */
    relevantLocations: undefined.IMap<string, undefined.WalletRelevantLocation>;

    /**
     * Gets the transaction history collection of the wallet item. 
     */
    transactionHistory: undefined.IMap<string, undefined.WalletTransaction>;

    /**
     * Gets the collection of WalletVerb objects associated with the wallet item. 
     */
    verbs: undefined.IMap<string, undefined.WalletVerb >
}


/**
 * Defines a custom property on a wallet item. Apps can show data in the details view or back of card view of the item. 
 */
declare class WalletItemCustomProperty {

    /**
     * Initializes a new instance of the WalletItemCustomProperty class.
     * @param name The custom property label. Sets the initial Name value.
     * @param value The value of the property. Sets the initial Value value.
     */
    constructor(name: string, value: string): this;

    /**
     * Gets or sets whether this WalletItemCustomProperty is entity-extracted and actionable upon display. 
     */
    autoDetectLinks: boolean;

    /**
     * Gets or sets the optional position of this property when shown in the wallet item's detail view. 
     */
    detailViewPosition: undefined.WalletDetailViewPosition;

    /**
     * Gets or sets the custom property label. 
     */
    name: string;

    /**
     * Gets or sets the optional position of this property when shown in the summary view for a wallet item. 
     */
    summaryViewPosition: undefined.WalletSummaryViewPosition;

    /**
     * Gets or sets the custom property value. 
     */
    value: string
}


/**
 * Defines a set of asynchronous actions and operations that manage the wallet items in the wallet database. These can be used to read the existing items, or to add and remove items. 
 */
declare class WalletItemStore {

    /**
     * Adds a new wallet item to the wallet.
     * @param id The identifier of the wallet item. This value must be unique. This sets the initial WalletItem.Id value (the identifier is for the WalletItemStore store, and isn't part of the initialization of a WalletItem object.
     * @param item The wallet item to add to the wallet.
     * @return  An asynchronous action. If you use Asynchronous programming, the return type is void.
     */
    addAsync(id: string, item: undefined.WalletItem): undefined.IPromiseWithIAsyncAction;

    /**
     * Clears all app-owned wallet items from the wallet data store.
     * @return  An asynchronous action. If you use Asynchronous programming, the result type is void.
     */
    clearAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Removes a specific wallet item with the given ID from the wallet data store.
     * @param id The ID of the wallet item to remove from the data store.
     * @return  An asynchronous action. If you use Asynchronous programming, the result type is void.
     */
    deleteAsync(id: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Returns the collection of all wallet items owned by this app.
     * @return  An asynchronous operation that, on successful completion, returns the collection of wallet items accessible by this app. If you use Asynchronous programming, the result type is a read-only list/vector of WalletItem items. (You can use APIs of IVectorView<WalletItem> for C++ or JavaScript, APIs of IReadOnlyList<WalletItem> for .NET.)
     */
    getItemsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<undefined.WalletItem >> ;

    /**
     * Returns the collection of wallet items of the given type that are owned by this app.
     * @param kind The type of wallet item to retrieve.
     * @return  An asynchronous operation that, on successful completion, returns the collection of wallet items of the specified type that are accessible by this app. If you use Asynchronous programming, the result type is a read-only list/vector of WalletItem items. (You can use APIs of IVectorView<WalletItem> for C++ or JavaScript, APIs of IReadOnlyList<WalletItem> for .NET.)
     */
    getItemsAsync(
        kind: undefined.WalletItemKind): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets an individual wallet item with the given ID from the wallet database. The item requested must be owned by this app.
     * @param id The ID of the wallet item.
     * @return  An asynchronous operation that, on successful completion, returns the wallet item with the specified ID that is owned by this app. If you use Asynchronous programming, the result type is a single WalletItem (or null, see Remarks).
     */
    getWalletItemAsync(id: string): undefined.IPromiseWithIAsyncOperation<undefined.WalletItem>;

    /**
     * Imports data from a ".mswallet" XML file into the wallet store.
     * @param stream The ".mswallet" file to import.
     * @return  An asynchronous operation that, on successful completion, returns the wallet item that was imported into the wallet. If you use Asynchronous programming, the result type on successful completion is a single WalletItem .
     */
    importItemAsync(
        stream: undefined.IRandomAccessStreamReference): undefined.IPromiseWithIAsyncOperation<undefined.WalletItem>;

    /**
     * Displays the item with the given ID in the Wallet UI.
     * @param id The ID of the item to display.
     * @return  An asynchronous action. If you use Asynchronous programming, the result type is void.
     */
    showAsync(id: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Displays the Wallet UI.
     * @return  An asynchronous action. If you use Asynchronous programming, the result type is void.
     */
    showAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Updates a wallet item in the shared store, based on the changed values in the WalletItem object provided.
     * @param item The updated data for the wallet item.
     * @return  An asynchronous action. If you use Asynchronous programming, the result type is void.
     */
    updateAsync(item: undefined.WalletItem): undefined.IPromiseWithIAsyncAction
}


/**
 * Provides a static method to get an instance of the default wallet store for this app. 
 */
declare class WalletManager {

    /**
     * Requests an instance of the default wallet store for the app.
     * @return  An asynchronous operation that, on successful completion, returns an instance of the default wallet store. If you use Asynchronous programming, the result type is a single WalletItemStore object.
     */
    requestStoreAsync(): undefined.IPromiseWithIAsyncOperation<undefined.WalletItemStore >
}


/**
 * Represents relevant location data for a wallet item. 
 */
declare class WalletRelevantLocation {

    /**
     * Initializes a new instance of the WalletRelevantLocation class. 
     */
    constructor(): this;

    /**
     * Gets or sets the message associated with a relevant location. 
     */
    displayMessage: string;

    /**
     * Gets or sets the basic geographic position information of the location. 
     */
    position: undefined.BasicGeoposition
}


/**
 * Represents a single wallet transaction in the transaction history. 
 */
declare class WalletTransaction {

    /**
     * Initializes a new instance of the WalletTransaction class. 
     */
    constructor(): this;

    /**
     * Gets or sets the summary description (suitable for user UI) of the transaction. 
     */
    description: string;

    /**
     * Gets or sets the transaction amount. 
     */
    displayAmount: string;

    /**
     * Gets or sets a description (suitable for user UI) of the transaction location. 
     */
    displayLocation: string;

    /**
     * Gets or sets whether to display the time of the transaction. 
     */
    ignoreTimeOfDay: boolean;

    /**
     * Gets or sets whether to launch your app when the user taps "see more transaction history". 
     */
    isLaunchable: boolean;

    /**
     * Gets or sets the date and time of the transaction. 
     */
    transactionDate: Date
}


/**
 * Represents a wallet verb, which is potentially used for app activation. This is a string suitable for UI that is descriptive of the action. 
 */
declare class WalletVerb {

    /**
     * Initializes a new instance of the WalletVerb class.
     * @param name The name of the custom verb. Sets the value of the Name property.
     */
    constructor(name: string): this;

    /**
     * Gets or sets the custom verb name. 
     */
    name: string
}


/**
 * Represents the package version info. 
 */
declare interface ApplicationModel$PackageVersion {

    /**
     * The build version number of the package. 
     */
    build: number,

        /**
         * The major version number of the package. 
         */
        major: number,

        /**
         * The minor version number of the package. 
         */
        minor: number,

        /**
         * The revision version number of the package. 
         */
        revision: number
}


/**
 * Provides data for an app suspending event. 
 */
declare interface ApplicationModel$ISuspendingEventArgs {

    /**
     * Gets the app suspending operation. 
     */
    suspendingOperation: undefined.SuspendingOperation
}






/**
 * Represents a Portable Document Format (PDF) document. 
 */
declare class PdfDocument {

    /**
     * Outputs an asynchronous operation. When the operation completes, a PdfDocument object is returned, which represents a Portable Document Format (PDF) document. Use this method if the PDF document is password-protected.
     * @param file The file, which represents a PDF document.
     * @param password The password to open the PDF document, if it requires one.
     * @return  The asynchronous operation.
     */
    loadFromFileAsync(
        file: undefined.IStorageFile,
        password: string): undefined.IPromiseWithIAsyncOperation<undefined.PdfDocument>;

    /**
     * Outputs an asynchronous operation. When the operation completes, a PdfDocument object is returned, which represents a Portable Document Format (PDF) document.
     * @param file The file, which represents a PDF document.
     * @return  The asynchronous operation.
     */
    loadFromFileAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.PdfDocument>;

    /**
     * Creates a PdfDocument object, representing a Portable Document Format (PDF) document, from a stream of data that represents a PDF document in the file system. Use this method if the PDF document is password-protected.
     * @param inputStream The stream of data, which represents a PDF document.
     * @param password The password to open the PDF document, if it requires one.
     * @return  The asynchronous operation.
     */
    loadFromStreamAsync(
        inputStream: undefined.IRandomAccessStream,
        password: string): undefined.IPromiseWithIAsyncOperation<undefined.PdfDocument>;

    /**
     * Creates a PdfDocument object, representing a Portable Document Format (PDF) document, from a stream of data that represents a PDF document in the file system.
     * @param inputStream The stream of data, which represents a PDF document.
     * @return  The asynchronous operation.
     */
    loadFromStreamAsync(
        inputStream: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncOperation<undefined.PdfDocument>;

    /**
     * Gets a page from a Portable Document Format (PDF) document.
     * @param pageIndex The location of the PDF page relative to its parent document.
     * @return  The PDF page.
     */
    getPage(pageIndex: number): undefined.PdfPage;

    /**
     * Gets whether the Portable Document Format (PDF) document is password-protected. 
     */
    isPasswordProtected: boolean;

    /**
     * Gets the number of pages in the Portable Document Format (PDF) document. 
     */
    pageCount: number
}


/**
 * Represents a single page in a Portable Document Format (PDF) document. 
 */
declare class PdfPage {

    /**
     * Releases all resources associated with the Portable Document Format (PDF) page. 
     */
    close(): void;

    /**
     * Gets the group of dimension properties for a single page in a Portable Document Format (PDF) document. 
     */
    dimensions: undefined.PdfPageDimensions;

    /**
     * Gets the relative position of the Portable Document Format (PDF) page within its parent PDF document. 
     */
    index: number;

    /**
     * Gets the Portable Document Format (PDF) page's preferred magnification factor. 
     */
    preferredZoom: number;

    /**
     * Begins building the Portable Document Format (PDF) page. After this method finishes, the PDF page is completely built.
     * @return  Represents the fully-built PDF page.
     */
    preparePageAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Outputs a stream of data, which represents a Portable Document Format (PDF) page's contents, as an asynchronous action. This asynchronous action can be used to create an image of the PDF page.
     * @param outputStream The stream of data, which represents a PDF page's content.
     * @return  The asynchronous action.
     */
    renderToStreamAsync(
        outputStream: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncAction;

    /**
     * Takes a set of display settings, applies them to the output of a Portable Document Format (PDF) page's contents, and creates a stream with the customized, rendered output as an asynchronous action. This asynchronous action can be used to create a customized display image of the PDF page.
     * @param outputStream The stream of data, which represents a PDF page's contents.
     * @param options The requested set of display settings to apply to the display image that is output based on the PDF page.
     * @return  The asynchronous action.
     */
    renderToStreamAsync(
        outputStream: undefined.IRandomAccessStream,
        options: undefined.PdfPageRenderOptions): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the number of degrees that the Portable Document Format (PDF) page will be rotated when it's displayed or printed. 
     */
    rotation: undefined.PdfPageRotation;

    /**
     * Gets the Portable Document Format (PDF) page's size based on its related CropBox , MediaBox , and Rotation property values. 
     */
    size: undefined.Size
}


/**
 * Represents the dimensions of a single page in a Portable Document Format (PDF) document. 
 */
declare class PdfPageDimensions {

    /**
     * Gets the size of a rectangle that contains the Portable Document Format (PDF) page's contents, including any meaningful surrounding white space, as intended by the PDF page's creator. 
     */
    artBox: undefined.Rect;

    /**
     * Gets the size of a rectangle that specifies the clipped region of a Portable Document Format (PDF) page's contents when it is displayed. 
     */
    bleedBox: undefined.Rect;

    /**
     * Gets the size of a rectangle that specifies the cropped region of a Portable Document Format (PDF) page's contents when it is displayed. 
     */
    cropBox: undefined.Rect;

    /**
     * Gets the size of a rectangle that defines the boundaries of the area that the Portable Document Format (PDF) page will be displayed or printed to. 
     */
    mediaBox: undefined.Rect;

    /**
     * Gets the size of a rectangle that specifies the intended dimensions of the Portable Document Format (PDF) page after it has been trimmed. 
     */
    trimBox: undefined.Rect
}


/**
 * Represents display settings for a single page of a Portable Document Format (PDF) document, such as the page's background color and its encoding type. 
 */
declare class PdfPageRenderOptions {

    /**
     * Creates and initializes a new instance of display settings for a single page of a Portable Document Format (PDF) document. 
     */
    constructor(): this;

    /**
     * Gets or sets the Portable Document Format (PDF) page's background color. 
     */
    backgroundColor: undefined.Color;

    /**
     * Gets or sets the Portable Document Format (PDF) page's encoding type to be used while the page is being converted to a bitmap. 
     */
    bitmapEncoderId: string;

    /**
     * Gets or sets the final size of the rendering of the Portable Document Format (PDF) page in device-independent pixels (DIPs). 
     */
    destinationHeight: number;

    /**
     * Gets or sets the final size of the rendering of the Portable Document Format (PDF) page in device-independent pixels (DIPs). 
     */
    destinationWidth: number;

    /**
     * Gets or sets whether the Portable Document Format (PDF) page uses the system's high contrast display setting. 
     */
    isIgnoringHighContrast: boolean;

    /**
     * Gets or sets a portion of the Portable Document Format (PDF) page to be displayed. 
     */
    sourceRect: undefined.Rect
}


/**
 * Identifies an alternate form of the word represented by a WordSegment object.. For example, this may contain a number in a normalized format. 
 */
declare class AlternateWordForm {

    /**
     * Gets the text of the alternate word form identified by this AlternateWordForm object. 
     */
    alternateText: string;

    /**
     * Gets the normalization format for this current AlternateWordForm object. 
     */
    normalizationFormat: undefined.AlternateNormalizationFormat;

    /**
     * Gets the TextSegment that identifies the source text's sub-string for which this AlternateWordForm object is an alternate. 
     */
    sourceTextSegment: undefined.TextSegment
}


/**
 * Represents a segment from your provided text that includes a word and any trailing whitespace and/or punctuation after this word. 
 */
declare class SelectableWordSegment {

    /**
     * Gets the TextSegment that identifies the source text's sub-string that is the selected word. 
     */
    sourceTextSegment: undefined.TextSegment;

    /**
     * Gets the text of the selected word identified by this SelectableWordSegment object. 
     */
    text: string
}


/**
 * A segmenter class that is able to segment provided text into units appropriate for selecting text by words. 
 */
declare class SelectableWordsSegmenter {

    /**
     * Creates a SelectableWordsSegmenter object. See the introduction in SelectableWordsSegmenter for a description of how the language supplied to this constructor is used.
     * @param language A BCP-47 language tag.
     */
    constructor(language: string): this;

    /**
     * Determines and returns the selectable word which contains or follows a specified index into the provided text.
     * @param text Provided text in which a word is to be selected.
     * @param startIndex A zero-based index into text. It must be less than the length of text.
     * @return  A SelectableWordSegment that represents the selected word.
     */
    getTokenAt(text: string, startIndex: number): undefined.SelectableWordSegment;

    /**
     * Determines and returns all of the selectable words in the provided text.
     * @param text Provided text containing words to be selected.
     * @return  A collection of SelectableWordSegment objects that represent the selectable words.
     */
    getTokens(text: string): undefined.IVectorView<undefined.SelectableWordSegment>;

    /**
     * Gets the language of the rules used by this SelectableWordsSegmenter object. 
     */
    resolvedLanguage: string;

    /**
     * Calls the provided handler with two iterators that iterate through the selectable words prior to and following a given index into the provided text.
     * @param text Provided text containing words to be selected.
     * @param startIndex A zero-based index into text. It must be less than the length of text.
     * @param handler The function that receives the iterators.
     */
    tokenize(
        text: string,
        startIndex: number,
        handler: undefined.SelectableWordSegmentsTokenizingHandler): void
}


/**
 * Permits apps to perform text queries using Advanced Query Syntax (AQS) strings, with the option of providing a language tag to be employed in the query. 
 */
declare class SemanticTextQuery {

    /**
     * Creates a SemanticTextQuery from an Advanced Query Syntax (AQS) query string and a language tag.
     * @param aqsFilter An AQS string that contains the desired query. Learn more about AQS in Advanced Query Syntax (AQS).
     * @param filterLanguage The BCP-47 language tag to be employed in the query.
     */
    constructor(aqsFilter: string, filterLanguage: string): this;

    /**
     * Creates a SemanticTextQuery from an Advanced Query Syntax (AQS) query string.
     * @param aqsFilter An AQS string that contains the desired query. Learn more about AQS in Advanced Query Syntax (AQS).
     */
    constructor(aqsFilter: string): this;

    /**
     * Returns segments of a source string that match the SemanticTextQuery object's query.
     * @param content A source string to be queried.
     * @return  A collection of TextSegment structures that represent hits from the query.
     */
    find(content: string): undefined.IVectorView<undefined.TextSegment>;

    /**
     * Returns segments of a source string that match the SemanticTextQuery object's query over properties.
     * @param propertyContent A source string to be queried.
     * @param propertyName The name of the property.
     * @return  A collection of TextSegment structures that represent hits from the query.
     */
    findInProperty(
        propertyContent: string,
        propertyName: string): undefined.IVectorView<undefined.TextSegment >
}


/**
 * Converts input phonetic characters into a collection of corresponding ideographic characters (Chinese characters). 
 */
declare class TextConversionGenerator {

    /**
     * Constructs a TextConversionGenerator object based on a specific BCP-47 language tag.
     * @param languageTag The BCP-47 language tag of the language in which the words are to be projected. Japanese ("ja") and Simplified Chinese ("zh-Hans") are supported.
     */
    constructor(languageTag: string): this;

    /**
     * Asynchronously gets a list of candidate words based on the provided phonetic characters.
     * @param input The phonetic characters of the words to be returned.
     * @return  An asynchronous operation to return an IVectorView of the list of candidate words.
     */
    getCandidatesAsync(
        input: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously gets a list of candidate words, up to a maximum count, based on the provided phonetic characters.
     * @param input The phonetic characters of the words to be returned.
     * @param maxCandidates The maximum number of candidate words to return.
     * @return  An asynchronous operation to return an IVectorView of the list of candidate words.
     */
    getCandidatesAsync(
        input: string,
        maxCandidates: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Determines if the language tag specified is available for conversions, but is not installed on the user's device. 
     */
    languageAvailableButNotInstalled: boolean;

    /**
     * Gets the language tag of the successfully created TextConversionGenerator object. 
     */
    resolvedLanguage: string
}


/**
 * Predicts Japanese words based on a phonetic characters prefix. 
 */
declare class TextPredictionGenerator {

    /**
     * Constructs a TextPredictionGenerator object based on a specific BCP-47 language tag.
     * @param languageTag The BCP-47 language tag of the language in which the words are to be projected. Only Japanese ("ja") is supported.
     */
    constructor(languageTag: string): this;

    /**
     * Asynchronously gets a list of candidate words based on the provided phonetic characters prefix.
     * @param input The beginning phonetic characters of the words to be returned.
     * @return  An asynchronous operation to return an IVectorView of the list of predicted words.
     */
    getCandidatesAsync(
        input: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously gets a list of candidate words, up to a maximum count, based on the provided phonetic characters prefix.
     * @param input The beginning phonetic characters of the words to be returned.
     * @param maxCandidates The maximum number of predicted words to return.
     * @return  An asynchronous operation to return an IVectorView of the list of predicted words.
     */
    getCandidatesAsync(
        input: string,
        maxCandidates: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Determines if the language tag specified is available for generating predictions, but is not installed on the user's device. 
     */
    languageAvailableButNotInstalled: boolean;

    /**
     * Gets the language tag of the successfully created TextPredictionGenerator object. 
     */
    resolvedLanguage: string
}


/**
 * Reverse-converts a Japanese string which is mix of phonetic and ideographic characters, to a string of phonetic characters. 
 */
declare class TextReverseConversionGenerator {

    /**
     * Constructs a TextReverseConversionGenerator object based on a specific BCP-47 language tag.
     * @param languageTag The BCP-47 language tag of the language in which the words are to be reverse-converted. Only Japanese ("ja") is supported.
     */
    constructor(languageTag: string): this;

    /**
     * Asynchronously reverse-converts a string which contains ideographic characters to a phonetic expression.
     * @param input The string containing ideographic characters to be reverse-converted.
     * @return  An asynchronous operation to return the phonetic expression.
     */
    convertBackAsync(input: string): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Determines if the language tag specified is available for reverse conversions, but is not installed on the user's device. 
     */
    languageAvailableButNotInstalled: boolean;

    /**
     * Gets the language tag of the successfully created TextReverseConversionGenerator object. 
     */
    resolvedLanguage: string
}


/**
 * Provides a way for apps to get information about Unicode characters. 
 */
declare class UnicodeCharacters {

    /**
     * Returns the supplementary Unicode character for the specified high and low surrogate pair.
     * @param highSurrogate The high surrogate value. This must be in the proper range: 0xD800 <= highSurrogate <= 0xDBFF.
     * @param lowSurrogate The low surrogate value. This must be in the proper range: 0xDC00 <= lowSurrogate <= 0xDFFF.
     * @return  The supplementary Unicode character.
     */
    getCodepointFromSurrogatePair(highSurrogate: number, lowSurrogate: number): number;

    /**
     * Returns the UnicodeGeneralCategory of the specified Unicode character.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  The Unicode general category for codepoint.
     */
    getGeneralCategory(codepoint: number): undefined.UnicodeGeneralCategory;

    /**
     * Returns the UnicodeNumericType of the specified Unicode character.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  The Unicode numeric type for codepoint.
     */
    getNumericType(codepoint: number): undefined.UnicodeNumericType;

    /**
     * Returns the high and low surrogate pair values for the specified supplementary Unicode character.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     */
    getSurrogatePairFromCodepoint(codepoint: number): {
        highSurrogate: string,
        lowSurrogate: string
    };

    /**
     * Determines if a specified Unicode character can be considered alphabetic.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is alphabetic; otherwise FALSE.
     */
    isAlphabetic(codepoint: number): boolean;

    /**
     * Determines if a specified Unicode character can be considered cased (uppercase, lowercase or titlecase).
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is cased; otherwise FALSE.
     */
    isCased(codepoint: number): boolean;

    /**
     * Determines if a specified Unicode character can be considered the beginning of a grapheme.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is the beginning of a grapheme; otherwise FALSE.
     */
    isGraphemeBase(codepoint: number): boolean;

    /**
     * Determines if a specified Unicode character can be considered to continue a previous grapheme.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint continues the previous grapheme; otherwise FALSE.
     */
    isGraphemeExtend(codepoint: number): boolean;

    /**
     * Determines if a specified Unicode character is a high surrogate.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is a high surrogate; otherwise FALSE.
     */
    isHighSurrogate(codepoint: number): boolean;

    /**
     * Determines if a specified Unicode character can be considered a continuation character of an identifier in programming.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is a continuation character of an identifier in programming; otherwise FALSE.
     */
    isIdContinue(codepoint: number): boolean;

    /**
     * Determines if a specified Unicode character can be considered the start character of an identifier in programming.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is the start character of an identifier in programming; otherwise FALSE.
     */
    isIdStart(codepoint: number): boolean;

    /**
     * Determines if a specified Unicode character is a low surrogate.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is a low surrogate; otherwise FALSE.
     */
    isLowSurrogate(codepoint: number): boolean;

    /**
     * Determines if a specified Unicode character can be considered a lower case character.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is a lower case character; otherwise FALSE.
     */
    isLowercase(codepoint: number): boolean;

    /**
     * Determines if a specified codepoint is a non-character.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is a non-character; otherwise FALSE.
     */
    isNoncharacter(codepoint: number): boolean;

    /**
     * Determines if a specified Unicode character is a supplementary character.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is a supplementary character; otherwise FALSE.
     */
    isSupplementary(codepoint: number): boolean;

    /**
     * Determines if a specified Unicode character can be considered an upper case character.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is an upper case character; otherwise FALSE.
     */
    isUppercase(codepoint: number): boolean;

    /**
     * Determines if a specified Unicode character can be considered whitespace.
     * @param codepoint A Unicode character. This must be in the proper range: 0 <= codepoint <= 0x10FFFF.
     * @return  TRUE if codepoint is whitespace; otherwise FALSE.
     */
    isWhitespace(codepoint: number): boolean
}


/**
 * Represents a word from your provided text. 
 */
declare class WordSegment {

    /**
     * Gets the alternate forms (if any) associated with the current word. 
     */
    alternateForms: undefined.IVectorView<undefined.AlternateWordForm>;

    /**
     * Gets the TextSegment that identifies the source text's sub-string that is a word. 
     */
    sourceTextSegment: undefined.TextSegment;

    /**
     * Gets the text of the word identified by this WordSegment object. 
     */
    text: string
}


/**
 * A segmenter class that is able to segment provided text into words. 
 */
declare class WordsSegmenter {

    /**
     * Creates a WordsSegmenter object. See the introduction in WordsSegmenter for a description of how the language supplied to this constructor is used.
     * @param language A BCP-47 language tag.
     */
    constructor(language: string): this;

    /**
     * Determines and returns the word which contains or follows a specified index into the provided text.
     * @param text Provided text from which the word is to be returned.
     * @param startIndex A zero-based index into text. It must be less than the length of text.
     * @return  A WordSegment that represents the word.
     */
    getTokenAt(text: string, startIndex: number): undefined.WordSegment;

    /**
     * Determines and returns all of the words in the provided text.
     * @param text Provided text containing words to be returned.
     * @return  A collection of WordSegment objects that represent the words.
     */
    getTokens(text: string): undefined.IVectorView<undefined.WordSegment>;

    /**
     * Gets the language of the rules used by this WordsSegmenter object. 
     */
    resolvedLanguage: string;

    /**
     * Calls the provided handler with two iterators that iterate through the words prior to and following a given index into the provided text.
     * @param text Provided text containing words to be returned.
     * @param startIndex A zero-based index into text. It must be less than the length of text.
     * @param handler The function that receives the iterators.
     */
    tokenize(
        text: string,
        startIndex: number,
        handler: undefined.WordSegmentsTokenizingHandler): void
}


/**
 * Identifies a sub-string of a source text string. Your app can use this structure to obtain the segment of your provided text that is identified by AlternateWordForm , SelectableWordSegment , WordSegment , or SemanticTextQuery . 
 */
declare interface Text$TextSegment {

    /**
     * The number of characters in the associated text segment. 
     */
    length: number,

        /**
         * The zero-based index of the start of the associated text segment. 
         */
        startPosition: number
}


/**
 * Defines the signature of a function that is provided to SelectableWordsSegmenter.Tokenize . 
 */
declare type Text$SelectableWordSegmentsTokenizingHandler = (
    precedingWords: undefined.IIterable<undefined.SelectableWordSegment>,
    words: undefined.IIterable<undefined.SelectableWordSegment>) => void;


/**
 * Defines the signature of a function that is provided to WordsSegmenter.Tokenize . 
 */
declare type Text$WordSegmentsTokenizingHandler = (
    precedingWords: undefined.IIterable<undefined.WordSegment>,
    words: undefined.IIterable<undefined.WordSegment>) => void;


/**
 * Represents a parsed or unparsed entity in the XML document. 
 */
declare class DtdEntity {

    /**
     * Appends a new child node as the last child of the node.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the list of attributes of this node. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Gets the first child node. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children.
     * @return  True if this node has children; otherwise false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the child node list.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the last child node. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * Gets the next sibling of the node in the parent's child list. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. This value is always NULL. 
     */
    nodeValue: any;

    /**
     * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
     */
    normalize(): void;

    /**
     * Gets the notation name. 
     */
    notationName: any;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * Gets the parent node of the node instance. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Returns the namespace prefix. 
     */
    prefix: any;

    /**
     * Gets the previous sibling of the node in the parent's child list. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Gets the public identifier associated with the entity. 
     */
    publicId: any;

    /**
     * Removes the specified child node from the list of children and returns it.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode;

    /**
     * Gets the system identifier associated with the entity. 
     */
    systemId: any
}


/**
 * Contains a notation declared in the DTD or schema. 
 */
declare class DtdNotation {

    /**
     * Appends a new child node as the last child of the node.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the list of attributes of this node. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Gets the first child node. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children.
     * @return  True if this node has children; otherwise false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the child node list.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the last child node. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * Gets the next sibling of the node in the parent's child list. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. 
     */
    nodeValue: any;

    /**
     * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
     */
    normalize(): void;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * Gets the parent node of the node instance. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Gets or sets the namespace prefix. 
     */
    prefix: any;

    /**
     * Gets the previous sibling of the node in the parent's child list. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Gets the public identifier for the notation. 
     */
    publicId: any;

    /**
     * Removes the specified child node from the list of children and returns it.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
     * @param xpath Specifies an XPath expresssion.
     * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode;

    /**
     * Gets the system identifier for the notation. 
     */
    systemId: any
}


/**
 * Represents an attribute of an XmlElement. Valid and default values for the attribute are defined in a document type definition (DTD) or schema. 
 */
declare class XmlAttribute {

    /**
     * This method is not applicable to this class and will throw an exception.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * This method is not applicable to this class and will throw an exception. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Gets the first child node. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children.
     * @return  True if this node has children; otherwise false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the child node list.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the last child node. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * Returns the attribute name. 
     */
    name: string;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * This property is not applicable to this class and will always return null. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. 
     */
    nodeValue: any;

    /**
     * This method is not applicable to this class and will throw an exception. 
     */
    normalize(): void;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * This property is not applicable to this class and will throw an exception. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Gets or sets the namespace prefix. 
     */
    prefix: any;

    /**
     * This property is not applicable to this class and will throw an exception. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Removes the specified child node from the list of children and returns it.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expresssion.
     * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode;

    /**
     * Gets a value that indicates whether the attribute is explicitly specified or derived from a default value in the document type definition (DTD) or schema. 
     */
    specified: boolean;

    /**
     * Gets or sets the attribute value. 
     */
    value: string
}


/**
 * Represents a CDATA section of an XML document. 
 */
declare class XmlCDataSection {

    /**
     * This method is not applicable to this class. The CDataSection does not have children. This method will throw an exception.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Appends the supplied string to the existing string data.
     * @param data The data to be appended to the existing string.
     */
    appendData(data: string): void;

    /**
     * Gets the list of attributes of this node. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. This property always returns NULL. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Gets or sets the node data depending on the node type. 
     */
    data: string;

    /**
     * Deletes specified data.
     * @param offset The offset, in characters, at which to start deleting the string data.
     * @param count The number of characters to delete.
     */
    deleteData(offset: number, count: number): void;

    /**
     * Gets the first child node. This property always returns NULL. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children. The CDataSection does not have children. This method always returns false.
     * @return  True if this node has children; otherwise false. This method always returns false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the child node list. This method is not applicable to this class and will throw an exception.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Inserts a string at the specified offset.
     * @param offset The offset, in characters, at which to insert the supplied string data.
     * @param data The data to be inserted into the existing string.
     */
    insertData(offset: number, data: string): void;

    /**
     * Gets the last child node. This property always returns NULL because the CDataSection does not have children. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Gets the length of the data, in Unicode characters. 
     */
    length: number;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * Gets the next sibling of the node in the parent's child list. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. 
     */
    nodeValue: any;

    /**
     * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
     */
    normalize(): void;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * Gets the parent node of the node instance. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Gets or sets the namespace prefix. 
     */
    prefix: any;

    /**
     * Gets the previous sibling of the node in the parent's child list. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Removes the specified child node from the list of children and returns it. This method is not applicable to this class as the CDataSection does not have children. This method will throw an exception.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node. This method is not applicable to this class as the CDataSection does not have children. This method will throw an exception.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified number of characters with the supplied string.
     * @param offset The offset, in characters, at which to start replacing string data.
     * @param count The number of characters to replace.
     * @param data The new data that replaces the old string data.
     */
    replaceData(offset: number, count: number, data: string): void;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
     * @param xpath Specifies an XPath expresssion.
     * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode;

    /**
     * Splits this text node into two text nodes at the specified offset and inserts the new text node into the tree as a sibling that immediately follows this node.
     * @param offset The number of characters at which to split this text node into two nodes, starting from zero.
     * @return  The new text node.
     */
    splitText(offset: number): undefined.IXmlText;

    /**
     * Retrieves a substring of the full string from the specified range.
     * @param offset Specifies the offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
     * @param count Specifies the number of characters to retrieve from the specified offset.
     * @return  The returned substring.
     */
    substringData(offset: number, count: number): string
}


/**
 * Represents an XML comment. 
 */
declare class XmlComment {

    /**
     * Appends a new child node as the last child of the node. This method is not applicable to this class and it will throw an exception.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Appends the supplied string to the existing string data.
     * @param data The data to be appended to the existing string.
     */
    appendData(data: string): void;

    /**
     * Gets the list of attributes of this node. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. This method always returns NULL. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Gets or sets the node data depending on the node type. 
     */
    data: string;

    /**
     * Deletes the specified data.
     * @param offset The offset, in characters, at which to start deleting the string data.
     * @param count The number of characters to delete.
     */
    deleteData(offset: number, count: number): void;

    /**
     * Gets the first child node. This property always returns NULL. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children.
     * @return  True if this node has children; otherwise false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the list. This method is not applicable to this class and will throw an exception.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Inserts a string at the specified offset.
     * @param offset The offset, in characters, at which to insert the supplied string data.
     * @param data The data to be inserted into the existing string.
     */
    insertData(offset: number, data: string): void;

    /**
     * Gets the last child node. This property always returns NULL. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Gets the length of the data in Unicode characters. 
     */
    length: number;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * Gets the next sibling of the node in the parent's child list. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. 
     */
    nodeValue: any;

    /**
     * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
     */
    normalize(): void;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * Gets the parent node of the node instance. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Gets or sets the namespace prefix. 
     */
    prefix: any;

    /**
     * Gets the previous sibling of the node in the parent's child list. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Removes the specified child node from the list of children and returns it. This method is not applicable to this class and will throw an exception.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node. This method is not applicable to this class and will throw an exception.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified number of characters with the supplied string.
     * @param offset The offset, in characters, at which to start replacing string data.
     * @param count The number of characters to replace.
     * @param data The new data that replaces the old string data.
     */
    replaceData(offset: number, count: number, data: string): void;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList . This method is not applicable to this class and will throw an exception.
     * @param xpath Specifies an XPath expresssion.
     * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node. This method is not applicable to this class and will throw an exception.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode;

    /**
     * Retrieves a substring of the full string from the specified range.
     * @param offset Specifies the offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
     * @param count Specifies the number of characters to retrieve from the specified offset.
     * @return  The returned substring.
     */
    substringData(offset: number, count: number): string
}


/**
 * Represents the top level of the XML source. This class includes members for retrieving and creating all other XML objects. 
 */
declare class XmlDocument {

    /**
     * Asynchronously loads an XML document from the specified file. The document is parsed using the provided settings.
     * @param file The file from which to load the document.
     * @param loadSettings Settings for customizing parser behavior.
     * @return  The object that must be used to start the operation.
     */
    loadFromFileAsync(
        file: undefined.IStorageFile,
        loadSettings: undefined.XmlLoadSettings): undefined.IPromiseWithIAsyncOperation<undefined.XmlDocument>;

    /**
     * Asynchronously loads an XML document from the specified file. The document is parsed using the default parser settings.
     * @param file The file from which to load the document.
     * @return  The object that must be used to start the operation.
     */
    loadFromFileAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.XmlDocument>;

    /**
     * Asynchronously loads an XML document from the specified location. The document is parsed using the provided settings.
     * @param uri A URL that specifies the location of the XML file.
     * @param loadSettings Customizes parser behavior.
     * @return  An object that must be used to start the operation.
     */
    loadFromUriAsync(
        uri: undefined.Uri,
        loadSettings: undefined.XmlLoadSettings): undefined.IPromiseWithIAsyncOperation<undefined.XmlDocument>;

    /**
     * Asynchronously loads an XML document from the specified location. The document is parsed using the default parser settings.
     * @param uri A URL that specifies the location of the XML file.
     * @return  The object that must be used to start the operation.
     */
    loadFromUriAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperation<undefined.XmlDocument>;

    /**
     * Creates a new instance of the XmlDocument class. 
     */
    constructor(): this;

    /**
     * Appends a new child node as the last child of the node.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the list of attributes of this node. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Creates a new attribute with the specified name.
     * @param name The name of the new attribute object. This name is subsequently available as the new node's NodeName property.
     * @return  The newly created attribute.
     */
    createAttribute(name: string): undefined.XmlAttribute;

    /**
     * Creates a new attribute with the specified namespace and name.
     * @param namespaceUri The name of the desired namespace or a null value if no namespace is desired.
     * @param qualifiedName The name of the new attribute object. This name is subsequently available as the new node's NodeName property.
     * @return  The newly created attribute.
     */
    createAttributeNS(namespaceUri: any, qualifiedName: string): undefined.XmlAttribute;

    /**
     * Creates a CDATA section node that contains the supplied data.
     * @param data The value to be supplied to the new CDATA section object's NodeValue property.
     * @return  The newly created object.
     */
    createCDataSection(data: string): undefined.XmlCDataSection;

    /**
     * Creates a comment node that contains the supplied data.
     * @param data The value to be supplied to the new comment object's NodeValue .
     * @return  The newly created comment node.
     */
    createComment(data: string): undefined.XmlComment;

    /**
     * Creates an empty XmlDocumentFragment object.
     * @return  The newly created object.
     */
    createDocumentFragment(): undefined.XmlDocumentFragment;

    /**
     * Creates an element node using the specified name.
     * @param tagName The name for the new element node. The string is case-sensitive. This name is subsequently available as the element node's NodeName property.
     * @return  The newly created object.
     */
    createElement(tagName: string): undefined.XmlElement;

    /**
     * Creates an element node using the specified namespace and name.
     * @param namespaceUri The name of the desired namespace or a null value if no namespace is desired.
     * @param qualifiedName The name for the new element node. It is case-sensitive. This name is subsequently available as the element node's NodeName property.
     * @return  The newly created object.
     */
    createElementNS(namespaceUri: any, qualifiedName: string): undefined.XmlElement;

    /**
     * Creates a new XmlEntityReference object.
     * @param name The name of the entity referenced. This name is subsequently available as the new object's NodeName property.
     * @return  The newly created object.
     */
    createEntityReference(name: string): undefined.XmlEntityReference;

    /**
     * Creates a processing instruction node that contains the supplied target and data.
     * @param target The target part of the processing instruction. It supplies the NodeName property of the new object.
     * @param data The remainder of the processing instruction preceding the closing ?> characters. It supplies the NodeValue property for the new object.
     * @return  The newly created object.
     */
    createProcessingInstruction(target: string, data: string): undefined.XmlProcessingInstruction;

    /**
     * Creates a text node that contains the supplied data.
     * @param data The value to be supplied to the new text object's NodeValue .
     * @return  The created text node.
     */
    createTextNode(data: string): undefined.XmlText;

    /**
     * For XML, this property gets the address of the node that specifies the DTD. This property returns Null for for HTML documents and XML documents without a DTD. 
     */
    doctype: undefined.XmlDocumentType;

    /**
     * Gets the root element of the document. 
     */
    documentElement: undefined.XmlElement;

    /**
     * Returns the URL for the last loaded XML document. 
     */
    documentUri: string;

    /**
     * Gets the first child node. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the element that matches the ID attribute.
     * @param elementId The ID to match.
     * @return  The element that matches the supplied ID. If no elements match, this method returns Null.
     */
    getElementById(elementId: string): undefined.XmlElement;

    /**
     * Returns a collection of elements that have the specified name.
     * @param tagName The element name to find. The value "*" returns all elements in the document.
     * @return  The collection of elements that match the specified name.
     */
    getElementsByTagName(tagName: string): undefined.XmlNodeList;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children.
     * @return  True if this node has children; otherwise false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the Implementation object for the document. 
     */
    implementation: undefined.XmlDomImplementation;

    /**
     * Imports a node from another document to this document.
     * @param node The object to be cloned.
     * @param deep If true, any children of node will be cloned as well. If false, no children of the node will be cloned.
     * @return  The imported node.
     */
    importNode(node: undefined.IXmlNode, deep: boolean): undefined.IXmlNode;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the child node list.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the last child node. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Loads an XML document using the supplied string. The document is parsed using the settings provided.
     * @param xml The XML string to load into this XML document object. This string can contain an entire XML document or a well-formed fragment.
     * @param loadSettings The settings for parsing the document.
     */
    loadXml(xml: string, loadSettings: undefined.XmlLoadSettings): void;

    /**
     * Loads an XML document using the supplied string. The document is parsed using the default parser settings.
     * @param xml The XML string to load into this XML document object. This string can contain an entire XML document or a well-formed fragment.
     */
    loadXml(xml: string): void;

    /**
     * Loads an XML document using the buffer. The document is parsed using the default parser settings.
     * @param buffer The buffer to load into this XML document object. This buffer can contain an entire XML document or a well-formed fragment.
     */
    loadXmlFromBuffer(buffer: undefined.IBuffer): void;

    /**
     * Loads an XML document using the buffer. The document is parsed using the settings provided.
     * @param buffer The buffer to load into this XML document object. This buffer can contain an entire XML document or a well-formed fragment.
     * @param loadSettings The settings for parsing the document.
     */
    loadXmlFromBuffer(buffer: undefined.IBuffer, loadSettings: undefined.XmlLoadSettings): void;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * Gets the next sibling of the node in the parent's child list. This property is not applicable to this class. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. 
     */
    nodeValue: any;

    /**
     * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
     */
    normalize(): void;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * Gets the parent node of the node instance. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Gets or sets the namespace prefix. 
     */
    prefix: any;

    /**
     * Gets the previous sibling of the node in the parent's child list. This property is not applicable to this class. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Removes the specified child node from the list of children and returns it.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Asynchronously saves an XML document to the specified file.
     * @param file The file to save the document to.
     * @return  The object that must be used to start the operation.
     */
    saveToFileAsync(file: undefined.IStorageFile): undefined.IPromiseWithIAsyncAction;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode
}


/**
 * Represents a lightweight object that is useful for tree insertion operations. 
 */
declare class XmlDocumentFragment {

    /**
     * Appends a new child node as the last child of the node.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the list of attributes of this node. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Gets the first child node. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children.
     * @return  True if this node has children; otherwise false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the list.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the last child node. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * Gets the next sibling of the node in the parent's child list. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. 
     */
    nodeValue: any;

    /**
     * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
     */
    normalize(): void;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * Gets the parent node of the node instance. This property is not applicable to this class. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Gets or sets the namespace prefix. 
     */
    prefix: any;

    /**
     * Gets the previous sibling of the node in the parent's child list. This property is not applicable to this class. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Removes the specified child node from the list of children and returns it.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode
}


/**
 * Contains information associated with the document type. 
 */
declare class XmlDocumentType {

    /**
     * Appends a new child node as the last child of the node.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the list of attributes of this node. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Gets a list of the entities declared in the <!DOCTYPE> declaration. 
     */
    entities: undefined.XmlNamedNodeMap;

    /**
     * Gets the first child node. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children.
     * @return  True if this node has children; otherwise false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the list.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the last child node. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * A list of the general entities, both external and internal, that are present in this document. 
     */
    name: string;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * Gets the next sibling of the node in the parent's child list. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. 
     */
    nodeValue: any;

    /**
     * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
     */
    normalize(): void;

    /**
     * Returns a list of the DtdNotation members that are present in the document type declaration. 
     */
    notations: undefined.XmlNamedNodeMap;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * Gets the parent node of the node instance. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Gets or sets the namespace prefix. 
     */
    prefix: any;

    /**
     * Gets the previous sibling of the node in the parent's child list. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Removes the specified child node from the list of children and returns it.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode
}


/**
 * Provides methods that are independent of any particular instance of the document object model. 
 */
declare class XmlDomImplementation {

    /**
     * Indicates support for the specified feature.
     * @param feature Specifies the feature to test. In Level 1, valid feature values are "XML", "DOM", and "MS-DOM" (case-insensitive).
     * @param version Specifies the version number to test. If NULL, tests for implementation of the feature in any version. In Level 1, "1.0" is the valid version value.
     * @return  True if the specified feature is implemented; otherwise false.
     */
    hasFeature(feature: string, version: any): boolean
}


/**
 * Encapsulates information specific to XML Element nodes. 
 */
declare class XmlElement {

    /**
     * Appends a new child node as the last child of the node.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the list of attributes of this node. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Gets the first child node. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the value of the attribute.
     * @param attributeName The name of the required attribute.
     * @return  The string value of the attribute.
     */
    getAttribute(attributeName: string): string;

    /**
     * Returns the value of the attribute.
     * @param namespaceUri The namespace of the attribute to get.
     * @param localName The name of the attribute without the namespace prefix.
     * @return  The string value of the attribute.
     */
    getAttributeNS(namespaceUri: any, localName: string): string;

    /**
     * Returns the attribute node.
     * @param attributeName The name of the required attribute.
     * @return  The returned attribute pointer.
     */
    getAttributeNode(attributeName: string): undefined.XmlAttribute;

    /**
     * Returns the specified attribute from the specified namespace.
     * @param namespaceUri The namespace of the attribute to get.
     * @param localName The name of the attribute without the namespace prefix.
     * @return  The returned attribute pointer.
     */
    getAttributeNodeNS(namespaceUri: any, localName: string): undefined.XmlAttribute;

    /**
     * Returns a list of all descendant elements that match the supplied name.
     * @param tagName The tag of the required elements.
     * @return  The required elements. The list can be empty.
     */
    getElementsByTagName(tagName: string): undefined.XmlNodeList;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children.
     * @return  True if this node has children; otherwise false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the list.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the last child node. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * Gets the next sibling of the node in the parent's child list. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. 
     */
    nodeValue: any;

    /**
     * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
     */
    normalize(): void;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * Gets the parent node of the node instance. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Gets or sets the namespace prefix. 
     */
    prefix: any;

    /**
     * Gets the previous sibling of the node in the parent's child list. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Removes or replaces the named attribute.
     * @param attributeName The name of the attribute to be removed.
     */
    removeAttribute(attributeName: string): void;

    /**
     * Removes the specified attribute from this element in the specified namespace.
     * @param namespaceUri The namespace of attribute to be removed.
     * @param localName The name of the attribute without the namespace prefix.
     */
    removeAttributeNS(namespaceUri: any, localName: string): void;

    /**
     * Removes the specified attribute from this element.
     * @param attributeNode The attribute to be removed.
     * @return  The removed attribute, if any.
     */
    removeAttributeNode(attributeNode: undefined.XmlAttribute): undefined.XmlAttribute;

    /**
     * Removes the specified child node from the list of children and returns it.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode;

    /**
     * Sets the value of the named attribute.
     * @param attributeName The name of the required attribute.
     * @param attributeValue The new value for the attribute.
     */
    setAttribute(attributeName: string, attributeValue: string): void;

    /**
     * Sets the value of the named attribute in the given namespace.
     * @param namespaceUri The namespace of the attribute being set.
     * @param qualifiedName The name of the attribute being set.
     * @param value The new value for the attribute.
     */
    setAttributeNS(namespaceUri: any, qualifiedName: string, value: string): void;

    /**
     * Sets or updates the supplied attribute node on this element.
     * @param newAttribute A pointer to the new attribute.
     * @return  The returned pointer to the previous attribute (if any) with the same name.
     */
    setAttributeNode(newAttribute: undefined.XmlAttribute): undefined.XmlAttribute;

    /**
     * Sets or updates the supplied attribute node on this element. If you are not using any namespaces, then use the SetAttributeNode method.
     * @param newAttribute The node to add to the collection.
     * @return  The attribute successfully added to the collection. If Null, no object is created.
     */
    setAttributeNodeNS(newAttribute: undefined.XmlAttribute): undefined.XmlAttribute;

    /**
     * Gets the element name. 
     */
    tagName: string
}


/**
 * Represents an entity reference node. 
 */
declare class XmlEntityReference {

    /**
     * Appends a new child node as the last child of the node.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the list of attributes of this node. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Gets the first child node. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children.
     * @return  True if this node has children; otherwise false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the list.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the last child node. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * Gets the next sibling of the node in the parent's child list. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. 
     */
    nodeValue: any;

    /**
     * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
     */
    normalize(): void;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * Gets the parent node of the node instance. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Gets or sets the namespace prefix. 
     */
    prefix: any;

    /**
     * Gets the previous sibling of the node in the parent's child list. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Removes the specified child node from the list of children and returns it.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode
}


/**
 * Contains settings that are used during loading and parsing of XML documents. The default settings are chosen for the highest security. This class can be instantiated and is accepted by LoadXml , LoadFromUriAsync , and LoadFromFileAsync . 
 */
declare class XmlLoadSettings {

    /**
     * Creates a new XmlLoadSettings object. 
     */
    constructor(): this;

    /**
     * Specifies whether default handling preserves white space. 
     */
    elementContentWhiteSpace: boolean;

    /**
     * Gets and sets the limits of the element depth of an XML document to be loaded into a DOM object. 
     */
    maxElementDepth: number;

    /**
     * Gets or sets a value that specifies whether to prohibit or allow the inclusion of a DTD in the XML DOM document. 
     */
    prohibitDtd: boolean;

    /**
     * Gets or sets a value that specifies whether external definitions, resolvable namespaces, external subsets of document type definitions (DTDs), and external entity references are to be resolved at the time the document is parsed. 
     */
    resolveExternals: boolean;

    /**
     * Gets or sets a value that specifies whether the XML parser should validate this document against the document type definition (DTD) on loading. 
     */
    validateOnParse: boolean
}


/**
 * Encapsulates iteration through the collection of attribute nodes. 
 */
declare class XmlNamedNodeMap mixins Array<undefined.IXmlNode>{

    /**
     * Returns an iterator that iterates over the items in the collection.
     * @return  The iterator.
     */
    first(): undefined.IIterator<undefined.IXmlNode>;

    /**
     * Returns the item at the specified index in the vector view.
     * @param index The zero-based index of the item in the vector view to return.
     * @return  The item in the vector view at the specified index.
     */
    getAt(index: number): undefined.IXmlNode;

    /**
     * Returns the items that start at the specified index of the vector view.
     * @param startIndex The zero-based index of the start of the items in the vector to return.
     */
    getMany(startIndex: number): {
        items: undefined.IXmlNode,
        returnValue: number
    };

    /**
     * Retrieves the attribute with the specified name.
     * @param name The name of the attribute.
     * @return  The returned attribute with the specified name. This method returns Null if the attribute node is not in this collection.
     */
    getNamedItem(name: string): undefined.IXmlNode;

    /**
     * Retrieves the attribute with the specified namespace and name.
     * @param namespaceUri The namespace name of the attribute.
     * @param name The name of the attribute.
     * @return  The attribute with the specified namespace and name. This method returns Null if the attribute node is not in this collection.
     */
    getNamedItemNS(namespaceUri: any, name: string): undefined.IXmlNode;

    /**
     * Returns the index of a specified item in the vector view.
     * @param value The item to find in the vector view.
     */
    indexOf(value: undefined.IXmlNode): {
        index: number,
        returnValue: boolean
    };

    /**
     * Allows random access to individual nodes within the collection.
     * @param index The index of the item within the collection. The first item is zero.
     * @return  The object to access. This method returns null if the index is out of range.
     */
    item(index: number): undefined.IXmlNode;

    /**
     * Gets the length of the list of nodes. 
     */
    length: number;

    /**
     * Removes the specified item.
     * @param name The name of the attribute to remove from the collection.
     * @return  The node removed from the collection. This method returns Null if the named node is not an attribute.
     */
    removeNamedItem(name: string): undefined.IXmlNode;

    /**
     * Removes an item that is specified by a namespace and local name.
     * @param namespaceUri The namespace name of the attribute.
     * @param name The name of the attribute.
     * @return  The node removed from the collection. This method returns Null if the named node is not an attribute.
     */
    removeNamedItemNS(namespaceUri: any, name: string): undefined.IXmlNode;

    /**
     * Adds the specified node to the collection.
     * @param node The node to add to the collection.
     * @return  The attribute successfully added to the collection. If Null, no object is created.
     */
    setNamedItem(node: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Adds the specified node to the collection in the specified namespace. If you are not using any namespaces, then use the SetNamedItem method.
     * @param node The node to add to the collection.
     * @return  The attribute successfully added to the collection. If Null, no object is created.
     */
    setNamedItemNS(node: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the number of elements in the vector view. 
     */
    size: number;
    indexOf(
        value: undefined.IXmlNode,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.IXmlNode, fromIndex?: number): number
}


/**
 * Describes a collection of nodes. 
 */
declare class XmlNodeList mixins Array<undefined.IXmlNode>{

    /**
     * Returns an iterator that iterates over the items in the collection.
     * @return  The iterator.
     */
    first(): undefined.IIterator<undefined.IXmlNode>;

    /**
     * Returns the item at the specified index in the vector view.
     * @param index The zero-based index of the item in the vector view to return.
     * @return  The item in the vector view at the specified index.
     */
    getAt(index: number): undefined.IXmlNode;

    /**
     * Returns the items that start at the specified index of the vector view.
     * @param startIndex The zero-based index of the start of the items in the vector to return.
     */
    getMany(startIndex: number): {
        items: undefined.IXmlNode,
        returnValue: number
    };

    /**
     * Returns the index of a specified item in the vector.
     * @param value The item to find in the vector.
     */
    indexOf(value: undefined.IXmlNode): {
        index: number,
        returnValue: boolean
    };

    /**
     * Returns the item in the list at the specified index.
     * @param index The zero-based index of the requested item.
     * @return  The requested item. This method returns NULL if the index is not valid.
     */
    item(index: number): undefined.IXmlNode;

    /**
     * Gets the length of the list. 
     */
    length: number;

    /**
     * Gets the number of elements in the vector view. 
     */
    size: number;
    indexOf(
        value: undefined.IXmlNode,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.IXmlNode, fromIndex?: number): number
}


/**
 * Represents a processing instruction, which XML defines to keep processor-specific information in the text of the document. 
 */
declare class XmlProcessingInstruction {

    /**
     * Appends a new child node as the last child of the node.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the list of attributes of this node. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Gets or sets the content of the processing instruction, excluding the target. 
     */
    data: string;

    /**
     * Gets the first child node. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children.
     * @return  True if this node has children; otherwise false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the list.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Gets the last child node. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * Gets the next sibling of the node in the parent's child list. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. 
     */
    nodeValue: any;

    /**
     * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
     */
    normalize(): void;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * Gets the parent node of the node instance. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Gets or sets the namespace prefix. 
     */
    prefix: any;

    /**
     * Gets the previous sibling of the node in the parent's child list. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Removes the specified child node from the list of children and returns it.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode;

    /**
     * Gets the target for the processing instruction. 
     */
    target: string
}


/**
 * Represents the text content of an element. 
 */
declare class XmlText {

    /**
     * Appends a new child node as the last child of the node.
     * @param newChild The new child node to be appended to the end of the list of children of this node.
     * @return  The new child node successfully appended to the list. If null, no object is created.
     */
    appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Appends the supplied string to the existing string data.
     * @param data The data to be appended to the existing string.
     */
    appendData(data: string): void;

    /**
     * Gets the list of attributes of this node. 
     */
    attributes: undefined.XmlNamedNodeMap;

    /**
     * Gets a list of children in the current node. 
     */
    childNodes: undefined.XmlNodeList;

    /**
     * Clones a new node.
     * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
     * @return  The newly created clone node.
     */
    cloneNode(deep: boolean): undefined.IXmlNode;

    /**
     * Gets or sets the node data depending on the node type. 
     */
    data: string;

    /**
     * Deletes specified data.
     * @param offset The offset, in characters, at which to start deleting the string data.
     * @param count The number of characters to delete.
     */
    deleteData(offset: number, count: number): void;

    /**
     * Gets the first child node. 
     */
    firstChild: undefined.IXmlNode;

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string;

    /**
     * Determines whether a node has children.
     * @return  True if this node has children; otherwise false.
     */
    hasChildNodes(): boolean;

    /**
     * Gets the text from inside the XML. 
     */
    innerText: string;

    /**
     * Inserts a child node to the left of the specified node, or at the end of the list.
     * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
     * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
     * @return  On success, the child node that was inserted. If null, no object is created.
     */
    insertBefore(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Inserts a string at the specified offset.
     * @param offset The offset, in characters, at which to insert the supplied string data.
     * @param data The data to be inserted into the existing string.
     */
    insertData(offset: number, data: string): void;

    /**
     * Gets the last child node. 
     */
    lastChild: undefined.IXmlNode;

    /**
     * Gets the length of the data, in Unicode characters. 
     */
    length: number;

    /**
     * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
     */
    localName: any;

    /**
     * Returns the Uniform Resource Identifier (URI) for the namespace. 
     */
    namespaceUri: any;

    /**
     * Gets the next sibling of the node in the parent's child list. 
     */
    nextSibling: undefined.IXmlNode;

    /**
     * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
     */
    nodeName: string;

    /**
     * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
     */
    nodeType: undefined.NodeType;

    /**
     * Gets or sets the text associated with the node. 
     */
    nodeValue: any;

    /**
     * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
     */
    normalize(): void;

    /**
     * Returns the root of the document that contains the node. 
     */
    ownerDocument: undefined.XmlDocument;

    /**
     * Gets the parent node of the node instance. 
     */
    parentNode: undefined.IXmlNode;

    /**
     * Gets or sets the namespace prefix. 
     */
    prefix: any;

    /**
     * Gets the previous sibling of the node in the parent's child list. 
     */
    previousSibling: undefined.IXmlNode;

    /**
     * Removes the specified child node from the list of children and returns it.
     * @param childNode The child node to be removed from the list of children of this node.
     * @return  The removed child node. If null, the childNode object is not removed.
     */
    removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified old child node with the supplied new child node.
     * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
     * @param referenceChild The old child that is to be replaced by the new child.
     * @return  The old child that is replaced. If null, no object is created.
     */
    replaceChild(
        newChild: undefined.IXmlNode,
        referenceChild: undefined.IXmlNode): undefined.IXmlNode;

    /**
     * Replaces the specified number of characters with the supplied string.
     * @param offset The offset, in characters, at which to start replacing string data.
     * @param count The number of characters to replace.
     * @param data The new data that replaces the old string data.
     */
    replaceData(offset: number, count: number, data: string): void;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
     */
    selectNodes(xpath: string): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList .
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
     */
    selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
     */
    selectSingleNode(xpath: string): undefined.IXmlNode;

    /**
     * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
     * @param xpath Specifies an XPath expression.
     * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
     * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
     */
    selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode;

    /**
     * Splits this text node into two text nodes at the specified offset and inserts the new text node into the tree as a sibling that immediately follows this node.
     * @param offset The number of characters at which to split this text node into two nodes, starting from zero.
     * @return  The new text node.
     */
    splitText(offset: number): undefined.IXmlText;

    /**
     * Retrieves a substring of the full string from the specified range.
     * @param offset The offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
     * @param count The number of characters to retrieve from the specified offset.
     * @return  The returned substring.
     */
    substringData(offset: number, count: number): string
}


/**
 * Contains information for the entire Document Object Model. This interface represents a single node in the document tree. While all objects that implement this interface expose methods for dealing with children, not all objects that implement this interface may have children. 
 */
declare type Dom$IXmlNode = {

        /**
         * Appends a new child node as the last child of the node.
         * @param newChild The new child node to be appended to the end of the list of children of this node.
         * @return  The new child node successfully appended to the list. If null, no object is created.
         */
        appendChild(newChild: undefined.IXmlNode): undefined.IXmlNode,

        /**
         * Clones a new node.
         * @param deep A flag that indicates whether to recursively clone all nodes that are descendants of this node. If true, this method creates a clone of the complete tree below this node. If false, this method clones this node and its attributes only.
         * @return  The newly created clone node.
         */
        cloneNode(deep: boolean): undefined.IXmlNode,

        /**
         * Determines whether a node has children.
         * @return  True if this node has children; otherwise false.
         */
        hasChildNodes(): boolean,

        /**
         * Inserts a child node to the left of the specified node, or at the end of the list.
         * @param newChild The address of the new node to be inserted. The node passed here must be a valid child of the current XML DOM document node. For example, if the current node is an attribute, you cannot pass another attribute in the newChild parameter, because an attribute cannot have an attribute as a child. If newChild is a DOCUMENT_FRAGMENT node type, all its children are inserted in order before referenceChild.
         * @param referenceChild The reference node. The node specified is where the newChild node is to be inserted to the left as the preceding sibling in the child list. The node passed here must be a either a child node of the current node or null. If the value is null, the newChild node is inserted at the end of the child list. If the referenceChild node is not a child of the current node, an error is returned.
         * @return  On success, the child node that was inserted. If null, no object is created.
         */
        insertBefore(
            newChild: undefined.IXmlNode,
            referenceChild: undefined.IXmlNode): undefined.IXmlNode,

        /**
         * Normalizes all descendant elements by combining two or more adjacent text nodes into one unified text node. 
         */
        normalize(): void,

        /**
         * Removes the specified child node from the list of children and returns it.
         * @param childNode The child node to be removed from the list of children of this node.
         * @return  The removed child node. If null, the childNode object is not removed.
         */
        removeChild(childNode: undefined.IXmlNode): undefined.IXmlNode,

        /**
         * Replaces the specified old child node with the supplied new child node.
         * @param newChild The new child that is to replace the old child. If null, the referenceChild parameter is removed without a replacement.
         * @param referenceChild The old child that is to be replaced by the new child.
         * @return  The old child that is replaced. If null, no object is created.
         */
        replaceChild(
            newChild: undefined.IXmlNode,
            referenceChild: undefined.IXmlNode): undefined.IXmlNode,

        /**
         * Gets the list of attributes of this node. 
         */
        attributes: undefined.XmlNamedNodeMap,

        /**
         * Gets a list of children in the current node. 
         */
        childNodes: undefined.XmlNodeList,

        /**
         * Gets the first child node. 
         */
        firstChild: undefined.IXmlNode,

        /**
         * Gets the last child node. 
         */
        lastChild: undefined.IXmlNode,

        /**
         * Gets the local name, which is the local part of a qualified name. This is called the local part in Namespaces in XML. 
         */
        localName: any,

        /**
         * Returns the Uniform Resource Identifier (URI) for the namespace. 
         */
        namespaceUri: any,

        /**
         * Gets the next sibling of the node in the parent's child list. 
         */
        nextSibling: undefined.IXmlNode,

        /**
         * Returns the qualified name for attribute, document type, element, entity, or notation nodes. Returns a fixed string for all other node types. 
         */
        nodeName: string,

        /**
         * Gets the XML Document Object Model (DOM) node type, which determines valid values and whether the node can have child nodes. 
         */
        nodeType: undefined.NodeType,

        /**
         * Gets or sets the text associated with the node. 
         */
        nodeValue: any,

        /**
         * Returns the root of the document that contains the node. 
         */
        ownerDocument: undefined.XmlDocument,

        /**
         * Gets the parent node of the node instance. 
         */
        parentNode: undefined.IXmlNode,

        /**
         * Gets or sets the namespace prefix. 
         */
        prefix: any,

        /**
         * Gets the previous sibling of the node in the parent's child list. 
         */
        previousSibling: undefined.IXmlNode
    } & &



    /**
     * Represents the text content of an element or attribute. 
     */
    declare type Dom$IXmlText = {

        /**
         * Splits this text node into two text nodes at the specified offset and inserts the new text node into the tree as a sibling that immediately follows this node.
         * @param offset The number of characters at which to split this text node into two nodes, starting from zero.
         * @return  The new text node.
         */
        splitText(offset: number): undefined.IXmlText
    } & & & &



    /**
     * Encapsulates the methods needed to execute XPath queries on an XML DOM tree or subtree. 
     */
    declare interface Dom$IXmlNodeSelector {

        /**
         * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
         * @param xpath Specifies an XPath expression.
         * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, this method returns an empty collection.
         */
        selectNodes(xpath: string): undefined.XmlNodeList,

            /**
             * Applies the specified pattern-matching operation to this node's context and returns the list of matching nodes as an XmlNodeList.
             * @param xpath Specifies an XPath expresssion.
             * @param namespaces Contains a string that specifies namespaces for use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
             * @return  The collection of nodes selected by applying the given pattern-matching operation. If no nodes are selected, returns an empty collection.
             */
            selectNodesNS(xpath: string, namespaces: any): undefined.XmlNodeList,

            /**
             * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
             * @param xpath Specifies an XPath expression.
             * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, the method returns a null value.
             */
            selectSingleNode(xpath: string): undefined.IXmlNode,

            /**
             * Applies the specified pattern-matching operation to this node's context and returns the first matching node.
             * @param xpath Specifies an XPath expression.
             * @param namespaces Contains a string that specifies the namespaces to use in XPath expressions when it is necessary to define new namespaces externally. Namespaces are defined in the XML style, as a space-separated list of namespace declaration attributes. You can use this property to set the default namespace as well.
             * @return  The first node that matches the given pattern-matching operation. If no nodes match the expression, this method returns a null value.
             */
            selectSingleNodeNS(xpath: string, namespaces: any): undefined.IXmlNode
    }


/**
 * Encapsulates the methods needed to serialize a DOM tree or subtree to a string representation. 
 */
declare interface Dom$IXmlNodeSerializer {

    /**
     * Returns the XML representation of the node and all its descendants.
     * @return  The XML representation of the node and all its descendants.
     */
    getXml(): string,

        /**
         * Gets and sets the text from inside the XML. 
         */
        innerText: string
}


/**
 * Provides text manipulation methods that are used by several objects. 
 */
declare type Dom$IXmlCharacterData = {

        /**
         * Appends the supplied string to the existing string data.
         * @param data The data to be appended to the existing string.
         */
        appendData(data: string): void,

        /**
         * Deletes specified data.
         * @param offset The offset, in characters, at which to start deleting the string data.
         * @param count The number of characters to delete.
         */
        deleteData(offset: number, count: number): void,

        /**
         * Inserts a string at the specified offset.
         * @param offset The offset, in characters, at which to insert the supplied string data.
         * @param data The data to be inserted into the existing string.
         */
        insertData(offset: number, data: string): void,

        /**
         * Replaces the specified number of characters with the supplied string.
         * @param offset The offset, in characters, at which to start replacing string data.
         * @param count The number of characters to replace.
         * @param data The new data that replaces the old string data.
         */
        replaceData(offset: number, count: number, data: string): void,

        /**
         * Retrieves a substring of the full string from the specified range.
         * @param offset Specifies the offset, in characters, from the beginning of the string. An offset of zero indicates copying from the start of the data.
         * @param count Specifies the number of characters to retrieve from the specified offset.
         * @return  The returned substring.
         */
        substringData(offset: number, count: number): string,

        /**
         * Gets or sets the node data depending on the node type. 
         */
        data: string,

        /**
         * Gets the length of the data, in Unicode characters. 
         */
        length: number
    } & & &



    /**
     * Provides the methods needed by the Xslt processor. 
     */
    declare class XsltProcessor {

        /**
         * Creates a new XsltProcessor object from the document provided.
         * @param document The XSLT to process.
         */
        constructor(document: undefined.XmlDocument): this;

        /**
         * Processes a node and its children and returns the resulting XmlDocument .
         * @param inputNode The node to process.
         * @return  The resulting transformation.
         */
        transformToDocument(inputNode: undefined.IXmlNode): undefined.XmlDocument;

        /**
         * Processes a node and its children and returns the resulting string transformation.
         * @param inputNode The node to process.
         * @return  The resulting transformation.
         */
        transformToString(inputNode: undefined.IXmlNode): string
    }


/**
 * Represents a single ADC channel. 
 */
declare class AdcChannel {

    /**
     * Closes the connection on this channel, making it available to be opened by others. 
     */
    close(): void;

    /**
     * Gets the ADC controller for this channel. 
     */
    controller: undefined.AdcController;

    /**
     * Reads the value as a percentage of the max value possible for this controller.
     * @return  The value as percentage of the max value.
     */
    readRatio(): number;

    /**
     * Reads the digital representation of the analog value from the ADC.
     * @return  The digital value.
     */
    readValue(): number
}


/**
 * Represents an ADC controller on the system 
 */
declare class AdcController {

    /**
     * Gets all the controllers that are connected to the system asynchronously .
     * @param provider The ADC provider for the controllers on the system.
     * @return  When the method completes successfully, it returns a list of values that represent the controllers available on the system.
     */
    getControllersAsync(
        provider: undefined.IAdcProvider): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the default ADC controller on the system.
     * @return  The default ADC controller on the system, or null if the system has no ADC controller.
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.AdcController>;

    /**
     * The number of channels available on the ADC controller. 
     */
    channelCount: number;

    /**
     * Gets or sets the channel mode for the ADC controller. 
     */
    channelMode: undefined.AdcChannelMode;

    /**
     * Verifies that the specified channel mode is supported by the controller.
     * @param channelMode The channel mode.
     * @return  True if the specified channel mode is supported, otherwise false.
     */
    isChannelModeSupported(channelMode: undefined.AdcChannelMode): boolean;

    /**
     * Gets the maximum value that the controller can report. 
     */
    maxValue: number;

    /**
     * The minimum value the controller can report. 
     */
    minValue: number;

    /**
     * Opens a connection to the specified ADC channel.
     * @param channelNumber The channel to connect to.
     * @return  The ADC channel.
     */
    openChannel(channelNumber: number): undefined.AdcChannel;

    /**
     * Gets the resolution of the controller as number of bits it has. For example, if we have a 10-bit ADC, that means it can detect 1024 (2^10) discrete levels. 
     */
    resolutionInBits: number
}


/**
 * Represents methods common to all ADC providers. 
 */
declare interface Provider$IAdcProvider {

    /**
     * Gets the ADC controllers available on the system.
     * @return  When this method completes it returns a list of all the available controllers on the system.
     */
    getControllers(): undefined.IVectorView<undefined.IAdcControllerProvider >
}


/**
 * Represents properties and methods common to all ADC controllers. 
 */
declare interface Provider$IAdcControllerProvider {

    /**
     * Acquires a connection to the specified channel.
     * @param channel Which channel to connect to.
     */
    acquireChannel(channel: number): void,

        /**
         * Determines if the specified channel mode is supported by the controller.
         * @param channelMode The channel mode in question.
         * @return  True if the specified channel mode is supported, otherwise false.
         */
        isChannelModeSupported(channelMode: undefined.ProviderAdcChannelMode): boolean,

        /**
         * Gets the digital representation of the analog value on the specified channel.
         * @param channelNumber Which channel to read from.
         * @return  The digital representation of the analog value.
         */
        readValue(channelNumber: number): number,

        /**
         * Releases the channel connection, opening that channel for others to use.
         * @param channel Which channel to close the connection to.
         */
        releaseChannel(channel: number): void,

        /**
         * Gets the number of channels available on for the controller. 
         */
        channelCount: number,

        /**
         * Gets or sets the controller channel mode. 
         */
        channelMode: undefined.ProviderAdcChannelMode,

        /**
         * Gets the maximum value that the controller can return. 
         */
        maxValue: number,

        /**
         * Gets the minimum value that the controller can return. 
         */
        minValue: number,

        /**
         * Gets the resolution of the controller as number of bits it has. 
         */
        resolutionInBits: number
}


/**
 * Used to set descriptive information about the app and the device it is running on. 
 */
declare class AllJoynAboutData {

    /**
     * A globally unique identifier associated with the app. 
     */
    appId: string;

    /**
     * A collection of language-specific app names. 
     */
    appNames: undefined.IMap<string, string>;

    /**
     * The date of manufacture. 
     */
    dateOfManufacture: Date;

    /**
     * The default app name assigned by the manufacturer- either the developer or the OEM. This property is a shortcut to the entry in the AppNames property for the DefaultLanguage . 
     */
    defaultAppName: string;

    /**
     * The default description of the app. This property is a shortcut to the entry in the Descriptions property for the DefaultLanguage . 
     */
    defaultDescription: string;

    /**
     * The name of the manufacturer of the app. This property is a shortcut to the entry in the Manufacturers property for the DefaultLanguage . 
     */
    defaultManufacturer: string;

    /**
     * A collection of language-specific app description strings. 
     */
    descriptions: undefined.IMap<string, string>;

    /**
     * Indicates if the service should advertise the provided AllJoynAboutData values. 
     */
    isEnabled: boolean;

    /**
     * A collection of language-specific manufacturer name strings. 
     */
    manufacturers: undefined.IMap<string, string>;

    /**
     * The model number of the device running the app. 
     */
    modelNumber: string;

    /**
     * The version number of the app. Use of this property applies to Producer apps. 
     */
    softwareVersion: string;

    /**
     * A URL to the manufacturer or developer support portal. 
     */
    supportUrl: undefined.Uri
}


/**
 * Used to view data about another app and the device it is running on. 
 */
declare class AllJoynAboutDataView {

    /**
     * Gets the About data for a session in a particular language.
     * @param uniqueName The unique name.
     * @param busAttachment The bus attachment supporting the session.
     * @param sessionPort The port used to connect to the session.
     * @param language The language to return the descriptive data in.
     * @return  An object containing About data for the session in the set language.
     */
    getDataBySessionPortAsync(
        uniqueName: string,
        busAttachment: undefined.AllJoynBusAttachment,
        sessionPort: number,
        language: undefined.Language): undefined.IPromiseWithIAsyncOperation<undefined.AllJoynAboutDataView>;

    /**
     * Gets the About data for a session.
     * @param uniqueName The unique name.
     * @param busAttachment The bus attachment supporting the session.
     * @param sessionPort The port used to connect to the session.
     * @return  An object containing About data for the session.
     */
    getDataBySessionPortAsync(
        uniqueName: string,
        busAttachment: undefined.AllJoynBusAttachment,
        sessionPort: number): undefined.IPromiseWithIAsyncOperation<undefined.AllJoynAboutDataView>;

    /**
     * The version number for the implemented AllJoyn platform software. 
     */
    ajSoftwareVersion: string;

    /**
     * A globally unique identifier associated with the app. 
     */
    appId: string;

    /**
     * The name of the app. 
     */
    appName: string;

    /**
     * The date of manufacture. 
     */
    dateOfManufacture: Date;

    /**
     * The default language of the app. 
     */
    defaultLanguage: undefined.Language;

    /**
     * An app description provided by the manufacturer. 
     */
    description: string;

    /**
     * The device ID used during advertising. 
     */
    deviceId: string;

    /**
     * Name of the device. 
     */
    deviceName: string;

    /**
     * The current version of the hardware that the app is running on. This field is optional, presenting as an empty string if not set. 
     */
    hardwareVersion: string;

    /**
     * The name of the manufacturer. 
     */
    manufacturer: string;

    /**
     * The model number of the device running the app. 
     */
    modelNumber: string;

    /**
     * This is a set of fields, where each other named AllJoynAboutDataView property is also accessible. For example, ModelNumber is Properties ["ModelNumber"]. Additionally, this property can be used to get custom properties. 
     */
    properties: undefined.IMapView<string, any>;

    /**
     * The version number of the app. 
     */
    softwareVersion: string;

    /**
     * The status returned by the GetDataBySessionPortAsync operation that created the AllJoynAboutDataView object. 
     */
    status: number;

    /**
     * A URL to the manufacturer or developer support portal. 
     */
    supportUrl: undefined.Uri;

    /**
     * A list of languages supported by the app and will always include the DefaultLanguage . 
     */
    supportedLanguages: undefined.IVectorView<undefined.Language >
}


/**
 * Contains information about a join session request that is used to determine if the request will be accepted and initiate the session connection. 
 */
declare class AllJoynAcceptSessionJoinerEventArgs {

    /**
     * Generates an object containing information about the connection being accepted to the session and the method that completes the session join.
     * @param uniqueName The unique bus name.
     * @param sessionPort The session port used for the connection.
     * @param trafficType The type of traffic provided over the connection.
     * @param proximity Indicates network proximity.
     * @param acceptSessionJoiner The IAllJoynAcceptSessionJoiner object used to complete the session join.
     */
    constructor(uniqueName: string, sessionPort: number, trafficType: undefined.AllJoynTrafficType, proximity: number, acceptSessionJoiner: undefined.IAllJoynAcceptSessionJoiner): this;

    /**
     * Called to accept the session connection. 
     */
    accept(): void;

    /**
     * Indicates if the app joining the session is on the same network. 
     */
    sameNetwork: boolean;

    /**
     * The app joining the session is on the same physical node. 
     */
    samePhysicalNode: boolean;

    /**
     * The session port being used to connect to the session. 
     */
    sessionPort: number;

    /**
     * The traffic type supported during the session. 
     */
    trafficType: undefined.AllJoynTrafficType;

    /**
     * The unique bus name of the app requesting a session connection. 
     */
    uniqueName: string
}


/**
 * Contains information about a successful or unsuccessful completion of an authentication operation. 
 */
declare class AllJoynAuthenticationCompleteEventArgs {

    /**
     * The mechanism used during authentication. 
     */
    authenticationMechanism: undefined.AllJoynAuthenticationMechanism;

    /**
     * The unique bus name of the Consumer being authenticated. On the initiating side this will be the unique bus name of the remote app being authenticated. On the accepting side this will be the unique bus name for the remote app. 
     */
    peerUniqueName: string;

    /**
     * Indicates if the remote app was authenticated. 
     */
    succeeded: boolean
}


/**
 * Represents a connection to the underlying communication pipeline (transport agnostic) that AllJoyn uses to communicate with other endpoints regardless of the transport. 
 */
declare class AllJoynBusAttachment {

    /**
     * Generates an AllJoynBusAttachment object using the default named pipe connection specification. 
     */
    constructor(): this;

    /**
     * Generates an AllJoynBusAttachment object using the provided connection specification.
     * @param connectionSpecification Specification used to initiate and maintain connections to a router node (bus). Windows 10 supports the 'npipe:' transport, formatted according to the D-Bus Specification.
     */
    constructor(connectionSpecification: string): this;

    /**
     * This property returns an AllJoynAboutData object containing the descriptive data that the platform may advertise on behalf of the app. 
     */
    aboutData: undefined.AllJoynAboutData;

    /**
     * A list of AllJoynAuthenticationMechanism objects representing the acceptable authentication mechanisms. Default values include Rsa and None. 
     */
    authenticationMechanisms: undefined.IVector<undefined.AllJoynAuthenticationMechanism>;

    /**
     * Initiates the connection. 
     */
    connect(): void;

    /**
     * The connection specification used to establish and maintain the bus attachment. If a specification was not provided, this property will retrieve a default named pipe specification. 
     */
    connectionSpecification: string;

    /**
     * Initiates a disconnect operation from the router node (bus). 
     */
    disconnect(): void;

    /**
     * Occurs when verification of supplied credentials is complete. 
     */
    onauthenticationcomplete: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynAuthenticationCompleteEventArgs>;
    addEventListener(
        type: "authenticationcomplete",
        listener: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynAuthenticationCompleteEventArgs>): void;
    removeEventListener(
        type: "authenticationcomplete",
        listener: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynAuthenticationCompleteEventArgs>): void;

    /**
     * Occurs when credentials are requested for authentication. 
     */
    oncredentialsrequested: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynCredentialsRequestedEventArgs>;
    addEventListener(
        type: "credentialsrequested",
        listener: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynCredentialsRequestedEventArgs>): void;
    removeEventListener(
        type: "credentialsrequested",
        listener: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynCredentialsRequestedEventArgs>): void;

    /**
     * Occurs when credentials have been provided by a remote Consumer for verification. 
     */
    oncredentialsverificationrequested: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynCredentialsVerificationRequestedEventArgs>;
    addEventListener(
        type: "credentialsverificationrequested",
        listener: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynCredentialsVerificationRequestedEventArgs>): void;
    removeEventListener(
        type: "credentialsverificationrequested",
        listener: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynCredentialsVerificationRequestedEventArgs>): void;

    /**
     * Occurs when the state of the bus attachment changes. The AllJoynBusAttachmentState enumeration defines the possible state values. 
     */
    onstatechanged: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynBusAttachmentStateChangedEventArgs>;
    addEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynBusAttachmentStateChangedEventArgs>): void;
    removeEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.AllJoynBusAttachment, undefined.AllJoynBusAttachmentStateChangedEventArgs>): void;

    /**
     * Pings the specified connection asynchronously.
     * @param uniqueName The unique name associated with the connection.
     * @return  An AllJoyn status code.
     */
    pingAsync(uniqueName: string): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * The current state of the bus attachment. State changes are surfaced via StateChanged events. Possible values are defined by the AllJoynBusAttachmentState enumeration. 
     */
    state: undefined.AllJoynBusAttachmentState;

    /**
     * The unique bus name associated with the remote app. This unique bus name is used to represent it on the bus via the bus attachment. 
     */
    uniqueName: string;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains information about state and status changes to an AllJoyn bus connection managed by an AllJoynBusAttachment object. 
 */
declare class AllJoynBusAttachmentStateChangedEventArgs {

    /**
     * Indicates the current state of a connection to an AllJoyn bus. 
     */
    state: undefined.AllJoynBusAttachmentState;

    /**
     * Contains a status code that provides status information for AllJoynBusAttachment change events. Properties used in the generation of possible values are defined by AllJoynStatus . 
     */
    status: number
}


/**
 * Defines properties used when passing credentials during authentication. 
 */
declare class AllJoynCredentials {

    /**
     * The mechanism used for credential authentication. 
     */
    authenticationMechanism: undefined.AllJoynAuthenticationMechanism;

    /**
     * The cryptography certificate used for the Rsa and EcdheEcdsa authentication mechanisms. 
     */
    certificate: undefined.Certificate;

    /**
     * The user name, if any, and password used for authentication. 
     */
    passwordCredential: undefined.PasswordCredential;

    /**
     * The period of time before provided credentials expire. 
     */
    timeout: number
}


/**
 * Contains information about a request for credentials in order to authenticate to a peer. 
 */
declare class AllJoynCredentialsRequestedEventArgs {

    /**
     * The number of times the credential request has been tried. 
     */
    attemptCount: number;

    /**
     * The authentication credentials to be filled in by the app. 
     */
    credentials: undefined.AllJoynCredentials;

    /**
     * Allows JavaScript Windows Store apps to handle the verification of provided of credentials asynchronously.
     * @return  The credential request deferral.
     */
    getDeferral(): undefined.Deferral;

    /**
     * The unique bus name of the remote app that provided the requested credentials. 
     */
    peerUniqueName: string;

    /**
     * A user name value used by mechanisms that accept a user name/password pair. 
     */
    requestedUserName: string
}


/**
 * Used to allow the application to indicate whether the credentials provided by a peer are valid. 
 */
declare class AllJoynCredentialsVerificationRequestedEventArgs {

    /**
     * Calling this method indicates that the credentials provided for authentication are valid. 
     */
    accept(): void;

    /**
     * The mechanism used to authenticate credentials. 
     */
    authenticationMechanism: undefined.AllJoynAuthenticationMechanism;

    /**
     * Conducts verification of provided of credentials asynchronously.
     * @return  The verification deferral.
     */
    getDeferral(): undefined.Deferral;

    /**
     * The cryptography certificate provided for authentication. 
     */
    peerCertificate: undefined.Certificate;

    /**
     * The category of an errors encountered authenticating the cryptography certificate. 
     */
    peerCertificateErrorSeverity: undefined.SocketSslErrorSeverity;

    /**
     * A list of errors that occurred during authentication of the provided cryptography certificate. 
     */
    peerCertificateErrors: undefined.IVectorView<undefined.ChainValidationResult>;

    /**
     * Retrieves the intermediate certificates sent during authentication. 
     */
    peerIntermediateCertificates: undefined.IVectorView<undefined.Certificate>;

    /**
     * The unique bus name of the remote app being authenticated. 
     */
    peerUniqueName: string
}


/**
 * Exposes information about the sender of a message being processed. 
 */
declare class AllJoynMessageInfo {

    /**
     * Generates an AllJoynMessageInfo object that contains the unique name of the sender that sent the message being processed.
     * @param senderUniqueName The unique name of the sender.
     */
    constructor(senderUniqueName: string): this;

    /**
     * The unique bus name of the message sender. 
     */
    senderUniqueName: string
}


/**
 * Contains status information that indicates why a Producer app was stopped. 
 */
declare class AllJoynProducerStoppedEventArgs {

    /**
     * Generates an object containing status information for the stopped Producer app.
     * @param status An AllJoyn status code that indicates why the Producer was stopped.
     */
    constructor(status: number): this;

    /**
     * Returns an AllJoyn status code that indicates why the Producer was stopped. Common values are defined by AllJoynStatus . 
     */
    status: number
}


/**
 * Exposes unique name and transport information for an advertising app. 
 */
declare class AllJoynServiceInfo {

    /**
     * Generates an AllJoynServiceInfo object that represents an advertising app. This object provides the unique bus name, object path and transport information.
     * @param uniqueName The unique bus name.
     * @param objectPath The object path.
     * @param sessionPort The port for this session.
     */
    constructor(uniqueName: string, objectPath: string, sessionPort: number): this;

    /**
     * The path to the service object. This path is used to match communications with service objects connected to the session. 
     */
    objectPath: string;

    /**
     * The port used to connect to the session. 
     */
    sessionPort: number;

    /**
     * The unique bus name associated with the advertising app. 
     */
    uniqueName: string
}


/**
 * Contains information that identifies an advertising app that is no longer available. 
 */
declare class AllJoynServiceInfoRemovedEventArgs {

    /**
     * Generates an object containing information about an advertising app that is no longer available.
     * @param uniqueName The unique app name.
     */
    constructor(uniqueName: string): this;

    /**
     * The unique bus name of the advertising app that is no longer available. 
     */
    uniqueName: string
}


/**
 * Contains information that identifies the reason for a lost session. 
 */
declare class AllJoynSessionLostEventArgs {

    /**
     * Generates an AllJoynSessionLostEventArgs object containing information that identifies the reason for the lost session.
     * @param reason The reason the session was lost.
     */
    constructor(reason: undefined.AllJoynSessionLostReason): this;

    /**
     * Retrieves a value that indicates the reason for a lost session. 
     */
    reason: undefined.AllJoynSessionLostReason
}


/**
 * Contains information about a peer that was added to a session. 
 */
declare class AllJoynSessionMemberAddedEventArgs {

    /**
     * Generates an object that contains information about the remote app added to the session.
     * @param uniqueName The unique Consumer name.
     */
    constructor(uniqueName: string): this;

    /**
     * The unique bus name of the remote app new to the session. 
     */
    uniqueName: string
}


/**
 * Contains information about a remote app removed from a session. 
 */
declare class AllJoynSessionMemberRemovedEventArgs {

    /**
     * Generates an object containing information about a remote app removed from a session.
     * @param uniqueName The unique bus name of the remote app removed from the session.
     */
    constructor(uniqueName: string): this;

    /**
     * The unique bus name of the remote app removed from the session. 
     */
    uniqueName: string
}


/**
 * Defines a collection of properties used to convey meaning for AllJoyn status codes. For possible status values, refer to the AllJoyn standard documentation. 
 */
declare class AllJoynStatus {

    /**
     * Indicates that authentication could not be completed. 
     */
    authenticationFailed: number;

    /**
     * Authentication was rejected by the advertising app. 
     */
    authenticationRejectedByUser: number;

    /**
     * The connection to the session was refused. 
     */
    connectionRefused: number;

    /**
     * The operation has failed. 
     */
    fail: number;

    /**
     * Insufficient security provided for session connections. 
     */
    insufficientSecurity: number;

    /**
     * Function call argument 1 is invalid. 
     */
    invalidArgument1: number;

    /**
     * Function call argument 2 is invalid. 
     */
    invalidArgument2: number;

    /**
     * Function call argument 3 is invalid. 
     */
    invalidArgument3: number;

    /**
     * Function call argument 4 is invalid. 
     */
    invalidArgument4: number;

    /**
     * Function call argument 5 is invalid. 
     */
    invalidArgument5: number;

    /**
     * Function call argument 6 is invalid. 
     */
    invalidArgument6: number;

    /**
     * Function call argument 7 is invalid. 
     */
    invalidArgument7: number;

    /**
     * Function call argument 8 is invalid. 
     */
    invalidArgument8: number;

    /**
     * Operation successful. 
     */
    ok: number;

    /**
     * The operation timed out. 
     */
    operationTimedOut: number;

    /**
     * The Producer end of the session connection was closed. 
     */
    otherEndClosed: number;

    /**
     * The SSL connection has failed. 
     */
    sslConnectFailed: number;

    /**
     * The SSL verification failed. Review provided SSL credentials. 
     */
    sslIdentityVerificationFailed: number
}


/**
 * Contains information about the stopped session watcher object. 
 */
declare class AllJoynWatcherStoppedEventArgs {

    /**
     * Generates an AllJoynWatcherStoppedEventArgs object that contains status information that identifies the reason the watcher object was stopped.
     * @param status The AllJoyn status code.
     */
    constructor(status: number): this;

    /**
     * Returns a status code that was returned when the watcher object is stopped. This value is represented by AllJoynStatus . 
     */
    status: number
}


/**
 * Use this interface to accept requests from peers to join a session. 
 */
declare interface AllJoyn$IAllJoynAcceptSessionJoiner {

    /**
     * Accept an incoming request to join the session. 
     */
    accept(): void
}


/**
 * Used to provide the DeviceInformation.ID , expected duration, and arguments given by the app that triggered the background servicing task. 
 */
declare class DeviceServicingDetails {

    /**
     * Gets the arguments string provided by the app when it called RequestAsync on the DeviceServicingTrigger . This allows the app to easily pass parameters to the task when it invokes it. 
     */
    arguments: string;

    /**
     * Gets the DeviceInformation.ID of the device the task is targeting. The background task can provide this to the FromIdAsync method of the appropriate device access class to open the device. For example, call UsbDevice.FromIdAsync in the Windows.Devices.Usb namespace to open a USB device. 
     */
    deviceId: string;

    /**
     * Gets the estimated duration provided by the app when it called RequestAsync on the DeviceServicingTrigger . 
     */
    expectedDuration: number
}


/**
 * Used to provide the DeviceInformation.ID and arguments given by the app that triggered the background sync task. 
 */
declare class DeviceUseDetails {

    /**
     * Gets the arguments string provided by the app when it called RequestAsync on the DeviceUseTrigger . This allows the app to easily pass parameters to the task when it invokes it. 
     */
    arguments: string;

    /**
     * Gets the DeviceInformation.ID of the device the task is targeting. The background task can provide this to the FromIdAsync method of the appropriate device access class to open the device. For example, call UsbDevice.FromIdAsync in the Windows.Devices.Usb namespace to open a USB device. 
     */
    deviceId: string
}


/**
 * A representation of a Bluetooth LE advertisement payload. 
 */
declare class BluetoothLEAdvertisement {

    /**
     * Creates a new BluetoothLEAdvertisement object. 
     */
    constructor(): this;

    /**
     * Gets the list of raw data sections. 
     */
    dataSections: undefined.IVector<undefined.BluetoothLEAdvertisementDataSection>;

    /**
     * Bluetooth LE advertisement flags. 
     */
    flags: undefined.BluetoothLEAdvertisementFlags;

    /**
     * Return a list of all manufacturer data sections in the BluetoothLEAdvertisement payload matching the specified company ID.
     * @param companyId The company identifier code defined by the Bluetooth Special Interest Group (SIG).
     * @return  A vector of BluetoothLEManufacturerData contained within the payload.
     */
    getManufacturerDataByCompanyId(
        companyId: number): undefined.IVectorView<undefined.BluetoothLEManufacturerData>;

    /**
     * Return a list of advertisement data sections that matches a given advertisement section type in a BluetoothLEAdvertisement .
     * @param type The advertisement section type
     * @return  A vector of all the BluetoothLEAdvertisementDataSection matching the given advertisement type.
     */
    getSectionsByType(
        type: number): undefined.IVectorView<undefined.BluetoothLEAdvertisementDataSection>;

    /**
     * The local name contained within the advertisement. 
     */
    localName: string;

    /**
     * Gets the list of manufacturer-specific data sections in a BluetoothLEAdvertisement . 
     */
    manufacturerData: undefined.IVector<undefined.BluetoothLEManufacturerData>;

    /**
     * The list of service UUIDs in 128-bit GUID format in a BluetoothLEAdvertisement . 
     */
    serviceUuids: undefined.IVector<string >
}


/**
 * A Bluetooth LE advertisement byte pattern for filters to match. 
 */
declare class BluetoothLEAdvertisementBytePattern {

    /**
     * Create a new BluetoothLEAdvertisementBytePattern object. 
     */
    constructor(): this;

    /**
     * Create a new BluetoothLEAdvertisementBytePattern object with an advertisement data type to match, the advertisement data byte pattern to match, and the offset of the byte pattern from the beginning of the advertisement data section.
     * @param dataType The Bluetooth LE advertisement data type to match.
     * @param offset The offset of byte pattern from beginning of advertisement data section.
     * @param data The Bluetooth LE advertisement data byte pattern to match.
     */
    constructor(dataType: number, offset: number, data: undefined.IBuffer): this;

    /**
     * The Bluetooth LE advertisement data byte pattern to match. 
     */
    data: undefined.IBuffer;

    /**
     * The Bluetooth LE advertisement data type defined by the Bluetooth Special Interest Group (SIG) to match. 
     */
    dataType: number;

    /**
     * The offset of byte pattern from beginning of advertisement data section. 
     */
    offset: number
}


/**
 * A Bluetooth LE advertisement section. 
 */
declare class BluetoothLEAdvertisementDataSection {

    /**
     * Creates a new BluetoothLEAdvertisementDataSection object. 
     */
    constructor(): this;

    /**
     * Creates a new BluetoothLEAdvertisementDataSection object with the Bluetooth LE advertisement data type and the payload.
     * @param dataType The Bluetooth LE advertisement data type as defined by the Bluetooth Special Interest Group (SIG).
     * @param data The Bluetooth LE advertisement data payload.
     */
    constructor(dataType: number, data: undefined.IBuffer): this;

    /**
     * The Bluetooth LE advertisement data payload. 
     */
    data: undefined.IBuffer;

    /**
     * The Bluetooth LE advertisement data type as defined by the Bluetooth Special Interest Group (SIG). 
     */
    dataType: number
}


/**
 * Some of the Bluetooth LE advertisement types defined in the Generic Access Profile (GAP) by the Bluetooth Special Interest Group (SIG). 
 */
declare class BluetoothLEAdvertisementDataTypes {

    /**
     * Section data type for the Bluetooth LE advertising interval. 
     */
    advertisingInterval: number;

    /**
     * Section data type for the Bluetooth LE advertising appearance. 
     */
    appearance: number;

    /**
     * Section data type for the Bluetooth LE complete local name. 
     */
    completeLocalName: number;

    /**
     * Section data type for the complete list of 128-bit Bluetooth LE service UUIDs 
     */
    completeService128BitUuids: number;

    /**
     * Section data type for the complete list of 16-bit Bluetooth LE service UUIDs 
     */
    completeService16BitUuids: number;

    /**
     * Section data type for the complete list of 32-bit Bluetooth LE service UUIDs 
     */
    completeService32BitUuids: number;

    /**
     * Section data type for a set of flags for internal use. 
     */
    flags: number;

    /**
     * Section data type for an incomplete list of 128-bit Bluetooth LE service UUIDs. 
     */
    incompleteService128BitUuids: number;

    /**
     * Section data type for an incomplete list of 16-bit Bluetooth LE service UUIDs. 
     */
    incompleteService16BitUuids: number;

    /**
     * Section data type for an incomplete list of 32-bit Bluetooth LE service UUIDs. 
     */
    incompleteService32BitUuids: number;

    /**
     * Section data type for manufacturer-specific data for a Bluetooth LE advertisements. 
     */
    manufacturerSpecificData: number;

    /**
     * Section data type for a list of public Bluetooth LE target addresses. 
     */
    publicTargetAddress: number;

    /**
     * Section data type for a list of random Bluetooth LE target addresses. 
     */
    randomTargetAddress: number;

    /**
     * Section data type for service data for 128-bit Bluetooth LE UUIDs. 
     */
    serviceData128BitUuids: number;

    /**
     * Section data type for service data for 16-bit Bluetooth LE UUIDs. 
     */
    serviceData16BitUuids: number;

    /**
     * Section data type for service data for 32-bit Bluetooth LE UUIDs.. 
     */
    serviceData32BitUuids: number;

    /**
     * Section data type for a list of 128-bit Bluetooth LE service solicitation UUIDs. 
     */
    serviceSolicitation128BitUuids: number;

    /**
     * Section data type for a list of 16-bit Bluetooth LE service solicitation UUIDs. 
     */
    serviceSolicitation16BitUuids: number;

    /**
     * Section data type for a list of 32-bit Bluetooth LE service solicitation UUIDs. 
     */
    serviceSolicitation32BitUuids: number;

    /**
     * Section data type for a shortened local name. 
     */
    shortenedLocalName: number;

    /**
     * Section data type for the slave connection interval range. 
     */
    slaveConnectionIntervalRange: number;

    /**
     * Section data type for the Bluetooth LE transmit power level. 
     */
    txPowerLevel: number
}


/**
 * Groups parameters used to configure payload-based filtering of received Bluetooth LE advertisements. 
 */
declare class BluetoothLEAdvertisementFilter {

    /**
     * Creates a new BluetoothLEAdvertisementFilter object. 
     */
    constructor(): this;

    /**
     * A BluetoothLEAdvertisement object that can be applied as filters to received Bluetooth LE advertisements. 
     */
    advertisement: undefined.BluetoothLEAdvertisement;

    /**
     * Gets a vector of byte patterns with offsets to match advertisement sections in a received Bluetooth LE advertisement. 
     */
    bytePatterns: undefined.IVector<undefined.BluetoothLEAdvertisementBytePattern >
}


/**
 * An object to send Bluetooth Low Energy (LE) advertisements. 
 */
declare class BluetoothLEAdvertisementPublisher {

    /**
     * Creates a new BluetoothLEAdvertisementPublisher object. 
     */
    constructor(): this;

    /**
     * Creates a new BluetoothLEAdvertisementPublisher object with the Bluetooth LE advertisement to publish.
     * @param advertisement The Bluetooth LE advertisement to publish.
     */
    constructor(advertisement: undefined.BluetoothLEAdvertisement): this;

    /**
     * Gets a copy of the Bluetooth LE advertisement to publish. 
     */
    advertisement: undefined.BluetoothLEAdvertisement;

    /**
     * Notification that the status of the BluetoothLEAdvertisementPublisher has changed. 
     */
    onstatuschanged: undefined.TypedEventHandler<undefined.BluetoothLEAdvertisementPublisher, undefined.BluetoothLEAdvertisementPublisherStatusChangedEventArgs>;
    addEventListener(
        type: "statuschanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEAdvertisementPublisher, undefined.BluetoothLEAdvertisementPublisherStatusChangedEventArgs>): void;
    removeEventListener(
        type: "statuschanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEAdvertisementPublisher, undefined.BluetoothLEAdvertisementPublisherStatusChangedEventArgs>): void;

    /**
     * Start advertising a Bluetooth LE advertisement payload. 
     */
    start(): void;

    /**
     * Gets the current status of the BluetoothLEAdvertisementPublisher . 
     */
    status: undefined.BluetoothLEAdvertisementPublisherStatus;

    /**
     * Stop the publisher and stop advertising a Bluetooth LE advertisement payload. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for a StatusChanged event on a BluetoothLEAdvertisementPublisher . 
 */
declare class BluetoothLEAdvertisementPublisherStatusChangedEventArgs {

    /**
     * Gets the error status for a StatusChanged event on a BluetoothLEAdvertisementPublisher . 
     */
    error: undefined.BluetoothError;

    /**
     * Gets the new status of the BluetoothLEAdvertisementPublisher . 
     */
    status: undefined.BluetoothLEAdvertisementPublisherStatus
}


/**
 * Provides data for a Received event on a BluetoothLEAdvertisementWatcher . 
 */
declare class BluetoothLEAdvertisementReceivedEventArgs {

    /**
     * Gets the Bluetooth LE advertisement payload data received. 
     */
    advertisement: undefined.BluetoothLEAdvertisement;

    /**
     * Gets the type of the received Bluetooth LE advertisement packet. 
     */
    advertisementType: undefined.BluetoothLEAdvertisementType;

    /**
     * Gets the Bluetooth address of the device sending the Bluetooth LE advertisement. 
     */
    bluetoothAddress: number;

    /**
     * Gets the received signal strength indicator (RSSI) value, in dBm, for this received Bluetooth LE advertisement event. 
     */
    rawSignalStrengthInDBm: number;

    /**
     * Gets the timestamp when the Received event occurred. 
     */
    timestamp: Date
}


/**
 * An object to receive Bluetooth Low Energy (LE) advertisements. 
 */
declare class BluetoothLEAdvertisementWatcher {

    /**
     * Creates a new BluetoothLEAdvertisementWatcher object with an advertisement filter to initialize the watcher.
     * @param advertisementFilter The advertisement filter to initialize the watcher.
     */
    constructor(advertisementFilter: undefined.BluetoothLEAdvertisementFilter): this;

    /**
     * Creates a new BluetoothLEAdvertisementWatcher object. 
     */
    constructor(): this;

    /**
     * Gets or sets a BluetoothLEAdvertisementFilter object used for configuration of Bluetooth LE advertisement filtering that uses payload section-based filtering. 
     */
    advertisementFilter: undefined.BluetoothLEAdvertisementFilter;

    /**
     * Gets the maximum out of range timeout. 
     */
    maxOutOfRangeTimeout: number;

    /**
     * Gets the maximum sampling interval. 
     */
    maxSamplingInterval: number;

    /**
     * Gets the minimum out of range timeout. 
     */
    minOutOfRangeTimeout: number;

    /**
     * Gets the minimum sampling interval. 
     */
    minSamplingInterval: number;

    /**
     * Notification for new Bluetooth LE advertisement events received. 
     */
    onreceived: undefined.TypedEventHandler<undefined.BluetoothLEAdvertisementWatcher, undefined.BluetoothLEAdvertisementReceivedEventArgs>;
    addEventListener(
        type: "received",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEAdvertisementWatcher, undefined.BluetoothLEAdvertisementReceivedEventArgs>): void;
    removeEventListener(
        type: "received",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEAdvertisementWatcher, undefined.BluetoothLEAdvertisementReceivedEventArgs>): void;

    /**
     * Notification to the app that the Bluetooth LE scanning for advertisements has been cancelled or aborted either by the app or due to an error. 
     */
    onstopped: undefined.TypedEventHandler<undefined.BluetoothLEAdvertisementWatcher, undefined.BluetoothLEAdvertisementWatcherStoppedEventArgs>;
    addEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEAdvertisementWatcher, undefined.BluetoothLEAdvertisementWatcherStoppedEventArgs>): void;
    removeEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEAdvertisementWatcher, undefined.BluetoothLEAdvertisementWatcherStoppedEventArgs>): void;

    /**
     * Gets or sets the Bluetooth LE scanning mode. 
     */
    scanningMode: undefined.BluetoothLEScanningMode;

    /**
     * Gets or sets a BluetoothSignalStrengthFilter object used for configuration of Bluetooth LE advertisement filtering that uses signal strength-based filtering. 
     */
    signalStrengthFilter: undefined.BluetoothSignalStrengthFilter;

    /**
     * Start the BluetoothLEAdvertisementWatcher to scan for Bluetooth LE advertisements. 
     */
    start(): void;

    /**
     * Gets the current status of the BluetoothLEAdvertisementWatcher . 
     */
    status: undefined.BluetoothLEAdvertisementWatcherStatus;

    /**
     * Stop the BluetoothLEAdvertisementWatcher and disable the scanning for Bluetooth LE advertisements. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for a Stopped event on a BluetoothLEAdvertisementWatcher . 
 */
declare class BluetoothLEAdvertisementWatcherStoppedEventArgs {

    /**
     * Gets the error status for Stopped event. 
     */
    error: undefined.BluetoothError
}


/**
 * A Bluetooth LE manufacturer-specific data section (one particular type of LE advertisement section) 
 */
declare class BluetoothLEManufacturerData {

    /**
     * Creates a new BluetoothLEManufacturerData object. 
     */
    constructor(): this;

    /**
     * Creates a new BluetoothLEManufacturerData object with a company identifier code and manufacterer-specific section data.
     * @param companyId The Bluetooth LE company identifier code as defined by the Bluetooth Special Interest Group (SIG).
     * @param data Bluetooth LE manufacturer-specific section data.
     */
    constructor(companyId: number, data: undefined.IBuffer): this;

    /**
     * The Bluetooth LE company identifier code as defined by the Bluetooth Special Interest Group (SIG). 
     */
    companyId: number;

    /**
     * Bluetooth LE manufacturer-specific section data. 
     */
    data: undefined.IBuffer
}


/**
 * Provides information about a BluetoothLEAdvertisementPublisher trigger. 
 */
declare class BluetoothLEAdvertisementPublisherTriggerDetails {

    /**
     * Gets the error status for the trigger. 
     */
    error: undefined.BluetoothError;

    /**
     * Gets the current status of the BluetoothLEAdvertisementPublisher . 
     */
    status: undefined.BluetoothLEAdvertisementPublisherStatus
}


/**
 * Provides information about a BluetoothLEAdvertisementWatcher trigger. 
 */
declare class BluetoothLEAdvertisementWatcherTriggerDetails {

    /**
     * Gets a collection of Bluetooth LE advertisements. 
     */
    advertisements: undefined.IVectorView<undefined.BluetoothLEAdvertisementReceivedEventArgs>;

    /**
     * Gets the error status for the trigger. 
     */
    error: undefined.BluetoothError;

    /**
     * Gets the parameters used to configure received signal strength indicator (RSSI)-based filtering. 
     */
    signalStrengthFilter: undefined.BluetoothSignalStrengthFilter
}


/**
 * Provides information about the Bluetooth LE device that caused this trigger to fire. 
 */
declare class GattCharacteristicNotificationTriggerDetails {

    /**
     * Gets the GATT characteristic that changed. 
     */
    characteristic: undefined.GattCharacteristic;

    /**
     * Gets a byte stream containing the new value of the characteristic. 
     */
    value: undefined.IBuffer
}


/**
 * Provides information about the Bluetooth device that caused this trigger to fire. 
 */
declare class RfcommConnectionTriggerDetails {

    /**
     * Gets whether this is an incoming connection. 
     */
    incoming: boolean;

    /**
     * Gets the BluetoothDevice object that represents the remote device. 
     */
    remoteDevice: undefined.BluetoothDevice;

    /**
     * Gets a reference to the underlying StreamSocket of this connection. 
     */
    socket: undefined.StreamSocket
}


/**
 * Provides information about incoming RFCOMM connections. If an app wants the system to listen for incoming connections on behalf of an RfcommConnectionTrigger , the app must create this object and attach it to the RfcommConnectionTrigger. 
 */
declare class RfcommInboundConnectionInformation {

    /**
     * Gets or sets the service UUID that will be advertised in the SDP record. 
     */
    localServiceId: undefined.RfcommServiceId;

    /**
     * Gets or sets the Bluetooth SDP record that the system will advertise on behalf of the app. 
     */
    sdpRecord: undefined.IBuffer;

    /**
     * Gets or sets the service capabilities that will be advertised. 
     */
    serviceCapabilities: undefined.BluetoothServiceCapabilities
}


/**
 * Provides information for RFCOMM outbound connections. If an app wants the system to create outbound connections on its behalf, the app must create this object and attach it to the RfcommConnectionTrigger . 
 */
declare class RfcommOutboundConnectionInformation {

    /**
     * Gets or sets the service UUID of the remote service to which the system will connect on behalf of the app. 
     */
    remoteServiceId: undefined.RfcommServiceId
}


/**
 * Provides functionality to determine the Bluetooth Class Of Device (Bluetooth COD) information for a device. 
 */
declare class BluetoothClassOfDevice {

    /**
     * Creates a BluetoothClassOfDevice object by supplying values for BluetoothMajorClass , BluetoothMinorClass and BluetoothClassOfDevice.
     * @param majorClass One of the enumeration values that specifies the device's main function.
     * @param minorClass One of the enumeration values that specifies the minor class value to be used.
     * @param serviceCapabilities One of the enumeration values that specifies the service the device supports.
     * @return  A BluetoothClassOfDevice object.
     */
    fromParts(
        majorClass: undefined.BluetoothMajorClass,
        minorClass: undefined.BluetoothMinorClass,
        serviceCapabilities: undefined.BluetoothServiceCapabilities): undefined.BluetoothClassOfDevice;

    /**
     * Creates a BluetoothClassOfDevice object from a raw integer value representing the Major Class, Minor Class and Service Capabilities of the device.
     * @param rawValue The raw integer value from which to create the BluetoothClassOfDevice object.
     * @return  A BluetoothClassOfDevice object.
     */
    fromRawValue(rawValue: number): undefined.BluetoothClassOfDevice;

    /**
     * Gets the Major Class code of the Bluetooth device. 
     */
    majorClass: undefined.BluetoothMajorClass;

    /**
     * Gets the Minor Class code of the device. 
     */
    minorClass: undefined.BluetoothMinorClass;

    /**
     * Gets the Bluetooth Class Of Device information, represented as an integer value. 
     */
    rawValue: number;

    /**
     * Gets the service capabilities of the device. 
     */
    serviceCapabilities: undefined.BluetoothServiceCapabilities
}


/**
 * Represents a Bluetooth device. 
 */
declare class BluetoothDevice {

    /**
     * Returns a BluetoothDevice object for the given BluetoothAddress .
     * @param address The address of the Bluetooth device.
     * @return  After the asynchronous operation completes, returns the BluetoothDevice object with the given BluetoothAddress or null if the address does not resolve to a valid device.
     */
    fromBluetoothAddressAsync(
        address: number): undefined.IPromiseWithIAsyncOperation<undefined.BluetoothDevice>;

    /**
     * Returns a BluetoothDevice object identified by the given HostName .
     * @param hostName The HostName that identifies the BluetoothDevice instance.
     * @return  After the asynchronous operation completes, returns the BluetoothDevice object identified by the given HostName .
     */
    fromHostNameAsync(
        hostName: undefined.HostName): undefined.IPromiseWithIAsyncOperation<undefined.BluetoothDevice>;

    /**
     * Returns a BluetoothDevice object identified by the given DeviceId .
     * @param deviceId The DeviceId value that identifies the BluetoothDevice instance.
     * @return  After the asynchronous operation completes, returns the BluetoothDevice object identified by the given DeviceId .
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.BluetoothDevice>;

    /**
     * Gets an Advanced Query Syntax (AQS) string for identifying instances of this device. This string is passed to the FindAllAsync or CreateWatcher method.
     * @return  The device selector for this device.
     */
    getDeviceSelector(): string;

    /**
     * Creates an Advanced Query Syntax (AQS) filter string from a 64-bit address that represents a Bluetooth device. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
     * @param bluetoothAddress A 64-bit Bluetooth device address used for constructing the AQS string.
     * @return  An AQS string that can be passed as a parameter to the CreateWatcher method.
     */
    getDeviceSelectorFromBluetoothAddress(bluetoothAddress: number): string;

    /**
     * Creates an Advanced Query Syntax (AQS) filter string from a BluetoothClassOfDevice object. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
     * @param classOfDevice The class of device used for constructing the AQS string.
     * @return  An AQS string that can be passed as a parameter to the CreateWatcher method.
     */
    getDeviceSelectorFromClassOfDevice(classOfDevice: undefined.BluetoothClassOfDevice): string;

    /**
     * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth devices with the indicated BluetoothConnectionStatus . The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects with the indicated Bluetooth connection status.
     * @param connectionStatus The connection status used for constructing the AQS string.
     * @return  An AQS string that can be passed as a parameter to the CreateWatcher method.
     */
    getDeviceSelectorFromConnectionStatus(connectionStatus: undefined.BluetoothConnectionStatus): string;

    /**
     * Creates an Advanced Query Syntax (AQS) filter string that contains a query for the Bluetooth device name. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects containing the specified Bluetooth device name.
     * @param deviceName The Bluetooth device name used for constructing the AQS string.
     * @return  An AQS string that is passed as a parameter to the CreateWatcher method.
     */
    getDeviceSelectorFromDeviceName(deviceName: string): string;

    /**
     * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth devices that are either paired or unpaired. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
     * @param pairingState The current pairing state for Bluetooth devices used for constructing the AQS string. Bluetooth devices can be either paired (true) or unpaired (false). The AQS Filter string will request scanning to be performed when the pairingState is false.
     * @return  An AQS string that can be passed as a parameter to the CreateWatcher method.
     */
    getDeviceSelectorFromPairingState(pairingState: boolean): string;

    /**
     * Gets the device address. 
     */
    bluetoothAddress: number;

    /**
     * Gets the Bluetooth Class Of Device information of the device. 
     */
    classOfDevice: undefined.BluetoothClassOfDevice;

    /**
     * Closes the Bluetooth device. 
     */
    close(): void;

    /**
     * Gets the connection status of the device. 
     */
    connectionStatus: undefined.BluetoothConnectionStatus;

    /**
     * Gets the device ID. 
     */
    deviceId: string;

    /**
     * Gets the DeviceInformation object for the Bluetooth device. 
     */
    deviceInformation: undefined.DeviceInformation;

    /**
     * Gets the HostName of the device. 
     */
    hostName: undefined.HostName;

    /**
     * Gets the Name of the device. 
     */
    name: string;

    /**
     * Occurs when the connection status of the device has changed. 
     */
    onconnectionstatuschanged: undefined.TypedEventHandler<undefined.BluetoothDevice, any>;
    addEventListener(
        type: "connectionstatuschanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothDevice, any>): void;
    removeEventListener(
        type: "connectionstatuschanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothDevice, any>): void;

    /**
     * Occurs when the name of the device has changed. 
     */
    onnamechanged: undefined.TypedEventHandler<undefined.BluetoothDevice, any>;
    addEventListener(
        type: "namechanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothDevice, any>): void;
    removeEventListener(
        type: "namechanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothDevice, any>): void;

    /**
     * Occurs when the list SDP records for the device has changed. 
     */
    onsdprecordschanged: undefined.TypedEventHandler<undefined.BluetoothDevice, any>;
    addEventListener(
        type: "sdprecordschanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothDevice, any>): void;
    removeEventListener(
        type: "sdprecordschanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothDevice, any>): void;

    /**
     * Gets the read-only list of RFCOMM services supported by the device. 
     */
    rfcommServices: undefined.IVectorView<undefined.RfcommDeviceService>;

    /**
     * Gets the read-only list of Service Discovery Protocol (SDP) records for the device. 
     */
    sdpRecords: undefined.IVectorView<undefined.IBuffer>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides functionality to determine the Bluetooth Low Energy (LE) Appearance information for a device. 
 */
declare class BluetoothLEAppearance {

    /**
     * Creates a BluetoothLEAppearance object by supplying values for Category (see BluetoothLEAppearanceCategories ) and Subcategory (see BluetoothLEAppearanceSubcategories ) of the Bluetooth LE device.
     * @param appearanceCategory The Bluetooth LE appearance category. See BluetoothLEAppearanceSubcategories .
     * @param appearanceSubCategory The Bluetooth LE appearance subcategory. See BluetoothLEAppearanceSubcategories .
     * @return  The Bluetooth LE appearance object that was created from the appearance category and subcategory.
     */
    fromParts(
        appearanceCategory: number,
        appearanceSubCategory: number): undefined.BluetoothLEAppearance;

    /**
     * Creates a BluetoothLEAppearance object by supplying for raw integer values representing the Category and Subcategory of the Bluetooth LE device.
     * @param rawValue The raw integer value representing the appearance category and subcategory.
     * @return  The Bluetooth LE appearance object that was created from the appearance category and subcategory.
     */
    fromRawValue(rawValue: number): undefined.BluetoothLEAppearance;

    /**
     * Gets the appearance category value of the Bluetooth LE device. 
     */
    category: number;

    /**
     * Gets the appearance raw value of the Bluetooth LE device. 
     */
    rawValue: number;

    /**
     * Gets the appearance subcategory value of the Bluetooth LE device. 
     */
    subCategory: number
}


/**
 * Indicates the appearance category code of the Bluetooth LE device. 
 */
declare class BluetoothLEAppearanceCategories {

    /**
     * Gets the barcode scanner appearance category code. 
     */
    barcodeScanner: number;

    /**
     * Gets the blood pressure appearance category code. 
     */
    bloodPressure: number;

    /**
     * Gets the clock appearance category code. 
     */
    clock: number;

    /**
     * Gets the computer appearance category code. 
     */
    computer: number;

    /**
     * Gets the cycling appearance category code. 
     */
    cycling: number;

    /**
     * Gets the display appearance category code. 
     */
    display: number;

    /**
     * Gets the eye glasses appearance category code. 
     */
    eyeGlasses: number;

    /**
     * Gets the glucose meter appearance category code. 
     */
    glucoseMeter: number;

    /**
     * Gets the heart rate appearance category code. 
     */
    heartRate: number;

    /**
     * Gets the human interface device appearance category code. 
     */
    humanInterfaceDevice: number;

    /**
     * Gets the key ring appearance category code. 
     */
    keyring: number;

    /**
     * Gets the media player appearance category code. 
     */
    mediaPlayer: number;

    /**
     * Gets the outdoor sport activity appearance category code. 
     */
    outdoorSportActivity: number;

    /**
     * Gets the phone appearance category code. 
     */
    phone: number;

    /**
     * Gets the pulse oximeter appearance category code. 
     */
    pulseOximeter: number;

    /**
     * Gets the remote control appearance category code. 
     */
    remoteControl: number;

    /**
     * Gets the running or walking appearance category code. 
     */
    runningWalking: number;

    /**
     * Gets the tag appearance category code. 
     */
    tag: number;

    /**
     * Gets the thermometer appearance category code. 
     */
    thermometer: number;

    /**
     * Gets the uncategorized appearance category code. 
     */
    uncategorized: number;

    /**
     * Gets the watch appearance category code. 
     */
    watch: number;

    /**
     * Gets the weight scale appearance category code. 
     */
    weightScale: number
}


/**
 * Indicates the appearance subcategory code of the Bluetooth LE device. 
 */
declare class BluetoothLEAppearanceSubcategories {

    /**
     * Gets the pulse barcode scanner appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category. 
     */
    barcodeScanner: number;

    /**
     * Gets the blood pressure arm appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.BloodPressure appearance category. 
     */
    bloodPressureArm: number;

    /**
     * Gets the blood pressure wrist appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.BloodPressure appearance category. 
     */
    bloodPressureWrist: number;

    /**
     * Gets the card reader appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category. 
     */
    cardReader: number;

    /**
     * Gets the cycling cadence sensor appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.Cycling appearance category. 
     */
    cyclingCadenceSensor: number;

    /**
     * Gets the cycling computer appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.Cycling appearance category. 
     */
    cyclingComputer: number;

    /**
     * Gets the cycling power sensor appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.Cycling appearance category. 
     */
    cyclingPowerSensor: number;

    /**
     * Gets the cycling speed cadence sensor appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.Cycling appearance category. 
     */
    cyclingSpeedCadenceSensor: number;

    /**
     * Gets the cycling speed sensor appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.Cycling appearance category. 
     */
    cyclingSpeedSensor: number;

    /**
     * Gets the digital pen appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category. 
     */
    digitalPen: number;

    /**
     * Gets the digitizer tablet appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category. 
     */
    digitizerTablet: number;

    /**
     * Gets the gamepad appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category. 
     */
    gamepad: number;

    /**
     * Gets the generic appearance subcategory code. 
     */
    generic: number;

    /**
     * Gets the heart rate belt appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HeartRate appearance category. 
     */
    heartRateBelt: number;

    /**
     * Gets the joystick appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category. 
     */
    joystick: number;

    /**
     * Gets the keyboard appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category. 
     */
    keyboard: number;

    /**
     * Gets the location display appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.OutdoorSportActivity appearance category. 
     */
    locationDisplay: number;

    /**
     * Gets the location navigation display appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.OutdoorSportActivity appearance category. 
     */
    locationNavigationDisplay: number;

    /**
     * Gets the location navigation pod appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.OutdoorSportActivity appearance category. 
     */
    locationNavigationPod: number;

    /**
     * Gets the location pod appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.OutdoorSportActivity appearance category. 
     */
    locationPod: number;

    /**
     * Gets the mouse appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.HumanInterfaceDevice appearance category. 
     */
    mouse: number;

    /**
     * Gets the oximeter fingertip appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.PulseOximeter appearance category. 
     */
    oximeterFingertip: number;

    /**
     * Gets the oximeter wrist worn appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.PulseOximeter appearance category. 
     */
    oximeterWristWorn: number;

    /**
     * Gets the running or walking in shoe appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.RunningWalking appearance category. 
     */
    runningWalkingInShoe: number;

    /**
     * Gets the running or walking on hip appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.RunningWalking appearance category. 
     */
    runningWalkingOnHip: number;

    /**
     * Gets the running or walking on shoe appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.RunningWalking appearance category. 
     */
    runningWalkingOnShoe: number;

    /**
     * Gets the sports watch appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.RunningWalking appearance category. 
     */
    sportsWatch: number;

    /**
     * Gets the ear thermometer appearance subcategory code. This is only applicable for Bluetooth LE devices that are part of the BluetoothLEAppearanceCategories.RunningWalking appearance category. 
     */
    thermometerEar: number
}


/**
 * Represents a Bluetooth LE device. 
 */
declare class BluetoothLEDevice {

    /**
     * Returns a BluetoothLEDevice object for the given BluetoothAddress value and BluetoothAddressType value.
     * @param bluetoothAddress The 64-bit address of the Bluetooth LE device.
     * @param bluetoothAddressType The address type of the Bluetooth LE device.
     * @return  Returns an asynchronous operation that completes with the BluetoothLEDevice object.
     */
    fromBluetoothAddressAsync(
        bluetoothAddress: number,
        bluetoothAddressType: undefined.BluetoothAddressType): undefined.IPromiseWithIAsyncOperation<undefined.BluetoothLEDevice>;

    /**
     * Returns a BluetoothLEDevice object for the given Id.
     * @param deviceId The Id of the Bluetooth LE device.
     * @return  After the asynchronous operation completes, returns the BluetoothLEDevice object with the given Id.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.BluetoothLEDevice>;

    /**
     * Gets an Advanced Query Syntax (AQS) string for identifying all Bluetooth Low Energy (LE) devices. This string is passed to the FindAllAsync or CreateWatcher method in order to get a list of Bluetooth LE devices.
     * @return  The device selector for this device.
     */
    getDeviceSelector(): string;

    /**
     * Creates an Advanced Query Syntax (AQS) filter string from a BluetoothLEAppearance object. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects with the specified appearance.
     * @param appearance The Bluetooth LE appearance used for constructing the AQS string.
     * @return  An AQS string that can be passed as a parameter to the CreateWatcher method.
     */
    getDeviceSelectorFromAppearance(appearance: undefined.BluetoothLEAppearance): string;

    /**
     * Creates an Advanced Query Syntax (AQS) filter string from a 64-bit address that represents a Bluetooth LE device. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
     * @param bluetoothAddress A 64-bit Bluetooth LE device address used for constructing the AQS string.
     * @return  An AQS string that can be passed as a parameter to the CreateWatcher method.
     */
    getDeviceSelectorFromBluetoothAddress(bluetoothAddress: number): string;

    /**
     * Creates an Advanced Query Syntax (AQS) filter string from a 64-bit address and address type that represents a Bluetooth LE device. The AQS string is passed into the CreateWatcher method.
     * @param bluetoothAddress A 64-bit Bluetooth LE device address used for constructing the AQS string.
     * @param bluetoothAddressType The Bluetooth LE device address type.
     * @return  An AQS string that can be passed as a parameter to the CreateWatcher method.
     */
    getDeviceSelectorFromBluetoothAddress(
        bluetoothAddress: number,
        bluetoothAddressType: undefined.BluetoothAddressType): string;

    /**
     * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth LE devices with the indicated BluetoothConnectionStatus . The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects with the indicated Bluetooth connection status.
     * @param connectionStatus The connection status used for constructing the AQS string.
     * @return  An AQS string that can be passed as a parameter to the CreateWatcher method.
     */
    getDeviceSelectorFromConnectionStatus(connectionStatus: undefined.BluetoothConnectionStatus): string;

    /**
     * Creates an Advanced Query Syntax (AQS) filter string that contains a query for the Bluetooth LE device name. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects containing the specified Bluetooth LE device name.
     * @param deviceName The Bluetooth LE device name used for constructing the AQS string.
     * @return  An AQS string that is passed as a parameter to the CreateWatcher method.
     */
    getDeviceSelectorFromDeviceName(deviceName: string): string;

    /**
     * Creates an Advanced Query Syntax (AQS) filter string that contains a query for Bluetooth LE devices that are either paired or unpaired. The AQS string is passed into the CreateWatcher method to return a collection of DeviceInformation objects.
     * @param pairingState The current pairing state for Bluetooth LE devices used for constructing the AQS string. Bluetooth LE devices can be either paired (true) or unpaired (false). The AQS Filter string will request scanning to be performed when the pairingState is false.
     * @return  An AQS string that can be passed as a parameter to the CreateWatcher method.
     */
    getDeviceSelectorFromPairingState(pairingState: boolean): string;

    /**
     * Gets the BluetoothLEAppearance object for the Bluetooth LE device. 
     */
    appearance: undefined.BluetoothLEAppearance;

    /**
     * Gets the device address. 
     */
    bluetoothAddress: number;

    /**
     * Gets the address type for the Bluetooth LE device. 
     */
    bluetoothAddressType: undefined.BluetoothAddressType;

    /**
     * Closes this Bluetooth LE device. 
     */
    close(): void;

    /**
     * Gets the connection status of the device. 
     */
    connectionStatus: undefined.BluetoothConnectionStatus;

    /**
     * Gets the device Id. 
     */
    deviceId: string;

    /**
     * Gets the DeviceInformation object for the Bluetooth LE device. 
     */
    deviceInformation: undefined.DeviceInformation;

    /**
     * Gets the read-only list of GATT services supported by the device. 
     */
    gattServices: undefined.IVectorView<undefined.GattDeviceService>;

    /**
     * Returns the GATT service with the given service Id.
     * @param serviceUuid The service Id of the GATT service.
     * @return  The GATT service represented by the given service Id.
     */
    getGattService(serviceUuid: string): undefined.GattDeviceService;

    /**
     * Gets the name of the Bluetooth LE device. 
     */
    name: string;

    /**
     * Occurs when the connection status for the device has changed. 
     */
    onconnectionstatuschanged: undefined.TypedEventHandler<undefined.BluetoothLEDevice, any>;
    addEventListener(
        type: "connectionstatuschanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEDevice, any>): void;
    removeEventListener(
        type: "connectionstatuschanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEDevice, any>): void;

    /**
     * Occurs when the list of GATT services supported by the device has changed. 
     */
    ongattserviceschanged: undefined.TypedEventHandler<undefined.BluetoothLEDevice, any>;
    addEventListener(
        type: "gattserviceschanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEDevice, any>): void;
    removeEventListener(
        type: "gattserviceschanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEDevice, any>): void;

    /**
     * Occurs when the name of the device has changed. 
     */
    onnamechanged: undefined.TypedEventHandler<undefined.BluetoothLEDevice, any>;
    addEventListener(
        type: "namechanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEDevice, any>): void;
    removeEventListener(
        type: "namechanged",
        listener: undefined.TypedEventHandler<undefined.BluetoothLEDevice, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Groups parameters used to configure received signal strength indicator (RSSI)-based filtering. 
 */
declare class BluetoothSignalStrengthFilter {

    /**
     * Create a new BluetoothSignalStrengthFilter object. 
     */
    constructor(): this;

    /**
     * The minimum received signal strength indicator (RSSI) value in dBm on which RSSI events will be propagated or considered in range if the previous events were considered out of range. 
     */
    inRangeThresholdInDBm: number;

    /**
     * The minimum received signal strength indicator (RSSI) value in dBm on which RSSI events will be considered out of range. 
     */
    outOfRangeThresholdInDBm: number;

    /**
     * The timeout for a received signal strength indicator (RSSI) event to be considered out of range. 
     */
    outOfRangeTimeout: number;

    /**
     * The interval at which received signal strength indicator (RSSI) events are sampled. 
     */
    samplingInterval: number
}


/**
 * Represents a Characteristic of a GATT service. 
 */
declare class GattCharacteristic {

    /**
     * Converts a Bluetooth SIG defined short Id to a full GATT UUID.
     * @param shortId A 16-bit Bluetooth GATT Service UUID.
     * @return  The corresponding 128-bit GATT Characteristic UUID, that uniquely identifies this characteristic.
     */
    convertShortIdToUuid(shortId: number): string;

    /**
     * Gets the handle used to uniquely identify GATT-based characteristic attributes as declared on the Bluetooth LE device. 
     */
    attributeHandle: number;

    /**
     * Gets the GATT characteristic properties, as defined by the GATT profile. 
     */
    characteristicProperties: undefined.GattCharacteristicProperties;

    /**
     * Gets the collection of all descriptors belonging to this GattCharacteristic instance.
     * @return  The collection of all descriptors belonging to this GattCharacteristic instance.
     */
    getAllDescriptors(): undefined.IVectorView<undefined.GattDescriptor>;

    /**
     * Returns a vector of descriptors, that are identified by the specified UUID, and belong to this GattCharacteristic instance.
     * @param descriptorUuid The UUID for the descriptors to be retrieved.
     * @return  A vector of descriptors whose UUIDs match descriptorUuid.
     */
    getDescriptors(descriptorUuid: string): undefined.IVectorView<undefined.GattDescriptor>;

    /**
     * An App can register an event handler in order to receive events when notification or indications are received from a device, after setting the Client Characteristic Configuration Descriptor. 
     */
    onvaluechanged: undefined.TypedEventHandler<undefined.GattCharacteristic, undefined.GattValueChangedEventArgs>;
    addEventListener(
        type: "valuechanged",
        listener: undefined.TypedEventHandler<undefined.GattCharacteristic, undefined.GattValueChangedEventArgs>): void;
    removeEventListener(
        type: "valuechanged",
        listener: undefined.TypedEventHandler<undefined.GattCharacteristic, undefined.GattValueChangedEventArgs>): void;

    /**
     * Gets the list of presentation format descriptors associated with this GattCharacteristic, in the order specified by the Aggregate Format Descriptor. 
     */
    presentationFormats: undefined.IVectorView<undefined.GattPresentationFormat>;

    /**
     * Gets or sets the desired GATT security options for over the air communication with the device. 
     */
    protectionLevel: undefined.GattProtectionLevel;

    /**
     * Reads the current value of the ClientCharacteristicConfigurationDescriptor.
     * @return  The object that manages the asynchronous operation. Upon completion of the asynchronous method, the IAsyncOperation(GattReadClientCharacteristicConfigurationDescriptorResult) contains the result of the read operation, which contains the status of completed operation.
     */
    readClientCharacteristicConfigurationDescriptorAsync(): undefined.IPromiseWithIAsyncOperation<undefined.GattReadClientCharacteristicConfigurationDescriptorResult>;

    /**
     * Performs a Characteristic Value read either from the value cache maintained by Windows, or directly from the device.
     * @param cacheMode Specifies whether to read the value directly from the device or from a value cache maintained by Windows.
     * @return  The object required to manage the asynchronous operation, which, upon completion, returns a GattReadResult object, which in turn contains the completion status of the asynchronous operation and, if successful, the data read from the device.
     */
    readValueAsync(
        cacheMode: undefined.BluetoothCacheMode): undefined.IPromiseWithIAsyncOperation<undefined.GattReadResult>;

    /**
     * Performs a Characteristic Value read from the value cache maintained by Windows.
     * @return  The object required to manage the asynchronous operation, which, upon completion, returns a GattReadResult object, which in turn contains the completion status of the asynchronous operation and, if successful, the data read from the device.
     */
    readValueAsync(): undefined.IPromiseWithIAsyncOperation<undefined.GattReadResult>;

    /**
     * Gets the GattDeviceService of which this characteristic is a member. 
     */
    service: undefined.GattDeviceService;

    /**
     * Get the user friendly description for this GattCharacteristic, if the User Description Descriptor is present, otherwise this will be an empty string. 
     */
    userDescription: string;

    /**
     * Gets the GATT Characteristic UUID for this GattCharacteristic. 
     */
    uuid: string;

    /**
     * Writes the ClientCharacteristicConfigurationDescriptor to the Bluetooth LE device, and if the value to be written represents an indication or a notification and a ValueChanged event handler is registered, enables receiving ValueChanged events from the device.
     * @param clientCharacteristicConfigurationDescriptorValue Specifies a new value for the ClientCharacteristicConfigurationDescriptor of this Characteristic object.
     * @return  The object that manages the asynchronous operation, which, upon completion, returns the status with which the operation completed.
     */
    writeClientCharacteristicConfigurationDescriptorAsync(
        clientCharacteristicConfigurationDescriptorValue: undefined.GattClientCharacteristicConfigurationDescriptorValue): undefined.IPromiseWithIAsyncOperation<undefined.GattCommunicationStatus>;

    /**
     * Performs a Characteristic Value write to a Bluetooth LE device.
     * @param value A Windows.Storage.Streams.IBuffer object which contains the data to be written to the Bluetooth LE device.
     * @return  The object that manages the asynchronous operation, which, upon completion, returns the status with which the operation completed.
     */
    writeValueAsync(
        value: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.GattCommunicationStatus>;

    /**
     * Performs a Characteristic Value write to a Bluetooth LE device.
     * @param value A Windows.Storage.Streams.IBuffer object which contains the data to be written to the Bluetooth LE device.
     * @param writeOption Specifies what type of GATT write should be performed.
     * @return  The object that manages the asynchronous operation, which, upon completion, returns the status with which the operation completed.
     */
    writeValueAsync(
        value: undefined.IBuffer,
        writeOption: undefined.GattWriteOption): undefined.IPromiseWithIAsyncOperation<undefined.GattCommunicationStatus>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an enumeration of the most well known Characteristic UUID values, and provides convenience methods for working with GATT characteristic UUIDs, and static properties providing characteristic UUIDs for common GATT characteristics. 
 */
declare class GattCharacteristicUuids {

    /**
     * Gets the Bluetooth SIG-defined AlertCategoryId characteristic UUID. 
     */
    alertCategoryId: string;

    /**
     * Gets the Bluetooth SIG-Defined AlertCategoryIdBitMask characteristic UUID. 
     */
    alertCategoryIdBitMask: string;

    /**
     * Gets the Bluetooth SIG-defined AlertLevel characteristic UUID. 
     */
    alertLevel: string;

    /**
     * Gets the Bluetooth SIG-defined AlertNotificationControlPoint characteristic UUID. 
     */
    alertNotificationControlPoint: string;

    /**
     * Gets the Bluetooth SIG-defined AlertStatus characteristic UUID. 
     */
    alertStatus: string;

    /**
     * Gets the Bluetooth SIG-defined Battery Level Characteristic UUID. 
     */
    batteryLevel: string;

    /**
     * Gets the Bluetooth SIG-defined Blood Pressure Feature Characteristic UUID. 
     */
    bloodPressureFeature: string;

    /**
     * Gets the Bluetooth SIG-defined Blood Pressure Measurement Characteristic UUID. 
     */
    bloodPressureMeasurement: string;

    /**
     * Gets the Bluetooth SIG-defined Body Sensor Location Characteristic UUID. 
     */
    bodySensorLocation: string;

    /**
     * Gets the Bluetooth SIG-defined BootKeyboardInputReport characteristic UUID. 
     */
    bootKeyboardInputReport: string;

    /**
     * Gets the Bluetooth SIG-defined BootKeyboardOutputReport characteristic UUID. 
     */
    bootKeyboardOutputReport: string;

    /**
     * Gets the Bluetooth SIG-defined BootMouseInputReport characteristic UUID. 
     */
    bootMouseInputReport: string;

    /**
     * Gets the Bluetooth SIG-defined Csc Feature Characteristic UUID. 
     */
    cscFeature: string;

    /**
     * Gets the Bluetooth SIG-defined Csc Measurement Characteristic UUID. 
     */
    cscMeasurement: string;

    /**
     * Gets the Bluetooth SIG-defined CurrentTime characteristic UUID. 
     */
    currentTime: string;

    /**
     * Gets the Bluetooth SIG-defined CyclingPowerControlPoint characteristic UUID. 
     */
    cyclingPowerControlPoint: string;

    /**
     * Gets the Bluetooth SIG-defined CyclingPowerFeature characteristic UUID. 
     */
    cyclingPowerFeature: string;

    /**
     * Gets the Bluetooth SIG-defined CyclingPowerMeasurement characteristic UUID. 
     */
    cyclingPowerMeasurement: string;

    /**
     * Gets the Bluetooth SIG-defined CyclingPowerVector characteristic UUID. 
     */
    cyclingPowerVector: string;

    /**
     * Gets the Bluetooth SIG-defined DateTime characteristic UUID. 
     */
    dateTime: string;

    /**
     * Gets the Bluetooth SIG-defined DayDateTime characteristic UUID. 
     */
    dayDateTime: string;

    /**
     * Gets the Bluetooth SIG-defined DayOfWeek characteristic UUID. 
     */
    dayOfWeek: string;

    /**
     * Gets the Bluetooth SIG-defined DstOffset characteristic UUID. 
     */
    dstOffset: string;

    /**
     * Gets the Bluetooth SIG-defined ExactTime256 characteristic UUID. 
     */
    exactTime256: string;

    /**
     * Gets the Bluetooth SIG-defined FirmwareRevisionString characteristic UUID. 
     */
    firmwareRevisionString: string;

    /**
     * Gets the Bluetooth SIG-defined GapAppearance characteristic UUID. 
     */
    gapAppearance: string;

    /**
     * Gets the Bluetooth SIG-defined GapDeviceName characteristic UUID. 
     */
    gapDeviceName: string;

    /**
     * Gets the Bluetooth SIG-defined GapPeripheralPreferredConnectionParameters characteristic UUID. 
     */
    gapPeripheralPreferredConnectionParameters: string;

    /**
     * Gets the Bluetooth GapPeripheralPrivacyFlag characterisitc UUID. 
     */
    gapPeripheralPrivacyFlag: string;

    /**
     * Gets the Bluetooth SIG-defined GapReconnectionAddress characteristic UUID. 
     */
    gapReconnectionAddress: string;

    /**
     * Gets the Bluetooth SIG-defined GattServiceChanged characteristic UUID. 
     */
    gattServiceChanged: string;

    /**
     * Gets the Bluetooth SIG-defined Glucose Feature Characteristic UUID. 
     */
    glucoseFeature: string;

    /**
     * Gets the Bluetooth SIG-defined Glucose Measurement Characteristic UUID. 
     */
    glucoseMeasurement: string;

    /**
     * Gets the Bluetooth SIG-defined Glucose Measurement Context Characteristic UUID. 
     */
    glucoseMeasurementContext: string;

    /**
     * Gets the Bluetooth SIG-defined HardwareRevisionString characterisitc UUID. 
     */
    hardwareRevisionString: string;

    /**
     * Gets the Bluetooth SIG-defined Heart Rate Control Point Characteristic UUID. 
     */
    heartRateControlPoint: string;

    /**
     * Gets the Bluetooth SIG-defined Heart Rate Measurement Characteristic UUID. 
     */
    heartRateMeasurement: string;

    /**
     * Gets the Bluetooth SIG-defined HidControlPoint characteristic UUID. 
     */
    hidControlPoint: string;

    /**
     * Gets the Bluetooth SIG-defined HidInformation characteristic UUID. 
     */
    hidInformation: string;

    /**
     * Gets the Bluetooth SIG-defined Ieee1107320601RegulatoryCertificationDataList characteristic UUID. 
     */
    ieee1107320601RegulatoryCertificationDataList: string;

    /**
     * Gets the Bluetooth SIG-defined Intermediate Cuff Pressure Characteristic UUID. 
     */
    intermediateCuffPressure: string;

    /**
     * Gets the Bluetooth SIG-defined Intermediate Temperature Characteristic UUID. 
     */
    intermediateTemperature: string;

    /**
     * Gets the Bluetooth SIG-defined LnControlPoint characteristic UUID. 
     */
    lnControlPoint: string;

    /**
     * Gets the Bluetooth SIG-defined LnFeature characteristic UUID. 
     */
    lnFeature: string;

    /**
     * Gets the Bluetooth SIG-defined LocalTimeInformation characteristic UUID. 
     */
    localTimeInformation: string;

    /**
     * Gets the Bluetooth SIG-defined LocationAndSpeed characteristic UUID. 
     */
    locationAndSpeed: string;

    /**
     * Gets the Bluetooth SIG-defined ManufacturerNameString characteristic UUID. 
     */
    manufacturerNameString: string;

    /**
     * Gets the Bluetooth SIG-defined Measurement Interval Characteristic UUID. 
     */
    measurementInterval: string;

    /**
     * Gets the Bluetooth SIG-defined ModelNumberString UUID. 
     */
    modelNumberString: string;

    /**
     * Gets the Bluetooth SIG-defined Navigation characteristic UUID. 
     */
    navigation: string;

    /**
     * Gets the Bluetooth SIG-defined NewAlert characteristic UUID. 
     */
    newAlert: string;

    /**
     * Gets the Bluetooth SIG-defined PnpId characteristic UUID. 
     */
    pnpId: string;

    /**
     * Gets the Bluetooth SIG-defined PositionQuality characteristic UUID. 
     */
    positionQuality: string;

    /**
     * Gets the Bluetooth SIG-defined ProtocolMode characteristic UUID. 
     */
    protocolMode: string;

    /**
     * Gets the Bluetooth SIG-defined Record Access Control Point Characteristic UUID. 
     */
    recordAccessControlPoint: string;

    /**
     * Gets the Bluetooth SIG-defined ReferenceTimeInformation characteristic UUID. 
     */
    referenceTimeInformation: string;

    /**
     * Gets the Bluetooth SIG-defined Report characteristic UUID. 
     */
    report: string;

    /**
     * Gets the Bluetooth SIG-defined ReportMap characteristic UUID. 
     */
    reportMap: string;

    /**
     * Gets the Bluetooth SIG-defined RingerControlPoint characteristic UUID. 
     */
    ringerControlPoint: string;

    /**
     * Gets the Bluetooth SIG-defined RingerSetting characteristic UUID. 
     */
    ringerSetting: string;

    /**
     * Gets the Bluetooth SIG-defined Rsc Feature Characteristic UUID. 
     */
    rscFeature: string;

    /**
     * Gets the Bluetooth SIG-defined Rsc Measurement Characteristic UUID. 
     */
    rscMeasurement: string;

    /**
     * Gets the Bluetooth SIG-defined SC Control Point Characteristic UUID. 
     */
    scControlPoint: string;

    /**
     * Gets the Bluetooth SIG-defined ScanIntervalWindow characteristic UUID. 
     */
    scanIntervalWindow: string;

    /**
     * Gets the Bluetooth SIG-defined ScanRefresh characteristic UUID. 
     */
    scanRefresh: string;

    /**
     * Gets the Bluetooth SIG-defined Sensor Location Characteristic UUID. 
     */
    sensorLocation: string;

    /**
     * Gets the Bluetooth SIG-defined SerialNumberString characteristic UUID. 
     */
    serialNumberString: string;

    /**
     * Gets the Bluetooth SIG-defined SoftwareRevisionString characteristic UUID. 
     */
    softwareRevisionString: string;

    /**
     * Gets the Bluetooth SIG-defined SupportUnreadAlertCategory characteristic UUID. 
     */
    supportUnreadAlertCategory: string;

    /**
     * Gets the Bluetooth SIG-defined SupportedNewAlertCategory characteristic UUID. 
     */
    supportedNewAlertCategory: string;

    /**
     * Gets the Bluetooth SIG-defined SystemId characteristic UUID. 
     */
    systemId: string;

    /**
     * Gets the Bluetooth SIG-defined Temperature Measurement Characteristic UUID. 
     */
    temperatureMeasurement: string;

    /**
     * Gets the Bluetooth SIG-defined Temperature Type Characteristic UUID. 
     */
    temperatureType: string;

    /**
     * Gets the Bluetooth SIG-defined TimeAccuracy characteristic UUID. 
     */
    timeAccuracy: string;

    /**
     * Gets the Bluetooth SIG-defined TimeSource characteristic UUID. 
     */
    timeSource: string;

    /**
     * Gets the Bluetooth SIG-defined TimeUpdateControlPoint characteristic UUID. 
     */
    timeUpdateControlPoint: string;

    /**
     * Gets the Bluetooth SIG-defined TimeUpdateState characteristic UUID. 
     */
    timeUpdateState: string;

    /**
     * Gets the Bluetooth SIG-defined TimeWithDst characteristic UUID. 
     */
    timeWithDst: string;

    /**
     * Gets the Bluetooth SIG-defined TimeZone characteristic UUID. 
     */
    timeZone: string;

    /**
     * Gets the Bluetooth SIG-defined TxPowerLevel characteristic UUID. 
     */
    txPowerLevel: string;

    /**
     * Gets the Bluetooth SIG-defined UnreadAlertStatus characteristic UUID. 
     */
    unreadAlertStatus: string
}


/**
 * Represents a Descriptor of a GATT Characteristic. 
 */
declare class GattDescriptor {

    /**
     * Converts a Bluetooth SIG defined short Id to a full GATT UUID.
     * @param shortId A 16-bit Bluetooth GATT Descriptor UUID.
     * @return  The corresponding 128-bit GATT Descriptor UUID, that uniquely identifies this descriptor.
     */
    convertShortIdToUuid(shortId: number): string;

    /**
     * Gets the GATT Attribute handle used to uniquely identify this attribute on the GATT Server Device. 
     */
    attributeHandle: number;

    /**
     * Gets or sets the desired GATT security options for over the air communication with the device. 
     */
    protectionLevel: undefined.GattProtectionLevel;

    /**
     * Performs a Descriptor Value read either from the value cache maintained by Windows, or directly from the device.
     * @param cacheMode Specifies whether to read the value directly from the device or from a value cache maintained by Windows.
     * @return  The object required to manage the asynchronous operation, which, upon completion, returns a GattReadResult object, which in turn contains the completion status of the asynchronous operation and, if successful, the data read from the device.
     */
    readValueAsync(
        cacheMode: undefined.BluetoothCacheMode): undefined.IPromiseWithIAsyncOperation<undefined.GattReadResult>;

    /**
     * Performs a Descriptor Value read from a value cache maintained by Windows.
     * @return  The object required to manage the asynchronous operation, which, upon completion, returns a GattReadResult object, which in turn contains the completion status of the asynchronous operation and, if successful, the data read from the device.
     */
    readValueAsync(): undefined.IPromiseWithIAsyncOperation<undefined.GattReadResult>;

    /**
     * Gets the GATT Descriptor UUID for this GattDescriptor. 
     */
    uuid: string;

    /**
     * Performs a Descriptor Value write to a Bluetooth LE device.
     * @param value A Windows.Storage.Streams.IBuffer object which contains the data to be written to the Bluetooth LE device.
     * @return  The object that manages the asynchronous operation, which, upon completion, returns the status with which the operation completed.
     */
    writeValueAsync(
        value: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.GattCommunicationStatus >
}


/**
 * Represents an enumeration of the most well known Descriptor UUID values, and provides convenience methods for working with GATT descriptor UUIDs, and static properties providing descriptor UUIDs for common GATT descriptors. 
 */
declare class GattDescriptorUuids {

    /**
     * Gets the Bluetooth SIG-defined Characteristic Aggregate Format Descriptor UUID. 
     */
    characteristicAggregateFormat: string;

    /**
     * Gets the Bluetooth SIG-defined Characteristic Extended Properties Descriptor UUID. 
     */
    characteristicExtendedProperties: string;

    /**
     * Gets the Bluetooth SIG-defined Characteristic Presentation Format Descriptor UUID. 
     */
    characteristicPresentationFormat: string;

    /**
     * Gets the Bluetooth SIG-defined Characteristic User Description Descriptor UUID. 
     */
    characteristicUserDescription: string;

    /**
     * Gets the Bluetooth SIG-defined Client Characteristic Configuration Descriptor UUID. 
     */
    clientCharacteristicConfiguration: string;

    /**
     * Gets the Bluetooth SIG-defined Server Characteristic Configuration Descriptor UUID. 
     */
    serverCharacteristicConfiguration: string
}


/**
 * Represents a GATT Primary Service on a Bluetooth device. 
 */
declare class GattDeviceService {

    /**
     * Converts a Bluetooth SIG defined short Id to a full GATT UUID.
     * @param shortId A 16-bit Bluetooth GATT Service UUID.
     * @return  The corresponding 128-bit GATT Service UUID, that uniquely identifies this service.
     */
    convertShortIdToUuid(shortId: number): string;

    /**
     * Instantiates a new GattDeviceService from the device ID.
     * @param deviceId The GATT device ID.
     * @return  The object for managing the asynchronous operation, which, upon completion, returns the newly instantiated GattDeviceService.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.GattDeviceService>;

    /**
     * Creates a suitable AQS Filter string for use with the CreateWatcher method, from a 16-bit Bluetooth GATT Service UUID.
     * @param serviceShortId A 16-bit Bluetooth GATT Service UUID.
     * @return  A suitable AQS Selector String which can be passed as a parameter to the CreateWatcher method, in order to retrieve a GATT service instance path
     */
    getDeviceSelectorFromShortId(serviceShortId: number): string;

    /**
     * Creates a suitable AQS Filter string for use with the CreateWatcher method, from a Bluetooth service UUID.
     * @param serviceUuid A 128-bit Bluetooth GATT Service UUID, represented as a standard GUID object.
     * @return  A suitable AQS Selector String which can be passed as a parameter to the CreateWatcher method, in order to retrieve a GATT service instance path.
     */
    getDeviceSelectorFromUuid(serviceUuid: string): string;

    /**
     * Gets the handle used to uniquely identify GATT-based service attributes as declared on the Bluetooth LE device. 
     */
    attributeHandle: number;

    /**
     * Releases the resources associated with the GattDeviceService class. This allows other apps to access the resources of the GattDeviceService in question. A GattDeviceService object should not be used after Close is invoked, instead a new GattDeviceService object should be instantiated using the FromIdAsync method. 
     */
    close(): void;

    /**
     * Gets the BluetoothLEDevice object describing the device associated with the current GattDeviceService object. 
     */
    device: undefined.BluetoothLEDevice;

    /**
     * Get the string that represents the GATT service instance path used to instantiate the GattDeviceService. 
     */
    deviceId: string;

    /**
     * Gets the collection of all characteristics belonging to this GattDeviceService instance.
     * @return  The collection of all characteristics belonging to this GattDeviceService instance.
     */
    getAllCharacteristics(): undefined.IVectorView<undefined.GattCharacteristic>;

    /**
     * Gets the collection of all included services belonging to this GattDeviceService instance.
     * @return  The collection of all included services belonging to this GattDeviceService instance.
     */
    getAllIncludedServices(): undefined.IVectorView<undefined.GattDeviceService>;

    /**
     * Returns a vector of characteristics, that are identified by the specified UUID and belong to this GattDeviceService instance.
     * @param characteristicUuid The UUID for the characteristics to be retrieved.
     * @return  A vector of GattCharacteristic objects whose UUIDs match characteristicUuid.
     */
    getCharacteristics(
        characteristicUuid: string): undefined.IVectorView<undefined.GattCharacteristic>;

    /**
     * Returns a vector of included services, that are identified by the specified UUID and belong to this GattDeviceService instance.
     * @param serviceUuid The UUID for the included services to be retrieved.
     * @return  A vector of included services whose UUIDs match serviceUuid.
     */
    getIncludedServices(serviceUuid: string): undefined.IVectorView<undefined.GattDeviceService>;

    /**
     * Gets the read-only list of parent services for this service. 
     */
    parentServices: undefined.IVectorView<undefined.GattDeviceService>;

    /**
     * The GATT Service UUID associated with this GattDeviceService. 
     */
    uuid: string
}


/**
 * Represents the value of a single Presentation Format GATT Descriptor. 
 */
declare class GattPresentationFormat {

    /**
     * Gets the value of the Bluetooth SIG Assigned Numbers Namespace. 
     */
    bluetoothSigAssignedNumbers: number;

    /**
     * Gets the Description of the GattPresentationFormat object. 
     */
    description: number;

    /**
     * Gets the Exponent of the GattPresentationFormat object. 
     */
    exponent: number;

    /**
     * Gets the Format Type of the GattPresentationFormat object. 
     */
    formatType: number;

    /**
     * Gets the Namespace of the GattPresentationFormat object. 
     */
    namespace: number;

    /**
     * Gets the Unit of the GattPresentationFormat object. 
     */
    unit: number
}


/**
 * Represents the different well-known values that the GattPresentationFormat.FormatType property can take. 
 */
declare class GattPresentationFormatTypes {

    /**
     * Gets the value of the Bit2 Format Type. 
     */
    bit2: number;

    /**
     * Gets the value of the Boolean Format Type. 
     */
    boolean: number;

    /**
     * Gets the value of the DUInt16 Format Type. 
     */
    duInt16: number;

    /**
     * Gets the value of the Float Format Type. 
     */
    float: number;

    /**
     * Gets the value of the Float32 Format Type. 
     */
    float32: number;

    /**
     * Gets the value of the Float64 Format Type. 
     */
    float64: number;

    /**
     * Gets the value of the Nibble Format Type. 
     */
    nibble: number;

    /**
     * Gets the value of the SFloat Format Type. 
     */
    sfloat: number;

    /**
     * Gets the value of the SInt12 Format Type. 
     */
    sint12: number;

    /**
     * Gets the value of the SInt128 Format Type. 
     */
    sint128: number;

    /**
     * Gets the value of the SInt16 Format Type. 
     */
    sint16: number;

    /**
     * Gets the value of the SInt24 Format Type. 
     */
    sint24: number;

    /**
     * Gets the value of the SInt32 Format Type. 
     */
    sint32: number;

    /**
     * Gets the value of the SInt48 Format Type. 
     */
    sint48: number;

    /**
     * Gets the value of the SInt64 Format Type. 
     */
    sint64: number;

    /**
     * Gets the value of the SInt8 Format Type. 
     */
    sint8: number;

    /**
     * Gets the value of the Struct Format Type. 
     */
    struct: number;

    /**
     * Gets the value of the UInt12 Format Type. 
     */
    uint12: number;

    /**
     * Gets the value of the UInt128 Format Type. 
     */
    uint128: number;

    /**
     * Gets the value of the UInt16 Format Type. 
     */
    uint16: number;

    /**
     * Gets the value of the UInt24 Format Type. 
     */
    uint24: number;

    /**
     * Gets the value of the UInt32 Format Type. 
     */
    uint32: number;

    /**
     * Gets the value of the UInt48 Format Type. 
     */
    uint48: number;

    /**
     * Gets the value of the UInt64 Format Type. 
     */
    uint64: number;

    /**
     * Gets the value of the UInt8 Format Type. 
     */
    uint8: number;

    /**
     * Gets the value of the Utf16 Format Type. 
     */
    utf16: number;

    /**
     * Gets the value of the Utf8 Format Type. 
     */
    utf8: number
}


/**
 * Represents the result of reading a GATT Client CharacteristicConfigurationClientDescriptor value. 
 */
declare class GattReadClientCharacteristicConfigurationDescriptorResult {

    /**
     * Gets the result of an asynchronous read operation. 
     */
    clientCharacteristicConfigurationDescriptor: undefined.GattClientCharacteristicConfigurationDescriptorValue;

    /**
     * Gets the status of an asynchronous operation. 
     */
    status: undefined.GattCommunicationStatus
}


/**
 * Represents the result of an asynchronous read operation of a GATT Characteristic or Descriptor value. 
 */
declare class GattReadResult {

    /**
     * Gets the status of an asynchronous operation. 
     */
    status: undefined.GattCommunicationStatus;

    /**
     * Gets the value read from the device. 
     */
    value: undefined.IBuffer
}


/**
 * Performs GATT reliable writes on the Bluetooth LE device, in the form of a transaction write operation. 
 */
declare class GattReliableWriteTransaction {

    /**
     * Creates a new GattReliableWriteTransaction object. 
     */
    constructor(): this;

    /**
     * Performs all the queued writes, in sequence, writing the data to the device. Once a transaction object has been committed, no further operations are possible on the GattReliableWriteTransaction object.
     * @return  The object used to manage the asynchronous operation, which, upon completion, will return the status of the asynchronous operation.
     */
    commitAsync(): undefined.IPromiseWithIAsyncOperation<undefined.GattCommunicationStatus>;

    /**
     * Adds a new write operation to the transaction object.
     * @param characteristic The GattCharacteristic object on which to perform the write operation.
     * @param value The Characteristic Value to be written to characteristic.
     */
    writeValue(characteristic: undefined.GattCharacteristic, value: undefined.IBuffer): void
}


/**
 * Represents an enumeration of the most well known Service UUID values, and provides convenience methods for working with GATT service UUIDs, and static properties providing service UUIDs for common GATT services. 
 */
declare class GattServiceUuids {

    /**
     * Gets the Bluetooth SIG-defined AlertNotification Service UUID. 
     */
    alertNotification: string;

    /**
     * Gets the Bluetooth SIG-defined Battery Service UUID. 
     */
    battery: string;

    /**
     * Gets the Bluetooth SIG-defined Blood Pressure Service UUID. 
     */
    bloodPressure: string;

    /**
     * Gets the Bluetooth SIG-defined CurrentTime service UUID. 
     */
    currentTime: string;

    /**
     * Gets the Bluetooth SIG-defined CyclingPower service UUID. 
     */
    cyclingPower: string;

    /**
     * Gets the Bluetooth SIG-defined Cycling Speed And Cadence Service UUID. 
     */
    cyclingSpeedAndCadence: string;

    /**
     * Gets the Bluetooth SIG-defined DeviceInformation service UUID. 
     */
    deviceInformation: string;

    /**
     * Gets the Bluetooth SIG-defined UUID for the Generic Access Service. 
     */
    genericAccess: string;

    /**
     * Gets the Bluetooth SIG-defined UUID for the Generic Attribute Service. 
     */
    genericAttribute: string;

    /**
     * Gets the Bluetooth SIG-defined Glucose Service UUID. 
     */
    glucose: string;

    /**
     * Gets the Bluetooth SIG-defined Health Thermometer Service UUID. 
     */
    healthThermometer: string;

    /**
     * Gets the Bluetooth SIG-defined Heart Rate Service UUID. 
     */
    heartRate: string;

    /**
     * Gets the Bluetooth SIG-defined HumanInterfaceDevice service UUID. 
     */
    humanInterfaceDevice: string;

    /**
     * Gets the Bluetooth SIG-defined ImmediateAlert service UUID. 
     */
    immediateAlert: string;

    /**
     * Gets the Bluetooth SIG-defined LinkLoss service UUID. 
     */
    linkLoss: string;

    /**
     * Gets the Bluetooth SIG-defined LocationAndNavigation service UUID. 
     */
    locationAndNavigation: string;

    /**
     * Gets the Bluetooth SIG-defined NextDstChange service UUID. 
     */
    nextDstChange: string;

    /**
     * Gets the Bluetooth SIG-defined PhoneAlertStatus service UUID. 
     */
    phoneAlertStatus: string;

    /**
     * Gets the Bluetooth SIG-defined ReferenceTimeUpdate service UUID. 
     */
    referenceTimeUpdate: string;

    /**
     * Gets the Bluetooth SIG-defined Running Speed And Cadence Service UUID. 
     */
    runningSpeedAndCadence: string;

    /**
     * Gets the Bluetooth SIG-defined ScanParameters service UUID. 
     */
    scanParameters: string;

    /**
     * Gets the Bluetooth SIG-defined TxPower service UUID. 
     */
    txPower: string
}


/**
 * Represents the value received when registering to receive notifications or indications from a Bluetooth LE device. 
 */
declare class GattValueChangedEventArgs {

    /**
     * Gets the new Characteristic Value. 
     */
    characteristicValue: undefined.IBuffer;

    /**
     * Gets the time at which the system was notified of the Characteristic Value change. 
     */
    timestamp: Date
}


/**
 * Represents an instance of a service on a Bluetooth BR device. 
 */
declare class RfcommDeviceService {

    /**
     * Gets an RfcommDeviceService object from a DeviceInformation Id for an RFCOMM service instance.
     * @param deviceId The DeviceInformation Id that identifies the RFCOMM service instance. This id can be retrieved from Windows.Devices.Enumeration .
     * @return  The RfcommDeviceService object that represents the RFCOMM service instance.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.RfcommDeviceService>;

    /**
     * Gets an Advanced Query Syntax (AQS) string for identifying instances of an RFCOMM service. This string is passed to the CreateWatcher method.
     * @param serviceId The service id for which to query.
     * @return  An AQS string for identifying RFCOMM service instances.
     */
    getDeviceSelector(serviceId: undefined.RfcommServiceId): string;

    /**
     * Closes the RFCOMM device. 
     */
    close(): void;

    /**
     * Gets the connection host name of the RFCOMM service instance, which is used to connect to the remote device. 
     */
    connectionHostName: undefined.HostName;

    /**
     * Gets the connection service name of the RFCOMM service instance, which is used to connect to the remote device. 
     */
    connectionServiceName: string;

    /**
     * Gets the BluetoothDevice object describing the device associated with the current RfcommDeviceService object. 
     */
    device: undefined.BluetoothDevice;

    /**
     * Gets the cached SDP attributes of the RFCOMM service instance.
     * @return  The SDP attributes of the RFCOMM service instance.
     */
    getSdpRawAttributesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IMapView<any, any >> ;

    /**
     * Gets the SDP attributes of the RFCOMM service instance.
     * @param cacheMode Indicates whether SDP attributes should be retrieved from the cache or from the device.
     * @return  The SDP attributes of the RFCOMM service instance.
     */
    getSdpRawAttributesAsync(
        cacheMode: undefined.BluetoothCacheMode): undefined.IPromiseWithIAsyncOperation<undefined.IMapView<any, any >> ;

    /**
     * Gets the maximum SocketProtectionLevel supported by this RFCOMM service instance. 
     */
    maxProtectionLevel: undefined.SocketProtectionLevel;

    /**
     * Gets the current SocketProtectionLevel of the RFCOMM service instance. 
     */
    protectionLevel: undefined.SocketProtectionLevel;

    /**
     * Gets the RfcommServiceId of this RFCOMM service instance. 
     */
    serviceId: undefined.RfcommServiceId
}


/**
 * Represents an RFCOMM service ID. 
 */
declare class RfcommServiceId {

    /**
     * Creates a RfcommServiceId object from a 32-bit service id.
     * @param shortId The 32-bit service id.
     * @return  The RfcommServiceId object.
     */
    fromShortId(shortId: number): undefined.RfcommServiceId;

    /**
     * Creates a RfcommServiceId object from a 128-bit service id.
     * @param uuid The 128-bit service id.
     * @return  The RfcommServiceId object.
     */
    fromUuid(uuid: string): undefined.RfcommServiceId;

    /**
     * Creates a RfcommServiceId object corresponding to the service id for the standardized Generic File Transfer service (with short id 0x1202). 
     */
    genericFileTransfer: undefined.RfcommServiceId;

    /**
     * Creates a RfcommServiceId object corresponding to the service id for the standardized OBEX File Transfer service (with short id 0x1106). 
     */
    obexFileTransfer: undefined.RfcommServiceId;

    /**
     * Creates a RfcommServiceId object corresponding to the service id for the standardized OBEX Object Push service (with short id 0x1105). 
     */
    obexObjectPush: undefined.RfcommServiceId;

    /**
     * Creates a RfcommServiceId object corresponding to the service id for the standardized Phone Book Access (PCE) service (with short id 0x112E). 
     */
    phoneBookAccessPce: undefined.RfcommServiceId;

    /**
     * Creates a RfcommServiceId object corresponding to the service id for the standardized Phone Book Access (PSE) service (with short id 0x112F). 
     */
    phoneBookAccessPse: undefined.RfcommServiceId;

    /**
     * Creates a RfcommServiceId object corresponding to the service id for the standardized Serial Port service (with short id 0x1101). 
     */
    serialPort: undefined.RfcommServiceId;

    /**
     * Converts the RfcommServiceId to a 32-bit service id if possible.
     * @return  Returns the 32-bit service id if the RfcommServiceId represents a standardized service.
     */
    asShortId(): number;

    /**
     * Converts the RfcommServiceId to a string.
     * @return  Returns the string representation of the 128-bit service id.
     */
    asString(): string;

    /**
     * Retrieves the 128-bit service id. 
     */
    uuid: string
}


/**
 * Represents an instance of a local RFCOMM service. 
 */
declare class RfcommServiceProvider {

    /**
     * Gets a RfcommServiceProvider object from a DeviceInformation Id for a RFCOMM service instance.
     * @param serviceId The RfcommServiceId to be hosted locally.
     * @return  The RfcommServiceProvider object that represents the local RFCOMM service instance.
     */
    createAsync(
        serviceId: undefined.RfcommServiceId): undefined.IPromiseWithIAsyncOperation<undefined.RfcommServiceProvider>;

    /**
     * Gets a collection of SDP attributes for advertising. 
     */
    sdpRawAttributes: undefined.IMap<number, undefined.IBuffer>;

    /**
     * Gets the RfcommServiceId of this local RFCOMM service instance. 
     */
    serviceId: undefined.RfcommServiceId;

    /**
     * Begins advertising the SDP attributes.
     * @param listener The StreamSocketListener that is listening for incoming connections.
     */
    startAdvertising(listener: undefined.StreamSocketListener): void;

    /**
     * Begins advertising the SDP attributes.
     * @param listener The StreamSocketListener that is listening for incoming connections.
     * @param radioDiscoverable Indicates whether the radio is discoverable (true) or not (false).
     */
    startAdvertising(listener: undefined.StreamSocketListener, radioDiscoverable: boolean): void;

    /**
     * Stops advertising the SDP attributes. 
     */
    stopAdvertising(): void
}


/**
 * Represents a custom device. 
 */
declare class CustomDevice {

    /**
     * Creates a CustomDevice object asynchronously for the specified DeviceInformation.Id .
     * @param deviceId The DeviceInformation.Id of the device .
     * @param desiredAccess The desired access.
     * @param sharingMode The sharing mode.
     * @return  Returns a custom device.
     */
    fromIdAsync(
        deviceId: string,
        desiredAccess: undefined.DeviceAccessMode,
        sharingMode: undefined.DeviceSharingMode): undefined.IPromiseWithIAsyncOperation<undefined.CustomDevice>;

    /**
     * Gets a device selector.
     * @param classGuid The Device Interface Class GUID of the device interface to create a device selector for.
     * @return  The device selector.
     */
    getDeviceSelector(classGuid: string): string;

    /**
     * The input stream. 
     */
    inputStream: undefined.IInputStream;

    /**
     * The output stream. 
     */
    outputStream: undefined.IOutputStream;

    /**
     * Sends an IO control code.
     * @param ioControlCode The IO control code.
     * @param inputBuffer The input buffer.
     * @param outputBuffer The output buffer.
     * @return  The result of the async operation.
     */
    sendIOControlAsync(
        ioControlCode: undefined.IIOControlCode,
        inputBuffer: undefined.IBuffer,
        outputBuffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Sends an IO control code. A return value indicates whether the operation succeeded.
     * @param ioControlCode The IO control code.
     * @param inputBuffer The input buffer.
     * @param outputBuffer The output buffer.
     * @return  true if the operation is successful; otherwise, false.
     */
    trySendIOControlAsync(
        ioControlCode: undefined.IIOControlCode,
        inputBuffer: undefined.IBuffer,
        outputBuffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<boolean >
}


/**
 * Represents the control code. 
 */
declare class IOControlCode {

    /**
     * The control code.
     * @param deviceType The device type.
     * @param function The device function.
     * @param accessMode The access mode.
     * @param bufferingMethod The buffering method.
     */
    constructor(deviceType: number, func: number, accessMode: undefined.IOControlAccessMode, bufferingMethod: undefined.IOControlBufferingMethod): this;

    /**
     * The access mode. 
     */
    accessMode: undefined.IOControlAccessMode;

    /**
     * The buffering method. 
     */
    bufferingMethod: undefined.IOControlBufferingMethod;

    /**
     * The control code. 
     */
    controlCode: number;

    /**
     * The device type. 
     */
    deviceType: number;

    /**
     * The function. 
     */
    function: number
}


/**
 * Represents know device types. 
 */
declare class KnownDeviceTypes {

    /**
     * Defined by the device vendor. 
     */
    unknown: number
}


/**
 * Represents IO control code. 
 */
declare interface Custom$IIOControlCode {

    /**
     * The access mode. 
     */
    accessMode: undefined.IOControlAccessMode,

        /**
         * The buffering method. 
         */
        bufferingMethod: undefined.IOControlBufferingMethod,

        /**
         * The control code. 
         */
        controlCode: number,

        /**
         * The device type. 
         */
        deviceType: number,

        /**
         * The function. 
         */
        function: number
}


/**
 * Provides data for the AccessChanged event. 
 */
declare class DeviceAccessChangedEventArgs {

    /**
     * The new status of access to a device. 
     */
    status: undefined.DeviceAccessStatus
}


/**
 * Contains the information about access to a device. 
 */
declare class DeviceAccessInformation {

    /**
     * Initializes a DeviceAccessInformation object based on a given DeviceClass .
     * @param deviceClass Device class to get DeviceAccessInformation about.
     * @return  The DeviceAccessInformation object for the given DeviceClass .
     */
    createFromDeviceClass(deviceClass: undefined.DeviceClass): undefined.DeviceAccessInformation;

    /**
     * Initializes a DeviceAccessInformation object based on a device class id.
     * @param deviceClassId Id of the device class to get DeviceAccessInformation about.
     * @return  The DeviceAccessInformation object for the given device class id.
     */
    createFromDeviceClassId(deviceClassId: string): undefined.DeviceAccessInformation;

    /**
     * Initializes a DeviceAccessInformation object based on a device id.
     * @param deviceId Id of the device to get DeviceAccessInformation about.
     * @return  The DeviceAccessInformation object for the given device id.
     */
    createFromId(deviceId: string): undefined.DeviceAccessInformation;

    /**
     * The current device access status. 
     */
    currentStatus: undefined.DeviceAccessStatus;

    /**
     * Raised when access to a device has changed. 
     */
    onaccesschanged: undefined.TypedEventHandler<undefined.DeviceAccessInformation, undefined.DeviceAccessChangedEventArgs>;
    addEventListener(
        type: "accesschanged",
        listener: undefined.TypedEventHandler<undefined.DeviceAccessInformation, undefined.DeviceAccessChangedEventArgs>): void;
    removeEventListener(
        type: "accesschanged",
        listener: undefined.TypedEventHandler<undefined.DeviceAccessInformation, undefined.DeviceAccessChangedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides information about the device that caused this trigger to fire. 
 */
declare class DeviceConnectionChangeTriggerDetails {

    /**
     * Gets the device Id of the device that caused this trigger to fire. 
     */
    deviceId: string
}


/**
 * Provides data for the DisconnectButtonClicked event on the DevicePicker object. 
 */
declare class DeviceDisconnectButtonClickedEventArgs {

    /**
     * The device that the user clicked the disconnect button for. 
     */
    device: undefined.DeviceInformation
}


/**
 * Represents a device. This class allows access to well-known device properties as well as additional properties specified during device enumeration. 
 */
declare class DeviceInformation {

    /**
     * Creates a DeviceInformation object from a DeviceInformation ID and a list of additional properties.
     * @param deviceId A string containing the DeviceInformation ID.
     * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
     * @return  An object for starting and managing the asynchronous creation of the DeviceInformation object.
     */
    createFromIdAsync(
        deviceId: string,
        additionalProperties: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.DeviceInformation>;

    /**
     * Creates a DeviceInformation object from a DeviceInformation ID.
     * @param deviceId The device ID.
     * @return  An object for starting and managing the asynchronous creation of the DeviceInformation object.
     */
    createFromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.DeviceInformation>;

    /**
     * Creates a DeviceInformation object from a DeviceInformation ID, a list of additional properties, and a DeviceInformationKind parameter.
     * @param deviceId A string containing the DeviceInformation ID.
     * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
     * @param kind The type of DeviceInformation object you want to create.
     * @return  An object for starting and managing the asynchronous creation of the DeviceInformation object.
     */
    createFromIdAsync(
        deviceId: string,
        additionalProperties: undefined.IIterable<string>,
        kind: undefined.DeviceInformationKind): undefined.IPromiseWithIAsyncOperation<undefined.DeviceInformation>;

    /**
     * Creates a DeviceWatcher for all devices.
     * @return  The created DeviceWatcher .
     */
    createWatcher(): undefined.DeviceWatcher;

    /**
     * Creates a DeviceWatcher for devices matching the specified Advanced Query Syntax (AQS) string and the specified collection of properties.
     * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
     * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
     * @return  The created DeviceWatcher .
     */
    createWatcher(
        aqsFilter: string,
        additionalProperties: undefined.IIterable<string>): undefined.DeviceWatcher;

    /**
     * Creates a DeviceWatcher for devices matching the specified Advanced Query Syntax (AQS) string.
     * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
     * @return  The created DeviceWatcher .
     */
    createWatcher(aqsFilter: string): undefined.DeviceWatcher;

    /**
     * Creates a DeviceWatcher for devices matching the specified DeviceClass .
     * @param deviceClass The class of device to enumerate using the DeviceWatcher .
     * @return  The created DeviceWatcher .
     */
    createWatcher(deviceClass: undefined.DeviceClass): undefined.DeviceWatcher;

    /**
     * Creates a DeviceWatcher for devices matching the specified Advanced Query Syntax (AQS) string, the specified collection of properties, and the kind of devices.
     * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
     * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
     * @param kind The specific types of devices the DeviceWatcher is interested in.
     * @return  The created DeviceWatcher .
     */
    createWatcher(
        aqsFilter: string,
        additionalProperties: undefined.IIterable<string>,
        kind: undefined.DeviceInformationKind): undefined.DeviceWatcher;

    /**
     * Enumerates DeviceInformation objects matching the specified Advanced Query Syntax (AQS) string and including the specified collection of properties.
     * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
     * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
     * @return  The object for managing the asynchronous operation.
     */
    findAllAsync(
        aqsFilter: string,
        additionalProperties: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.DeviceInformationCollection>;

    /**
     * Enumerates DeviceInformation objects of the specified class.
     * @param deviceClass The class of devices to enumerate.
     * @return  The object for managing the asynchronous operation.
     */
    findAllAsync(
        deviceClass: undefined.DeviceClass): undefined.IPromiseWithIAsyncOperation<undefined.DeviceInformationCollection>;

    /**
     * Enumerates DeviceInformation objects matching the specified Advanced Query Syntax (AQS) string.
     * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
     * @return  The object for managing the asynchronous operation.
     */
    findAllAsync(
        aqsFilter: string): undefined.IPromiseWithIAsyncOperation<undefined.DeviceInformationCollection>;

    /**
     * Enumerates all DeviceInformation objects.
     * @return  The object for managing the asynchronous operation.
     */
    findAllAsync(): undefined.IPromiseWithIAsyncOperation<undefined.DeviceInformationCollection>;

    /**
     * Enumerates DeviceInformation objects matching the specified Advanced Query Syntax (AQS) string, the device kind, and including the specified collection of properties.
     * @param aqsFilter An AQS string that filters the DeviceInformation objects to enumerate. Typically this string is retrieved from the GetDeviceSelector method of a class that interacts with devices. For example, GetDeviceSelector retrieves the string for the StorageDevice class.
     * @param additionalProperties An iterable list of additional properties to include in the Properties property of the DeviceInformation objects in the enumeration results. For more info on what the properties represent, see Device information properties.
     * @param kind The specific type of device to find.
     * @return  The object for managing the asynchronous operation.
     */
    findAllAsync(
        aqsFilter: string,
        additionalProperties: undefined.IIterable<string>,
        kind: undefined.DeviceInformationKind): undefined.IPromiseWithIAsyncOperation<undefined.DeviceInformationCollection>;

    /**
     * Creates a filter to use to enumerate through a subset of device types.
     * @param deviceClass The type of devices that you want to create a filter for.
     * @return  The Advanced Query Syntax (AQS) filter used to specifically enumerate through the device type specified by deviceClass.
     */
    getAqsFilterFromDeviceClass(deviceClass: undefined.DeviceClass): string;

    /**
     * The physical location of the device in its enclosure. For example, it may describe the location of a webcam inside a laptop. 
     */
    enclosureLocation: undefined.EnclosureLocation;

    /**
     * Gets a glyph for the device.
     * @return  The object for managing the asynchronous operation that will return a DeviceThumbnail
     */
    getGlyphThumbnailAsync(): undefined.IPromiseWithIAsyncOperation<undefined.DeviceThumbnail>;

    /**
     * Returns a thumbnail image for the device.
     * @return  The object for managing the asynchronous operation that will return a DeviceThumbnail .
     */
    getThumbnailAsync(): undefined.IPromiseWithIAsyncOperation<undefined.DeviceThumbnail>;

    /**
     * A string representing the identity of the device. 
     */
    id: string;

    /**
     * Indicates whether this device is the default device for the class. 
     */
    isDefault: boolean;

    /**
     * Indicates whether this device is enabled. 
     */
    isEnabled: boolean;

    /**
     * Gets the type of DeviceInformation represented by this object. 
     */
    kind: undefined.DeviceInformationKind;

    /**
     * The name of the device. This name is in the best available language for the app. 
     */
    name: string;

    /**
     * Gets the information about the capabilities for this device to pair. 
     */
    pairing: undefined.DeviceInformationPairing;

    /**
     * Property store containing well-known values as well as additional properties that can be specified during device enumeration. 
     */
    properties: undefined.IMapView<string, any>;

    /**
     * Updates the properties of an existing DeviceInformation object.
     * @param updateInfo Indicates the properties to update.
     */
    update(updateInfo: undefined.DeviceInformationUpdate): void
}


/**
 * Represents a collection of DeviceInformation objects. 
 */
declare class DeviceInformationCollection mixins Array<undefined.DeviceInformation>{

    /**
     * Gets an object that can iterate through the enumerated DeviceInformation objects, starting with the first.
     * @return  An object that can iterate through the enumerated devices, starting with the first.
     */
    first(): undefined.IIterator<undefined.DeviceInformation>;

    /**
     * Gets the DeviceInformation object at the specified index.
     * @param index The index.
     * @return  The DeviceInformation object at the specified index.
     */
    getAt(index: number): undefined.DeviceInformation;

    /**
     * Gets a range of DeviceInformation objects.
     * @param startIndex The index at which to start retrieving DeviceInformation objects.
     */
    getMany(
        startIndex: number): {
        items: undefined.DeviceInformation,
        returnValue: number
    };

    /**
     * Returns the index of the specified DeviceInformation object in the collection.
     * @param value The DeviceInformation object in the collection.
     */
    indexOf(value: undefined.DeviceInformation): {
        index: number,
        returnValue: boolean
    };

    /**
     * The number of DeviceInformation objects in the collection. 
     */
    size: number;
    indexOf(
        value: undefined.DeviceInformation,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.DeviceInformation, fromIndex?: number): number
}


/**
 * Represents a custom pairing for a DeviceInformation object. 
 */
declare class DeviceInformationCustomPairing {

    /**
     * Raised when a pairing action is requested. 
     */
    onpairingrequested: undefined.TypedEventHandler<undefined.DeviceInformationCustomPairing, undefined.DevicePairingRequestedEventArgs>;
    addEventListener(
        type: "pairingrequested",
        listener: undefined.TypedEventHandler<undefined.DeviceInformationCustomPairing, undefined.DevicePairingRequestedEventArgs>): void;
    removeEventListener(
        type: "pairingrequested",
        listener: undefined.TypedEventHandler<undefined.DeviceInformationCustomPairing, undefined.DevicePairingRequestedEventArgs>): void;

    /**
     * Attempts to pair the device.
     * @param pairingKindsSupported The different pairing kinds supported by this DeviceInformation object.
     * @return  The result of the pairing action.
     */
    pairAsync(
        pairingKindsSupported: undefined.DevicePairingKinds): undefined.IPromiseWithIAsyncOperation<undefined.DevicePairingResult>;

    /**
     * Attempts to pair a device using a minimum protection level and custom settings.
     * @param pairingKindsSupported The different pairing kinds supported by this DeviceInformation object.
     * @param minProtectionLevel The minimum protection level this DeviceInformation object requires in order to pair.
     * @param devicePairingSettings The custom device pairing settings.
     * @return  The result of the pairing action.
     */
    pairAsync(
        pairingKindsSupported: undefined.DevicePairingKinds,
        minProtectionLevel: undefined.DevicePairingProtectionLevel,
        devicePairingSettings: undefined.IDevicePairingSettings): undefined.IPromiseWithIAsyncOperation<undefined.DevicePairingResult>;

    /**
     * Attempts to pair a device using a minimum protection level.
     * @param pairingKindsSupported The different pairing kinds supported by this DeviceInformation object.
     * @param minProtectionLevel The minimum protection level this DeviceInformation object requires in order to pair.
     * @return  The result of the pairing action.
     */
    pairAsync(
        pairingKindsSupported: undefined.DevicePairingKinds,
        minProtectionLevel: undefined.DevicePairingProtectionLevel): undefined.IPromiseWithIAsyncOperation<undefined.DevicePairingResult>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains information and enables pairing for a device. 
 */
declare class DeviceInformationPairing {

    /**
     * Attempts to pair for all inbound pairing requests
     * @param pairingKindsSupported The pairing kinds this device supports.
     * @return  Whether or not the attempt was successful.
     */
    tryRegisterForAllInboundPairingRequests(pairingKindsSupported: undefined.DevicePairingKinds): boolean;

    /**
     * Gets a value that indicates whether the device can be paired. 
     */
    canPair: boolean;

    /**
     * Gets the DeviceInformationCustomPairing object necessary for custom pairing. 
     */
    custom: undefined.DeviceInformationCustomPairing;

    /**
     * Gets a value that indicates whether the device is currently paired. 
     */
    isPaired: boolean;

    /**
     * Attempts to pair the device.
     * @return  The result of the pairing action.
     */
    pairAsync(): undefined.IPromiseWithIAsyncOperation<undefined.DevicePairingResult>;

    /**
     * Attempts to pair the device using a provided level of protection.
     * @param minProtectionLevel The required level of protection to use for the pairing action.
     * @return  The result of the pairing action.
     */
    pairAsync(
        minProtectionLevel: undefined.DevicePairingProtectionLevel): undefined.IPromiseWithIAsyncOperation<undefined.DevicePairingResult>;

    /**
     * Attempts to pair a device object with a specified protection level and custom settings.
     * @param minProtectionLevel The required level of protection to use for the pairing action.
     * @param devicePairingSettings The custom device pairing settings.
     * @return  The result of the pairing action.
     */
    pairAsync(
        minProtectionLevel: undefined.DevicePairingProtectionLevel,
        devicePairingSettings: undefined.IDevicePairingSettings): undefined.IPromiseWithIAsyncOperation<undefined.DevicePairingResult>;

    /**
     * Gets the level of protection used to pair the device. 
     */
    protectionLevel: undefined.DevicePairingProtectionLevel;

    /**
     * Attempts to unpair the device.
     * @return  The result of the unpairing action.
     */
    unpairAsync(): undefined.IPromiseWithIAsyncOperation<undefined.DeviceUnpairingResult >
}


/**
 * Contains updated properties for a DeviceInformation object. 
 */
declare class DeviceInformationUpdate {

    /**
     * The DeviceInformation ID of the updated device. 
     */
    id: string;

    /**
     * Gets the type of device for the updated device. 
     */
    kind: undefined.DeviceInformationKind;

    /**
     * The changed properties in a update to a DeviceInformation object. 
     */
    properties: undefined.IMapView<string, any >
}


/**
 * Provides data for the PairingRequested event. 
 */
declare class DevicePairingRequestedEventArgs {

    /**
     * Accepts a PairingRequested event and pairs the device with the application. 
     */
    accept(): void;

    /**
     * Accepts a PairingRequested event and pairs the device with the application. Requires a pin for pairing purposes.
     * @param pin The pin to use for attempting to pair a device.
     */
    accept(pin: string): void;

    /**
     * Gets the DeviceInformation object associated with this pairing request. 
     */
    deviceInformation: undefined.DeviceInformation;

    /**
     * Requests a Deferral to support asynchronous operations.
     * @return  The deferral necessary to support asynchronous actions.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Gets the kind of pairing associated with this pairing event. 
     */
    pairingKind: undefined.DevicePairingKinds;

    /**
     * Gets the pin associated with a pairing request. 
     */
    pin: string
}


/**
 * Contains information about the result of attempting to pair a device. 
 */
declare class DevicePairingResult {

    /**
     * Gets the level of protection used to pair the device. 
     */
    protectionLevelUsed: undefined.DevicePairingProtectionLevel;

    /**
     * Gets the paired status of the device after the pairing action completed. 
     */
    status: undefined.DevicePairingResultStatus
}


/**
 * Represents a picker flyout that contains a list of devices for the user to choose from. 
 */
declare class DevicePicker {

    /**
     * Creates a DevicePicker object. 
     */
    constructor(): this;

    /**
     * Gets the colors of the picker. 
     */
    appearance: undefined.DevicePickerAppearance;

    /**
     * Gets the filter used to choose what devices to show in the picker. 
     */
    filter: undefined.DevicePickerFilter;

    /**
     * Hides the picker. 
     */
    hide(): void;

    /**
     * Indicates that the device picker was light dismissed by the user. Light dismiss happens when the user clicks somewhere other than the picker UI and the picker UI disappears. 
     */
    ondevicepickerdismissed: undefined.TypedEventHandler<undefined.DevicePicker, any>;
    addEventListener(
        type: "devicepickerdismissed",
        listener: undefined.TypedEventHandler<undefined.DevicePicker, any>): void;
    removeEventListener(
        type: "devicepickerdismissed",
        listener: undefined.TypedEventHandler<undefined.DevicePicker, any>): void;

    /**
     * Indicates that the user selected a device in the picker. 
     */
    ondeviceselected: undefined.TypedEventHandler<undefined.DevicePicker, undefined.DeviceSelectedEventArgs>;
    addEventListener(
        type: "deviceselected",
        listener: undefined.TypedEventHandler<undefined.DevicePicker, undefined.DeviceSelectedEventArgs>): void;
    removeEventListener(
        type: "deviceselected",
        listener: undefined.TypedEventHandler<undefined.DevicePicker, undefined.DeviceSelectedEventArgs>): void;

    /**
     * Indicates that the user clicked or tapped the disconnect button for a device in the picker. 
     */
    ondisconnectbuttonclicked: undefined.TypedEventHandler<undefined.DevicePicker, undefined.DeviceDisconnectButtonClickedEventArgs>;
    addEventListener(
        type: "disconnectbuttonclicked",
        listener: undefined.TypedEventHandler<undefined.DevicePicker, undefined.DeviceDisconnectButtonClickedEventArgs>): void;
    removeEventListener(
        type: "disconnectbuttonclicked",
        listener: undefined.TypedEventHandler<undefined.DevicePicker, undefined.DeviceDisconnectButtonClickedEventArgs>): void;

    /**
     * Shows the picker UI and returns the selected device; does not require you to register for an event. The picker flies out from the specified edge of the specified rectangle.
     * @param selection The rectangle from which you want the picker to fly out.
     * @param placement The edge of the rectangle from which you want the picker to fly out.
     * @return  The device selected.
     */
    pickSingleDeviceAsync(
        selection: undefined.Rect,
        placement: undefined.Placement): undefined.IPromiseWithIAsyncOperation<undefined.DeviceInformation>;

    /**
     * Shows the picker UI and returns the selected device; does not require you to register for an event. The picker flies out from the edge of the specified rectangle.
     * @param selection The rectangle from which you want the picker to fly out.
     * @return  The device selected by the user.
     */
    pickSingleDeviceAsync(
        selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<undefined.DeviceInformation>;

    /**
     * Gets a collection of properties for the returned device information object. 
     */
    requestedProperties: undefined.IVector<string>;

    /**
     * Updates the picker UI to reflect the provided status and display options for a specified device.
     * @param device The device information.
     * @param status The status to display.
     * @param options The display options for the device.
     */
    setDisplayStatus(
        device: undefined.DeviceInformation,
        status: string,
        options: undefined.DevicePickerDisplayStatusOptions): void;

    /**
     * Shows the picker UI. The picker flies out from the specified edge of the specified rectangle.
     * @param selection The rectangle from which you want the picker to fly out.
     * @param placement The edge of the rectangle from which you want the picker to fly out.
     */
    show(selection: undefined.Rect, placement: undefined.Placement): void;

    /**
     * Shows the picker UI. The picker flies out from the edge of the specified rectangle.
     * @param selection The rectangle from which you want the picker to fly out.
     */
    show(selection: undefined.Rect): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the appearance of a device picker. 
 */
declare class DevicePickerAppearance {

    /**
     * Gets and sets the accent color of the picker UI. 
     */
    accentColor: undefined.Color;

    /**
     * Gets and sets the background color of the picker UI. 
     */
    backgroundColor: undefined.Color;

    /**
     * Gets and sets the foreground color of the picker UI. 
     */
    foregroundColor: undefined.Color;

    /**
     * Gets and sets the accent color for a device that has been selected in the picker. 
     */
    selectedAccentColor: undefined.Color;

    /**
     * Gets and sets the background color for a device that is selected in the picker. 
     */
    selectedBackgroundColor: undefined.Color;

    /**
     * Gets and sets the foreground color for a device that is selected in the picker. 
     */
    selectedForegroundColor: undefined.Color;

    /**
     * Gets and sets the title for the picker UI. 
     */
    title: string
}


/**
 * Represents the filter used to determine which devices to show in the device picker. The filter parameters are OR-ed together to build the resulting filter. 
 */
declare class DevicePickerFilter {

    /**
     * Gets a list of supported device classes to show in the picker. This defaults to an empty list (no filter). You can add device classes to this vector and filter the devices list to those that are in one or more of the provided classes. 
     */
    supportedDeviceClasses: undefined.IVector<undefined.DeviceClass>;

    /**
     * Gets a list of AQS filter strings. This defaults to empty list (no filter). You can add one or more AQS filter strings to this vector and filter the devices list to those that meet one or more of the provided filters. 
     */
    supportedDeviceSelectors: undefined.IVector<string >
}


/**
 * Provides data for the DeviceSelected event on the DevicePicker object. 
 */
declare class DeviceSelectedEventArgs {

    /**
     * The device selected by the user in the picker. 
     */
    selectedDevice: undefined.DeviceInformation
}


/**
 * Represents the thumbnail image for a device. 
 */
declare class DeviceThumbnail {

    /**
     * Gets a value that indicates whether the stream can be read from. 
     */
    canRead: boolean;

    /**
     * Gets a value that indicates whether the stream can be written to. 
     */
    canWrite: boolean;

    /**
     * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
     * @return  The new stream. The initial, internal position of the stream is 0.
     */
    cloneStream(): undefined.IRandomAccessStream;

    /**
     * Closes the current stream and releases system resources. 
     */
    close(): void;

    /**
     * Returns the content type of the thumbnail image. 
     */
    contentType: string;

    /**
     * Flushes data asynchronously in a sequential stream.
     * @return  The stream flush operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Returns a pointer to an input stream starting at the specified location.
     * @param position The position in the input stream.
     * @return  A pointer to an input stream.
     */
    getInputStreamAt(position: number): undefined.IInputStream;

    /**
     * Returns a pointer to an output stream starting at the specified location.
     * @param position The position in the output stream.
     * @return  A pointer to an output stream.
     */
    getOutputStreamAt(position: number): undefined.IOutputStream;

    /**
     * Gets the byte offset of the stream. 
     */
    position: number;

    /**
     * Returns an asynchronous byte reader object.
     * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
     * @param count The number of bytes to read.
     * @param options Specifies the type of the asynchronous read operation.
     * @return  The asynchronous operation.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Sets the position of the stream to the specified value.
     * @param position The new position of the stream.
     */
    seek(position: number): void;

    /**
     * Gets or sets the size of the device thumbnail image. 
     */
    size: number;

    /**
     * Writes data asynchronously in a sequential stream.
     * @param buffer The buffer into which the asynchronous writer operation writes.
     * @return  The byte writer operation.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Contains information about the result of attempting to unpair a device. 
 */
declare class DeviceUnpairingResult {

    /**
     * Gets the paired status of the device after the unpairing action completed. 
     */
    status: undefined.DeviceUnpairingResultStatus
}


/**
 * Enumerates devices dynamically, so that the app receives notifications if devices are added, removed, or changed after the initial enumeration is complete. 
 */
declare class DeviceWatcher {

    /**
     * Gets a DeviceWatcherTrigger object monitoring for changes to the list of devices.
     * @param requestedEventKinds A list of the specific updates you want to monitor.
     * @return  The watcher trigger to monitor for the specified changes.
     */
    getBackgroundTrigger(
        requestedEventKinds: undefined.IIterable<undefined.DeviceWatcherEventKind>): undefined.DeviceWatcherTrigger;

    /**
     * Event that is raised when a device is added to the collection enumerated by the DeviceWatcher . 
     */
    onadded: undefined.TypedEventHandler<undefined.DeviceWatcher, undefined.DeviceInformation>;
    addEventListener(
        type: "added",
        listener: undefined.TypedEventHandler<undefined.DeviceWatcher, undefined.DeviceInformation>): void;
    removeEventListener(
        type: "added",
        listener: undefined.TypedEventHandler<undefined.DeviceWatcher, undefined.DeviceInformation>): void;

    /**
     * Event that is raised when the enumeration of devices completes. 
     */
    onenumerationcompleted: undefined.TypedEventHandler<undefined.DeviceWatcher, any>;
    addEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.DeviceWatcher, any>): void;
    removeEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.DeviceWatcher, any>): void;

    /**
     * Event that is raised when a device is removed from the collection of enumerated devices. 
     */
    onremoved: undefined.TypedEventHandler<undefined.DeviceWatcher, undefined.DeviceInformationUpdate>;
    addEventListener(
        type: "removed",
        listener: undefined.TypedEventHandler<undefined.DeviceWatcher, undefined.DeviceInformationUpdate>): void;
    removeEventListener(
        type: "removed",
        listener: undefined.TypedEventHandler<undefined.DeviceWatcher, undefined.DeviceInformationUpdate>): void;

    /**
     * Event that is raised when the enumeration operation has been stopped. 
     */
    onstopped: undefined.TypedEventHandler<undefined.DeviceWatcher, any>;
    addEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.DeviceWatcher, any>): void;
    removeEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.DeviceWatcher, any>): void;

    /**
     * Event that is raised when a device is updated in the collection of enumerated devices. 
     */
    onupdated: undefined.TypedEventHandler<undefined.DeviceWatcher, undefined.DeviceInformationUpdate>;
    addEventListener(
        type: "updated",
        listener: undefined.TypedEventHandler<undefined.DeviceWatcher, undefined.DeviceInformationUpdate>): void;
    removeEventListener(
        type: "updated",
        listener: undefined.TypedEventHandler<undefined.DeviceWatcher, undefined.DeviceInformationUpdate>): void;

    /**
     * Starts a search for devices, and subscribes to device enumeration events. 
     */
    start(): void;

    /**
     * The status of the DeviceWatcher . 
     */
    status: undefined.DeviceWatcherStatus;

    /**
     * Stop raising the events that add, update and remove enumeration results. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Triggered when the list of devices is updated after the initial enumeration is complete. 
 */
declare class DeviceWatcherEvent {

    /**
     * Gets the information for the device associated with the DeviceWatcherEvent . 
     */
    deviceInformation: undefined.DeviceInformation;

    /**
     * Gets updated information for a device updated by the DeviceWatcherEvent . 
     */
    deviceInformationUpdate: undefined.DeviceInformationUpdate;

    /**
     * Gets the type for the device indicated by the DeviceWatcherEvent . 
     */
    kind: undefined.DeviceWatcherEventKind
}


/**
 * Provides details about the device updates that invoked the trigger. 
 */
declare class DeviceWatcherTriggerDetails {

    /**
     * Gets the events that activated the trigger. 
     */
    deviceWatcherEvents: undefined.IVectorView<undefined.DeviceWatcherEvent >
}


/**
 * Describes the physical location of a device in its enclosure. 
 */
declare class EnclosureLocation {

    /**
     * Indicates whether the device is physically located in the docking station of the portable computer. 
     */
    inDock: boolean;

    /**
     * Indicates whether the device is physically located in the lid of the portable computer. 
     */
    inLid: boolean;

    /**
     * Indicates which panel of the computer the device is physically located on. 
     */
    panel: undefined.Panel
}


/**
 * Represents a PnP object. This class allows access to well-known properties of a PnP object as well as a property store of additional properties that are specified to be retrieved from the the PnP object. 
 */
declare class PnpObject {

    /**
     * Creates a PnpObject object asynchronously from a previously saved DeviceInformation ID.
     * @param type The type of the PnpObject .
     * @param id The string value identifying the PnpObject .
     * @param requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject object to create. For more info on what the properties represent, see Device information properties.
     * @return  The PnpObject created from the previously saved DeviceInformation ID.
     */
    createFromIdAsync(
        type: undefined.PnpObjectType,
        id: string,
        requestedProperties: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.PnpObject>;

    /**
     * Returns a PnpObjectWatcher object that is used to enumerate a filtered collection of PnP objects using events.
     * @param type The type of the PnpObject .
     * @param requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject objects included in enumeration results. For more info on what the properties represent, see Device information properties.
     * @param aqsFilter An AQS string that filters the PnP objects that will be returned. Typically, this string is retrieved from the GetDeviceSelector method of a class that interacts with devices.
     * @return  A PnpObjectWatcher object used to enumerate the collection by registering event notification delegates and by issuing start and stop event notifications.
     */
    createWatcher(
        type: undefined.PnpObjectType,
        requestedProperties: undefined.IIterable<string>,
        aqsFilter: string): undefined.PnpObjectWatcher;

    /**
     * Returns a PnpObjectWatcher object that is used to enumerate the PnP objects in the collection using events.
     * @param type The type of the PnpObject .
     * @param requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject objects included in enumeration results. For more info on what the properties represent, see Device information properties.
     * @return  A PnpObjectWatcher object used to enumerate the collection by registering event notification delegates and by issuing start and stop event notifications.
     */
    createWatcher(
        type: undefined.PnpObjectType,
        requestedProperties: undefined.IIterable<string>): undefined.PnpObjectWatcher;

    /**
     * Returns all of the PnP objects of a specified type that match the specified filter.
     * @param type The type of the PnpObject .
     * @param requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject objects included in enumeration results. For more info on what the properties represent, see Device information properties.
     * @param aqsFilter An AQS string that filters the PnP objects that will be returned. Typically, this string is retrieved from the GetDeviceSelector method of a class that interacts with devices.
     * @return  An object that represents the asynchronous operation.
     */
    findAllAsync(
        type: undefined.PnpObjectType,
        requestedProperties: undefined.IIterable<string>,
        aqsFilter: string): undefined.IPromiseWithIAsyncOperation<undefined.PnpObjectCollection>;

    /**
     * Returns all of the PnP objects of a specified type that match the specified criteria.
     * @param type The type of the PnpObject .
     * @param requestedProperties An iterable list of additional properties to include in the Properties property of the PnpObject objects included in enumeration results. For more info on what the properties represent, see Device information properties.
     * @return  An object that represents the asynchronous operation.
     */
    findAllAsync(
        type: undefined.PnpObjectType,
        requestedProperties: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.PnpObjectCollection>;

    /**
     * A string representing the identity of the PnpObject . 
     */
    id: string;

    /**
     * A property store containing well-known values as well as additional specified properties. 
     */
    properties: undefined.IMapView<string, any>;

    /**
     * The type of the PnpObject . 
     */
    type: undefined.PnpObjectType;

    /**
     * Updates the properties of an existing PnpObject by applying the changes described in a PnpObjectUpdate object.
     * @param updateInfo Indicates the properties to update.
     */
    update(updateInfo: undefined.PnpObjectUpdate): void
}


/**
 * Represents an iterable collection of Pnp device objects. 
 */
declare class PnpObjectCollection mixins Array<undefined.PnpObject>{

    /**
     * Returns the iterator for iteration over the items in the collection.
     * @return  The iterator object. The iterator's current position is at the 0-index position, or at the end of the collection if the collection is empty.
     */
    first(): undefined.IIterator<undefined.PnpObject>;

    /**
     * Returns the PnpObject located at the specified index.
     * @param index The integer index for the value to retrieve.
     * @return  The PnpObject at the specified index.
     */
    getAt(index: number): undefined.PnpObject;

    /**
     * Retrieves multiple elements in a single pass through the iterator.
     * @param startIndex The index from which to start retrieval.
     */
    getMany(startIndex: number): {
        items: undefined.PnpObject,
        returnValue: number
    };

    /**
     * Retrieves the index of the specified item.
     * @param value The value to find in the collection.
     */
    indexOf(value: undefined.PnpObject): {
        index: number,
        returnValue: boolean
    };

    /**
     * Returns the number of items in the collection. 
     */
    size: number;
    indexOf(
        value: undefined.PnpObject,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.PnpObject, fromIndex?: number): number
}


/**
 * Contains the updated properties of a PnpObject . 
 */
declare class PnpObjectUpdate {

    /**
     * The identifier of the PnpObject . 
     */
    id: string;

    /**
     * The changed properties in an update to a PnpObject . 
     */
    properties: undefined.IMapView<string, any>;

    /**
     * The type of the PnpObject . One of the values of the PnpObjectType enumeration. 
     */
    type: undefined.PnpObjectType
}


/**
 * Raises events to notify the client that a PnpObject has been added, updated, or removed from an enumerated collection of Pnp device objects in an incremental and asynchronous way. 
 */
declare class PnpObjectWatcher {

    /**
     * Occurs when a PnpObject is added to the collection enumerated by the PnpObjectWatcher . 
     */
    onadded: undefined.TypedEventHandler<undefined.PnpObjectWatcher, undefined.PnpObject>;
    addEventListener(
        type: "added",
        listener: undefined.TypedEventHandler<undefined.PnpObjectWatcher, undefined.PnpObject>): void;
    removeEventListener(
        type: "added",
        listener: undefined.TypedEventHandler<undefined.PnpObjectWatcher, undefined.PnpObject>): void;

    /**
     * Occurs when the enumeration of Pnp device objects has been completed. 
     */
    onenumerationcompleted: undefined.TypedEventHandler<undefined.PnpObjectWatcher, any>;
    addEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.PnpObjectWatcher, any>): void;
    removeEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.PnpObjectWatcher, any>): void;

    /**
     * Occurs when a PnpObject is removed from the collection enumerated by the PnpObjectWatcher . 
     */
    onremoved: undefined.TypedEventHandler<undefined.PnpObjectWatcher, undefined.PnpObjectUpdate>;
    addEventListener(
        type: "removed",
        listener: undefined.TypedEventHandler<undefined.PnpObjectWatcher, undefined.PnpObjectUpdate>): void;
    removeEventListener(
        type: "removed",
        listener: undefined.TypedEventHandler<undefined.PnpObjectWatcher, undefined.PnpObjectUpdate>): void;

    /**
     * Occurs when the PnpObjectWatcher has stopped monitoring changes to the collection of Pnp device objects. 
     */
    onstopped: undefined.TypedEventHandler<undefined.PnpObjectWatcher, any>;
    addEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.PnpObjectWatcher, any>): void;
    removeEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.PnpObjectWatcher, any>): void;

    /**
     * Occurs when the properties of a PnpObject in the collection enumerated by the PnpObjectWatcher are updated. 
     */
    onupdated: undefined.TypedEventHandler<undefined.PnpObjectWatcher, undefined.PnpObjectUpdate>;
    addEventListener(
        type: "updated",
        listener: undefined.TypedEventHandler<undefined.PnpObjectWatcher, undefined.PnpObjectUpdate>): void;
    removeEventListener(
        type: "updated",
        listener: undefined.TypedEventHandler<undefined.PnpObjectWatcher, undefined.PnpObjectUpdate>): void;

    /**
     * Starts raising the events to inform the client that a PnpObject has been added, updated, or removed. 
     */
    start(): void;

    /**
     * The status associated with the asynchronous operation. 
     */
    status: undefined.DeviceWatcherStatus;

    /**
     * Stops raising the events to inform the client that a PnpObject has been added, updated, or removed. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Identifies a collection of settings for device pairing. 
 */
declare interface Enumeration$IDevicePairingSettings {}


/**
 * Unsupported API. 
 */
declare class CivicAddress {

    /**
     * Unsupported API. 
     */
    city: string;

    /**
     * Unsupported API. 
     */
    country: string;

    /**
     * Unsupported API. 
     */
    postalCode: string;

    /**
     * Unsupported API. 
     */
    state: string;

    /**
     * Unsupported API. 
     */
    timestamp: Date
}


/**
 * Represents a rectangle that defines a geographic area. 
 */
declare class GeoboundingBox {

    /**
     * Calculates a GeoboundingBox that contains the specified set of geographic positions.
     * @param positions A collection of geographic positions to include inside the GeoboundingBox .
     * @return  The calculated rectangle that contains the specified set of geographic positions.
     */
    tryCompute(
        positions: undefined.IIterable<undefined.BasicGeoposition>): undefined.GeoboundingBox;

    /**
     * Calculates a GeoboundingBox that contains the specified set of geographic positions and uses the specified altitude reference system and spatial reference ID (SRID).
     * @param positions A collection of geographic positions to include inside the GeoboundingBox .
     * @param altitudeRefSystem The altitude reference system to use for the GeoboundingBox . For more info, see the AltitudeReferenceSystem property.
     * @param spatialReferenceId The spatial reference ID (SRID) to use for the GeoboundingBox . For more info, see the SpatialReferenceId property.
     * @return  The calculated rectangle that contains the specified set of geographic positions.
     */
    tryCompute(
        positions: undefined.IIterable<undefined.BasicGeoposition>,
        altitudeRefSystem: undefined.AltitudeReferenceSystem,
        spatialReferenceId: number): undefined.GeoboundingBox;

    /**
     * Calculates a GeoboundingBox that contains the specified set of geographic positions and uses the specified altitude reference system.
     * @param positions A collection of geographic positions to include inside the GeoboundingBox .
     * @param altitudeRefSystem The altitude reference system to use for the GeoboundingBox . For more info, see the AltitudeReferenceSystem property.
     * @return  The calculated rectangle that contains the specified set of geographic positions.
     */
    tryCompute(
        positions: undefined.IIterable<undefined.BasicGeoposition>,
        altitudeRefSystem: undefined.AltitudeReferenceSystem): undefined.GeoboundingBox;

    /**
     * Initializes a new instance of the GeoboundingBox class that has the specified corners.
     * @param northwestCorner The northwest corner to use for the new GeoboundingBox . For more info, see the NorthwestCorner property.
     * @param southeastCorner The southeast corner to use for the new GeoboundingBox . For more info, see the SoutheastCorner property.
     */
    constructor(northwestCorner: undefined.BasicGeoposition, southeastCorner: undefined.BasicGeoposition): this;

    /**
     * Initializes a new instance of the GeoboundingBox class that has the specified corners and uses the specified altitude reference system.
     * @param northwestCorner The northwest corner to use for the new GeoboundingBox . For more info, see the NorthwestCorner property.
     * @param southeastCorner The southeast corner to use for the new GeoboundingBox . For more info, see the SoutheastCorner property.
     * @param altitudeReferenceSystem The altitude reference system to use for the new GeoboundingBox . For more info, see the AltitudeReferenceSystem property.
     */
    constructor(northwestCorner: undefined.BasicGeoposition, southeastCorner: undefined.BasicGeoposition, altitudeReferenceSystem: undefined.AltitudeReferenceSystem): this;

    /**
     * Initializes a new instance of the GeoboundingBox class that has the specified corners and uses the specified altitude reference system and spatial reference ID (SRID).
     * @param northwestCorner The northwest corner to use for the new GeoboundingBox . For more info, see the NorthwestCorner property.
     * @param southeastCorner The southeast corner to use for the new GeoboundingBox . For more info, see the SoutheastCorner property.
     * @param altitudeReferenceSystem The altitude reference system to use for the new GeoboundingBox . For more info, see the AltitudeReferenceSystem property.
     * @param spatialReferenceId The spatial reference ID (SRID) to use for the new GeoboundingBox . For more info, see the SpatialReferenceId property.
     */
    constructor(northwestCorner: undefined.BasicGeoposition, southeastCorner: undefined.BasicGeoposition, altitudeReferenceSystem: undefined.AltitudeReferenceSystem, spatialReferenceId: number): this;

    /**
     * Gets the altitude reference system used by the GeoboundingBox . 
     */
    altitudeReferenceSystem: undefined.AltitudeReferenceSystem;

    /**
     * Gets the center of the GeoboundingBox . 
     */
    center: undefined.BasicGeoposition;

    /**
     * Gets the type of geographic shape represented by the GeoboundingBox . 
     */
    geoshapeType: undefined.GeoshapeType;

    /**
     * Gets the altitude of the highest corner of the GeoboundingBox . 
     */
    maxAltitude: number;

    /**
     * Gets the altitude of the lowest corner of the GeoboundingBox . 
     */
    minAltitude: number;

    /**
     * Gets the northwest corner of the GeoboundingBox . 
     */
    northwestCorner: undefined.BasicGeoposition;

    /**
     * Gets the southeast corner of the GeoboundingBox . 
     */
    southeastCorner: undefined.BasicGeoposition;

    /**
     * Gets the spatial reference ID (SRID) used by the GeoboundingBox . 
     */
    spatialReferenceId: number
}


/**
 * Describes a geographic circle with a center point and a radius. 
 */
declare class Geocircle {

    /**
     * Create a geographic circle object for the given position and radius.
     * @param position The geographic position of the new circle.
     * @param radius The radius of the new circle, in meters.
     */
    constructor(position: undefined.BasicGeoposition, radius: number): this;

    /**
     * Create a geographic circle object for the given position, radius, altitude reference system, and spatial reference id.
     * @param position The geographic position of the new circle.
     * @param radius The radius of the new circle, in meters.
     * @param altitudeReferenceSystem The altitude reference system of the new circle.
     * @param spatialReferenceId The spatial reference Id of the new circle.
     */
    constructor(position: undefined.BasicGeoposition, radius: number, altitudeReferenceSystem: undefined.AltitudeReferenceSystem, spatialReferenceId: number): this;

    /**
     * Create a geographic circle object for the given position, radius and altitude reference system.
     * @param position The geographic position of the new circle.
     * @param radius The radius of the new circle, in meters.
     * @param altitudeReferenceSystem The altitude reference system of the new circle.
     */
    constructor(position: undefined.BasicGeoposition, radius: number, altitudeReferenceSystem: undefined.AltitudeReferenceSystem): this;

    /**
     * The altitude reference system of the geographic circle. 
     */
    altitudeReferenceSystem: undefined.AltitudeReferenceSystem;

    /**
     * The center point of a geographic circle. 
     */
    center: undefined.BasicGeoposition;

    /**
     * The type of geographic shape. 
     */
    geoshapeType: undefined.GeoshapeType;

    /**
     * The radius of a geographic circle in meters. 
     */
    radius: number;

    /**
     * The spatial reference identifier for the geographic circle, corresponding to a spatial reference system based on the specific ellipsoid used for either flat-earth mapping or round-earth mapping. 
     */
    spatialReferenceId: number
}


/**
 * Contains the information for identifying a geographic location. 
 */
declare class Geocoordinate {

    /**
     * The accuracy of the location in meters. 
     */
    accuracy: number;

    /**
     * The altitude of the location, in meters. 
     */
    altitude: number;

    /**
     * The accuracy of the altitude, in meters. 
     */
    altitudeAccuracy: number;

    /**
     * The current heading in degrees relative to true north. 
     */
    heading: number;

    /**
     * The latitude in degrees. 
     */
    latitude: number;

    /**
     * The longitude in degrees. 
     */
    longitude: number;

    /**
     * The location of the Geocoordinate. 
     */
    point: undefined.Geopoint;

    /**
     * Gets the source used to obtain a Geocoordinate. 
     */
    positionSource: undefined.PositionSource;

    /**
     * Gets the time at which the associated Geocoordinate position was calculated. 
     */
    positionSourceTimestamp: Date;

    /**
     * Gets information about the satellites used to obtain a Geocoordinate. 
     */
    satelliteData: undefined.GeocoordinateSatelliteData;

    /**
     * The speed in meters per second. 
     */
    speed: number;

    /**
     * The system time at which the location was determined. 
     */
    timestamp: Date
}


/**
 * Provides additional information about a Geocoordinate . This information is only applicable to position estimates obtained using satellite signals. 
 */
declare class GeocoordinateSatelliteData {

    /**
     * Gets the horizontal dilution of precision (HDOP) of a Geocoordinate . 
     */
    horizontalDilutionOfPrecision: number;

    /**
     * Gets the position dilution of precision (PDOP) of a Geocoordinate . 
     */
    positionDilutionOfPrecision: number;

    /**
     * Gets the vertical dilution of precision (VDOP) of a Geocoordinate . 
     */
    verticalDilutionOfPrecision: number
}


/**
 * Contains the information to define a geofence, an area of interest, to monitor. 
 */
declare class Geofence {

    /**
     * Initializes a new Geofence object given the id, the shape of the geofence, the states to monitor the geofence for, the singleUse flag, the dwellTime for the geofence, the time to start monitoring the geofence, and the duration of the geofence.
     * @param id The Id of the geofence.
     * @param geoshape The area that defines the geofence to monitor.
     * @param monitoredStates The states to monitor the geofence for.
     * @param singleUse True indicates the geofence should be monitored only for one use. False indicates the geofence should be monitored for multiple uses.
     * @param dwellTime The time that a position has to be in or out of the geofence in order for the notification to be triggered.
     * @param startTime The time to start monitoring the geofence.
     * @param duration The duration of time to monitor the geofence for. The duration begins at the startTime.
     */
    constructor(id: string, geoshape: undefined.IGeoshape, monitoredStates: undefined.MonitoredGeofenceStates, singleUse: boolean, dwellTime: number, startTime: Date, duration: number): this;

    /**
     * Initializes a new Geofence object given the id, the shape of the geofence, the states to monitor the geofence for, and the singleUse flag.
     * @param id The Id of the geofence.
     * @param geoshape The area that defines the geofence to monitor.
     * @param monitoredStates The states to monitor the geofence for.
     * @param singleUse True indicates the geofence should be monitored only for one use. False indicates the geofence should be monitored for multiple uses.
     */
    constructor(id: string, geoshape: undefined.IGeoshape, monitoredStates: undefined.MonitoredGeofenceStates, singleUse: boolean): this;

    /**
     * Initializes a new Geofence object given the id and the shape of the geofence.
     * @param id The Id of the geofence.
     * @param geoshape The area that defines the geofence to monitor.
     */
    constructor(id: string, geoshape: undefined.IGeoshape): this;

    /**
     * Initializes a new Geofence object given the id, the shape of the geofence, the states to monitor the geofence for, the singleUse flag, and the dwellTime for the geofence.
     * @param id The Id of the geofence.
     * @param geoshape The area that defines the geofence to monitor.
     * @param monitoredStates The states to monitor the geofence for.
     * @param singleUse True indicates the geofence should be monitored only for one use. False indicates the geofence should be monitored for multiple uses.
     * @param dwellTime The time that a position has to be in or out of the geofence in order for the notification to be triggered.
     */
    constructor(id: string, geoshape: undefined.IGeoshape, monitoredStates: undefined.MonitoredGeofenceStates, singleUse: boolean, dwellTime: number): this;

    /**
     * Gets the time window, beginning after the StartTime , during which the Geofence is monitored. 
     */
    duration: number;

    /**
     * The minimum time that a position has to be inside or outside of the Geofence in order for the notification to be triggered. 
     */
    dwellTime: number;

    /**
     * The shape of the geofence region. 
     */
    geoshape: undefined.IGeoshape;

    /**
     * The id of the Geofence . 
     */
    id: string;

    /**
     * Indicates the states that the Geofence is being monitored for. 
     */
    monitoredStates: undefined.MonitoredGeofenceStates;

    /**
     * Indicates whether the Geofence should be triggered once or multiple times. 
     */
    singleUse: boolean;

    /**
     * The time to start monitoring the Geofence . 
     */
    startTime: Date
}


/**
 * Contains the information about the monitored Geofence objects. 
 */
declare class GeofenceMonitor {

    /**
     * Gets the GeofenceMonitor object which contains all of an app's Geofence information. 
     */
    current: undefined.GeofenceMonitor;

    /**
     * Returns a vector of the app's Geofence objects currently registered with the system wide GeofenceMonitor . 
     */
    geofences: undefined.IVector<undefined.Geofence>;

    /**
     * Last reading of the device's location. 
     */
    lastKnownGeoposition: undefined.Geoposition;

    /**
     * Raised when the state of one or more Geofence objects in the Geofences collection of the GeofenceMonitor has changed 
     */
    ongeofencestatechanged: undefined.TypedEventHandler<undefined.GeofenceMonitor, any>;
    addEventListener(
        type: "geofencestatechanged",
        listener: undefined.TypedEventHandler<undefined.GeofenceMonitor, any>): void;
    removeEventListener(
        type: "geofencestatechanged",
        listener: undefined.TypedEventHandler<undefined.GeofenceMonitor, any>): void;

    /**
     * Raised when the status of the GeofenceMonitor has changed. 
     */
    onstatuschanged: undefined.TypedEventHandler<undefined.GeofenceMonitor, any>;
    addEventListener(
        type: "statuschanged",
        listener: undefined.TypedEventHandler<undefined.GeofenceMonitor, any>): void;
    removeEventListener(
        type: "statuschanged",
        listener: undefined.TypedEventHandler<undefined.GeofenceMonitor, any>): void;

    /**
     * Gets a collection of status changes to the Geofence objects in the Geofences collection of the GeofenceMonitor .
     * @return  collection of status changes to the GeofenceMonitor .
     */
    readReports(): undefined.IVectorView<undefined.GeofenceStateChangeReport>;

    /**
     * Indicates the current state of the GeofenceMonitor . 
     */
    status: undefined.GeofenceMonitorStatus;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains the information about the state changes for a Geofence . 
 */
declare class GeofenceStateChangeReport {

    /**
     * The Geofence object whose state has changed. 
     */
    geofence: undefined.Geofence;

    /**
     * The position of the Geofence object whose state has changed. 
     */
    geoposition: undefined.Geoposition;

    /**
     * The new state of the Geofence object whose state has changed. 
     */
    newState: undefined.GeofenceState;

    /**
     * Indicates the reason a Geofence was removed. 
     */
    removalReason: undefined.GeofenceRemovalReason
}


/**
 * Provides access to the current geographic location. 
 */
declare class Geolocator {

    /**
     * Starts an asynchronous operation to retrieve the location history of the device.
     * @param startTime Represents the beginning of the time span for which positions are to be returned.
     * @return  Positions (of type Geoposition ) that were collected during the specified time span.
     */
    getGeopositionHistoryAsync(
        startTime: Date): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Starts an asynchronous operation to retrieve the location history of the device.
     * @param startTime Represents the beginning of the time span for which positions are to be returned.
     * @param duration Represents the length of time after startTime for which positions are to be returned.
     * @return  Positions (of type Geoposition ) that were collected during the specified time span.
     */
    getGeopositionHistoryAsync(
        startTime: Date,
        duration: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Requests permission to access location data.
     * @return  A GeolocationAccessStatus that indicates if permission to location data has been granted.
     */
    requestAccessAsync(): undefined.IPromiseWithIAsyncOperation<undefined.GeolocationAccessStatus>;

    /**
     * Initializes a new Geolocator object. 
     */
    constructor(): this;

    /**
     * The accuracy level at which the Geolocator provides location updates. 
     */
    desiredAccuracy: undefined.PositionAccuracy;

    /**
     * Gets or sets the desired accuracy in meters for data returned from the location service. 
     */
    desiredAccuracyInMeters: number;

    /**
     * Starts an asynchronous operation to retrieve the current location of the device.
     * @return  Provides methods for starting the asynchronous request for location data and handling its completion.
     */
    getGeopositionAsync(): undefined.IPromiseWithIAsyncOperation<undefined.Geoposition>;

    /**
     * Starts an asynchronous operation to retrieve the current location of the device.
     * @param maximumAge The maximum acceptable age of cached location data. A TimeSpan is a time period expressed in 100-nanosecond units.
     * @param timeout The timeout. A TimeSpan is a time period expressed in 100-nanosecond units.
     * @return  Provides methods for starting the asynchronous request for location data and handling its completion.
     */
    getGeopositionAsync(
        maximumAge: number,
        timeout: number): undefined.IPromiseWithIAsyncOperation<undefined.Geoposition>;

    /**
     * The status that indicates the ability of the Geolocator to provide location updates. 
     */
    locationStatus: undefined.PositionStatus;

    /**
     * Gets and sets the distance of movement, in meters, relative to the coordinate from the last PositionChanged event, that is required for the Geolocator to raise a PositionChanged event. 
     */
    movementThreshold: number;

    /**
     * Raised when the location is updated. 
     */
    onpositionchanged: undefined.TypedEventHandler<undefined.Geolocator, undefined.PositionChangedEventArgs>;
    addEventListener(
        type: "positionchanged",
        listener: undefined.TypedEventHandler<undefined.Geolocator, undefined.PositionChangedEventArgs>): void;
    removeEventListener(
        type: "positionchanged",
        listener: undefined.TypedEventHandler<undefined.Geolocator, undefined.PositionChangedEventArgs>): void;

    /**
     * Raised when the ability of the Geolocator to provide updated location changes. 
     */
    onstatuschanged: undefined.TypedEventHandler<undefined.Geolocator, undefined.StatusChangedEventArgs>;
    addEventListener(
        type: "statuschanged",
        listener: undefined.TypedEventHandler<undefined.Geolocator, undefined.StatusChangedEventArgs>): void;
    removeEventListener(
        type: "statuschanged",
        listener: undefined.TypedEventHandler<undefined.Geolocator, undefined.StatusChangedEventArgs>): void;

    /**
     * The requested minimum time interval between location updates, in milliseconds. If your application requires updates infrequently, set this value so that location services can conserve power by calculating location only when needed. 
     */
    reportInterval: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an ordered series of geographic points. 
 */
declare class Geopath {

    /**
     * Initializes a new instance of the Geopath class with the specified collection of positions.
     * @param positions The collection of positions to use to create the new Geopath . For more info, see the Positions property.
     */
    constructor(positions: undefined.IIterable<undefined.BasicGeoposition>): this;

    /**
     * Initializes a new instance of the Geopath class with the specified collection of positions and with the specified altitude reference system and spatial reference ID (SRID).
     * @param positions The collection of positions to use to create the new Geopath . For more info, see the Positions property.
     * @param altitudeReferenceSystem The altitude reference system to use to create the new Geopath . For more info, see the AltitudeReferenceSystem property.
     * @param spatialReferenceId The spatial reference ID (SRID) to use to create the new Geopath . For more info, see the SpatialReferenceId property.
     */
    constructor(positions: undefined.IIterable<undefined.BasicGeoposition>, altitudeReferenceSystem: undefined.AltitudeReferenceSystem, spatialReferenceId: number): this;

    /**
     * Initializes a new instance of the Geopath class with the specified collection of positions and with the specified altitude reference system.
     * @param positions The collection of positions to use to create the new Geopath . For more info, see the Positions property.
     * @param altitudeReferenceSystem The altitude reference system to use to create the new Geopath . For more info, see the AltitudeReferenceSystem property.
     */
    constructor(positions: undefined.IIterable<undefined.BasicGeoposition>, altitudeReferenceSystem: undefined.AltitudeReferenceSystem): this;

    /**
     * Gets the altitude reference system used by the Geopath . 
     */
    altitudeReferenceSystem: undefined.AltitudeReferenceSystem;

    /**
     * Gets the type of geographic shape represented by the Geopath . 
     */
    geoshapeType: undefined.GeoshapeType;

    /**
     * Gets the collection of geographic points that define the Geopath . 
     */
    positions: undefined.IVectorView<undefined.BasicGeoposition>;

    /**
     * Gets the spatial reference ID (SRID) used by the Geopath . 
     */
    spatialReferenceId: number
}


/**
 * Describes a geographic point. 
 */
declare class Geopoint {

    /**
     * Create a geographic point object for the given position.
     * @param position Create a geographic point object for the given position.
     */
    constructor(position: undefined.BasicGeoposition): this;

    /**
     * Create a geographic point object for the given position, altitude reference system, and spatial reference Id.
     * @param position Create a geographic point object for the given position.
     * @param altitudeReferenceSystem The altitude reference system of the new point.
     * @param spatialReferenceId The spatial reference Id of the new point.
     */
    constructor(position: undefined.BasicGeoposition, altitudeReferenceSystem: undefined.AltitudeReferenceSystem, spatialReferenceId: number): this;

    /**
     * Create a geographic point object for the given position and altitude reference system.
     * @param position Create a geographic point object for the given position.
     * @param altitudeReferenceSystem The altitude reference system of the new point.
     */
    constructor(position: undefined.BasicGeoposition, altitudeReferenceSystem: undefined.AltitudeReferenceSystem): this;

    /**
     * The altitude reference system of the geographic point. 
     */
    altitudeReferenceSystem: undefined.AltitudeReferenceSystem;

    /**
     * The type of geographic shape. 
     */
    geoshapeType: undefined.GeoshapeType;

    /**
     * The position of a geographic point. 
     */
    position: undefined.BasicGeoposition;

    /**
     * The spatial reference identifier for the geographic point, corresponding to a spatial reference system based on the specific ellipsoid used for either flat-earth mapping or round-earth mapping. 
     */
    spatialReferenceId: number
}


/**
 * Represents a location that may contain latitude and longitude data or venue data. 
 */
declare class Geoposition {

    /**
     * Unsupported API. 
     */
    civicAddress: undefined.CivicAddress;

    /**
     * The latitude and longitude associated with a geographic location. 
     */
    coordinate: undefined.Geocoordinate;

    /**
     * Represents the venue associated with a geographic location. 
     */
    venueData: undefined.VenueData
}


/**
 * Provides data for the PositionChanged event. 
 */
declare class PositionChangedEventArgs {

    /**
     * The location data associated with the PositionChanged event. 
     */
    position: undefined.Geoposition
}


/**
 * Provides information for the StatusChanged event. 
 */
declare class StatusChangedEventArgs {

    /**
     * The updated status of the Geolocator object. 
     */
    status: undefined.PositionStatus
}


/**
 * Represents the venue associated with a geographic location. 
 */
declare class VenueData {

    /**
     * Gets the identifier (ID) of the venue. 
     */
    id: string;

    /**
     * Gets the identifier (ID) of the building level. 
     */
    level: string
}


/**
 * The basic information to describe a geographic position. 
 */
declare interface Geolocation$BasicGeoposition {

    /**
     * The altitude of the geographic position in meters. 
     */
    altitude: number,

        /**
         * The latitude of the geographic position. The valid range of latitude values is from -90.0 to 90.0 degrees. 
         */
        latitude: number,

        /**
         * The longitude of the geographic position. This can be any value. For values less than or equal to-180.0 or values greater than 180.0, the value may be wrapped and stored appropriately before it is used. For example, a longitude of 183.0 degrees would become -177.0 degrees. 
         */
        longitude: number
}


/**
 * Interface to define a geographic shape. 
 */
declare interface Geolocation$IGeoshape {

    /**
     * The altitude reference system of the geographic shape. 
     */
    altitudeReferenceSystem: undefined.AltitudeReferenceSystem,

        /**
         * The type of geographic shape. 
         */
        geoshapeType: undefined.GeoshapeType,

        /**
         * The spatial reference identifier for the geographic shape, corresponding to a spatial reference system based on the specific ellipsoid used for either flat-earth mapping or round-earth mapping. 
         */
        spatialReferenceId: number
}


/**
 * Represents the default general-purpose I/O (GPIO) controller for the system. 
 */
declare class GpioController {

    /**
     * Gets all the controllers that are connected to the system asynchronously.
     * @param provider The GPIO provider for the controllers on the system.
     * @return  When the method completes successfully, it returns a list of values that represent the controllers available on the system.
     */
    getControllersAsync(
        provider: undefined.IGpioProvider): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the default general-purpose I/O (GPIO) controller for the system.
     * @return  The default GPIO controller for the system, or null if the system has no GPIO controller.
     */
    getDefault(): undefined.GpioController;

    /**
     * Gets the default general-purpose I/O (GPIO) controller for the system.
     * @return  The default GPIO controller for the system, or null if the system has no GPIO controller.
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.GpioController>;

    /**
     * Opens a connection to the specified general-purpose I/O (GPIO) pin in exclusive mode.
     * @param pinNumber The pin number of the GPIO pin that you want to open. Some pins may not be available in user mode. For information about how the pin numbers correspond to physical pins, see the documentation for your circuit board.
     * @return  The opened GPIO pin.
     */
    openPin(pinNumber: number): undefined.GpioPin;

    /**
     * Opens the specified general-purpose I/O (GPIO) pin in the specified mode.
     * @param pinNumber The pin number of the GPIO pin that you want to open. Some pins may not be available in user mode. For information about how the pin numbers correspond to physical pins, see the documentation for your circuit board.
     * @param sharingMode The mode in which you want to open the GPIO pin, which determines whether other connections to the pin can be opened while you have the pin open.
     * @return  The opened GPIO pin.
     */
    openPin(pinNumber: number, sharingMode: undefined.GpioSharingMode): undefined.GpioPin;

    /**
     * Gets the number of pins on the general-purpose I/O (GPIO) controller. 
     */
    pinCount: number;

    /**
     * Opens the specified general-purpose I/O (GPIO) pin in the specified mode, and gets a status value that you can use to handle a failure to open the pin programmatically.
     * @param pinNumber The pin number of the GPIO pin that you want to open. Some pins may not be available in user mode. For information about how the pin numbers correspond to physical pins, see the documentation for your circuit board.
     * @param sharingMode The mode in which you want to open the GPIO pin, which determines whether other connections to the pin can be opened while you have the pin open.
     */
    tryOpenPin(
        pinNumber: number,
        sharingMode: undefined.GpioSharingMode): {
        pin: undefined.GpioPin,
        openStatus: undefined.GpioOpenStatus,
        returnValue: boolean
    }
}


/**
 * Represents a general-purpose I/O (GPIO) pin. 
 */
declare class GpioPin {

    /**
     * Closes the general-purpose I/O (GPIO) pin and releases the resources associated with it. 
     */
    close(): void;

    /**
     * Gets or sets the debounce timeout for the general-purpose I/O (GPIO) pin, which is an interval during which changes to the value of the pin are filtered out and do not generate ValueChanged events. 
     */
    debounceTimeout: number;

    /**
     * Gets the current drive mode for the general-purpose I/O (GPIO) pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
     * @return  An enumeration value that indicates the current drive mode for the GPIO pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
     */
    getDriveMode(): undefined.GpioPinDriveMode;

    /**
     * Gets whether the general-purpose I/O (GPIO) pin supports the specified drive mode.
     * @param driveMode The drive mode that you want to check for support.
     * @return  True if the GPIO pin supports the drive mode that driveMode specifies; otherwise false. If you specify a drive mode for which this method returns false when you call SetDriveMode , SetDriveMode generates an exception.
     */
    isDriveModeSupported(driveMode: undefined.GpioPinDriveMode): boolean;

    /**
     * Occurs when the value of the general-purpose I/O (GPIO) pin changes, either because of an external stimulus when the pin is configured as an input, or when a value is written to the pin when the pin in configured as an output. 
     */
    onvaluechanged: undefined.TypedEventHandler<undefined.GpioPin, undefined.GpioPinValueChangedEventArgs>;
    addEventListener(
        type: "valuechanged",
        listener: undefined.TypedEventHandler<undefined.GpioPin, undefined.GpioPinValueChangedEventArgs>): void;
    removeEventListener(
        type: "valuechanged",
        listener: undefined.TypedEventHandler<undefined.GpioPin, undefined.GpioPinValueChangedEventArgs>): void;

    /**
     * Gets the pin number of the general-purpose I/O (GPIO) pin. 
     */
    pinNumber: number;

    /**
     * Reads the current value of the general-purpose I/O (GPIO) pin.
     * @return  The current value of the GPIO pin. If the pin is configured as an output, this value is the last value written to the pin.
     */
    read(): undefined.GpioPinValue;

    /**
     * Sets the drive mode of the general-purpose I/O (GPIO) pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
     * @param value An enumeration value that specifies drive mode to use for the GPIO pin. The drive mode specifies whether the pin is configured as an input or an output, and determines how values are driven onto the pin.
     */
    setDriveMode(value: undefined.GpioPinDriveMode): void;

    /**
     * Gets the sharing mode in which the general-purpose I/O (GPIO) pin is open. 
     */
    sharingMode: undefined.GpioSharingMode;

    /**
     * Drives the specified value onto the general purpose I/O (GPIO) pin according to the current drive mode for the pin if the pin is configured as an output, or updates the latched output value for the pin if the pin is configured as an input.
     * @param value The enumeration value to write to the GPIO pin.
     */
    write(value: undefined.GpioPinValue): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data about the GpioPin.ValueChanged event that occurs when the value of the general-purpose I/O (GPIO) pin changes, either because of an external stimulus when the pin is configured as an input, or when a value is written to the pin when the pin in configured as an output. 
 */
declare class GpioPinValueChangedEventArgs {

    /**
     * Gets the type of change that occurred to the value of the general-purpose I/O (GPIO) pin for the GpioPin.ValueChanged event. 
     */
    edge: undefined.GpioPinEdge
}

declare class GpioPinProviderValueChangedEventArgs {
    edge: any
}

declare
var input: any;

declare
var output: any;

declare
var inputPullUp: any;

declare
var inputPullDown: any;

declare
var outputOpenDrain: any;

declare
var outputOpenDrainPullUp: any;

declare
var outputOpenSource: any;

declare
var outputOpenSourcePullDown: any;

declare
var fallingEdge: any;

declare
var risingEdge: any;

declare
var low: any;

declare
var high: any;

declare
var exclusive: any;

declare
var sharedReadOnly: any;


/**
 * Represents actions common to general-purpose I/O (GPIO) controller providers. 
 */
declare interface Provider$IGpioProvider {
    getControllers: any
}


/**
 * Represents a simple Boolean control on a HID device that returns on/off values. An example would be the LED light on a keyboard. 
 */
declare class HidBooleanControl {

    /**
     * Retrieves a description of the given Boolean control. 
     */
    controlDescription: undefined.HidBooleanControlDescription;

    /**
     * Retrieves the identifier for a given Boolean control. 
     */
    id: number;

    /**
     * Retrieves a Boolean value indicating whether the given Boolean control is active. 
     */
    isActive: boolean;

    /**
     * Retrieves the usage identifier associated with the given Boolean control. 
     */
    usageId: number;

    /**
     * Retrieves the usage page for a given Boolean control. 
     */
    usagePage: number
}


/**
 * Describes a Boolean control for a given HID device. 
 */
declare class HidBooleanControlDescription {

    /**
     * Retrieves the identifier for a given Boolean control. 
     */
    id: number;

    /**
     * Retrieves the parent collection for a given Boolean control. 
     */
    parentCollections: undefined.IVectorView<undefined.HidCollection>;

    /**
     * Retrieves the identifier for the report associated with the given Boolean control. 
     */
    reportId: number;

    /**
     * Retrieves the report type for the report associated with the given Boolean control. 
     */
    reportType: undefined.HidReportType;

    /**
     * Retrieves the usage identifier associated with the given Boolean control. 
     */
    usageId: number;

    /**
     * Retrieves the usage page associated with the given Boolean control. 
     */
    usagePage: number
}


/**
 * Retrieves the collection information for a group of related controls. 
 */
declare class HidCollection {

    /**
     * Retrieves the identifier for a collection of HID controls. 
     */
    id: number;

    /**
     * Retrieves the collection type. 
     */
    type: undefined.HidCollectionType;

    /**
     * Retrieves the usage identifier for the given control collection. 
     */
    usageId: number;

    /**
     * Retrieves the usage page for the given control collection. 
     */
    usagePage: number
}


/**
 * Represents a top-level collection and the corresponding device. 
 */
declare class HidDevice {

    /**
     * Opens a handle to the device identified by the deviceId parameter. The acess type is specified by the accessMode parameter.
     * @param deviceId The DeviceInformation ID that identifies the HID device.
     * @param accessMode Specifies the access mode. The supported access modes are Read and ReadWrite.
     * @return  A HidDevice object.
     */
    fromIdAsync(
        deviceId: string,
        accessMode: undefined.FileAccessMode): undefined.IPromiseWithIAsyncOperation<undefined.HidDevice>;

    /**
     * Retrieves an Advanced Query Syntax (AQS) string based on the given usagePage and usageId.
     * @param usagePage Specifies the usage page of the top-level collection for the given HID device.
     * @param usageId Specifies the usage identifier of the top-level collection for the given HID device.
     * @return  An Advanced Query Syntax (AQS) string that represents a device selector.
     */
    getDeviceSelector(usagePage: number, usageId: number): string;

    /**
     * Retrieves an Advanced Query Syntax (AQS) string based on the given usagePage, usageId, vendorId, and productId.
     * @param usagePage Specifies the usage page of the top-level collection for the given HID device.
     * @param usageId Specifies the usage identifier of the top-level collection for the given HID device.
     * @param vendorId Identifies the device vendor.
     * @param productId Identifies the product.
     * @return  An Advanced Query Syntax (AQS) string that represents a device selector.
     */
    getDeviceSelector(
        usagePage: number,
        usageId: number,
        vendorId: number,
        productId: number): string;

    /**
     * Closes the connection between the host and the given HID device. 
     */
    close(): void;

    /**
     * Creates the only, or default, feature report that the host will send to the device.
     * @return  A HidFeatureReport object.
     */
    createFeatureReport(): undefined.HidFeatureReport;

    /**
     * Creates a feature report, identified by the reportId parameter, that the host will send to the device.
     * @param reportId Identifies the report being created.
     * @return  A HidFeatureReport object.
     */
    createFeatureReport(reportId: number): undefined.HidFeatureReport;

    /**
     * Creates the only, or default, output report that the host will send to the device.
     * @return  A HidOutputReport object.
     */
    createOutputReport(): undefined.HidOutputReport;

    /**
     * Creates an output report, identified by the reportId parameter, that the host will send to the device.
     * @param reportId Identifies the report being created.
     * @return  A HidOutputReport object.
     */
    createOutputReport(reportId: number): undefined.HidOutputReport;

    /**
     * Retrieves the descriptions of the boolean controls for the given HID device.
     * @param reportType Specifies the type of report for which the control descriptions are requested.
     * @param usagePage Identifies the usage page associated with the controls.
     * @param usageId Identifies the usage associated with the controls.
     * @return  A vector of HidBooleanControlDescription objects.
     */
    getBooleanControlDescriptions(
        reportType: undefined.HidReportType,
        usagePage: number,
        usageId: number): undefined.IVectorView<undefined.HidBooleanControlDescription>;

    /**
     * Asynchronously retrieves a feature report, identified by the reportId parameter, for the given HID device.
     * @param reportId Identifies the requested feature report.
     * @return  A HidFeatureReport object.
     */
    getFeatureReportAsync(
        reportId: number): undefined.IPromiseWithIAsyncOperation<undefined.HidFeatureReport>;

    /**
     * Asynchronously retrieves the first, or default, feature report from the given HID device.
     * @return  A HidFeatureReport object.
     */
    getFeatureReportAsync(): undefined.IPromiseWithIAsyncOperation<undefined.HidFeatureReport>;

    /**
     * Asynchronously retrieves the default, or first, input report from the given HID device.
     * @return  A HidInputReport object.
     */
    getInputReportAsync(): undefined.IPromiseWithIAsyncOperation<undefined.HidInputReport>;

    /**
     * Asynchronously retrieves an input report, identified by the reportId parameter, from the given HID device.
     * @param reportId Identifies the requested input report.
     * @return  A HidInputReport object.
     */
    getInputReportAsync(
        reportId: number): undefined.IPromiseWithIAsyncOperation<undefined.HidInputReport>;

    /**
     * Retrieves the descriptions of the numeric controls for the given HID device.
     * @param reportType Specifies the type of report for which the control descriptions are requested.
     * @param usagePage Identifies the usage page associated with the controls.
     * @param usageId Identifies the usage associated with the controls.
     * @return  A vector of HidNumericControlDescription objects.
     */
    getNumericControlDescriptions(
        reportType: undefined.HidReportType,
        usagePage: number,
        usageId: number): undefined.IVectorView<undefined.HidNumericControlDescription>;

    /**
     * Establishes an event listener which handles input reports issued by the device. 
     */
    oninputreportreceived: undefined.TypedEventHandler<undefined.HidDevice, undefined.HidInputReportReceivedEventArgs>;
    addEventListener(
        type: "inputreportreceived",
        listener: undefined.TypedEventHandler<undefined.HidDevice, undefined.HidInputReportReceivedEventArgs>): void;
    removeEventListener(
        type: "inputreportreceived",
        listener: undefined.TypedEventHandler<undefined.HidDevice, undefined.HidInputReportReceivedEventArgs>): void;

    /**
     * Gets the product identifier for the given HID device. 
     */
    productId: number;

    /**
     * Sends an feature report asynchronously from the host to the device.
     * @param featureReport The feature report which the host sends to the device.
     * @return  The result of the asynchronous operation.
     */
    sendFeatureReportAsync(
        featureReport: undefined.HidFeatureReport): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Sends an output report asynchronously from the host to the device.
     * @param outputReport The output report which the host sends to the device.
     * @return  Specifies the count of bytes written to the device.
     */
    sendOutputReportAsync(
        outputReport: undefined.HidOutputReport): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Gets the usage identifier for the given HID device. 
     */
    usageId: number;

    /**
     * Gets the usage page of the top-level collection. 
     */
    usagePage: number;

    /**
     * Gets the vendor identifier for the given HID device. 
     */
    vendorId: number;

    /**
     * Gets the version, or revision, number for the given HID device. 
     */
    version: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a feature report. 
 */
declare class HidFeatureReport {

    /**
     * Retrieves, or sets, the data associated with a given feature report. 
     */
    data: undefined.IBuffer;

    /**
     * Retrieves the Boolean control associated with the usagePage and usageIdparameter and found in the given feature report.
     * @param usagePage The usage page of the top-level collection for the given HID device.
     * @param usageId The usage identifier of the top-level collection for the given HID device.
     * @return  A HidBooleanControl object.
     */
    getBooleanControl(usagePage: number, usageId: number): undefined.HidBooleanControl;

    /**
     * Retrieves the Boolean control described by the controlDescription parameter and found in the given feature report.
     * @param controlDescription A HidBooleanControlDescription object.
     * @return  A HidBooleanControl object.
     */
    getBooleanControlByDescription(
        controlDescription: undefined.HidBooleanControlDescription): undefined.HidBooleanControl;

    /**
     * Retrieves the numeric control associated with the usagePage and usageId parameters and found in the given feature report.
     * @param usagePage The usage page of the top-level collection for the given HID device.
     * @param usageId The usage identifier of the top-level collection for the given HID device.
     * @return  A HidNumericControl object.
     */
    getNumericControl(usagePage: number, usageId: number): undefined.HidNumericControl;

    /**
     * Retrieves the numeric control described by the controlDescription parameter and found in the given feature report.
     * @param controlDescription A HidNumericControlDescription object.
     * @return  A HidNumericControl object.
     */
    getNumericControlByDescription(
        controlDescription: undefined.HidNumericControlDescription): undefined.HidNumericControl;

    /**
     * Retrieves the identifier associated with a given feature report. 
     */
    id: number
}


/**
 * Represents an input report. 
 */
declare class HidInputReport {

    /**
     * Retrieves the currently activated Boolean controls for the given HID device. 
     */
    activatedBooleanControls: undefined.IVectorView<undefined.HidBooleanControl>;

    /**
     * Retrieves the data associated with a given input report. 
     */
    data: undefined.IBuffer;
    getBooleanControl: any;

    /**
     * Retrieves the Boolean control described by the controlDescription parameter and found in the given input report.
     * @param controlDescription A HidBooleanControlDescription object.
     * @return  A HidBooleanControl object.
     */
    getBooleanControlByDescription(
        controlDescription: undefined.HidBooleanControlDescription): undefined.HidBooleanControl;
    getNumericControl: any;

    /**
     * Retrieves the numeric control described by the controlDescription parameter and found in the given input report.
     * @param controlDescription A HidNumericControlDescription object.
     * @return  A HidNumericControl object.
     */
    getNumericControlByDescription(
        controlDescription: undefined.HidNumericControlDescription): undefined.HidNumericControl;

    /**
     * Retrieves the identifier associated with a given input report. 
     */
    id: number;

    /**
     * Retrieves the recently transitioned Boolean controls for the given HID device. 
     */
    transitionedBooleanControls: undefined.IVectorView<undefined.HidBooleanControl >
}


/**
 * Represents the arguments which the HID API sends as part of an input-report event. 
 */
declare class HidInputReportReceivedEventArgs {

    /**
     * Retrieves the input report. 
     */
    report: undefined.HidInputReport
}


/**
 * Represents a numeric control on a HID device that returns a range of values. An example would be the volume control on a speaker. 
 */
declare class HidNumericControl {

    /**
     * Retrieves a control description for the given numeric control. 
     */
    controlDescription: undefined.HidNumericControlDescription;

    /**
     * Retrieves the identifier for the given numeric control. 
     */
    id: number;

    /**
     * Retrieves a Boolean value that indicates whether the given numeric control is grouped with other, related controls. 
     */
    isGrouped: boolean;

    /**
     * Retrieves, or sets, a scaled numeric-value for the given control. 
     */
    scaledValue: number;

    /**
     * Retrieves the usage identifier for the given numeric control. 
     */
    usageId: number;

    /**
     * Retrieves the usage page for the given numeric control. 
     */
    usagePage: number;

    /**
     * Retrieves, or sets, the numeric value for a given control. 
     */
    value: number
}


/**
 * Describes a numeric control for a given HID device. 
 */
declare class HidNumericControlDescription {

    /**
     * Retrieves a Boolean value which indicates whether the control supports a null, or out-of-range, value. 
     */
    hasNull: boolean;

    /**
     * Retrieves the identifier for a given numeric control. 
     */
    id: number;

    /**
     * Retrieves a Boolean value indicating whether the given control values are absolute or relative. 
     */
    isAbsolute: boolean;

    /**
     * Retrieves the logical maximum value for the given control. 
     */
    logicalMaximum: number;

    /**
     * Retrieves the logical minimum value for the control. 
     */
    logicalMinimum: number;

    /**
     * Retrieves the parent collections for a given numeric control. 
     */
    parentCollections: undefined.IVectorView<undefined.HidCollection>;

    /**
     * Retrieves the physical maximum-value for the given control. 
     */
    physicalMaximum: number;

    /**
     * Retrieves the physical minimum-value for the given control. 
     */
    physicalMinimum: number;

    /**
     * Retrieves the number of reports associated with the given control. 
     */
    reportCount: number;

    /**
     * Retrieves the identifier for the report associated with the given numeric control. 
     */
    reportId: number;

    /**
     * Retrieves the size, in bytes, of the given numeric control. 
     */
    reportSize: number;

    /**
     * Retrieves the type of report associated with the given numeric control. 
     */
    reportType: undefined.HidReportType;

    /**
     * Retrieves the unit associated with the given numeric control. 
     */
    unit: number;

    /**
     * Retrieves the unit exponent for the given numeric control. 
     */
    unitExponent: number;

    /**
     * Retrieves the usage identifier associated with the given numeric control. 
     */
    usageId: number;

    /**
     * Retrieves the usage page associated with the given numeric control. 
     */
    usagePage: number
}


/**
 * Represents an output report. 
 */
declare class HidOutputReport {

    /**
     * Retrieves, or sets, the data associated with a given output report. 
     */
    data: undefined.IBuffer;
    getBooleanControl: any;

    /**
     * Retrieves the boolean control associated with the given controlDescription.
     * @param controlDescription Describes the Boolean control.
     * @return  A HidBooleanControl object.
     */
    getBooleanControlByDescription(
        controlDescription: undefined.HidBooleanControlDescription): undefined.HidBooleanControl;
    getNumericControl: any;

    /**
     * Retrieves the numeric control associated with the given controlDescription.
     * @param controlDescription Describes the numeric control.
     * @return  A HidNumericControl object.
     */
    getNumericControlByDescription(
        controlDescription: undefined.HidNumericControlDescription): undefined.HidNumericControl;

    /**
     * Retrieves the identifier associated with a given output report. 
     */
    id: number
}


/**
 * Represents the connection settings you want to use for an inter-integrated circuit (I²C) device. 
 */
declare class I2cConnectionSettings {

    /**
     * Creates and initializes a new instance of the I2cConnectionSettings class for inter-integrated circuit (I²C) device with specified bus address, using the default settings of the standard mode for the bus speed and exclusive sharing mode.
     * @param slaveAddress The bus address of the inter-integrated circuit (I²C) device to which the settings of the I2cConnectionSettings should apply. Only 7-bit addressing is supported, so the range of values that are valid is from 8 to 119.
     */
    constructor(slaveAddress: number): this;

    /**
     * Gets or sets the bus speed to use for connecting to an inter-integrated circuit (I²C) device. The bus speed is the frequency at which to clock the I²C bus when accessing the device. 
     */
    busSpeed: undefined.I2cBusSpeed;

    /**
     * Gets or sets the sharing mode to use to connect to the inter-integrated circuit (I²C) bus address. This mode determines whether other connections to the I²C bus address can be opened while you are connect to the I²C bus address. 
     */
    sharingMode: undefined.I2cSharingMode;

    /**
     * Gets or sets the bus address of the inter-integrated circuit (I²C) device. 
     */
    slaveAddress: number
}


/**
 * Represents the I²C controller for the system. 
 */
declare class I2cController {

    /**
     * Gets all the I²C controllers that are on the system.
     * @param provider The I²C provider for the controllers on the system.
     * @return  When the method completes successfully, it returns a list of values that represent the available I²C controllers on the system.
     */
    getControllersAsync(
        provider: undefined.II2cProvider): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the default I²C controller on the system.
     * @return  The default I²C controller on the system, or null if the system has no I²C controller.
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.I2cController>;

    /**
     * Gets the I²C device with the specified settings.
     * @param settings The desired connection settings.
     * @return  The I²C device.
     */
    getDevice(settings: undefined.I2cConnectionSettings): undefined.I2cDevice
}


/**
 * Represents a communications channel to a device on an inter-integrated circuit (I²C) bus. 
 */
declare class I2cDevice {

    /**
     * Retrieves an I2cDevice object asynchronously for the inter-integrated circuit (I²C) bus controller that has the specified plug and play device identifier, using the specified connection settings.
     * @param deviceId The plug and play device identifier of the I²C bus controller for which you want to create an I2cDevice object.
     * @param settings The connection settings to use for communication with the I²C bus controller that deviceId specifies.
     * @return  An asynchronous operation that returns the I2cDevice object.
     */
    fromIdAsync(
        deviceId: string,
        settings: undefined.I2cConnectionSettings): undefined.IPromiseWithIAsyncOperation<undefined.I2cDevice>;

    /**
     * Retrieves an Advanced Query Syntax (AQS) string for the inter-integrated circuit (I²C) bus that has the specified friendly name. You can use this string with the DeviceInformation.FindAllAsync method to get a DeviceInformation object for that bus.
     * @param friendlyName A friendly name for the particular I²C bus on a particular hardware platform for which you want to get the AQS string.
     * @return  An AQS string for the I²C bus that friendlyName specifies, which you can use with the DeviceInformation.FindAllAsync method to get a DeviceInformation object for that bus.
     */
    getDeviceSelector(friendlyName: string): string;

    /**
     * Retrieves an Advanced Query Syntax (AQS) string for all of the inter-integrated circuit (I²C) bus controllers on the system. You can use this string with the DeviceInformation.FindAllAsync method to get DeviceInformation objects for those bus controllers.
     * @return  An AQS string for all of the I²C bus controllers on the system, which you can use with the DeviceInformation.FindAllAsync method to get DeviceInformation objects for those bus controllers.
     */
    getDeviceSelector(): string;

    /**
     * Closes the connection to the inter-integrated circuit (I²C) device. 
     */
    close(): void;

    /**
     * Gets the connection settings used for communication with the inter-integrated circuit (I²C) device. 
     */
    connectionSettings: undefined.I2cConnectionSettings;

    /**
     * Gets the plug and play device identifier of the inter-integrated circuit (I²C) bus controller for the device. 
     */
    deviceId: string;

    /**
     * Reads data from the inter-integrated circuit (I²C) bus on which the device is connected into the specified buffer.
     * @param buffer The buffer to which you want to read the data from the I²C bus. The length of the buffer determines how much data to request from the device.
     */
    read(buffer: number[]): void;

    /**
     * Reads data from the inter-integrated circuit (I²C) bus on which the device is connected into the specified buffer, and returns information about the success of the operation that you can use for error handling.
     * @param buffer The buffer to which you want to read the data from the I²C bus. The length of the buffer determines how much data to request from the device.
     * @return  A structure that contains information about the success of the read operation and the actual number of bytes that the operation read into the buffer.
     */
    readPartial(buffer: number[]): undefined.I2cTransferResult;

    /**
     * Writes data to the inter-integrated circuit (I²C) bus on which the device is connected, based on the bus address specified in the I2cConnectionSetting s object that you used to create the I2cDevice object.
     * @param buffer A buffer that contains the data that you want to write to the I²C device. This data should not include the bus address.
     */
    write(buffer: number[]): void;

    /**
     * Writes data to the inter-integrated circuit (I²C) bus on which the device is connected, and returns information about the success of the operation that you can use for error handling.
     * @param buffer A buffer that contains the data that you want to write to the I²C device. This data should not include the bus address.
     * @return  A structure that contains information about the success of the write operation and the actual number of bytes that the operation wrote into the buffer.
     */
    writePartial(buffer: number[]): undefined.I2cTransferResult;

    /**
     * Performs an atomic operation to write data to and then read data from the inter-integrated circuit (I²C) bus on which the device is connected, and sends a restart condition between the write and read operations.
     * @param writeBuffer A buffer that contains the data that you want to write to the I²C device. This data should not include the bus address.
     * @param readBuffer The buffer to which you want to read the data from the I²C bus. The length of the buffer determines how much data to request from the device.
     */
    writeRead(writeBuffer: number[], readBuffer: number[]): void;

    /**
     * Performs an atomic operation to write data to and then read data from the inter-integrated circuit (I²C) bus on which the device is connected, and returns information about the success of the operation that you can use for error handling.
     * @param writeBuffer A buffer that contains the data that you want to write to the I²C device. This data should not include the bus address.
     * @param readBuffer The buffer to which you want to read the data from the I²C bus. The length of the buffer determines how much data to request from the device.
     * @return  A structure that contains information about whether both the read and write parts of the operation succeeded and the sum of the actual number of bytes that the operation wrote and the actual number of bytes that the operation read.
     */
    writeReadPartial(writeBuffer: number[], readBuffer: number[]): undefined.I2cTransferResult
}

declare
var standardMode: any;

declare
var fastMode: any;

declare class ProviderI2cConnectionSettings {
    busSpeed: any;
    sharingMode: any;
    slaveAddress: any
}

declare
var exclusive: any;

declare
var shared: any;

declare
var fullTransfer: any;

declare
var partialTransfer: any;

declare
var slaveAddressNotAcknowledged: any;


/**
 * Represents actions common to all I²C providers. 
 */
declare interface Provider$II2cProvider {
    getControllersAsync: any
}


/**
 * Provides information about whether the data transfers that the ReadPartial , WritePartial , or WriteReadPartial method performed succeeded, and the actual number of bytes the method transferred. 
 */
declare interface I2c$I2cTransferResult {

    /**
     * The actual number of bytes that the operation actually transferred. The following table describes what this value represents for each method. 
     */
    bytesTransferred: number,

        /**
         * An enumeration value that indicates if the read or write operation transferred the full number of bytes that the method requested, or the reason that the full transfer did not succeed. For WriteReadPartial , the value indicates whether the data for both the write and the read operations was entirely transferred. 
         */
        status: undefined.I2cTransferStatus
}


/**
 * Supports the ability to determine the capabilities of any connected hardware keyboards. 
 */
declare class KeyboardCapabilities {

    /**
     * Initializes a new instance of the KeyboardCapabilities class. 
     */
    constructor(): this;

    /**
     * Gets a value that indicates whether a hardware keyboard is detected. 
     */
    keyboardPresent: number
}


/**
 * Supports the ability to determine the capabilities of any connected mouse devices. 
 */
declare class MouseCapabilities {

    /**
     * Initializes a new instance of the MouseCapabilities class. 
     */
    constructor(): this;

    /**
     * Gets a value indicating whether any of the mice connected to the computer have a scroll wheel that tilts left and right (usually for horizontal scrolling). 
     */
    horizontalWheelPresent: number;

    /**
     * Gets a value that indicates whether a mouse device is detected. 
     */
    mousePresent: number;

    /**
     * Gets a value representing the number of buttons on the mouse. If multiple mice are present, it returns the number of buttons of the mouse which has maximum number of buttons. 
     */
    numberOfButtons: number;

    /**
     * Gets a value indicating whether any of the mice connected to the computer has swapped left and right buttons. 
     */
    swapButtons: number;

    /**
     * Gets a value indicating whether any of the mice connected to the computer have a scroll wheel that rolls up and down (usually for vertical scrolling). 
     */
    verticalWheelPresent: number
}


/**
 * Supports the ability to identify and track connected mouse devices. 
 */
declare class MouseDevice {

    /**
     * Retrieves the mouse device that is associated with the current view.
     * @return  The mouse device.
     */
    getForCurrentView(): undefined.MouseDevice;

    /**
     * Occurs when the mouse pointer is moved. 
     */
    onmousemoved: undefined.TypedEventHandler<undefined.MouseDevice, undefined.MouseEventArgs>;
    addEventListener(
        type: "mousemoved",
        listener: undefined.TypedEventHandler<undefined.MouseDevice, undefined.MouseEventArgs>): void;
    removeEventListener(
        type: "mousemoved",
        listener: undefined.TypedEventHandler<undefined.MouseDevice, undefined.MouseEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains event data for the MouseMoved event. 
 */
declare class MouseEventArgs {

    /**
     * Gets a value that indicates the change in the screen location of the mouse pointer since the last mouse event. 
     */
    mouseDelta: undefined.MouseDelta
}


/**
 * Supports the ability to identify the connected pointer devices and determine their capabilities. 
 */
declare class PointerDevice {

    /**
     * Gets information about the pointer device associated with the specified input pointer ID.
     * @param pointerId The ID of the pointer input.
     * @return  The PointerDevice object that represents the associated pointer device.
     */
    getPointerDevice(pointerId: number): undefined.PointerDevice;

    /**
     * Gets information about the pointer devices attached to the system.
     * @return  The collection of PointerDevice objects that represent the pointer devices attached to the system.
     */
    getPointerDevices(): undefined.IVectorView<undefined.PointerDevice>;

    /**
     * Gets a value indicating whether the pointer device is an integrated device. For example, a video display with an integrated touch digitizer compared to an external pen/stylus digitizer. 
     */
    isIntegrated: boolean;

    /**
     * Gets a value indicating the maximum number of contacts supported by the input device. 
     */
    maxContacts: number;
    maxPointersWithZDistance: any;

    /**
     * Gets the coordinates of the bounding rectangle supported by the input device. 
     */
    physicalDeviceRect: undefined.Rect;

    /**
     * Gets the pointer device type. 
     */
    pointerDeviceType: undefined.PointerDeviceType;

    /**
     * Gets the screen coordinates that are mapped to the bounding rectangle supported by the input device. 
     */
    screenRect: undefined.Rect;

    /**
     * Gets a collection containing the supported pointer device usages . 
     */
    supportedUsages: undefined.IVectorView<undefined.PointerDeviceUsage >
}


/**
 * Supports the ability to determine the touch capabilities of any connected touch digitizers. 
 */
declare class TouchCapabilities {

    /**
     * Initializes a new instance of the TouchCapabilities class. 
     */
    constructor(): this;

    /**
     * Gets the minimum number of contacts supported by all the digitizers. 
     */
    contacts: number;

    /**
     * Gets a value that indicates whether a touch digitizer is detected. 
     */
    touchPresent: number
}


/**
 * Identifies the change in screen location of the mouse pointer, relative to the location of the last mouse event. 
 */
declare interface Input$MouseDelta {

    /**
     * The x-coordinate of the mouse pointer, relative to the location of the last mouse event. 
     */
    x: number,

        /**
         * The y-coordinate of the mouse pointer, relative to the location of the last mouse event. 
         */
        y: number
}


/**
 * Identifies the Human Interface Device (HID) usage details for the input device. 
 */
declare interface Input$PointerDeviceUsage {

    /**
     * The maximum logical value for Usage. 
     */
    maxLogical: number,

        /**
         * The maximum physical value for Usage. 
         */
        maxPhysical: number,

        /**
         * The minimum logical value for Usage. 
         */
        minLogical: number,

        /**
         * The minimum physical value for Usage. 
         */
        minPhysical: number,

        /**
         * The multiplier used to convert the usage value reported by the device to a physical value in units of Unit. (Valid only for usages that indicate a static or dynamic value associated with a control, such as pressure or width and height of the touch contact.) 
         */
        physicalMultiplier: number,

        /**
         * The HID unit of measure. 
         */
        unit: number,

        /**
         * The HID pointer device usage ID that specifies a device or property in the UsagePage. For example, 0x04 indicates a touch screen device and 0x47 indicates touch confidence. 
         */
        usage: number,

        /**
         * The HID usage page of the pointer device. 
         */
        usagePage: number
}


/**
 * Represents a lamp device. 
 */
declare class Lamp {

    /**
     * Gets a Lamp object representing the lamp device with the specified ID.
     * @param deviceId The ID of the requested lamp device.
     * @return  An asynchronous operation that returns a Lamp object upon successful completion.
     */
    fromIdAsync(deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.Lamp>;

    /**
     * Gets a Lamp object representing the default lamp for the device.
     * @return  An asynchronous operation that returns a Lamp object upon successful completion.
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.Lamp>;

    /**
     * Returns the class selection string that you can use to enumerate lamp devices.
     * @return  The class selection string for lamp devices.
     */
    getDeviceSelector(): string;

    /**
     * Gets or sets a value indicating the current brightness level of the lamp, where 0.0 is completely off and 1.0 is maximum brightness. 
     */
    brightnessLevel: number;

    /**
     * Releases the lamp device. 
     */
    close(): void;

    /**
     * Gets or sets the color of the lamp. 
     */
    color: undefined.Color;

    /**
     * Gets the DeviceInformation Id for a lamp device. 
     */
    deviceId: string;

    /**
     * Gets a value indicating whether you can set the Color property of the lamp device. 
     */
    isColorSettable: boolean;

    /**
     * Gets a value indicating whether the lamp device is enabled. 
     */
    isEnabled: boolean;

    /**
     * Occurs when the availability of the lamp device changes. 
     */
    onavailabilitychanged: undefined.TypedEventHandler<undefined.Lamp, undefined.LampAvailabilityChangedEventArgs>;
    addEventListener(
        type: "availabilitychanged",
        listener: undefined.TypedEventHandler<undefined.Lamp, undefined.LampAvailabilityChangedEventArgs>): void;
    removeEventListener(
        type: "availabilitychanged",
        listener: undefined.TypedEventHandler<undefined.Lamp, undefined.LampAvailabilityChangedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the AvailabilityChanged event. 
 */
declare class LampAvailabilityChangedEventArgs {

    /**
     * Gets a value indicating whether the lamp device that triggered the event is available. 
     */
    isAvailable: boolean
}

declare class LowLevelDevicesAggregateProvider {
    adcControllerProvider: any;
    gpioControllerProvider: any;
    i2cControllerProvider: any;
    pwmControllerProvider: any;
    spiControllerProvider: any
}

declare class LowLevelDevicesController {
    defaultProvider: any
}


/**
 * Represents a MIDI message that specifies active sensing. 
 */
declare class MidiActiveSensingMessage {

    /**
     * Creates a new MidiActiveSensingMessage object. 
     */
    constructor(): this;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies the channel pressure. 
 */
declare class MidiChannelPressureMessage {

    /**
     * Creates a new MidiChannelPressureMessage object.
     * @param channel The channel from 0-15 that this message applies to.
     * @param pressure The pressure from 0-127.
     */
    constructor(channel: number, pressure: number): this;

    /**
     * Gets the channel from 0-15 that this message applies to. 
     */
    channel: number;

    /**
     * Gets the pressure from 0-127. 
     */
    pressure: number;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies a continue message. 
 */
declare class MidiContinueMessage {

    /**
     * Creates a new MidiContinueMessage object. 
     */
    constructor(): this;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies a control change. 
 */
declare class MidiControlChangeMessage {

    /**
     * Creates a new MidiControlChangeMessage object.
     * @param channel The channel from 0-15 that this message applies to.
     * @param controller The controller from 0-127 to receive this message.
     * @param controlValue The value from 0-127 to apply to the controller .
     */
    constructor(channel: number, controller: number, controlValue: number): this;

    /**
     * Gets the channel from 0-15 that this message applies to. 
     */
    channel: number;

    /**
     * Gets the value from 0-127 to apply to the controller . 
     */
    controlValue: number;

    /**
     * Gets controller from 0-127 to receive this message. 
     */
    controller: number;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a port used to receive MIDI messages from a MIDI device. 
 */
declare class MidiInPort {

    /**
     * Creates a MidiInPort object for the specified device.
     * @param deviceId The device ID, which can be obtained by enumerating the devices on the system Windows.Devices.Enumeration.DeviceInformation.FindAllAsync .
     * @return  The asynchronous operation. Upon completion, IAsyncOperation.GetResults returns a MidiInPort object.
     */
    fromIdAsync(deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.MidiInPort>;

    /**
     * Gets a query string that can be used to enumerate all MidiInPort objects on the system.
     * @return  The query string used to enumerate the MidiInPort objects on the system.
     */
    getDeviceSelector(): string;

    /**
     * Closes the MidiInPort . 
     */
    close(): void;

    /**
     * Gets the id of the device that was used to initialize the MidiInPort . 
     */
    deviceId: string;

    /**
     * Occurs when the MidiInPort receives data. 
     */
    onmessagereceived: undefined.TypedEventHandler<undefined.MidiInPort, undefined.MidiMessageReceivedEventArgs>;
    addEventListener(
        type: "messagereceived",
        listener: undefined.TypedEventHandler<undefined.MidiInPort, undefined.MidiMessageReceivedEventArgs>): void;
    removeEventListener(
        type: "messagereceived",
        listener: undefined.TypedEventHandler<undefined.MidiInPort, undefined.MidiMessageReceivedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the MessageReceived event. 
 */
declare class MidiMessageReceivedEventArgs {

    /**
     * The MIDI message. 
     */
    message: undefined.IMidiMessage
}


/**
 * Represents a MIDI messages that specifies a MIDI note to turn off. 
 */
declare class MidiNoteOffMessage {

    /**
     * Creates a new MidiNoteOffMessage object.
     * @param channel The channel from 0-15 that this message applies to.
     * @param note The note which is specified as a value from 0-127.
     * @param velocity The velocity which is specified as a value from 0-127.
     */
    constructor(channel: number, note: number, velocity: number): this;

    /**
     * Gets the channel from 0-15 that this message applies to. 
     */
    channel: number;

    /**
     * Gets the note to turn off which is specified as a value from 0-127. 
     */
    note: number;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType;

    /**
     * Gets the value of the velocity from 0-127. 
     */
    velocity: number
}


/**
 * Represents a MIDI message that specifies a MIDI note to turn on. 
 */
declare class MidiNoteOnMessage {

    /**
     * Creates a new MidiNoteOnMessage object.
     * @param channel The channel from 0-15 that this message applies to.
     * @param note The note which is specified as a value from 0-127.
     * @param velocity The velocity which is specified as a value from 0-127.
     */
    constructor(channel: number, note: number, velocity: number): this;

    /**
     * Gets the channel from 0-15 that this message applies to. 
     */
    channel: number;

    /**
     * Gets the note to turn on which is specified as a value from 0-127. 
     */
    note: number;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType;

    /**
     * Gets the value of the velocity from 0-127. 
     */
    velocity: number
}


/**
 * Represents a port used to send MIDI messages to a MIDI device. 
 */
declare class MidiOutPort {

    /**
     * Creates a MidiOutPort object for the specified device.
     * @param deviceId The device ID, which can be obtained by enumerating the devices on the system Windows.Devices.Enumeration.DeviceInformation.FindAllAsync .
     * @return  The asynchronous operation. Upon completion, IAsyncOperation.GetResults returns a MidiOutPort object.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.IMidiOutPort>;

    /**
     * Gets a query string that can be used to enumerate all MidiOutPort objects on the system.
     * @return  The query string used to enumerate the MidiOutPort objects on the system.
     */
    getDeviceSelector(): string;

    /**
     * Closes the MidiOutPort . 
     */
    close(): void;

    /**
     * Gets the id of the device that was used to initialize the MidiOutPort . 
     */
    deviceId: string;

    /**
     * Send the specified data buffer to the device associated with this MidiOutPort .
     * @param midiData The data to send to the device.
     */
    sendBuffer(midiData: undefined.IBuffer): void;

    /**
     * Send the data in the specified MIDI message to the device associated with this MidiOutPort .
     * @param midiMessage The MIDI message to send to the device.
     */
    sendMessage(midiMessage: undefined.IMidiMessage): void
}


/**
 * Represents a MIDI message that specifies a pitch bend change. 
 */
declare class MidiPitchBendChangeMessage {

    /**
     * Creates a new MidiPitchBendChangeMessage object.
     * @param channel The channel from 0-15 that this message applies to.
     * @param bend The pitch bend value which is specified as a 14-bit value from 0-16383.
     */
    constructor(channel: number, bend: number): this;

    /**
     * Gets the pitch bend value which is specified as a 14-bit value from 0-16383. 
     */
    bend: number;

    /**
     * Gets the channel from 0-15 that this message applies to. 
     */
    channel: number;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies the polyphonic key pressure. 
 */
declare class MidiPolyphonicKeyPressureMessage {

    /**
     * Creates a new MidiPolyphonicKeyPressureMessage object.
     * @param channel The channel from 0-15 that this message applies to.
     * @param note The note which is specified as a value from 0-127.
     * @param pressure The polyphonic key pressure which is specified as a value from 0-127.
     */
    constructor(channel: number, note: number, pressure: number): this;

    /**
     * Gets the channel from 0-15 that this message applies to. 
     */
    channel: number;

    /**
     * Gets the note which is specified as a value from 0-127. 
     */
    note: number;

    /**
     * Gets the polyphonic key pressure which is specified as a value from 0-127. 
     */
    pressure: number;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies a program change. 
 */
declare class MidiProgramChangeMessage {

    /**
     * Creates a new MidiProgramChangeMessage object.
     * @param channel The channel from 0-15 that this message applies to.
     * @param program The program to change from 0-127.
     */
    constructor(channel: number, program: number): this;

    /**
     * Gets the channel from 0-15 that this message applies to. 
     */
    channel: number;

    /**
     * Gets the program to change from 0-127. 
     */
    program: number;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies a song position pointer. 
 */
declare class MidiSongPositionPointerMessage {

    /**
     * Creates a new MidiSongPositionPointerMessage object.
     * @param beats The song position pointer encoded in a 14-bit value from 0-16383.
     */
    constructor(beats: number): this;

    /**
     * Gets the song position pointer encoded in a 14-bit value from 0-16383. 
     */
    beats: number;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies the selected song. 
 */
declare class MidiSongSelectMessage {

    /**
     * Creates a new MidiSongSelectMessage object.
     * @param song The song to select from 0-127.
     */
    constructor(song: number): this;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the song to select from 0-127. 
     */
    song: number;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies a start message. 
 */
declare class MidiStartMessage {

    /**
     * Creates a new MidiStartMessage object. 
     */
    constructor(): this;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies a stop message. 
 */
declare class MidiStopMessage {

    /**
     * Creates a new MidiStopMessage object. 
     */
    constructor(): this;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents the Microsoft GS wavetable software synthesizer, included in Windows. This synthesizer provides a Roland GS sound set, which includes and extends the General MIDI sound set. 
 */
declare class MidiSynthesizer {

    /**
     * Creates a new instance of the Microsoft MIDI synthesizer with a specified audio output device.
     * @param audioDevice The audio output device.
     * @return  An instance of the Microsoft MIDI synthesizer.
     */
    createAsync(
        audioDevice: undefined.DeviceInformation): undefined.IPromiseWithIAsyncOperation<undefined.MidiSynthesizer>;

    /**
     * Creates a new instance of the Microsoft MIDI synthesizer that uses the system's default audio output device.
     * @return  An instance of the Windows MIDI synthesizer.
     */
    createAsync(): undefined.IPromiseWithIAsyncOperation<undefined.MidiSynthesizer>;

    /**
     * Determines whether a particular device is an instance of the Microsoft MIDI synthesizer. When all MIDI out ports on the system are enumerated, this method can be used to identify which of them is the Microsoft MIDI synthesizer.
     * @param midiDevice An object that represents the device in question.
     * @return  True if the device is the Microsoft MIDI synthesizer; otherwise, false.
     */
    isSynthesizer(midiDevice: undefined.DeviceInformation): boolean;

    /**
     * Gets the audio output device being used by this instance of the Microsoft MIDI synthesizer. 
     */
    audioDevice: undefined.DeviceInformation;

    /**
     * Closes this instance of the Microsoft MIDI synthesizer. It is a best practice for the caller to use this method to clear resources used by the MIDI object. 
     */
    close(): void;

    /**
     * Gets the device ID of the Microsoft MIDI synthesizer. Note that all instances of the synthesizer have the same ID. 
     */
    deviceId: string;

    /**
     * Sends an array of bytes through the synthesizer's out port . This enables you to send your data as a byte array instead of as a defined MIDI message.
     * @param midiData The array of bytes to send.
     */
    sendBuffer(midiData: undefined.IBuffer): void;

    /**
     * Sends a MIDI message through the Microsoft MIDI synthesizer's out port .
     * @param midiMessage The MIDI message to send.
     */
    sendMessage(midiMessage: undefined.IMidiMessage): void;

    /**
     * Gets or sets the output volume of this instance of the Microsoft MIDI synthesizer. 
     */
    volume: number
}


/**
 * Represents a MIDI message that specifies a system exclusive message. 
 */
declare class MidiSystemExclusiveMessage {

    /**
     * Creates a new MidiSystemExclusiveMessage object.
     * @param rawData The system exclusive data.
     */
    constructor(rawData: undefined.IBuffer): this;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies a system reset. 
 */
declare class MidiSystemResetMessage {

    /**
     * Creates a new MidiSystemResetMessage object. 
     */
    constructor(): this;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies a time code. 
 */
declare class MidiTimeCodeMessage {

    /**
     * Creates a new MidiTimeCodeMessage object.
     * @param frameType The frame type from 0-7.
     * @param values The time code from 0-32.
     */
    constructor(frameType: number, values: number): this;

    /**
     * Gets the value of the frame type from 0-7. 
     */
    frameType: number;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType;

    /**
     * Gets the time code value from 0-32. 
     */
    values: number
}


/**
 * Represents a MIDI message that specifies a timing clock. 
 */
declare class MidiTimingClockMessage {

    /**
     * Creates a new MidiTimingClockMessage object. 
     */
    constructor(): this;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message that specifies a tune request. 
 */
declare class MidiTuneRequestMessage {

    /**
     * Creates a new MidiTuneRequestMessage object. 
     */
    constructor(): this;

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer;

    /**
     * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
     */
    timestamp: number;

    /**
     * Gets the type of this MIDI message. 
     */
    type: undefined.MidiMessageType
}


/**
 * Represents a MIDI message which is implemented by all MIDI message classes. 
 */
declare interface Midi$IMidiMessage {

    /**
     * Gets the array of bytes associated with the MIDI message, including status byte. 
     */
    rawData: undefined.IBuffer,

        /**
         * Gets the duration from when the MidiInPort was created to the time the message was received. For messages being sent to a MidiOutPort , this value has no meaning. 
         */
        timestamp: number,

        /**
         * Gets the type of this MIDI message. 
         */
        type: undefined.MidiMessageType
}


/**
 * Represents a single MIDI out port. 
 */
declare type Midi$IMidiOutPort = {

    /**
     * Sends the contents of the buffer through the MIDI out port.
     * @param midiData The data to send to the device.
     */
    sendBuffer(midiData: undefined.IBuffer): void,

    /**
     * Send the data in the specified MIDI message to the device associated with this MidiOutPort .
     * @param midiMessage The MIDI message to send to the device.
     */
    sendMessage(midiMessage: undefined.IMidiMessage): void,

    /**
     * Gets the ID of the device that contains the MIDI out port. 
     */
    deviceId: string
}


/**
 * Provides static methods for retrieving intrinsic properties of a camera. 
 */
declare class KnownCameraIntrinsicsProperties {

    /**
     * Gets a string key used to retrieve an array of single-precision, floating-point property values indicating the focal length of the camera. 
     */
    focalLength: string;

    /**
     * Gets a string key used to retrieve an array of single-precision, floating-point property values indicating the principal point, relative to the camera. 
     */
    principalPoint: string;

    /**
     * Gets a string key used to retrieve an array of single-precision, floating-point property values indicating the radial distortion of the camera. 
     */
    radialDistortion: string;

    /**
     * Gets a string key used to retrieve an array of single-precision, floating-point property values indicating the tangential distortion of the camera. 
     */
    tangentialDistortion: string
}


/**
 * Provides static properties of color frame sources. 
 */
declare class KnownPerceptionColorFrameSourceProperties {

    /**
     * Gets a string key used to retrieve a Boolean property indicating whether or not auto exposure is enabled. 
     */
    autoExposureEnabled: string;

    /**
     * Gets a string key used to retrieve a TimeSpan property indicating the current exposure duration of the camera. 
     */
    exposure: string;

    /**
     * Gets a string key used to retrieve a single-precision, floating-point property indicating the exposure compensation. 
     */
    exposureCompensation: string
}


/**
 * Provides static properties of depth frame sources. 
 */
declare class KnownPerceptionDepthFrameSourceProperties {

    /**
     * Gets a string key used to retrieve a 16-bit unsigned integer property indicating the maximum depth of the depth frame source. 
     */
    maxDepth: string;

    /**
     * Gets a string key used to retrieve a 16-bit unsigned integer property indicating the minimum depth of the depth frame source. 
     */
    minDepth: string
}


/**
 * Provides static properties that are applicable to all types of frame sources. 
 */
declare class KnownPerceptionFrameSourceProperties {
    deviceId: any;

    /**
     * Gets a string key used to look up a string property with the device, model, version string for the physical sensor device this frame source represents. 
     */
    deviceModelVersion: string;

    /**
     * Gets a string key used to look up an enumeration property indicating the physical location of the sensor on the Windows device. 
     */
    enclosureLocation: string;

    /**
     * Gets a string key used to look up a string property that is a string key indicating the kind of frame the source provides. 
     */
    frameKind: string;

    /**
     * Gets a string key used to look up a string property with the unique ID of the frame source. 
     */
    id: string;

    /**
     * Gets a string key used to look up a string array property containing the physical device IDs of the sensor this frame source represents. 
     */
    physicalDeviceIds: string
}


/**
 * Provides static properties of infrared frame sources. 
 */
declare class KnownPerceptionInfraredFrameSourceProperties {

    /**
     * Gets a string key used to retrieve a Boolean property indicating whether or not active IR illumination is enabled. 
     */
    activeIlluminationEnabled: string;

    /**
     * Gets a string key used to retrieve a Boolean property indicating whether or not ambient IR light subtraction is enabled. 
     */
    ambientSubtractionEnabled: string;

    /**
     * Gets a string key used to retrieve a Boolean property indicating whether or not auto exposure is enabled. 
     */
    autoExposureEnabled: string;

    /**
     * Gets a string key used to retrieve a TimeSpan property indicating the current exposure duration of the camera. 
     */
    exposure: string;

    /**
     * Gets a string key used to retrieve a single-precision, floating-point property indicating the amount of exposure compensation. 
     */
    exposureCompensation: string;

    /**
     * Gets a string key used to retrieve a Boolean property indicating whether or not interleaved illumination is enabled. 
     */
    interleavedIlluminationEnabled: string;

    /**
     * Gets a string key used to retrieve a Boolean property indicating whether or not the structured light pattern is enabled. 
     */
    structureLightPatternEnabled: string
}


/**
 * Provides static properties of video frame sources. 
 */
declare class KnownPerceptionVideoFrameSourceProperties {

    /**
     * Gets a string key used to retrieve a boolean property indicating the supported video profiles that are currently available. 
     */
    availableVideoProfiles: string;

    /**
     * Gets a string key used to retrieve a CameraIntrinsics property defining the physical properties of the camera device. The CameraIntrinsics object also provides convenience methods for sensor-related geometry, including camera space to image space projections. 
     */
    cameraIntrinsics: string;

    /**
     * Gets a string key used to retrieve a boolean property indicating whether or not the video frame source is providing mirrored video frames. 
     */
    isMirrored: string;

    /**
     * Gets a string key used to retrieve the supported video profiles property. 
     */
    supportedVideoProfiles: string;

    /**
     * Gets a string key used to retrieve the current video profile property. 
     */
    videoProfile: string
}


/**
 * Provides static properties of a video profile. 
 */
declare class KnownPerceptionVideoProfileProperties {

    /**
     * Gets a string key used to retrieve an enumeration property indicating the bitmap alpha mode. 
     */
    bitmapAlphaMode: string;

    /**
     * Gets a string key used to retrieve an enumeration property indicating the bitmap pixel format. 
     */
    bitmapPixelFormat: string;

    /**
     * Gets a string key used to retrieve a TimeSpan property indicating the time duration of each frame. 
     */
    frameDuration: string;

    /**
     * Gets a string key used to retrieve a 32-bit unsigned integer property indicating the frame height, in pixels. 
     */
    height: string;

    /**
     * Gets a string key used to retrieve a 32-bit unsigned integer property indicating the frame width, in pixels. 
     */
    width: string
}


/**
 * Contains a Windows.Media.VideoFrame with the color frame data. 
 */
declare class PerceptionColorFrame {

    /**
     * Releases system resources that are exposed by a Windows Runtime object. 
     */
    close(): void;

    /**
     * Gets a Windows.Media.VideoFrame with the color frame data. 
     */
    videoFrame: undefined.VideoFrame
}


/**
 * Contains information about a color frame arrived event. 
 */
declare class PerceptionColorFrameArrivedEventArgs {

    /**
     * Gets the relative time of this frame. 
     */
    relativeTime: number;

    /**
     * Attempts to open the color frame that has arrived.
     * @return  If the attempt is successful, this method returns the newly-arrived color frame. If the attempt is unsuccessful, this value is unchanged.
     */
    tryOpenFrame(): undefined.PerceptionColorFrame
}


/**
 * Reads color frames from a color frame source. 
 */
declare class PerceptionColorFrameReader {

    /**
     * Releases system resources that are exposed by a Windows Runtime object. 
     */
    close(): void;

    /**
     * Gets or sets a boolean value indicating whether or not this reader is paused. 
     */
    isPaused: boolean;

    /**
     * Subscribes to the FrameArrived event. This event is fired whenever a new frame arrives from the color frame source. 
     */
    onframearrived: undefined.TypedEventHandler<undefined.PerceptionColorFrameReader, undefined.PerceptionColorFrameArrivedEventArgs>;
    addEventListener(
        type: "framearrived",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameReader, undefined.PerceptionColorFrameArrivedEventArgs>): void;
    removeEventListener(
        type: "framearrived",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameReader, undefined.PerceptionColorFrameArrivedEventArgs>): void;

    /**
     * Gets the color frame source this reader gets frames from. 
     */
    source: undefined.PerceptionColorFrameSource;

    /**
     * Attempts to read the most recent frame that is available to this color frame reader.
     * @return  If the attempt was successful, this method returns the most recent frame that is available to this color frame reader. If the attempt was not successful, this method returns null.
     */
    tryReadLatestFrame(): undefined.PerceptionColorFrame;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * A frame source that provides color frames. 
 */
declare class PerceptionColorFrameSource {

    /**
     * Creates a new color frame source watcher.
     * @return  A new color frame source watcher.
     */
    createWatcher(): undefined.PerceptionColorFrameSourceWatcher;

    /**
     * Finds all color frame sources.
     * @return  When the method completes, it asynchronously returns a list of color frame sources.
     */
    findAllAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Finds an color frame source by looking up its unique ID.
     * @param id The unique ID of the color frame source.
     * @return  When this method completes, it asynchronously returns a color frame source if one exists with the specified ID. Otherwise, this method asynchronously returns null.
     */
    fromIdAsync(
        id: string): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionColorFrameSource>;

    /**
     * Requests access to use color frame sources.
     * @return  When this method completes, it asynchronously returns a PerceptionFrameSourceAccessStatus indicating the result of the access request.
     */
    requestAccessAsync(): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionFrameSourceAccessStatus>;

    /**
     * Attempts to acquire Controller Mode on the color frame source.
     * @return  If the attempt is successful, this returns a PerceptionControlSession object that can be used to control properties of the color frame source. Otherwise, this returns null.
     */
    acquireControlSession(): undefined.PerceptionControlSession;

    /**
     * Gets a boolean value indicating whether or not the source is active. 
     */
    active: boolean;

    /**
     * Gets a boolean value indicating whether or not the source is available. 
     */
    available: boolean;

    /**
     * Gets a read-only collection of video profiles that are currently available from the color frame source. 
     */
    availableVideoProfiles: undefined.IVectorView<undefined.PerceptionVideoProfile>;

    /**
     * Gets a CameraIntrinsics value specifying the intrinsic properties of the color frame source camera device. 
     */
    cameraIntrinsics: undefined.CameraIntrinsics;

    /**
     * This method returns a boolean value indicating whether or not the color frame source can be controlled separately from another frame source.
     * @param targetId A string representing the unique ID of the other frame source.
     * @return  Returns true if the two sources can be controlled independently of one another, otherwise returns false.
     */
    canControlIndependentlyFrom(targetId: string): boolean;
    deviceId: any;

    /**
     * Gets a string value indicating the kind of physical device that generates the color frames for this source. 
     */
    deviceKind: string;

    /**
     * Gets a string value indicating the display name of the color frame source. 
     */
    displayName: string;

    /**
     * Gets a string value indicating the unique ID of the color frame source. 
     */
    id: string;

    /**
     * Gets a boolean value indicating whether or not the source is the subject of controller mode. 
     */
    isControlled: boolean;

    /**
     * Checks whether or not the color frame source is correlated with the target entity. If the result is true, a transform matrix can be retrieved to change coordinate basis from this color frame source to the entity, or vice versa.
     * @param targetId The unique ID of the target entity.
     * @return  Returns true if a correlation exists, otherwise returns false.
     */
    isCorrelatedWith(targetId: string): boolean;

    /**
     * Subscribes to the ActiveChanged event. 
     */
    onactivechanged: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>;
    addEventListener(
        type: "activechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>): void;
    removeEventListener(
        type: "activechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>): void;

    /**
     * Subscribes to the AvailableChanged event. 
     */
    onavailablechanged: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>;
    addEventListener(
        type: "availablechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>): void;
    removeEventListener(
        type: "availablechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>): void;

    /**
     * Subscribes to the CameraIntrinsicsChanged event. 
     */
    oncameraintrinsicschanged: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>;
    addEventListener(
        type: "cameraintrinsicschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>): void;
    removeEventListener(
        type: "cameraintrinsicschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>): void;

    /**
     * Subscribes to the PropertiesChanged event. 
     */
    onpropertieschanged: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, undefined.PerceptionFrameSourcePropertiesChangedEventArgs>;
    addEventListener(
        type: "propertieschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, undefined.PerceptionFrameSourcePropertiesChangedEventArgs>): void;
    removeEventListener(
        type: "propertieschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, undefined.PerceptionFrameSourcePropertiesChangedEventArgs>): void;

    /**
     * Subscribes to the VideoProfileChanged event. 
     */
    onvideoprofilechanged: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>;
    addEventListener(
        type: "videoprofilechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>): void;
    removeEventListener(
        type: "videoprofilechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSource, any>): void;

    /**
     * Gets a frame reader that reads frames from this color frame source.
     * @return  Returns a frame reader that reads frames from this color frame source.
     */
    openReader(): undefined.PerceptionColorFrameReader;

    /**
     * Gets a read-only collection of frame source properties. 
     */
    properties: undefined.IMapView<string, any>;

    /**
     * Gets a read-only collection of video profiles that are supported by the color frame source. 
     */
    supportedVideoProfiles: undefined.IVectorView<undefined.PerceptionVideoProfile>;

    /**
     * Attempts to get the intrinsic properties of the depth camera that is correlated with this color source.
     * @param correlatedDepthFrameSource The depth frame source to try to get intrinsic properties of.
     * @return  If the attempt is successful, this will return a read-only collection of PerceptionDepthCorrelatedCameraIntrinsics objects specifying the intrinsic properties of the camera used by the correlated depth frame source. Otherwise, this returns null.
     */
    tryGetDepthCorrelatedCameraIntrinsicsAsync(
        correlatedDepthFrameSource: undefined.PerceptionDepthFrameSource): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionDepthCorrelatedCameraIntrinsics>;

    /**
     * Attempts to get a coordinate mapper that maps from color frame image space to depth frame space.
     * @param targetSourceId The unique ID of the depth frame source to try to map to.
     * @param correlatedDepthFrameSource The depth frame source to try to map to. This should be in a correlation group with the color frame source.
     * @return  If the two sources are correlated, this method returns a PerceptionDepthCorrelatedCoordinateMapper. Otherwise, it returns null. This method returns asynchronously.
     */
    tryGetDepthCorrelatedCoordinateMapperAsync(
        targetSourceId: string,
        correlatedDepthFrameSource: undefined.PerceptionDepthFrameSource): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionDepthCorrelatedCoordinateMapper>;

    /**
     * This method returns the transform from the color frame source to the target entity and sets hasResult to true, if a correlation exists. If a correlation does not exist, hasResult is set to false and result is not modified.
     * @param targetId The unique ID of the target entity.
     */
    tryGetTransformTo(targetId: string): {
        result: undefined.Matrix4x4,
        returnValue: boolean
    };

    /**
     * Attempts to set a video profile on this color frame source. Requires an active Controller Mode control session on this frame source.
     * @param controlSession A PerceptionControlSession representing active control of this frame source.
     * @param profile The video profile to set.
     * @return  This method returns an PerceptionFrameSourcePropertyChangeResult object asynchonously. If the control session was still active when the video profile was set, and if the video profile is supported and can be activated, this will be a result that indicates success.
     */
    trySetVideoProfileAsync(
        controlSession: undefined.PerceptionControlSession,
        profile: undefined.PerceptionVideoProfile): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionFrameSourcePropertyChangeResult>;

    /**
     * Gets a PerceptionVideoProfile object indicating the current video profile. 
     */
    videoProfile: undefined.PerceptionVideoProfile;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Event data for color frame source added events. 
 */
declare class PerceptionColorFrameSourceAddedEventArgs {

    /**
     * Gets the color frame source that was added. 
     */
    frameSource: undefined.PerceptionColorFrameSource
}


/**
 * Event data for color frame source added events. 
 */
declare class PerceptionColorFrameSourceRemovedEventArgs {

    /**
     * Gets the color frame source that was removed. 
     */
    frameSource: undefined.PerceptionColorFrameSource
}


/**
 * Monitors changes to the list of color frame sources, and provides notifications when the list changes. 
 */
declare class PerceptionColorFrameSourceWatcher {

    /**
     * Subscribes to the EnumerationCompleted event. This event is fired after the initial enumeration of known color frame sources is complete. 
     */
    onenumerationcompleted: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, any>;
    addEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, any>): void;
    removeEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, any>): void;

    /**
     * Subscribes to the SourceAdded event. 
     */
    onsourceadded: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, undefined.PerceptionColorFrameSourceAddedEventArgs>;
    addEventListener(
        type: "sourceadded",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, undefined.PerceptionColorFrameSourceAddedEventArgs>): void;
    removeEventListener(
        type: "sourceadded",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, undefined.PerceptionColorFrameSourceAddedEventArgs>): void;

    /**
     * Subscribes to the SourceRemoved event. This event is fired once for every color frame source that is removed. 
     */
    onsourceremoved: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, undefined.PerceptionColorFrameSourceRemovedEventArgs>;
    addEventListener(
        type: "sourceremoved",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, undefined.PerceptionColorFrameSourceRemovedEventArgs>): void;
    removeEventListener(
        type: "sourceremoved",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, undefined.PerceptionColorFrameSourceRemovedEventArgs>): void;

    /**
     * Subscribes to the Stopped event. This event is fired when the IPerceptionColorFrameSourceWatcher has stopped listening for changes to the list of color frame sources. 
     */
    onstopped: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, any>;
    addEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, any>): void;
    removeEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.PerceptionColorFrameSourceWatcher, any>): void;

    /**
     * When this method is called, the color frame source watcher enumerates any existing color frame sources it has not already enumerated by firing a SourceAdded event for each one. An EnumerationCompleted event is fired when this enumeration is complete. The color frame source then starts watching for new color frame sources. 
     */
    start(): void;

    /**
     * Gets the operational status of the color frame source watcher. 
     */
    status: undefined.DeviceWatcherStatus;

    /**
     * When this method is called, the color frame source watcher stops looking for changes to the color frame source list. This operation is not immediate; the Stopped event will be triggered when the Stop operation is complete. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a control session on a controllable frame source. 
 */
declare class PerceptionControlSession {

    /**
     * Releases system resources that are exposed by a Windows Runtime object. 
     */
    close(): void;

    /**
     * Subscribes to the ControlLost event. This event is triggered when control of the session is lost to another client. 
     */
    oncontrollost: undefined.TypedEventHandler<undefined.PerceptionControlSession, any>;
    addEventListener(
        type: "controllost",
        listener: undefined.TypedEventHandler<undefined.PerceptionControlSession, any>): void;
    removeEventListener(
        type: "controllost",
        listener: undefined.TypedEventHandler<undefined.PerceptionControlSession, any>): void;

    /**
     * Creates a property change request. This request is asynchronously processed, and is not guaranteed to succeed. The property change result should be inspected to determine if the property change was actually accepted and, if it was not, the reason why the property change was not accepted.
     * @param name The name of the property to change.
     * @param value The new property value.
     * @return  This method asynchronously returns the result of the property change request.
     */
    trySetPropertyAsync(
        name: string,
        value: any): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionFrameSourcePropertyChangeResult>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides convenience methods to facilitate geometric math for a camera device, combining the intrinsic properties of that camera with correlated depth frames to provide screen-space pixel to camera-space coordinate projections. 
 */
declare class PerceptionDepthCorrelatedCameraIntrinsics {

    /**
     * Unprojects all pixels in an image from camera image space out into the coordinate frame of the camera device, using the corresponding depth values from a correlated depth camera.
     * @param depthFrame The depth frame containing the depth value to use when projecting the points into camera space. The coordinates of each pixel in the image will be mapped from camera image space to depth image space, and then used to look up the depth in this depth frame.
     */
    unprojectAllPixelsAtCorrelatedDepthAsync(
        depthFrame: undefined.PerceptionDepthFrame): {
        results: undefined.Vector3,
        returnValue: undefined.IPromiseWithIAsyncAction
    };

    /**
     * Unprojects a point in camera image space out into the coordinate frame of the camera device, using the corresponding depth from a correlated depth camera.
     * @param pixelCoordinate A point, relative to the camera frame.
     * @param depthFrame The depth frame containing the depth value to use when projecting the point into camera space. The pixelCoordinate will be mapped from camera image space to depth image space, and then used to look up the depth in depthFrame.
     * @return  An unprojected coordinate, relative to the coordinate system of the camera device. The coordinate is located in front of the camera, at the depth of the corresponding pixel in depthFrame.
     */
    unprojectPixelAtCorrelatedDepth(
        pixelCoordinate: undefined.Point,
        depthFrame: undefined.PerceptionDepthFrame): undefined.Vector3;

    /**
     * Unprojects a set of points in camera image space out into the coordinate frame of the camera device, using the corresponding depth values from a correlated depth camera.
     * @param sourceCoordinates A set of points, relative to the camera frame.
     * @param depthFrame The depth frame containing the depth value to use when projecting the points into camera space. The pixelCoordinate will be mapped from camera image space to depth image space, and then used to look up the depth in depthFrame.
     * @return  A set of coordinates, relative to the coordinate system of the camera device and with correlated depth values.
     */
    unprojectPixelsAtCorrelatedDepth(
        sourceCoordinates: undefined.Point,
        depthFrame: undefined.PerceptionDepthFrame): undefined.Vector3;

    /**
     * Unprojects a region of pixels in an image from camera image space out into the coordinate frame of the camera device, using the corresponding depth values from a correlated depth camera.
     * @param region The region of pixels to project from camera image space out into the coordinate frame of the camera device.
     * @param depthFrame The depth frame containing the depth value to use when projecting the points into camera space. The pixelCoordinates will be mapped from camera image space to depth image space, and then used to look up the depth in depthFrame.
     */
    unprojectRegionPixelsAtCorrelatedDepthAsync(
        region: undefined.Rect,
        depthFrame: undefined.PerceptionDepthFrame): {
        results: undefined.Vector3,
        returnValue: undefined.IPromiseWithIAsyncAction
    }
}


/**
 * Provides convenience methods to map pixel coordinates in camera image space to depth image space. 
 */
declare class PerceptionDepthCorrelatedCoordinateMapper {

    /**
     * Maps all pixels in an image from camera image space to depth image space.
     * @param depthFrame The depth frame to map the pixels to.
     */
    mapAllPixelsToTargetAsync(
        depthFrame: undefined.PerceptionDepthFrame): {
        targetCoordinates: undefined.Point,
        returnValue: undefined.IPromiseWithIAsyncAction
    };

    /**
     * Maps a pixel from camera image space to depth image space.
     * @param sourcePixelCoordinate A pixel coordinate, in camera image space.
     * @param depthFrame The depth frame to map the pixel to.
     * @return  Returns the mapping of the pixel coordinate to depth image space.
     */
    mapPixelToTarget(
        sourcePixelCoordinate: undefined.Point,
        depthFrame: undefined.PerceptionDepthFrame): undefined.Point;

    /**
     * Maps a set of pixels from camera image space to depth image space.
     * @param sourceCoordinates A set of pixel coordinates, in camera image space.
     * @param depthFrame The depth frame to map the pixels to.
     * @return  The mapping of the pixel coordinate to depth image space.
     */
    mapPixelsToTarget(
        sourceCoordinates: undefined.Point,
        depthFrame: undefined.PerceptionDepthFrame): undefined.Point;

    /**
     * Maps a region of pixels from camera image space to depth image space.
     * @param region The region of pixels to map from camera image space to depth image space.
     * @param depthFrame The depth frame to map the region of pixels to.
     */
    mapRegionOfPixelsToTargetAsync(
        region: undefined.Rect,
        depthFrame: undefined.PerceptionDepthFrame): {
        targetCoordinates: undefined.Point,
        returnValue: undefined.IPromiseWithIAsyncAction
    }
}


/**
 * Contains a Windows.Media.VideoFrame with the depth frame data. 
 */
declare class PerceptionDepthFrame {

    /**
     * Releases system resources that are exposed by a Windows Runtime object. 
     */
    close(): void;

    /**
     * Gets a Windows.Media.VideoFrame with the depth frame data. 
     */
    videoFrame: undefined.VideoFrame
}


/**
 * Contains information about a depth frame arrived event. 
 */
declare class PerceptionDepthFrameArrivedEventArgs {

    /**
     * Gets the relative time of this frame. 
     */
    relativeTime: number;

    /**
     * Attempts to open the depth frame that has arrived. Existing frames should be closed before opening new frames. If an app has three or more frames still open when this method is called, TryOpenFrame will fail.
     * @return  If the attempt is successful, this method returns the newly-arrived depth frame. If the attempt is unsuccessful, this value is unchanged.
     */
    tryOpenFrame(): undefined.PerceptionDepthFrame
}


/**
 * Reads depth frames from a depth frame source. 
 */
declare class PerceptionDepthFrameReader {

    /**
     * Releases system resources that are exposed by a Windows Runtime object 
     */
    close(): void;

    /**
     * Gets a boolean value indicating whether or not this reader is paused. 
     */
    isPaused: boolean;

    /**
     * Subscribes to the FrameArrived event. This event is fired whenever a new frame arrives from the depth frame source. 
     */
    onframearrived: undefined.TypedEventHandler<undefined.PerceptionDepthFrameReader, undefined.PerceptionDepthFrameArrivedEventArgs>;
    addEventListener(
        type: "framearrived",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameReader, undefined.PerceptionDepthFrameArrivedEventArgs>): void;
    removeEventListener(
        type: "framearrived",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameReader, undefined.PerceptionDepthFrameArrivedEventArgs>): void;

    /**
     * Gets the depth frame source this reader gets frames from. 
     */
    source: undefined.PerceptionDepthFrameSource;

    /**
     * Attempts to read the most recent frame that is available to this depth frame reader.
     * @return  If the attempt was successful, this method returns the most recent frame that is available to this depth frame reader. If the attempt was not successful, this method returns null.
     */
    tryReadLatestFrame(): undefined.PerceptionDepthFrame;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * A frame source that provides depth frames. 
 */
declare class PerceptionDepthFrameSource {

    /**
     * Creates a new depth frame source watcher.
     * @return  A new depth frame source watcher.
     */
    createWatcher(): undefined.PerceptionDepthFrameSourceWatcher;

    /**
     * Finds all depth frame sources.
     * @return  When the method completes, it asynchronously returns a list of depth frame sources.
     */
    findAllAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Finds an depth frame source by looking up its unique ID.
     * @param id The unique ID of the depth frame source.
     * @return  When this method completes, it asynchronously returns a depth frame source if one exists with the specified ID. Otherwise, this method asynchronously returns null.
     */
    fromIdAsync(
        id: string): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionDepthFrameSource>;

    /**
     * Requests access to use depth frame sources.
     * @return  When this method completes, it asynchronously returns a PerceptionFrameSourceAccessStatus indicating the result of the access request.
     */
    requestAccessAsync(): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionFrameSourceAccessStatus>;

    /**
     * Attempts to acquire Controller Mode on the depth frame source.
     * @return  If the attempt is successful, this returns a PerceptionControlSession object that can be used to control properties of the depth frame source. Otherwise, this returns null.
     */
    acquireControlSession(): undefined.PerceptionControlSession;

    /**
     * Gets a boolean value indicating whether or not the source is active. 
     */
    active: boolean;

    /**
     * Gets a boolean value indicating whether or not the source is available. 
     */
    available: boolean;

    /**
     * Gets a read-only collection of video profiles that are currently available from the depth frame source. 
     */
    availableVideoProfiles: undefined.IVectorView<undefined.PerceptionVideoProfile>;

    /**
     * Gets a CameraIntrinsics value specifying the intrinsic properties of the depth frame source camera device. 
     */
    cameraIntrinsics: undefined.CameraIntrinsics;

    /**
     * This method returns a boolean value indicating whether or not the depth frame source can be controlled separately from another frame source.
     * @param targetId A string representing the unique ID of the other frame source.
     * @return  True if the two sources can be controlled independently of one another; otherwise, false.
     */
    canControlIndependentlyFrom(targetId: string): boolean;
    deviceId: any;

    /**
     * Gets a string value indicating the kind of physical device that generates the depth frames. 
     */
    deviceKind: string;

    /**
     * Gets a string value indicating the display name of the depth frame source. 
     */
    displayName: string;

    /**
     * Gets a string value indicating the unique ID of the depth frame source. 
     */
    id: string;

    /**
     * Gets a boolean value indicating whether or not the source is the subject of controller mode. 
     */
    isControlled: boolean;

    /**
     * Checks whether or not the depth frame source is correlated with the target entity. If the result is true, a transform matrix can be retrieved to change coordinate basis from this depth frame source to the entity, or vice versa.
     * @param targetId The unique ID of the target entity.
     * @return  True if a correlation exists, otherwise false.
     */
    isCorrelatedWith(targetId: string): boolean;

    /**
     * Subscribes to the ActiveChanged event. 
     */
    onactivechanged: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>;
    addEventListener(
        type: "activechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>): void;
    removeEventListener(
        type: "activechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>): void;

    /**
     * Subscribes to the AvailableChanged event. 
     */
    onavailablechanged: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>;
    addEventListener(
        type: "availablechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>): void;
    removeEventListener(
        type: "availablechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>): void;

    /**
     * Subscribes to the CameraIntrinsicsChanged event. 
     */
    oncameraintrinsicschanged: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>;
    addEventListener(
        type: "cameraintrinsicschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>): void;
    removeEventListener(
        type: "cameraintrinsicschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>): void;

    /**
     * Subscribes to the PropertiesChanged event. 
     */
    onpropertieschanged: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, undefined.PerceptionFrameSourcePropertiesChangedEventArgs>;
    addEventListener(
        type: "propertieschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, undefined.PerceptionFrameSourcePropertiesChangedEventArgs>): void;
    removeEventListener(
        type: "propertieschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, undefined.PerceptionFrameSourcePropertiesChangedEventArgs>): void;

    /**
     * Subscribes to the VideoProfileChanged event. 
     */
    onvideoprofilechanged: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>;
    addEventListener(
        type: "videoprofilechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>): void;
    removeEventListener(
        type: "videoprofilechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSource, any>): void;

    /**
     * Gets a frame reader that reads frames from this depth frame source.
     * @return  A frame reader that reads frames from this depth frame source.
     */
    openReader(): undefined.PerceptionDepthFrameReader;

    /**
     * Gets a read-only collection of frame source properties. 
     */
    properties: undefined.IMapView<string, any>;

    /**
     * Gets a read-only collection of video profiles that are supported by the depth frame source. 
     */
    supportedVideoProfiles: undefined.IVectorView<undefined.PerceptionVideoProfile>;

    /**
     * Attempts to get the intrinsic properties of the depth camera that is correlated with this depth source.
     * @param target The depth frame source to try to get intrinsic properties of.
     * @return  If the attempt is successful, this returns a read-only collection of PerceptionDepthCorrelatedCameraIntrinsics objects specifying the intrinsic properties of the camera used by the correlated depth frame source. Otherwise, this returns null.
     */
    tryGetDepthCorrelatedCameraIntrinsicsAsync(
        target: undefined.PerceptionDepthFrameSource): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionDepthCorrelatedCameraIntrinsics>;

    /**
     * Attempts to get a coordinate mapper that maps from depth frame image space to depth frame space.
     * @param targetId The unique ID of the depth frame source to try to map to.
     * @param depthFrameSourceToMapWith The depth frame source to try to map to. This should be in a correlation group with the depth frame source.
     * @return  If the two sources are correlated, this method returns a PerceptionDepthCorrelatedCoordinateMapper. Otherwise, it returns null. This method returns asynchronously.
     */
    tryGetDepthCorrelatedCoordinateMapperAsync(
        targetId: string,
        depthFrameSourceToMapWith: undefined.PerceptionDepthFrameSource): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionDepthCorrelatedCoordinateMapper>;

    /**
     * Gets the transform from the depth frame source to the target entity and sets hasResult to true, if a correlation exists. If a correlation does not exist, hasResult is set to false and result is not modified.
     * @param targetId The unique ID of the target entity.
     */
    tryGetTransformTo(targetId: string): {
        result: undefined.Matrix4x4,
        returnValue: boolean
    };

    /**
     * Attempts to set a video profile on this depth frame source. Requires an active Controller Mode control session on this frame source.
     * @param controlSession A PerceptionControlSession representing active control of this frame source.
     * @param profile The video profile to set.
     * @return  This method returns an PerceptionFrameSourcePropertyChangeResult object asynchronously. If the control session was still active when the video profile was set, and if the video profile is supported and can be activated, this will be a result indicating success.
     */
    trySetVideoProfileAsync(
        controlSession: undefined.PerceptionControlSession,
        profile: undefined.PerceptionVideoProfile): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionFrameSourcePropertyChangeResult>;

    /**
     * Gets a PerceptionVideoProfile object indicating the current video profile. 
     */
    videoProfile: undefined.PerceptionVideoProfile;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Event data for depth frame source added events. 
 */
declare class PerceptionDepthFrameSourceAddedEventArgs {

    /**
     * Gets the depth frame source that was added. 
     */
    frameSource: undefined.PerceptionDepthFrameSource
}


/**
 * Event data for depth frame source removed events. 
 */
declare class PerceptionDepthFrameSourceRemovedEventArgs {

    /**
     * Gets the depth frame source that was removed. 
     */
    frameSource: undefined.PerceptionDepthFrameSource
}


/**
 * Monitors changes to the list of depth frame sources, and provides notifications when the list changes. 
 */
declare class PerceptionDepthFrameSourceWatcher {

    /**
     * Subscribes to the EnumerationCompleted event. This event is fired after the initial enumeration of known depth frame sources is complete. 
     */
    onenumerationcompleted: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, any>;
    addEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, any>): void;
    removeEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, any>): void;

    /**
     * Subscribes to the SourceAdded event. 
     */
    onsourceadded: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, undefined.PerceptionDepthFrameSourceAddedEventArgs>;
    addEventListener(
        type: "sourceadded",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, undefined.PerceptionDepthFrameSourceAddedEventArgs>): void;
    removeEventListener(
        type: "sourceadded",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, undefined.PerceptionDepthFrameSourceAddedEventArgs>): void;

    /**
     * Subscribes to the SourceRemoved event. This event is fired once for every depth frame source that is removed. 
     */
    onsourceremoved: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, undefined.PerceptionDepthFrameSourceRemovedEventArgs>;
    addEventListener(
        type: "sourceremoved",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, undefined.PerceptionDepthFrameSourceRemovedEventArgs>): void;
    removeEventListener(
        type: "sourceremoved",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, undefined.PerceptionDepthFrameSourceRemovedEventArgs>): void;

    /**
     * Subscribes to the Stopped event. This event is fired when the IPerceptionColorFrameSourceWatcher has stopped listening for changes to the list of depth frame sources. 
     */
    onstopped: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, any>;
    addEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, any>): void;
    removeEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.PerceptionDepthFrameSourceWatcher, any>): void;

    /**
     * When this method is called, the depth frame source watcher enumerates any existing depth frame sources it has not already enumerated by firing a SourceAdded event for each one. An EnumerationCompleted event is fired when this enumeration is complete. The depth frame source then starts watching for new depth frame sources. 
     */
    start(): void;

    /**
     * Gets the operational status of the depth frame source watcher. 
     */
    status: undefined.DeviceWatcherStatus;

    /**
     * When this method is called, the depth frame source watcher stops looking for changes to the depth frame source list. This operation is not immediate; the Stopped event will be triggered when the Stop operation is complete. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains information about an attempt to change properties on a frame source. 
 */
declare class PerceptionFrameSourcePropertiesChangedEventArgs {

    /**
     * Gets the type of change that occurred as a result of the property change request. 
     */
    collectionChange: undefined.CollectionChange;

    /**
     * Gets a string key indicating the location of the change in the collection. 
     */
    key: string
}


/**
 * Contains information about an attempted property change on a frame source. 
 */
declare class PerceptionFrameSourcePropertyChangeResult {

    /**
     * Gets a PerceptionFrameSourcePropertyChangeStatus indicating the status of the change request, including whether or not the change took effect. 
     */
    newValue: any;

    /**
     * Gets the value of the property after the change request has been processed. 
     */
    status: undefined.PerceptionFrameSourcePropertyChangeStatus
}


/**
 * Contains a Windows.Media.VideoFrame with the infrared frame data. 
 */
declare class PerceptionInfraredFrame {

    /**
     * Releases system resources that are exposed by a Windows Runtime object. 
     */
    close(): void;

    /**
     * Gets a Windows.Media.VideoFrame with the infrared frame data. 
     */
    videoFrame: undefined.VideoFrame
}


/**
 * Contains information about a infrared frame arrived event. 
 */
declare class PerceptionInfraredFrameArrivedEventArgs {

    /**
     * Gets the relative time of this frame. 
     */
    relativeTime: number;

    /**
     * Attempts to open the infrared frame that has arrived.
     * @return  If the attempt is successful, this method returns the newly-arrived infrared frame. If the attempt is unsuccessful, this value is unchanged.
     */
    tryOpenFrame(): undefined.PerceptionInfraredFrame
}


/**
 * Reads infrared frames from a infrared frame source. 
 */
declare class PerceptionInfraredFrameReader {

    /**
     * Releases system resources that are exposed by a Windows Runtime object 
     */
    close(): void;

    /**
     * Gets a boolean value indicating whether or not this reader is paused. 
     */
    isPaused: boolean;

    /**
     * Subscribes to the FrameArrived event. This event is fired whenever a new frame arrives from the infrared frame source. 
     */
    onframearrived: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameReader, undefined.PerceptionInfraredFrameArrivedEventArgs>;
    addEventListener(
        type: "framearrived",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameReader, undefined.PerceptionInfraredFrameArrivedEventArgs>): void;
    removeEventListener(
        type: "framearrived",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameReader, undefined.PerceptionInfraredFrameArrivedEventArgs>): void;

    /**
     * Gets the infrared frame source this reader gets frames from. 
     */
    source: undefined.PerceptionInfraredFrameSource;

    /**
     * Attempts to read the most recent frame that is available to this infrared frame reader.
     * @return  If the attempt was successful, this method returns the most recent frame that is available to this infrared frame reader. If the attempt was not successful, this method returns null.
     */
    tryReadLatestFrame(): undefined.PerceptionInfraredFrame;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * A frame source that provides infrared frames. 
 */
declare class PerceptionInfraredFrameSource {

    /**
     * Creates a new infrared frame source watcher.
     * @return  A new infrared frame source watcher.
     */
    createWatcher(): undefined.PerceptionInfraredFrameSourceWatcher;

    /**
     * Finds all infrared frame sources.
     * @return  When the method completes, it asynchronously returns a list of infrared frame sources.
     */
    findAllAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Finds an infrared frame source by looking up its unique ID.
     * @param id The unique ID of the infrared frame source.
     * @return  When the method completes, it asynchronously returns an infrared frame source if one exists with the specified ID. Otherwise, this method asynchronously returns nullptr.
     */
    fromIdAsync(
        id: string): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionInfraredFrameSource>;

    /**
     * Requests access to use infrared frame sources.
     * @return  When this method completes, it asynchronously returns a PerceptionFrameSourceAccessStatus indicating the result of the access request.
     */
    requestAccessAsync(): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionFrameSourceAccessStatus>;

    /**
     * Attempts to acquire Controller Mode on the infrared frame source.
     * @return  If the attempt is successful, this returns a PerceptionControlSession object that can be used to control properties of the infrared frame source. Otherwise, this returns null.
     */
    acquireControlSession(): undefined.PerceptionControlSession;

    /**
     * Gets a boolean value indicating whether or not the source is active. 
     */
    active: boolean;

    /**
     * Gets a boolean value indicating whether or not the source is available. 
     */
    available: boolean;

    /**
     * Gets a read-only collection of video profiles that are currently available from the infrared frame source. 
     */
    availableVideoProfiles: undefined.IVectorView<undefined.PerceptionVideoProfile>;

    /**
     * Gets a CameraIntrinsics value specifying the intrinsic properties of the infrared frame source camera device. 
     */
    cameraIntrinsics: undefined.CameraIntrinsics;

    /**
     * Retrieves a boolean value indicating whether or not the infrared frame source can be controlled separately from another frame source.
     * @param targetId A string representing the unique ID of the other frame source.
     * @return  True if the two sources can be controlled independently of one another, otherwise false.
     */
    canControlIndependentlyFrom(targetId: string): boolean;
    deviceId: any;

    /**
     * Gets a string value indicating the kind of physical device that generates the infrared frames. 
     */
    deviceKind: string;

    /**
     * Gets a string value indicating the display name of the infrared frame source. 
     */
    displayName: string;

    /**
     * Gets a string value indicating the unique ID of the infrared frame source. 
     */
    id: string;

    /**
     * Gets a boolean value indicating whether or not the source is the subject of controller mode. 
     */
    isControlled: boolean;

    /**
     * Checks whether or not the infrared frame source is correlated with the target entity.
     * @param targetId The unique ID of the target entity.
     * @return  True if a correlation exists, otherwise false. If the result is true, a transform matrix can be retrieved to change coordinate basis from this infrared frame source to the entity, or vice versa.
     */
    isCorrelatedWith(targetId: string): boolean;

    /**
     * Subscribes to the ActiveChanged event. 
     */
    onactivechanged: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>;
    addEventListener(
        type: "activechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>): void;
    removeEventListener(
        type: "activechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>): void;

    /**
     * Subscribes to the AvailableChanged event. 
     */
    onavailablechanged: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>;
    addEventListener(
        type: "availablechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>): void;
    removeEventListener(
        type: "availablechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>): void;

    /**
     * Subscribes to the CameraIntrinsicsChanged event. 
     */
    oncameraintrinsicschanged: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>;
    addEventListener(
        type: "cameraintrinsicschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>): void;
    removeEventListener(
        type: "cameraintrinsicschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>): void;

    /**
     * Subscribes to the PropertiesChanged event. 
     */
    onpropertieschanged: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, undefined.PerceptionFrameSourcePropertiesChangedEventArgs>;
    addEventListener(
        type: "propertieschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, undefined.PerceptionFrameSourcePropertiesChangedEventArgs>): void;
    removeEventListener(
        type: "propertieschanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, undefined.PerceptionFrameSourcePropertiesChangedEventArgs>): void;

    /**
     * Subscribes to the VideoProfileChanged event. 
     */
    onvideoprofilechanged: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>;
    addEventListener(
        type: "videoprofilechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>): void;
    removeEventListener(
        type: "videoprofilechanged",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSource, any>): void;

    /**
     * Gets a frame reader that reads frames from this infrared frame source.
     * @return  A frame reader that reads frames from this infrared frame source.
     */
    openReader(): undefined.PerceptionInfraredFrameReader;

    /**
     * Gets a read-only collection of frame source properties. 
     */
    properties: undefined.IMapView<string, any>;

    /**
     * Gets a read-only collection of video profiles that are supported by the infrared frame source. 
     */
    supportedVideoProfiles: undefined.IVectorView<undefined.PerceptionVideoProfile>;

    /**
     * Attempts to get the intrinsic properties of the depth camera that is correlated with this infrared source.
     * @param target The depth frame source to try to get intrinsic properties of.
     * @return  If the attempt is successful, this returns a read-only collection of PerceptionDepthCorrelatedCameraIntrinsics objects specifying the intrinsic properties of the camera used by the correlated depth frame source. Otherwise, this returns null.
     */
    tryGetDepthCorrelatedCameraIntrinsicsAsync(
        target: undefined.PerceptionDepthFrameSource): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionDepthCorrelatedCameraIntrinsics>;

    /**
     * Attempts to get a coordinate mapper that maps from infrared frame image space to depth frame space.
     * @param targetId The unique ID of the depth frame source to try to map to.
     * @param depthFrameSourceToMapWith The depth frame source to try to map to. This should be in a correlation group with the infrared frame source.
     * @return  If the two sources are correlated, this method returns a PerceptionDepthCorrelatedCoordinateMapper. Otherwise, it returns null. This method returns asynchronously.
     */
    tryGetDepthCorrelatedCoordinateMapperAsync(
        targetId: string,
        depthFrameSourceToMapWith: undefined.PerceptionDepthFrameSource): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionDepthCorrelatedCoordinateMapper>;

    /**
     * Gets the transform from the infrared frame source to the target entity and sets hasResult to true, if a correlation exists. If a correlation does not exist, hasResult is set to false and result is not modified.
     * @param targetId The unique ID of the target entity.
     */
    tryGetTransformTo(targetId: string): {
        result: undefined.Matrix4x4,
        returnValue: boolean
    };

    /**
     * Attempts to set a video profile on this infrared frame source. Requires an active Controller Mode control session on this frame source.
     * @param controlSession A PerceptionControlSession representing active control of this frame source.
     * @param profile The video profile to set.
     * @return  This method returns an PerceptionFrameSourcePropertyChangeResult object asynchonously. If the control session was still active when the video profile was set, and if the video profile is supported and can be activated, this will be a success result.
     */
    trySetVideoProfileAsync(
        controlSession: undefined.PerceptionControlSession,
        profile: undefined.PerceptionVideoProfile): undefined.IPromiseWithIAsyncOperation<undefined.PerceptionFrameSourcePropertyChangeResult>;

    /**
     * Gets a PerceptionVideoProfile object indicating the current video profile. 
     */
    videoProfile: undefined.PerceptionVideoProfile;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Event data for infrared frame source added events. 
 */
declare class PerceptionInfraredFrameSourceAddedEventArgs {

    /**
     * Gets the infrared frame source that was added. 
     */
    frameSource: undefined.PerceptionInfraredFrameSource
}


/**
 * Event data for infrared frame source removed events. 
 */
declare class PerceptionInfraredFrameSourceRemovedEventArgs {

    /**
     * Gets the infrared frame source that was removed. 
     */
    frameSource: undefined.PerceptionInfraredFrameSource
}


/**
 * Monitors changes to the list of infrared frame sources, and provides notifications when the list changes. 
 */
declare class PerceptionInfraredFrameSourceWatcher {

    /**
     * Subscribes to the EnumerationCompleted event. This event is fired after the initial enumeration of known infrared frame sources is complete. 
     */
    onenumerationcompleted: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, any>;
    addEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, any>): void;
    removeEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, any>): void;

    /**
     * Subscribes to the SourceAdded event. 
     */
    onsourceadded: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, undefined.PerceptionInfraredFrameSourceAddedEventArgs>;
    addEventListener(
        type: "sourceadded",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, undefined.PerceptionInfraredFrameSourceAddedEventArgs>): void;
    removeEventListener(
        type: "sourceadded",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, undefined.PerceptionInfraredFrameSourceAddedEventArgs>): void;

    /**
     * Subscribes to the SourceRemoved event. This event is fired once for every infrared frame source that is removed. 
     */
    onsourceremoved: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, undefined.PerceptionInfraredFrameSourceRemovedEventArgs>;
    addEventListener(
        type: "sourceremoved",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, undefined.PerceptionInfraredFrameSourceRemovedEventArgs>): void;
    removeEventListener(
        type: "sourceremoved",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, undefined.PerceptionInfraredFrameSourceRemovedEventArgs>): void;

    /**
     * Subscribes to the Stopped event. This event is fired when the IPerceptionColorFrameSourceWatcher has stopped listeningfor changes to the list of infrared frame sources. 
     */
    onstopped: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, any>;
    addEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, any>): void;
    removeEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.PerceptionInfraredFrameSourceWatcher, any>): void;

    /**
     * When this method is called, the infrared frame source watcher enumerates any existing infrared frame sources it has not already enumerated by firing a SourceAdded event for each one. An EnumerationCompleted event is fired when this enumeration is complete. The infrared frame source then starts watching for new infrared frame sources. 
     */
    start(): void;

    /**
     * Gets the operational status of the infrared frame source watcher. 
     */
    status: undefined.DeviceWatcherStatus;

    /**
     * When this method is called, the infrared frame source watcher stops looking for changes to the infrared frame source list. This operation is not immediate; the Stopped event will be triggered when the Stop operation is complete. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a Windows.Devices.Perception video profile. 
 */
declare class PerceptionVideoProfile {

    /**
     * Gets the bitmap alpha mode. 
     */
    bitmapAlphaMode: undefined.BitmapAlphaMode;

    /**
     * Gets the bitmap pixel format. 
     */
    bitmapPixelFormat: undefined.BitmapPixelFormat;

    /**
     * Gets the time duration of each frame. 
     */
    frameDuration: number;

    /**
     * Gets the frame height, in pixels. 
     */
    height: number;

    /**
     * A comparison function used to determine if two IPerceptionVideoProfile objects are equivalent.
     * @param other The IPerceptionVideoProfile object to compare to this one.
     * @return  True if the two video profiles are equivalent, otherwise false.
     */
    isEqual(other: undefined.PerceptionVideoProfile): boolean;

    /**
     * Gets the frame width, in pixels. 
     */
    width: number
}


/**
 * A string used to identify the type classification of a frame. 
 */
declare class KnownPerceptionFrameKind {

    /**
     * Gets the string representing the Color FrameKind of a PerceptionFrameProviderInfo. 
     */
    color: string;

    /**
     * Gets the string representing the Depth FrameKind of a PerceptionFrameProviderInfo. 
     */
    depth: string;

    /**
     * Gets the string representing the Infrared FrameKind of a PerceptionFrameProviderInfo. 
     */
    infrared: string
}


/**
 * A group of IPerceptionFrameProvider identifiers to be controlled together. 
 */
declare class PerceptionControlGroup {

    /**
     * Creates a PerceptionControlGroup containing the IPerceptionFrameProviders with the ids specified.
     * @param ids A list of the unique identifiers associated with the grouped IPerceptionFrameProviders. To be controllable, the id must match the associated PerceptionFrameProviderInfo::Id property.
     */
    constructor(ids: undefined.IIterable<string>): this;

    /**
     * The id(s) of the IPerceptionFrameProvider(s) controlled by this group. 
     */
    frameProviderIds: undefined.IVectorView<string >
}


/**
 * A description of the physical position and orientation of a device specified by the IPerceptionFrameProvider's unique identifier (PerceptionFrameProviderInfo::Id) sharing a common coordinate frame of other PerceptionCorrelations that will be combined into a PerceptionCorrelationGroup. 
 */
declare class PerceptionCorrelation {

    /**
     * Initializes a new PerceptionCorrelation instance.
     * @param targetId The unique identifier of the IPerceptionFrameProvider being described.
     * @param position The position of the device in a common coordinate frame of all members of a PerceptionCorrelationGroup.
     * @param orientation The orientation of the device in a common coordinate frame of all members of a PerceptionCorrelationGroup.
     */
    constructor(targetId: string, position: undefined.Vector3, orientation: undefined.Quaternion): this;

    /**
     * The orientation of the device in the common coordinate frame shared by other PerceptionCorrelations in the PerceptionCorrelationGroup. 
     */
    orientation: undefined.Quaternion;

    /**
     * The position of the device in the common coordinate frame shared by other PerceptionCorrelations in the PerceptionCorrelationGroup. 
     */
    position: undefined.Vector3;

    /**
     * The unique identifier of the described device. 
     */
    targetId: string
}


/**
 * A collection of PerceptionCorrelations describing multiple unique providers in a common coordinate frame. 
 */
declare class PerceptionCorrelationGroup {

    /**
     * Initializes a new PerceptionCorrelationGroup from a collection of one or more PerceptionCorrelation objects describing multiple providers in a common coordinate frame.
     * @param relativeLocations The collection of PerceptionCorrelations describing multiple providers in a common coordinate frame.
     */
    constructor(relativeLocations: undefined.IIterable<undefined.PerceptionCorrelation>): this;

    /**
     * The collection of PerceptionCorrelations describing multiple unique providers in a common coordinate frame. 
     */
    relativeLocations: undefined.IVectorView<undefined.PerceptionCorrelation >
}


/**
 * A group of unique identifiers specifying IPerceptionFrameProviders that share handlers for entering and exiting Face Authentication mode. 
 */
declare class PerceptionFaceAuthenticationGroup {

    /**
     * Initializes a new PerceptionFaceAuthenticationGroup instance.
     * @param ids The collection of unique identifiers which maps to IPerceptionFrameProviders via PerceptionFrameProviderInfo::Id.
     * @param startHandler The handler to invoke when this group is requested to enter Face Authentication mode returning if it's ready.
     * @param stopHandler The handler to invoke when this group is leaving Face Authentication mode after startHandler is called and returned true.
     */
    constructor(ids: undefined.IIterable<string>, startHandler: undefined.PerceptionStartFaceAuthenticationHandler, stopHandler: undefined.PerceptionStopFaceAuthenticationHandler): this;

    /**
     * The id(s) of the IPerceptionFrameProvider(s) referenced by this group. 
     */
    frameProviderIds: undefined.IVectorView<string >
}


/**
 * Represents a frame of data from the device. 
 */
declare class PerceptionFrame {

    /**
     * The actual bytes of the frame which can be consumed as described by the Properties of the IPerceptionFrameProvider which produced the frame. 
     */
    frameData: undefined.IMemoryBuffer;

    /**
     * Gets the Properties for this frame. 
     */
    properties: undefined.ValueSet;

    /**
     * Gets or sets the Relative Time of this frame relative to other frames from this IPerceptionFrameProvider. 
     */
    relativeTime: number
}


/**
 * A specific set of properties describing a unique IPerceptionFrameProvider. 
 */
declare class PerceptionFrameProviderInfo {

    /**
     * Initializes a new PerceptionFrameProviderInfo instance. 
     */
    constructor(): this;

    /**
     * Gets or sets the descriptor of the kind of FrameProvider categorically, for example, "com.contoso.depthcamera.x500". 
     */
    deviceKind: string;

    /**
     * Gets or sets the friendly name for the device, for example, "Contoso Depth Camera x500". 
     */
    displayName: string;

    /**
     * Gets or sets the type of frames the device creates. 
     */
    frameKind: string;

    /**
     * Gets or sets a value indicating whether the device enumerates via FindAllAsync or device-added events on source watchers. 
     */
    hidden: boolean;

    /**
     * Gets or sets the unique identifier of the IPerceptionFrameProvider. 
     */
    id: string
}


/**
 * Static methods for managing IPerceptionFrameProvider registration and unregistration, PerceptionFaceAuthenticationGroup registration and unregistration, PerceptionControlGroup registration and unregistration, PerceptionCorrelationGroup registration and unregistration, IPerceptionFrameProvider availablity, and publishing a new PerceptionFrame for an IPerceptionFrameProvider. 
 */
declare class PerceptionFrameProviderManagerService {

    /**
     * Sends the PerceptionFrame to the service to tell any apps listening for frames for the provided provider. Frames aren't expected to be published before IPerceptionFrameProvider::Start() is called or after IPerceptionFrameProvider::Stop() is called.
     * @param provider The IPerceptionFrameProvider which produced the frame.
     * @param frame The PerceptionFrame that was produced and should be sent to apps.
     */
    publishFrameForProvider(
        provider: undefined.IPerceptionFrameProvider,
        frame: undefined.PerceptionFrame): void;

    /**
     * Registers a PerceptionControlGroup associated with the IPerceptionFrameProviderManager.
     * @param manager The manager that owns the lifetime of the group.
     * @param controlGroup The group of IPerceptionFrameProvider(s) to control atomically.
     */
    registerControlGroup(
        manager: undefined.IPerceptionFrameProviderManager,
        controlGroup: undefined.PerceptionControlGroup): void;

    /**
     * Registers a PerceptionCorrelationGroup associated with the IPerceptionFrameProviderManager.
     * @param manager The manager that owns the lifetime of the group.
     * @param correlationGroup The group of PerceptionCorrelations(s) to control atomically.
     */
    registerCorrelationGroup(
        manager: undefined.IPerceptionFrameProviderManager,
        correlationGroup: undefined.PerceptionCorrelationGroup): void;

    /**
     * Registers a PerceptionFaceAuthenticationGroup associated with the given IPerceptionProviderManager.
     * @param manager The manager that owns the lifetime of the group.
     * @param faceAuthenticationGroup The group of IPerceptionFrameProvider(s) to atomically control.
     */
    registerFaceAuthenticationGroup(
        manager: undefined.IPerceptionFrameProviderManager,
        faceAuthenticationGroup: undefined.PerceptionFaceAuthenticationGroup): void;

    /**
     * Registers the PerceptionFrameProviderInfo in association with the given IPerceptionFrameProviderManager.
     * @param manager The manager which can provide the IPerceptionFrameProvider associated with the info.
     * @param frameProviderInfo The PerceptionFrameProviderInfo which identifies the available IPerceptionFrameProvider.
     */
    registerFrameProviderInfo(
        manager: undefined.IPerceptionFrameProviderManager,
        frameProviderInfo: undefined.PerceptionFrameProviderInfo): void;

    /**
     * Removes the registration of a previously registered PerceptionControlGroup.
     * @param manager The manager that owns the lifetime of the group.
     * @param controlGroup The group of IPerceptionFrameProvider(s) to prevent from being controlled.
     */
    unregisterControlGroup(
        manager: undefined.IPerceptionFrameProviderManager,
        controlGroup: undefined.PerceptionControlGroup): void;

    /**
     * Unregisters a PerceptionCorrelationGroup associated with the IPerceptionFrameProviderManager.
     * @param manager The manager that owns the lifetime of the group.
     * @param correlationGroup The PerceptionCorrelationGroup to unregister.
     */
    unregisterCorrelationGroup(
        manager: undefined.IPerceptionFrameProviderManager,
        correlationGroup: undefined.PerceptionCorrelationGroup): void;

    /**
     * Unregisters a PerceptionFaceAuthenticationGroup in association with the given IPerceptionProviderManager.
     * @param manager The manager that owns the lifetime of the group.
     * @param faceAuthenticationGroup The PerceptionFaceAuthenticationGroup to unregister.
     */
    unregisterFaceAuthenticationGroup(
        manager: undefined.IPerceptionFrameProviderManager,
        faceAuthenticationGroup: undefined.PerceptionFaceAuthenticationGroup): void;

    /**
     * Unregisters the PerceptionFrameProviderInfo in association with the given IPerceptionProviderManager.
     * @param manager The manager which previously registered this info.
     * @param frameProviderInfo The PerceptionFrameProviderInfo which identifies the IPerceptionFrameProvider.
     */
    unregisterFrameProviderInfo(
        manager: undefined.IPerceptionFrameProviderManager,
        frameProviderInfo: undefined.PerceptionFrameProviderInfo): void;

    /**
     * Sets whether or not the IPerceptionFrameProvider is available.
     * @param provider The provider to set availability for.
     * @param available Whether or not the provider is available.
     */
    updateAvailabilityForProvider(provider: undefined.IPerceptionFrameProvider, available: boolean): void
}


/**
 * A request from an app that's in control of this IPerceptionFrameProvider to update a property. 
 */
declare class PerceptionPropertyChangeRequest {

    /**
     * Gets a Windows::Foundation::Deferral object to allow background processing if needed.
     * @return  The Deferral object.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Gets the name of the property to change. 
     */
    name: string;

    /**
     * Sets the new status of the request after processing the request. 
     */
    status: undefined.PerceptionFrameSourcePropertyChangeStatus;

    /**
     * Gets the requested new value of the property. 
     */
    value: any
}


/**
 * An allocator that can create PerceptionFrames directly which can be written into or copied from Windows::Media::VideoFrame into a PerceptionFrame. 
 */
declare class PerceptionVideoFrameAllocator {

    /**
     * Initializes a new PerceptionVideoFrameAllocator with the required properties for use by the IPerceptionFrameProvider to create PerceptionFrames published via PerceptionFrameProviderManagerService::PublishFrameForProvider.
     * @param maxOutstandingFrameCountForWrite This is the number of buffers in flight required by the FrameProvider to produce its * frames at framerate. The suggestion is at least 2.
     * @param format The Windows::Graphics::Imaging::BitmapPixelFormat describing the format of the bytes of the frame.
     * @param resolution The resolution in pixels of the frame.
     * @param alpha The Windows::Graphics::Imaging::BitmapAlphaMode describing how transparency is handled in the pixels.
     */
    constructor(maxOutstandingFrameCountForWrite: number, format: undefined.BitmapPixelFormat, resolution: undefined.Size, alpha: undefined.BitmapAlphaMode): this;

    /**
     * Creates an empty PerceptionFrame with the properties specified when creating the PerceptionVideoFrameAllocator.
     * @return  The empty frame with the properties specified when creating the PerceptionVideoFrameAllocator.
     */
    allocateFrame(): undefined.PerceptionFrame;

    /**
     * Releases system resources that are exposed by a Windows Runtime object. 
     */
    close(): void;

    /**
     * Creates a deep copy of the video FrameProvider with the bytes already filled in with the resulting PerceptionFrame.
     * @param frame The input frame from which to copy the pixel data.
     * @return  The resulting filled PerceptionFrame.
     */
    copyFromVideoFrame(frame: undefined.VideoFrame): undefined.PerceptionFrame
}


/**
 * Invoked when a PerceptionFaceAuthenticationGroup enters Face Authentication mode. 
 */
declare type Provider$PerceptionStartFaceAuthenticationHandler = (sender: undefined.PerceptionFaceAuthenticationGroup) => void;


/**
 * Invoked when a PerceptionFaceAuthenticationGroup exits Face Authentication mode. This will only be invoked after the group received a PerceptionStartFaceAuthenticationHandler from which it returned true. 
 */
declare type Provider$PerceptionStopFaceAuthenticationHandler = (sender: undefined.PerceptionFaceAuthenticationGroup) => void;


/**
 * Represents an object that can produce PerceptionFrames. 
 */
declare type Provider$IPerceptionFrameProvider = {

    /**
     * The device is requested to update one of its Properties to a new value.
     * @param value Success or failure will be conveyed to the app.
     */
    setProperty(value: undefined.PerceptionPropertyChangeRequest): void,

    /**
     * Tells the device to start producing frames. If success is returned, PerceptionFrameProviderManagerService::PublishFrameForProvider is expected to be called by this Provider. 
     */
    start(): void,

    /**
     * Tells the device to stop producing frames. Called only after Start is called and only if Start returns success. 
     */
    stop(): void,

    /**
     * Gets a value indicating whether or not the device is ready to start producing PerceptionFrames. 
     */
    available: boolean,

    /**
     * Gets the PerceptionFrameProviderInfo describing this device. 
     */
    frameProviderInfo: undefined.PerceptionFrameProviderInfo,

    /**
     * The properties describing the device and the frames produced by the device. 
     */
    properties: undefined.IPropertySet
}


/**
 * The IPerceptionFrameProviderManager is expected to provide any IPerceptionFrameProvider that has been registered via PerceptionFrameProviderManagerService::RegisterFrameProviderInfo(). 
 */
declare type Provider$IPerceptionFrameProviderManager = {

    /**
     * The method to request an IPerceptionFrameProvider associated with a registered PerceptionFrameProviderInfo.
     * @param frameProviderInfo The info specifying the desired IPerceptionFrameProvider.
     * @return  The associated IPerceptionFrameProvider, or nullptr if there is no such registerd provider.
     */
    getFrameProvider(
        frameProviderInfo: undefined.PerceptionFrameProviderInfo): undefined.IPerceptionFrameProvider
}


/**
 * Represents the barcode scanner device. 
 */
declare class BarcodeScanner {

    /**
     * Creates BarcodeScanner object from the DeviceInformation.Id .
     * @param deviceId The DeviceInformation.Id that identifies a specific barcode scanner, which can be retrieved from the DeviceId property.
     * @return  The barcode scanner specified by the unique device identifier. Returns a null object in the following cases:
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.BarcodeScanner>;

    /**
     * Returns the first available barcode scanner.
     * @return  The first available barcode scanner. Returns a null object in the following cases:
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.BarcodeScanner>;

    /**
     * Gets an Advanced Query Syntax (AQS) string that you can use to list the available barcode scanners.
     * @return  An Advanced Query Syntax (AQS) string that is used to enumerate available barcode scanners.
     */
    getDeviceSelector(): string;

    /**
     * Gets the capabilities of the specified barcode scanner. 
     */
    capabilities: undefined.BarcodeScannerCapabilities;

    /**
     * Tests the state of the barcode scanner.
     * @param level The specified health check level.
     * @return  A text description of the test result. Returns an error if the specified check level is not supported by the device.
     */
    checkHealthAsync(
        level: undefined.UnifiedPosHealthCheckLevel): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Attempts to get an exclusive access to the barcode scanner.
     * @return  When the method completes, it returns a ClaimedBarcodeScanner .
     */
    claimScannerAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ClaimedBarcodeScanner>;

    /**
     * Gets the DeviceInformation.Id of the barcode scanner. 
     */
    deviceId: string;

    /**
     * Gets the list of profiles supported by the barcode scanner.
     * @return  As array of strings representing the supported profiles. Returns an empty list if the scanner does not support profiles.
     */
    getSupportedProfiles(): undefined.IVectorView<string>;

    /**
     * Gets the symbologies supported by the claimed barcode scanner.
     * @return  When the method completes successfully, it returns a list of values that represent the symbologies supported by the device.
     */
    getSupportedSymbologiesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Determines whether the profile is supported.
     * @param profile Barcode scanner profile.
     * @return  True if the barcode scanner supports the profile; otherwise false.
     */
    isProfileSupported(profile: string): boolean;

    /**
     * Determines whether the specified symbology is supported by the barcode scanner.
     * @param barcodeSymbology The specific barcode symbology.
     * @return  True if the device supports the specified symbology; otherwise, false.
     */
    isSymbologySupportedAsync(barcodeSymbology: number): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Occurs when the barcode scanner detects an operation status change. 
     */
    onstatusupdated: undefined.TypedEventHandler<undefined.BarcodeScanner, undefined.BarcodeScannerStatusUpdatedEventArgs>;
    addEventListener(
        type: "statusupdated",
        listener: undefined.TypedEventHandler<undefined.BarcodeScanner, undefined.BarcodeScannerStatusUpdatedEventArgs>): void;
    removeEventListener(
        type: "statusupdated",
        listener: undefined.TypedEventHandler<undefined.BarcodeScanner, undefined.BarcodeScannerStatusUpdatedEventArgs>): void;

    /**
     * Retrieves the requested statistics from the barcode scanner.
     * @param statisticsCategories The list of statistics to retrieve.
     * @return  IBuffer representing the requested statistics.
     */
    retrieveStatisticsAsync(
        statisticsCategories: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the barcode scanner capabilities. 
 */
declare class BarcodeScannerCapabilities {

    /**
     * Indicates whether the barcode scanner supports image preview. 
     */
    isImagePreviewSupported: boolean;

    /**
     * Indicates whether the barcode scanner supports the software trigger functionality. 
     */
    isSoftwareTriggerSupported: boolean;

    /**
     * Indicates whether the barcode scanner supports reporting of usage statistics. 
     */
    isStatisticsReportingSupported: boolean;

    /**
     * Indicates whether the barcode scanner supports updating or resetting of usage statistics. 
     */
    isStatisticsUpdatingSupported: boolean;

    /**
     * Gets the power reporting type for the barcode scanner. 
     */
    powerReportingType: undefined.UnifiedPosPowerReportingType
}


/**
 * Provides the barcode data from the DataReceived event. 
 */
declare class BarcodeScannerDataReceivedEventArgs {

    /**
     * Gets the data from the DataReceived event. 
     */
    report: undefined.BarcodeScannerReport
}


/**
 * Provides data for the ErrorOccurred event. 
 */
declare class BarcodeScannerErrorOccurredEventArgs {

    /**
     * Gets the data associated with the ErrorOccurred event. 
     */
    errorData: undefined.UnifiedPosErrorData;

    /**
     * Indicates whether it is worthwhile to make another attempt at the operation. 
     */
    isRetriable: boolean;

    /**
     * Gets any data that was successfully read. 
     */
    partialInputData: undefined.BarcodeScannerReport
}


/**
 * Provides the data from the ImagePreviewReceived event. 
 */
declare class BarcodeScannerImagePreviewReceivedEventArgs {

    /**
     * Gets the BitmapImage from the device representing a preview frame. 
     */
    preview: undefined.IRandomAccessStreamWithContentType
}


/**
 * Contains the barcode scanner data. 
 */
declare class BarcodeScannerReport {

    /**
     * Gets the full raw data from the DataReceived event. 
     */
    scanData: undefined.IBuffer;

    /**
     * Gets the decoded barcode label, which does not include the header, checksum, and other miscellaneous information. 
     */
    scanDataLabel: undefined.IBuffer;

    /**
     * Gets the decoded barcode label type. Possible values are defined in the BarcodeSymbologies class. 
     */
    scanDataType: number
}


/**
 * Provides information about an operation status change. 
 */
declare class BarcodeScannerStatusUpdatedEventArgs {

    /**
     * Gets the vendor specific status code. 
     */
    extendedStatus: number;

    /**
     * Gets the status change information. 
     */
    status: undefined.BarcodeScannerStatus
}


/**
 * Contains the barcode symbology. 
 */
declare class BarcodeSymbologies {

    /**
     * Gets the Australia Postal barcode symbology. 
     */
    ausPost: number;

    /**
     * Gets the Aztec barcode symbology. 
     */
    aztec: number;

    /**
     * Gets the Canada Postal barcode symbology. 
     */
    canPost: number;

    /**
     * Gets the Composite Component A or B barcode symbology. 
     */
    ccab: number;

    /**
     * Gets the Composite Component-C barcode symbology. 
     */
    ccc: number;

    /**
     * Gets the China Postal barcode symbology. 
     */
    chinaPost: number;

    /**
     * Gets the Codabar barcode symbology. 
     */
    codabar: number;

    /**
     * Gets the Codablock 128 barcode symbology. 
     */
    codablock128: number;

    /**
     * Gets the Codablock A barcode symbology. 
     */
    codablockA: number;

    /**
     * Gets the Codablock F barcode symbology. 
     */
    codablockF: number;

    /**
     * Gets the Code 11 barcode symbology. 
     */
    code11: number;

    /**
     * Gets the Code 128 barcode symbology. 
     */
    code128: number;

    /**
     * Gets the Code 16k barcode symbology. 
     */
    code16k: number;

    /**
     * Gets the Code 32 barcode symbology. 
     */
    code32: number;

    /**
     * Gets the Code 39 barcode symbology. 
     */
    code39: number;

    /**
     * Gets the Code 39 Extended barcode symbology. 
     */
    code39Ex: number;

    /**
     * Gets the Code 49 barcode symbology. 
     */
    code49: number;

    /**
     * Gets the Code 93 barcode symbology. 
     */
    code93: number;

    /**
     * Gets the Code 93 Extended barcode symbology. 
     */
    code93Ex: number;

    /**
     * Gets the Data Code barcode symbology. 
     */
    dataCode: number;

    /**
     * Gets the Data Matric barcode symbology. 
     */
    dataMatrix: number;

    /**
     * Gets the Dutch Postal barcode symbology. 
     */
    dutchKix: number;

    /**
     * Gets the EAN (European Article Number) 13 barcode symbology. 
     */
    ean13: number;

    /**
     * Gets the EAN 13 with 2 digit supplement barcode symbology. 
     */
    ean13Add2: number;

    /**
     * Gets the EAN 13 with 5 digit supplement barcode symbology. 
     */
    ean13Add5: number;

    /**
     * Gets the EAN 8 barcode symbology. 
     */
    ean8: number;

    /**
     * Gets the EAN 8 with 2 digit supplement barcode symbology. 
     */
    ean8Add2: number;

    /**
     * Gets the EAN 8 with 5 digit supplement barcode symbology. 
     */
    ean8Add5: number;

    /**
     * Gets the EAN 99 barcode symbology. 
     */
    ean99: number;

    /**
     * Gets the EAN 99 with 2 digit supplement barcode symbology. 
     */
    ean99Add2: number;

    /**
     * Gets the EAN 99 with 5 digit supplement barcode symbology. 
     */
    ean99Add5: number;

    /**
     * Gets the EAN Velocity barcode symbology. 
     */
    eanv: number;

    /**
     * Gets the EAN Velocity with 2 digit supplement barcode symbology. 
     */
    eanvAdd2: number;

    /**
     * Gets the EAN Velocity with 5 digit supplement barcode symbology. 
     */
    eanvAdd5: number;

    /**
     * Gets the first possible OEM defined barcode symbology when the symbology type is not included in the current list. 
     */
    extendedBase: number;

    /**
     * Returns the barcode symbology type as a string.
     * @param scanDataType The barcode symbology type.
     * @return  The barcode symbology type as a string.
     */
    getName(scanDataType: number): string;

    /**
     * Gets the GS1 128 shipping container barcode symbology. 
     */
    gs1128: number;

    /**
     * Gets the GS1 128 Coupon barcode symbology. 
     */
    gs1128Coupon: number;

    /**
     * Gets the GS1 Databar Omnidirectional, GS1 Databar Stacked Omnidirectional, GS1 Databar Stacked, or GS1 Databar Truncated barcode symbology. 
     */
    gs1DatabarType1: number;

    /**
     * Gets the GS1 DataBar Limited or RSS Limited barcode symbology. 
     */
    gs1DatabarType2: number;

    /**
     * Gets the GS1 Databar Expanded, GS1 Databar Expanded Stacked, or RSS Expanded barcode symbology. 
     */
    gs1DatabarType3: number;

    /**
     * Gets the Han Xin barcode symbology. 
     */
    hanXin: number;

    /**
     * Gets the InfoMail barcode symbology. 
     */
    infoMail: number;

    /**
     * Gets the International Standard Book Number (ISBN), also known as Bookland or Bookland EAN, barcode symbology. 
     */
    isbn: number;

    /**
     * Gets the ISBN with 5 digit supplement barcode symbology. 
     */
    isbnAdd5: number;

    /**
     * Gets the International Society of Blood Transfusion (ISBT) 128 barcode symbology. 
     */
    isbt: number;

    /**
     * Gets the International Standard Music Number (ISMN) barcode symbology. 
     */
    ismn: number;

    /**
     * Gets the ISMN with 2 digit supplement barcode symbology. 
     */
    ismnAdd2: number;

    /**
     * Gets the ISMN with 5 digit supplement barcode symbology. 
     */
    ismnAdd5: number;

    /**
     * Gets the International Standard Serial Number (ISSN) barcode symbology. 
     */
    issn: number;

    /**
     * Gets the ISSN with 2 digit supplement barcode symbology. 
     */
    issnAdd2: number;

    /**
     * Gets the ISSN with 5 digit supplement barcode symbology. 
     */
    issnAdd5: number;

    /**
     * Gets the Italian Post 25 barcode symbology. 
     */
    italianPost25: number;

    /**
     * Gets the Italian Post 39 barcode symbology. 
     */
    italianPost39: number;

    /**
     * Gets the Japan Postal barcode symbology. 
     */
    japanPost: number;

    /**
     * Gets the Korea Postal barcode symbology. 
     */
    koreanPost: number;

    /**
     * Gets the MaxiCode barcode symbology. 
     */
    maxicode: number;

    /**
     * Gets the Magnetic Ink Character Recognition (MICR) barcode symbology. 
     */
    micr: number;

    /**
     * Gets the Micro PDF 417 barcode symbology. 
     */
    microPdf417: number;

    /**
     * Gets the Micro QR Code barcode symbology. 
     */
    microQr: number;

    /**
     * Gets the Microsoft tag barcode symbology. 
     */
    msTag: number;

    /**
     * Gets the MSI barcode symbology. 
     */
    msi: number;

    /**
     * Gets the OCR-A barcode symbology. 
     */
    ocrA: number;

    /**
     * Gets the OCR-B barcode symbology. 
     */
    ocrB: number;

    /**
     * Gets the PDF 417 barcode symbology. 
     */
    pdf417: number;

    /**
     * Gets the Plessey barcode symbology. 
     */
    plessey: number;

    /**
     * Gets the Pharma-Zentral-Nummer (Pzn) barcode symbology. 
     */
    pzn: number;

    /**
     * Gets the Quick Response (QR) Code barcode symbology. 
     */
    qr: number;

    /**
     * Gets the Serials Industry Systems Advisory Committee (SISAC) barcode symbology. 
     */
    sisac: number;

    /**
     * Gets the Sweden Postal barcode symbology. 
     */
    swedenPost: number;

    /**
     * Gets the Telepen barcode symbology. 
     */
    telepen: number;

    /**
     * Gets the Discreet 2 of 5 barcode symbology. 
     */
    tfDis: number;

    /**
     * Gets the 2 of 5 International Air Transportation Association (IATA) barcode symbology. 
     */
    tfIata: number;

    /**
     * Gets the Industrial 2 of 5 barcode symbology. 
     */
    tfInd: number;

    /**
     * Gets the Interleaved 2 of 5 barcode symbology. 
     */
    tfInt: number;

    /**
     * Gets the 2 of 5 Matrix barcode symbology. 
     */
    tfMat: number;

    /**
     * Gets the Standard 2 of 5 barcode symbology. 
     */
    tfStd: number;

    /**
     * Gets the TLC 39 barcode symbology. 
     */
    tlc39: number;

    /**
     * Gets the Tri-Optic Media Storage Devices barcode symbology. 
     */
    trioptic39: number;

    /**
     * Gets the UCC/EAN 128 barcode symbology. 
     */
    uccEan128: number;

    /**
     * Gets the UK Postal barcode symbology. 
     */
    ukPost: number;

    /**
     * Unknown barcode symbology. 
     */
    unknown: number;

    /**
     * Gets the UPC Coupon with supplemental barcode symbology. 
     */
    upcCoupon: number;

    /**
     * Gets the Universal Product Code (UPC) version A barcode symbology. 
     */
    upca: number;

    /**
     * Gets the UPC A with 2 digit supplemental barcode symbology. 
     */
    upcaAdd2: number;

    /**
     * Gets the UPC A with 5 digit supplement barcode symbology. 
     */
    upcaAdd5: number;

    /**
     * Gets the Universal Product Code (UPC) version E barcode symbology. 
     */
    upce: number;

    /**
     * Gets the UPC-E with 2 digit supplemnent barcode symbology. 
     */
    upceAdd2: number;

    /**
     * Gets the UPC-E with 5 digit supplement barcode symbology. 
     */
    upceAdd5: number;

    /**
     * Gets the United States Postal Service 4-State Flat Mail Identification Code Sort (FICS) barcode symbology. 
     */
    us4StateFics: number;

    /**
     * Gets the United States Postal Service (USPS) Intelligent Mail barcode symbology. 
     */
    usIntelligent: number;

    /**
     * Gets the United States Postal Service (USPS) Intelligent Mail Package barcode symbology. 
     */
    usIntelligentPkg: number;

    /**
     * Gets the United States Postal Service PLANET barcode symbology. 
     */
    usPlanet: number;

    /**
     * Gets the United States Postal Numeric Encoding Technique (POSTNET) barcode symbology. 
     */
    usPostNet: number
}


/**
 * A cash drawer device in a retail scenario. 
 */
declare class CashDrawer {

    /**
     * Creates CashDrawer object from the DeviceInformation.Id .
     * @param deviceId The DeviceInformation.Id that identifies a specific cash drawer, which can be retrieved from the DeviceId property.
     * @return  The cash drawer specified by the unique device identifier. Returns a null object in the following cases:
     */
    fromIdAsync(deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.CashDrawer>;

    /**
     * Gets the default paired or locally-connected cash drawer.
     * @return  The default locally-connected drawer. May return null if there is no drawer available.
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.CashDrawer>;

    /**
     * Gets an Advanced Query Syntax (AQS) string that you can use to list the available cash drawers.
     * @return  An Advanced Query Syntax (AQS) string that is used to enumerate available cash drawers.
     */
    getDeviceSelector(): string;

    /**
     * The functionality of the cash drawer device as exposed by API. 
     */
    capabilities: undefined.CashDrawerCapabilities;

    /**
     * Gets the device's health state asynchronously.
     * @param level The specified health check level.
     * @return  This value is intended to be reflected in the app interface immediately so the user of the app can interpret it. For example, it will return “OK” as the health string if the device state is good.
     */
    checkHealthAsync(
        level: undefined.UnifiedPosHealthCheckLevel): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Attempts to get exclusive access on the cash drawer.
     * @return  When the method completes, it returns a ClaimedCashDrawer .
     */
    claimDrawerAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ClaimedCashDrawer>;

    /**
     * The identifier string of the cash drawer device. 
     */
    deviceId: string;

    /**
     * Gets the CashDrawerEventSource to allow the app to detect the open/close state of the drawer. The actual current state is reported by IsDrawerOpen. . 
     */
    drawerEventSource: undefined.CashDrawerEventSource;

    /**
     * Retrieves the requested statistics from the cash drawer.
     * @param statisticsCategories The list of statistics to retrieve.
     * @return  String representing the requested statistics.
     */
    getStatisticsAsync(
        statisticsCategories: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Indicates whether the cash drawer is open. 
     */
    isDrawerOpen: boolean;

    /**
     * Indicates there has been a change in the power availability status of the drawer. 
     */
    onstatusupdated: undefined.TypedEventHandler<undefined.CashDrawer, undefined.CashDrawerStatusUpdatedEventArgs>;
    addEventListener(
        type: "statusupdated",
        listener: undefined.TypedEventHandler<undefined.CashDrawer, undefined.CashDrawerStatusUpdatedEventArgs>): void;
    removeEventListener(
        type: "statusupdated",
        listener: undefined.TypedEventHandler<undefined.CashDrawer, undefined.CashDrawerStatusUpdatedEventArgs>): void;

    /**
     * Get the current power and availability status of the cash drawer. 
     */
    status: undefined.CashDrawerStatus;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the cash drawer capabilities. 
 */
declare class CashDrawerCapabilities {

    /**
     * Indicated whether cash drawer open sensor is available. 
     */
    isDrawerOpenSensorAvailable: boolean;

    /**
     * Whether statistics reporting is supported by the cash drawer. 
     */
    isStatisticsReportingSupported: boolean;

    /**
     * Whether statistics updating is supported by the cash drawer. 
     */
    isStatisticsUpdatingSupported: boolean;

    /**
     * Whether the status from multiple drawers is supported. 
     */
    isStatusMultiDrawerDetectSupported: boolean;

    /**
     * Whether status reporting is supported by the cash drawer. 
     */
    isStatusReportingSupported: boolean;

    /**
     * Whether the cash drawer has standard or advanced power reporting. 
     */
    powerReportingType: undefined.UnifiedPosPowerReportingType
}


/**
 * The cash drawer close alarm. Parameter defaults are provided, however the user can update them as appropriate. 
 */
declare class CashDrawerCloseAlarm {

    /**
     * Gets or sets the alarm timeout for the cash drawer close alarm. 
     */
    alarmTimeout: number;

    /**
     * Delay between cash drawer closed alarm beeps. 
     */
    beepDelay: number;

    /**
     * Duration of the cash drawer close alarm beep. 
     */
    beepDuration: number;

    /**
     * Frequency of beep tone. 
     */
    beepFrequency: number;

    /**
     * Event allowing the app to be notified if the alarm timeout has been triggered. 
     */
    onalarmtimeoutexpired: undefined.TypedEventHandler<undefined.CashDrawerCloseAlarm, any>;
    addEventListener(
        type: "alarmtimeoutexpired",
        listener: undefined.TypedEventHandler<undefined.CashDrawerCloseAlarm, any>): void;
    removeEventListener(
        type: "alarmtimeoutexpired",
        listener: undefined.TypedEventHandler<undefined.CashDrawerCloseAlarm, any>): void;

    /**
     * Starts the alarm countdown, returning an awaitable object that completes when the cash drawer is closed.
     * @return  True if the drawer has been closed; otherwise, false indicates a problem has occurred.
     */
    startAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * This object is passed as a parameter to the event handlers for the DrawerClosed event. 
 */
declare class CashDrawerClosedEventArgs {

    /**
     * Gets the data associated with the DrawerClosed event. 
     */
    cashDrawer: undefined.CashDrawer
}


/**
 * Provides event sources that allow a developer to detect when the cash drawer is opened or closed. 
 */
declare class CashDrawerEventSource {

    /**
     * Occurs when the cash drawer is closed. 
     */
    ondrawerclosed: undefined.TypedEventHandler<undefined.CashDrawerEventSource, undefined.CashDrawerClosedEventArgs>;
    addEventListener(
        type: "drawerclosed",
        listener: undefined.TypedEventHandler<undefined.CashDrawerEventSource, undefined.CashDrawerClosedEventArgs>): void;
    removeEventListener(
        type: "drawerclosed",
        listener: undefined.TypedEventHandler<undefined.CashDrawerEventSource, undefined.CashDrawerClosedEventArgs>): void;

    /**
     * Occurs when the cash drawer is opened. 
     */
    ondraweropened: undefined.TypedEventHandler<undefined.CashDrawerEventSource, undefined.CashDrawerOpenedEventArgs>;
    addEventListener(
        type: "draweropened",
        listener: undefined.TypedEventHandler<undefined.CashDrawerEventSource, undefined.CashDrawerOpenedEventArgs>): void;
    removeEventListener(
        type: "draweropened",
        listener: undefined.TypedEventHandler<undefined.CashDrawerEventSource, undefined.CashDrawerOpenedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * This object is passed as a parameter to the event handlers for the DrawerOpened event. 
 */
declare class CashDrawerOpenedEventArgs {

    /**
     * Gets the data associated with the DrawerOpened event. 
     */
    cashDrawer: undefined.CashDrawer
}


/**
 * Provides the current power and availability status of the cash drawer. 
 */
declare class CashDrawerStatus {

    /**
     * ExtendedStatus provides a way for a Point of Service driver or provider to send custom notifications to the app. 
     */
    extendedStatus: number;

    /**
     * Gets the status kind for the cash drawer status. 
     */
    statusKind: undefined.CashDrawerStatusKind
}


/**
 * This object is passed as a parameter to the event handlers for the StatusUpdated event. 
 */
declare class CashDrawerStatusUpdatedEventArgs {

    /**
     * Gets the data associated with the StatusUpdated event. 
     */
    status: undefined.CashDrawerStatus
}


/**
 * Represents the claimed barcode scanner. 
 */
declare class ClaimedBarcodeScanner {

    /**
     * Releases exclusive claim to the barcode scanner. 
     */
    close(): void;

    /**
     * Gets the DeviceInformation.Id of the claimed barcode scanner. 
     */
    deviceId: string;

    /**
     * Puts the barcode scanner into a state where it cannot receive DataReceived events.
     * @return  No object or value is returned when this method completes.
     */
    disableAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the barcode scanner into a ready state for DataReceived events.
     * @return  No object or value is returned when this method completes.
     */
    enableAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets a Boolean value that indicates whether to provide the decoded data to the service object. 
     */
    isDecodeDataEnabled: boolean;

    /**
     * Gets or sets a Boolean value that indicates whether the barcode scanner is disabled after receiving the data. 
     */
    isDisabledOnDataReceived: boolean;

    /**
     * Indicates whether the barcode scanner can receive DataReceived events. 
     */
    isEnabled: boolean;

    /**
     * Occurs when the device scans a barcode. 
     */
    ondatareceived: undefined.TypedEventHandler<undefined.ClaimedBarcodeScanner, undefined.BarcodeScannerDataReceivedEventArgs>;
    addEventListener(
        type: "datareceived",
        listener: undefined.TypedEventHandler<undefined.ClaimedBarcodeScanner, undefined.BarcodeScannerDataReceivedEventArgs>): void;
    removeEventListener(
        type: "datareceived",
        listener: undefined.TypedEventHandler<undefined.ClaimedBarcodeScanner, undefined.BarcodeScannerDataReceivedEventArgs>): void;

    /**
     * Occurs when there is a problem in reading a barcode. 
     */
    onerroroccurred: undefined.TypedEventHandler<undefined.ClaimedBarcodeScanner, undefined.BarcodeScannerErrorOccurredEventArgs>;
    addEventListener(
        type: "erroroccurred",
        listener: undefined.TypedEventHandler<undefined.ClaimedBarcodeScanner, undefined.BarcodeScannerErrorOccurredEventArgs>): void;
    removeEventListener(
        type: "erroroccurred",
        listener: undefined.TypedEventHandler<undefined.ClaimedBarcodeScanner, undefined.BarcodeScannerErrorOccurredEventArgs>): void;

    /**
     * Occurs when the device receives the bitmap image of the scan. 
     */
    onimagepreviewreceived: undefined.TypedEventHandler<undefined.ClaimedBarcodeScanner, undefined.BarcodeScannerImagePreviewReceivedEventArgs>;
    addEventListener(
        type: "imagepreviewreceived",
        listener: undefined.TypedEventHandler<undefined.ClaimedBarcodeScanner, undefined.BarcodeScannerImagePreviewReceivedEventArgs>): void;
    removeEventListener(
        type: "imagepreviewreceived",
        listener: undefined.TypedEventHandler<undefined.ClaimedBarcodeScanner, undefined.BarcodeScannerImagePreviewReceivedEventArgs>): void;

    /**
     * Occurs when the device gets a request to release its exclusive claim. 
     */
    onreleasedevicerequested: undefined.EventHandler<any>;
    addEventListener(type: "releasedevicerequested", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "releasedevicerequested", listener: undefined.EventHandler<any>): void;

    /**
     * Occurs when the barcode scanner trigger or button is pressed during a scanning operation. 
     */
    ontriggerpressed: undefined.EventHandler<any>;
    addEventListener(type: "triggerpressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "triggerpressed", listener: undefined.EventHandler<any>): void;

    /**
     * Occurs when the barcode scanner trigger or button is released during a scanning operation. 
     */
    ontriggerreleased: undefined.EventHandler<any>;
    addEventListener(type: "triggerreleased", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "triggerreleased", listener: undefined.EventHandler<any>): void;

    /**
     * Resets the specified statistics to zero for all statistics that can be reset.
     * @param statisticsCategories The list of names of the statistics to reset.
     * @return  No object or value is returned by this method when it completes.
     */
    resetStatisticsAsync(
        statisticsCategories: undefined.IIterable<string>): undefined.IPromiseWithIAsyncAction;

    /**
     * Retains exclusive claim to the barcode scanner. 
     */
    retainDevice(): void;

    /**
     * Sets the active profile on the barcode scanner.
     * @param profile The name of the profile to set on the device.
     * @return  No object or value is returned when the method completes.
     */
    setActiveProfileAsync(profile: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Sets the barcode symbologies for the device to use.
     * @param symbologies The specific symbologies to use.
     * @return  No object or value is returned when this method completes.
     */
    setActiveSymbologiesAsync(symbologies: undefined.IIterable<number>): undefined.IPromiseWithIAsyncAction;

    /**
     * Used to signal the barcode scanner to start scanning. A session is active until StopSoftwareTriggerAsync is invoked, or until the scanner ends the session on its own.
     * @return  No object or value is returned when this method completes.
     */
    startSoftwareTriggerAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Used to stop a session that was started with StartSoftwareTriggerAsync . No error is raised if this is called when no session is active.
     * @return  No object or value is returned when this method completes.
     */
    stopSoftwareTriggerAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Updates the specified statistics.
     * @param statistics The list of key-value pairs of statistics to update.
     * @return  No object or value is returned by this method when it completes.
     */
    updateStatisticsAsync(
        statistics: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncAction;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides access to exclusive and privileged methods, properties, and events on a point-of-service cash drawer device. 
 */
declare class ClaimedCashDrawer {

    /**
     * Disposes the claimed cash drawer, releases claim on the device, and disables the device the same way as calling DisableAsync. 
     */
    close(): void;

    /**
     * Gets the close alarm for this cash drawer. This is only valid if IsDrawerOpenSensorAvailable is true. 
     */
    closeAlarm: undefined.CashDrawerCloseAlarm;

    /**
     * The identifier string of the claimed cash drawer device. 
     */
    deviceId: string;

    /**
     * Notifies the underlying hardware to power off.
     * @return  Whether the attempt to disable succeeded or not.
     */
    disableAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously notifies the underlying hardware to power on for use.
     * @return  Whether the attempt to enable succeeded or not.
     */
    enableAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Indicates whether the cash drawer is open. 
     */
    isDrawerOpen: boolean;

    /**
     * Indicates whether the cash drawer is operational and can be used. 
     */
    isEnabled: boolean;

    /**
     * Occurs when the device gets a request to release its exclusive claim. 
     */
    onreleasedevicerequested: undefined.TypedEventHandler<undefined.ClaimedCashDrawer, any>;
    addEventListener(
        type: "releasedevicerequested",
        listener: undefined.TypedEventHandler<undefined.ClaimedCashDrawer, any>): void;
    removeEventListener(
        type: "releasedevicerequested",
        listener: undefined.TypedEventHandler<undefined.ClaimedCashDrawer, any>): void;

    /**
     * Opens the cash drawer.
     * @return  Boolean indicating whether the drawer was successfully opened.
     */
    openDrawerAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Resets the specified device statistics to their defaults.
     * @param statisticsCategories The list of names of the statistics to reset.
     * @return  True on success; otherwise false.
     */
    resetStatisticsAsync(
        statisticsCategories: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Retain the current claim on the cash drawer. This is usually called in response to a ReleaseDeviceRequested event notification.
     * @return  True if the retain attempt succeeded; false if the retain attempt failed.
     */
    retainDeviceAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Updates device statistics values using the provided key/value pair.
     * @param statistics The statistics to update.
     * @return  True if update succeeded; otherwise false.
     */
    updateStatisticsAsync(
        statistics: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncOperation<boolean>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a journal printer station that has been claimed for use. 
 */
declare class ClaimedJournalPrinter {

    /**
     * Gets or sets the number of characters per line for the journal printer station. 
     */
    charactersPerLine: number;

    /**
     * Gets or sets the color cartridge that the journal printer station should use when it prints. This property must agree with what is available through ColorCartridgeCapabilities . 
     */
    colorCartridge: undefined.PosPrinterColorCartridge;

    /**
     * Creates a new print job for the journal printer station.
     * @return  The new print job for the journal printer station.
     */
    createJob(): undefined.JournalPrintJob;

    /**
     * Gets whether the printer cartridge for the journal printer station is empty. Note, this may throw an exception if the corresponding sensor is not available on the printer. See JournalPrinterCapabilities to verify sensor availability. 
     */
    isCartridgeEmpty: boolean;

    /**
     * Gets whether the cartridge for journal printer station has been removed. Note, this may throw an exception if the corresponding sensor is not available on the printer. See JournalPrinterCapabilities to verify sensor availability. 
     */
    isCartridgeRemoved: boolean;

    /**
     * Gets whether the printer cover for the journal printer station is open. 
     */
    isCoverOpen: boolean;

    /**
     * Gets whether the head for the journal printer station is currently cleaning. 
     */
    isHeadCleaning: boolean;

    /**
     * Gets or sets whether the journal printer station prints with high quality or high speed. Note, this may throw an exception if the corresponding sensor is not available on the printer. 
     */
    isLetterQuality: boolean;

    /**
     * Gets whether the paper is empty for the journal printer station. Note, this may throw an exception if the corresponding sensor is not available on the printer. See JournalPrinterCapabilities to verify sensor availability. 
     */
    isPaperEmpty: boolean;

    /**
     * Gets whether the printer paper is near the end for the journal printer station. Note, this may throw an exception if the corresponding sensor is not available on the printer. See JournalPrinterCapabilities to verify sensor availability. 
     */
    isPaperNearEnd: boolean;

    /**
     * Gets whether the journal printer station is ready to print. Note, this may throw an exception if the corresponding sensor is not available on the printer. See JournalPrinterCapabilities to verify sensor availability. 
     */
    isReadyToPrint: boolean;

    /**
     * Gets or sets the current height of the printed line for the journal printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. 
     */
    lineHeight: number;

    /**
     * Gets or sets the spacing of each single-high print line for the journal printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. This spacing includes both the height of printed line and of the white space between each pair of lines. 
     */
    lineSpacing: number;

    /**
     * Gets the current width of the printed line for the journal printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. 
     */
    lineWidth: number;

    /**
     * Determines if a JournalPrintJob can successfully execute a print instruction with the specified data.
     * @param data The data sequence that you want to validate before you use it with the JournalPrintJob.Print method. This sequence may include printable data and escape sequences.
     * @return  True if the data passes validation; otherwise false.
     */
    validateData(data: string): boolean
}


/**
 * Represents the claimed magnetic stripe reader. 
 */
declare class ClaimedMagneticStripeReader {

    /**
     * Puts the device into an authenticated state.
     * @param responseToken A buffer containing the response token generated from the challenge token retrieved from a previous call to the RetrieveDeviceAuthenticationDataAsync method.
     */
    authenticateDeviceAsync(responseToken: number[]): any;

    /**
     * Releases the exclusive claim to the magnetic strip reader. 
     */
    close(): void;

    /**
     * Gets or sets the MagneticStripeReaderEncryptionAlgorithms that will be used to encrypt the track data. 
     */
    dataEncryptionAlgorithm: number;

    /**
     * Puts the device into an unauthenticated state.
     * @param responseToken A buffer containing the response token generated from the challenge token retrieved from a previous call to the RetrieveDeviceAuthenticationDataAsync method.
     */
    deAuthenticateDeviceAsync(responseToken: number[]): any;

    /**
     * Gets the DeviceInformation.Id of the claimed magnetic stripe reader. 
     */
    deviceId: string;

    /**
     * Puts the ClaimedMagneticStripeReader into a state where it cannot receive data events.
     * @return  No object or value is returned when this method completes.
     */
    disableAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the magnetic stripe reader into a ready state to receive data events.
     * @return  No object or value is returned by this method when it completes.
     */
    enableAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Indicates whether to provide raw or decoded data from the most recently swiped card. 
     */
    isDecodeDataEnabled: boolean;

    /**
     * Indicates whether the device is authenticated. 
     */
    isDeviceAuthenticated: boolean;

    /**
     * Gets or sets a Boolean value that indicates whether the magnetic stripe reader is disabled after receiving the data from the most recently swiped card. 
     */
    isDisabledOnDataReceived: boolean;

    /**
     * Indicates whether the magnetic stripe reader is ready to receive data events. 
     */
    isEnabled: boolean;

    /**
     * Indicates whether the track data contains start and end sentinel values. 
     */
    isTransmitSentinelsEnabled: boolean;

    /**
     * Occurs when a motor vehicle card is swiped. 
     */
    onaamvacarddatareceived: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderAamvaCardDataReceivedEventArgs>;
    addEventListener(
        type: "aamvacarddatareceived",
        listener: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderAamvaCardDataReceivedEventArgs>): void;
    removeEventListener(
        type: "aamvacarddatareceived",
        listener: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderAamvaCardDataReceivedEventArgs>): void;

    /**
     * Occurs when a bank card is swiped. 
     */
    onbankcarddatareceived: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderBankCardDataReceivedEventArgs>;
    addEventListener(
        type: "bankcarddatareceived",
        listener: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderBankCardDataReceivedEventArgs>): void;
    removeEventListener(
        type: "bankcarddatareceived",
        listener: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderBankCardDataReceivedEventArgs>): void;

    /**
     * Occurs when the magnetic stripe reader detects an error when reading a card. 
     */
    onerroroccurred: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderErrorOccurredEventArgs>;
    addEventListener(
        type: "erroroccurred",
        listener: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderErrorOccurredEventArgs>): void;
    removeEventListener(
        type: "erroroccurred",
        listener: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderErrorOccurredEventArgs>): void;

    /**
     * Occurs when the device gets a request to release its exclusive claim. 
     */
    onreleasedevicerequested: undefined.EventHandler<any>;
    addEventListener(type: "releasedevicerequested", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "releasedevicerequested", listener: undefined.EventHandler<any>): void;

    /**
     * Occurs when a vendor-specific card is swiped. 
     */
    onvendorspecificdatareceived: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>;
    addEventListener(
        type: "vendorspecificdatareceived",
        listener: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>): void;
    removeEventListener(
        type: "vendorspecificdatareceived",
        listener: undefined.TypedEventHandler<undefined.ClaimedMagneticStripeReader, undefined.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>): void;

    /**
     * Resets the specified statistics to zero for all statistics that can be reset.
     * @param statisticsCategories The list of names of the statistics to reset.
     * @return  No object or value is returned by this method when it completes.
     */
    resetStatisticsAsync(
        statisticsCategories: undefined.IIterable<string>): undefined.IPromiseWithIAsyncAction;

    /**
     * Retains exclusive claim to the magnetic stripe reader. 
     */
    retainDevice(): void;

    /**
     * Retrieves a challenge token from the device.
     * @return  Buffer used to store the resulting challenge token from the device.
     */
    retrieveDeviceAuthenticationDataAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Sets the type of error to report by the ErrorOccurred event.
     * @param value Error reporting type.
     */
    setErrorReportingType(value: undefined.MagneticStripeReaderErrorReportingType): void;

    /**
     * Gets or sets the track data that the application wants to receive following a card swipe. 
     */
    tracksToRead: undefined.MagneticStripeReaderTrackIds;

    /**
     * Provides a new encryption key to the device.
     * @param key The HEX-ASCII or base64-encoded value for the new key.
     * @param keyName The name used to identify the key.
     */
    updateKeyAsync(key: string, keyName: string): any;

    /**
     * Updates the specified statistics.
     * @param statistics The list of key-value pairs of statistics to update.
     * @return  No object or value is returned by this method when it completes.
     */
    updateStatisticsAsync(
        statistics: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncAction;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represent a point-of-service printer that has been claimed for use. 
 */
declare class ClaimedPosPrinter {

    /**
     * Gets or sets a numeric value that indicates the character set that the application wants to use for printing characters. 
     */
    characterSet: number;

    /**
     * Disposes the claimed point-of-service printer object synchronously, releases the exclusive claim on the printer and disables it. 
     */
    close(): void;

    /**
     * Gets the identifier string of the claimed point-of-service printer. 
     */
    deviceId: string;

    /**
     * Notifies the underlying hardware to turn off.
     * @return  True if the attempt turn off the printer succeeded; otherwise false.
     */
    disableAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Notifies the underlying hardware asynchronously to power on for use.
     * @return  True if the attempt to turn on the printer succeeded; otherwise false.
     */
    enableAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets or sets whether the driver or provider can map Unicode characters to characters that the point-of-service printer can print, or just sends the low byte of the Unicode character to the printer directly. 
     */
    isCharacterSetMappingEnabled: boolean;

    /**
     * Gets whether the cover of the point-of-service printer is currently open. 
     */
    isCoverOpen: boolean;

    /**
     * Gets whether the printer is powered on for use. 
     */
    isEnabled: boolean;

    /**
     * Gets an object that represents the journal station for a claimed point-of-service printer. 
     */
    journal: undefined.ClaimedJournalPrinter;

    /**
     * Gets or sets the mapping mode of the point-of-service printer that the app wants to use. The mapping mode defines the unit of measure used for other printer properties, such as line height and line spacing. 
     */
    mapMode: undefined.PosPrinterMapMode;

    /**
     * Occurs when a point-of-service printer gets a request to release its exclusive claim. 
     */
    onreleasedevicerequested: undefined.TypedEventHandler<undefined.ClaimedPosPrinter, undefined.PosPrinterReleaseDeviceRequestedEventArgs>;
    addEventListener(
        type: "releasedevicerequested",
        listener: undefined.TypedEventHandler<undefined.ClaimedPosPrinter, undefined.PosPrinterReleaseDeviceRequestedEventArgs>): void;
    removeEventListener(
        type: "releasedevicerequested",
        listener: undefined.TypedEventHandler<undefined.ClaimedPosPrinter, undefined.PosPrinterReleaseDeviceRequestedEventArgs>): void;

    /**
     * Gets an object that represents the receipt station for a claimed point-of-service printer. 
     */
    receipt: undefined.ClaimedReceiptPrinter;

    /**
     * Resets the specified statistics to zero for all statistics for the point-of-service printer that can be reset.
     * @param statisticsCategories A list of the names of the statistics that you want to reset.
     * @return  An operation that returns true if the reset succeeds, or otherwise returns false.
     */
    resetStatisticsAsync(
        statisticsCategories: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Retains the claim on the point-of-service printer asynchronously, usually in response to the ReleaseDeviceRequested event.
     * @return  True if the printer was successfully retained; otherwise, false.
     */
    retainDeviceAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets an object that represents the slip station for a claimed point-of-service printer. 
     */
    slip: undefined.ClaimedSlipPrinter;

    /**
     * Updates the specified statistics for the point-of-service printer.
     * @param statistics The statistics to update.
     * @return  An operation that returns true if the update succeeds, or otherwise returns false.
     */
    updateStatisticsAsync(
        statistics: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncOperation<boolean>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a receipt printer station that has been claimed for use. 
 */
declare class ClaimedReceiptPrinter {

    /**
     * Gets or sets the number of characters the receipt printer station can print per line of text. 
     */
    charactersPerLine: number;

    /**
     * Gets or sets the color cartridge that the receipt printer station should use when it prints. 
     */
    colorCartridge: undefined.PosPrinterColorCartridge;

    /**
     * Creates a new print job for the receipt printer station.
     * @return  The new print job for the receipt printer station.
     */
    createJob(): undefined.ReceiptPrintJob;

    /**
     * Gets whether the cartridge of the receipt printer station is currently out of ink or toner. 
     */
    isCartridgeEmpty: boolean;

    /**
     * Gets whether the cartridge of the receipt printer station is currently removed. 
     */
    isCartridgeRemoved: boolean;

    /**
     * Gets whether the cover of the receipt printer station is currently open. 
     */
    isCoverOpen: boolean;

    /**
     * Gets whether the receipt printer station is currently cleaning its print head. 
     */
    isHeadCleaning: boolean;

    /**
     * Gets or sets whether the receipt printer station prints with high quality or high speed. 
     */
    isLetterQuality: boolean;

    /**
     * Gets whether the receipt printer station needs paper. 
     */
    isPaperEmpty: boolean;

    /**
     * Gets whether the receipt printer station is almost out of paper. 
     */
    isPaperNearEnd: boolean;

    /**
     * Gets whether the receipt printer station is on and accepting print jobs. 
     */
    isReadyToPrint: boolean;

    /**
     * Gets or sets the current height of the printed line for the receipt printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. 
     */
    lineHeight: number;

    /**
     * Gets or sets the spacing of each single-high print line for the receipt printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. This spacing includes both the height of printed line and of the white space between each pair of lines. 
     */
    lineSpacing: number;

    /**
     * Gets the current width of the printed line for the receipt printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. 
     */
    lineWidth: number;

    /**
     * Gets the number of lines that must be advanced before cutting the receipt paper. 
     */
    linesToPaperCut: number;

    /**
     * Gets the size of paper that the claimed receipt printer station currently uses. 
     */
    pageSize: undefined.Size;

    /**
     * Gets the print area for the receipt printer station, expressed in the unit of measurement that the ClaimedPosPrinter.MapMode property specifies. 
     */
    printArea: undefined.Rect;

    /**
     * Gets the maximum number of characters that the receipt printer station can print on each line in sideways mode. 
     */
    sidewaysMaxChars: number;

    /**
     * Gets the maximum number of lines that the receipt printer station can print in sideways mode. 
     */
    sidewaysMaxLines: number;

    /**
     * Determines whether a data sequence, possibly including one or more escape sequences, is valid for the receipt printer station, before you use that data sequence when you call the ReceiptPrintJob.Print and ReceiptPrintJob.ExecuteAsync methods.
     * @param data The data sequence that you want to validate before you use it with the ReceiptPrintJob.Print method. This sequence may include printable data and escape sequences.
     * @return  True if the data passes validation; otherwise false.
     */
    validateData(data: string): boolean
}


/**
 * Represents a slip printer station that has been claimed for use. 
 */
declare class ClaimedSlipPrinter {

    /**
     * Changes the side of the sheet on which the claimed slip printer station is currently printing.
     * @param printSide The side of the sheet on which the claimed slip printer station is currently printing.
     */
    changePrintSide(printSide: undefined.PosPrinterPrintSide): void;

    /**
     * Gets or sets the number of characters the slip printer station can print per line of text. 
     */
    charactersPerLine: number;

    /**
     * Closes the mechanism that holds the slip in place while the slip printer station is printing, typically after the user inserts or removes the slip. 
     */
    closeJaws(): void;

    /**
     * Gets or sets the color cartridge that the slip printer station should use when it prints. 
     */
    colorCartridge: undefined.PosPrinterColorCartridge;

    /**
     * Creates a new print job for the slip printer stiation.
     * @return  The new print job for the slip printer station.
     */
    createJob(): undefined.SlipPrintJob;

    /**
     * Waits for the user to insert a slip into the slip printer station.
     * @param timeout The interval of time that the operation should wait for the user to insert the slip before exiting.
     * @return  An asynchronous operation that returns true if the user inserts the slip within the specified time span, and returns false otherwise.
     */
    insertSlipAsync(timeout: number): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets whether the cartridge of the slip printer station is currently out of ink or toner. 
     */
    isCartridgeEmpty: boolean;

    /**
     * Gets whether the cartridge of the slip printer station is currently removed. 
     */
    isCartridgeRemoved: boolean;

    /**
     * Gets whether the cover of the slip printer station is currently open. 
     */
    isCoverOpen: boolean;

    /**
     * Gets whether the slip printer station is currently cleaning its print head. 
     */
    isHeadCleaning: boolean;

    /**
     * Gets or sets whether the slip printer station prints with high quality or high speed. 
     */
    isLetterQuality: boolean;

    /**
     * Gets whether the slip printer station needs paper. 
     */
    isPaperEmpty: boolean;

    /**
     * Gets whether the slip printer station is almost out of paper. 
     */
    isPaperNearEnd: boolean;

    /**
     * Gets whether the slip printer station is on and accepting print jobs. 
     */
    isReadyToPrint: boolean;

    /**
     * Gets or sets the current height of the printed line for the slip printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. 
     */
    lineHeight: number;

    /**
     * Gets or sets the spacing of each single-high print line for the slip printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. This spacing includes both the height of printed line and of the white space between each pair of lines. 
     */
    lineSpacing: number;

    /**
     * Gets the current width of the printed line for the slip printer station, in the units that the ClaimedPosPrinter.MapMode property specifies. 
     */
    lineWidth: number;

    /**
     * Gets the number of lines that the slip printer station can print after the ClaimedSlipPrinter.IsPaperNearEnd property is set to true but before the printer reaches the end of the slip. 
     */
    linesNearEndToEnd: number;

    /**
     * Gets the maximum number of lines that the slip printer station can print on a form. 
     */
    maxLines: number;

    /**
     * Opens the mechanism that holds the slip in place while the slip printer station is printing, typically before the user inserts or removes the slip. 
     */
    openJaws(): void;

    /**
     * Gets the size of paper that the claimed slip printer station currently uses, in the units that the ClaimedPosPrinter.MapMode property specifies. 
     */
    pageSize: undefined.Size;

    /**
     * Gets the print area for the slip printer station, expressed in the unit of measurement that the ClaimedPosPrinter.MapMode property specifies. 
     */
    printArea: undefined.Rect;

    /**
     * Gets the side of the sheet on which the claimed slip printer station is currently printing. 
     */
    printSide: undefined.PosPrinterPrintSide;

    /**
     * Waits for the user to remove a slip from the slip printer station.
     * @param timeout The interval of time that the operation should wait for the user to remove the slip before exiting.
     * @return  An asynchronous operation that returns true if the user removes the slip within the specified time span, and returns false otherwise.
     */
    removeSlipAsync(timeout: number): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets the maximum number of characters that the slip printer station can print on each line in sideways mode. 
     */
    sidewaysMaxChars: number;

    /**
     * Gets the maximum number of lines that the slip printer station can print in sideways mode. 
     */
    sidewaysMaxLines: number;

    /**
     * Determines whether a data sequence, possibly including one or more escape sequences, is valid for the slip printer station, before you use that data sequence when you call the SlipPrintJob.Print and SlipPrintJob.ExecuteAsync methods.
     * @param data The data sequence that you want to validate before you use it with the SlipPrintJob.Print method. This sequence may include printable data and escape sequences.
     * @return  True if the data passes validation; otherwise false.
     */
    validateData(data: string): boolean
}


/**
 * Represents a set of printing instructions that you want to run on the journal printer station. 
 */
declare class JournalPrintJob {

    /**
     * Runs the print job on the journal printer station asynchronously.
     * @return  The operation to run the print job. This operation returns true if the print job succeeds; otherwise, the operation returns false.
     */
    executeAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Adds an instruction to the print job to print the specified text on the journal printer station.
     * @param data The text to print on the journal printer.
     */
    print(data: string): void;

    /**
     * Adds an instruction to the print job to print the specified line of text on the journal printer station.
     * @param data The line of text to print.
     */
    printLine(data: string): void;

    /**
     * Adds an instruction to the print job to print a newline character on the journal printer station. 
     */
    printLine(): void
}


/**
 * Represents the capabilities of journal station of a point-of-service printer. 
 */
declare class JournalPrinterCapabilities {

    /**
     * Gets information about the sensors that the journal printer station has available to report the status of the printer cartridge. 
     */
    cartridgeSensors: undefined.PosPrinterCartridgeSensors;

    /**
     * Gets the color cartridges that the journal printer station can use to print in color. 
     */
    colorCartridgeCapabilities: undefined.PosPrinterColorCapabilities;

    /**
     * Gets whether the journal printer station can print bold characters. 
     */
    isBoldSupported: boolean;

    /**
     * Gets whether the journal printer station can print characters that are both double-high and double-wide. 
     */
    isDoubleHighDoubleWidePrintSupported: boolean;

    /**
     * Gets whether the journal printer station can print double-high characters. 
     */
    isDoubleHighPrintSupported: boolean;

    /**
     * Gets whether the journal printer station can print double-wide characters. 
     */
    isDoubleWidePrintSupported: boolean;

    /**
     * Gets whether the journal printer station can print a dark color plus an alternate color. 
     */
    isDualColorSupported: boolean;

    /**
     * Gets whether the journal printer station can print italic characters. 
     */
    isItalicSupported: boolean;

    /**
     * Gets whether the journal printer station has an out-of-paper sensor. 
     */
    isPaperEmptySensorSupported: boolean;

    /**
     * Gets whether the journal printer station has a low-paper sensor. 
     */
    isPaperNearEndSensorSupported: boolean;

    /**
     * Gets whether a point-of-service printer with a station that functions as a journal printer station is present. 
     */
    isPrinterPresent: boolean;

    /**
     * Gets whether the journal printer station can underline characters. 
     */
    isUnderlineSupported: boolean;

    /**
     * Gets a collection of the line widths in characters per line that the journal printer station supports. 
     */
    supportedCharactersPerLine: undefined.IVectorView<number >
}


/**
 * Represents the magnetic stripe reader device. 
 */
declare class MagneticStripeReader {

    /**
     * Creates a MagneticStripeReader object from DeviceInformation.Id .
     * @param deviceId The DeviceInformation.Id that identifies a specific magnetic stripe reader, which can be retrieved from the DeviceId property.
     * @return  The magnetic stripe reader specified by the unique device identifier. Returns a null object in the following cases:
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.MagneticStripeReader>;

    /**
     * Returns the first magnetic stripe reader found.
     * @return  The first magnetic stripe reader found. Returns a null object in the following cases:
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.MagneticStripeReader>;

    /**
     * Returns an Advanced Query Syntax (AQS) string that is used to enumerate available magnetic stripe readers.
     * @return  An Advanced Query Syntax (AQS) string that is used to enumerate available magnetic stripe readers.
     */
    getDeviceSelector(): string;

    /**
     * Gets the capabilities of the magnetic stripe reader. 
     */
    capabilities: undefined.MagneticStripeReaderCapabilities;

    /**
     * Tests the health of the magnetic stripe reader.
     * @param level The specific health check level.
     * @return  A text description of the text result. Returns an error if the specified check level is not supported by the device.
     */
    checkHealthAsync(
        level: undefined.UnifiedPosHealthCheckLevel): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Attempts to get an exclusive access to the magnetic stripe reader.
     * @return  When the method completes, it returns a ClaimedMagneticStripeReader or it returns null if the operation fails to claim a magnetic stripe reader.
     */
    claimReaderAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ClaimedMagneticStripeReader>;

    /**
     * Device authentication protocol supported by the magnetic stripe reader. 
     */
    deviceAuthenticationProtocol: undefined.MagneticStripeReaderAuthenticationProtocol;

    /**
     * Gets the DeviceInformation.Id of the magnetic stripe reader. 
     */
    deviceId: string;

    /**
     * Gets the error reporting type the application wants to receive.
     * @return  The error reporting type.
     */
    getErrorReportingType(): undefined.MagneticStripeReaderErrorReportingType;

    /**
     * Occurs when the device detects an operation status change. 
     */
    onstatusupdated: undefined.TypedEventHandler<undefined.MagneticStripeReader, undefined.MagneticStripeReaderStatusUpdatedEventArgs>;
    addEventListener(
        type: "statusupdated",
        listener: undefined.TypedEventHandler<undefined.MagneticStripeReader, undefined.MagneticStripeReaderStatusUpdatedEventArgs>): void;
    removeEventListener(
        type: "statusupdated",
        listener: undefined.TypedEventHandler<undefined.MagneticStripeReader, undefined.MagneticStripeReaderStatusUpdatedEventArgs>): void;

    /**
     * Retrieves the requested statistics from the magnetic stripe reader.
     * @param statisticsCategories The list of statistics to retrieve.
     * @return  IBuffer representing the requested statistics.
     */
    retrieveStatisticsAsync(
        statisticsCategories: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Gets the card types supported by the magnetic stripe reader. 
     */
    supportedCardTypes: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides the American Association of Motor Vehicle Administrators (AAMVA) card data from the AamvaCardDataReceived event. 
 */
declare class MagneticStripeReaderAamvaCardDataReceivedEventArgs {

    /**
     * Gets the address from the swiped AAMVA card. 
     */
    address: string;

    /**
     * Gets the birth date from the swiped AAMVA card. 
     */
    birthDate: string;

    /**
     * Gets the city from the swiped AAMVA card. 
     */
    city: string;

    /**
     * Gets the class from the swiped AAMVA card. 
     */
    class: string;

    /**
     * Gets the endorsements from the swiped AAMVA card. 
     */
    endorsements: string;

    /**
     * Gets the expiration date from the swiped AAMVA card. 
     */
    expirationDate: string;

    /**
     * Gets the eye color from the swiped AAMVA card. 
     */
    eyeColor: string;

    /**
     * Gets the first name from the swiped AAMVA card. 
     */
    firstName: string;

    /**
     * Gets the gender from the swiped AAMVA card. 
     */
    gender: string;

    /**
     * Gets the hair color from the swiped AAMVA card. 
     */
    hairColor: string;

    /**
     * Gets the height from the swiped AAMVA card. 
     */
    height: string;

    /**
     * Gets the license number from the swiped AAMVA card. 
     */
    licenseNumber: string;

    /**
     * Gets the postal code from the swiped AAMVA card. 
     */
    postalCode: string;

    /**
     * Gets the additional data from the swiped AAMVA card. 
     */
    report: undefined.MagneticStripeReaderReport;

    /**
     * Gets the restrictions from the swiped AAMVA card. 
     */
    restrictions: string;

    /**
     * Gets the state from the swiped AAMVA card. 
     */
    state: string;

    /**
     * Gets the suffix from the swiped AAMVA card. 
     */
    suffix: string;

    /**
     * Gets the surname from the swiped card. 
     */
    surname: string;

    /**
     * Gets the weight from the swiped AAMVA card. 
     */
    weight: string
}


/**
 * Provides bank card data from the BankCardDataReceived event. 
 */
declare class MagneticStripeReaderBankCardDataReceivedEventArgs {

    /**
     * Gets the account number from the swiped bank card. 
     */
    accountNumber: string;

    /**
     * Gets the expiration date from the swiped card. 
     */
    expirationDate: string;

    /**
     * Gets the first name from the swiped bank card. 
     */
    firstName: string;

    /**
     * Gets the middle initial from the swiped bank card. 
     */
    middleInitial: string;

    /**
     * Gets the data from the swiped bank card. 
     */
    report: undefined.MagneticStripeReaderReport;

    /**
     * Gets the service code for the swiped bank card. 
     */
    serviceCode: string;

    /**
     * Gets the suffix from the swiped bank card. 
     */
    suffix: string;

    /**
     * Gets the surname from the swiped bank card. 
     */
    surname: string;

    /**
     * Gets the title from the swiped bank card. 
     */
    title: string
}


/**
 * Provides capabilities information for the magnetic stripe reader. 
 */
declare class MagneticStripeReaderCapabilities {

    /**
     * Gets the authentication level supported by the device. 
     */
    authenticationLevel: undefined.MagneticStripeReaderAuthenticationLevel;

    /**
     * Gets the type of card authentication data that is supported by the device. 
     */
    cardAuthentication: string;

    /**
     * Indicates whether the device supports ISO cards. 
     */
    isIsoSupported: boolean;

    /**
     * Indicates whether device supports JIS Type-I cards. 
     */
    isJisOneSupported: boolean;

    /**
     * Indicates whether the device supports JIS Type-II cards. 
     */
    isJisTwoSupported: boolean;

    /**
     * Indicates whether the device supports reporting of usage statistics. 
     */
    isStatisticsReportingSupported: boolean;

    /**
     * Indicates whether the device supports updating of usage statistics. 
     */
    isStatisticsUpdatingSupported: boolean;

    /**
     * Indicates whether the device is capable of masking track data. 
     */
    isTrackDataMaskingSupported: boolean;

    /**
     * Indicates whether the devices is able to transmit start and end sentinels. 
     */
    isTransmitSentinelsSupported: boolean;

    /**
     * Gets the power reporting capabilities of the device. 
     */
    powerReportingType: undefined.UnifiedPosPowerReportingType;

    /**
     * Gets the supported encryption algorithm. 
     */
    supportedEncryptionAlgorithms: number
}


/**
 * Contains the card type of the recently swiped card. 
 */
declare class MagneticStripeReaderCardTypes {

    /**
     * Indicates the American Association of Motor Vehicle Administrators (AAMVA) card type. 
     */
    aamva: number;

    /**
     * Indicates a bank card type. 
     */
    bank: number;

    /**
     * Indicates vendor-specific card type. 
     */
    extendedBase: number;

    /**
     * Indicates an unknown card type. 
     */
    unknown: number
}


/**
 * Contains the encryption algorithm supported by the device. 
 */
declare class MagneticStripeReaderEncryptionAlgorithms {

    /**
     * Indicates vendor specific encryption algorithm. 
     */
    extendedBase: number;

    /**
     * Indicates no encryption algorithm. 
     */
    none: number;

    /**
     * Indicates Triple DES DUKPT (Derived Unique Key Per Transaction) encryption algorithm supported by the device. 
     */
    tripleDesDukpt: number
}


/**
 * Provides error information for the ErrorOccurred event. 
 */
declare class MagneticStripeReaderErrorOccurredEventArgs {

    /**
     * Gets the error information, such as cause of error, severity, error message, and any available vendor specific error information. 
     */
    errorData: undefined.UnifiedPosErrorData;

    /**
     * Gets the track data for tracks the did not have errors. 
     */
    partialInputData: undefined.MagneticStripeReaderReport;

    /**
     * Gets the Track 1 error information. 
     */
    track1Status: undefined.MagneticStripeReaderTrackErrorType;

    /**
     * Gets the Track 2 error information. 
     */
    track2Status: undefined.MagneticStripeReaderTrackErrorType;

    /**
     * Gets the Track 3 error information. 
     */
    track3Status: undefined.MagneticStripeReaderTrackErrorType;

    /**
     * Gets the Track 4 error information. 
     */
    track4Status: undefined.MagneticStripeReaderTrackErrorType
}


/**
 * Contains data from the recently swiped card. 
 */
declare class MagneticStripeReaderReport {

    /**
     * Gets the additional security or encryption information for the recently swiped card. 
     */
    additionalSecurityInformation: undefined.IBuffer;

    /**
     * Gets the card authentication information for the recently swiped card. 
     */
    cardAuthenticationData: undefined.IBuffer;

    /**
     * Gets the length of the raw CardAuthenticationData before it is encrypted. 
     */
    cardAuthenticationDataLength: number;

    /**
     * Gets the card type identifier for the recently swiped card. 
     */
    cardType: number;

    /**
     * Gets a dictionary of properties for the recently swiped card. 
     */
    properties: undefined.IMapView<string, string>;

    /**
     * Gets the track data for Track 1. 
     */
    track1: undefined.MagneticStripeReaderTrackData;

    /**
     * Gets the track data for Track 2. 
     */
    track2: undefined.MagneticStripeReaderTrackData;

    /**
     * Gets the track data for Track 3. 
     */
    track3: undefined.MagneticStripeReaderTrackData;

    /**
     * Gets the track data for Track 4. 
     */
    track4: undefined.MagneticStripeReaderTrackData
}


/**
 * Provides information about an operation status change. 
 */
declare class MagneticStripeReaderStatusUpdatedEventArgs {

    /**
     * Gets the vendor specific error code. 
     */
    extendedStatus: number;

    /**
     * Gets the status change information. 
     */
    status: undefined.MagneticStripeReaderStatus
}


/**
 * Contains the track data obtained following a card swipe. 
 */
declare class MagneticStripeReaderTrackData {

    /**
     * Gets the raw or decoded data from the swiped card. 
     */
    data: undefined.IBuffer;

    /**
     * Gets the discretionary data from the swiped card. 
     */
    discretionaryData: undefined.IBuffer;

    /**
     * Gets the encrypted data from the swiped card. 
     */
    encryptedData: undefined.IBuffer
}


/**
 * Provides data for the recently swiped vendor card. 
 */
declare class MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs {

    /**
     * Gets data for the recently swiped vendor card. 
     */
    report: undefined.MagneticStripeReaderReport
}


/**
 * Represents a point-of-service printer. 
 */
declare class PosPrinter {

    /**
     * Creates a PosPrinter object for point-of-service printer with the specified DeviceInformation.Id .
     * @param deviceId The DeviceInformation.Id that identifies a specific point-of-service printer.
     * @return  The point-of-service printer that the unique device identifier identifies. Returns a null object in the following cases:
     */
    fromIdAsync(deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.PosPrinter>;

    /**
     * Gets the default paired or locally-connected printer.
     * @return  The default locally-connected printer.
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.PosPrinter>;

    /**
     * Gets an Advanced Query Syntax (AQS) string that you can use to list the available point-of-service printers.
     * @return  An Advanced Query Syntax (AQS) string that you can use to list the available point-of-service printers.
     */
    getDeviceSelector(): string;

    /**
     * Gets the capabilities of the point-of-service printer. 
     */
    capabilities: undefined.PosPrinterCapabilities;

    /**
     * Gets the health state of the point-of-service printer asynchronously.
     * @param level The type of health check that you want to perform for the point-of-service printer. Only level POSInternal(1) should be used, as any other UnifiedPosHealthCheckLevel levels will result in an error.
     * @return  An asynchronous operation that returns the health state of the point-of-service printer. You should display this value in the app interface immediately so the user of the app can interpret the value. For example, the operation returns “OK” as the health state if the state of the point-of-service printer is good.
     */
    checkHealthAsync(
        level: undefined.UnifiedPosHealthCheckLevel): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Claims the point-of-service printer for use, and gets an instance of the ClaimedPosPrinter class for the point-of-service printer.
     * @return  The claimed point-of-service printer.
     */
    claimPrinterAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ClaimedPosPrinter>;

    /**
     * Gets the identifier of the point-of-service printer. 
     */
    deviceId: string;

    /**
     * Gets the specified statistics from the point-of-service printer.
     * @param statisticsCategories The list of statistics to retrieve.
     * @return  The requested statistics.
     */
    getStatisticsAsync(
        statisticsCategories: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Occurs when the status of the power or availability of the point-of-service printer changes. 
     */
    onstatusupdated: undefined.TypedEventHandler<undefined.PosPrinter, undefined.PosPrinterStatusUpdatedEventArgs>;
    addEventListener(
        type: "statusupdated",
        listener: undefined.TypedEventHandler<undefined.PosPrinter, undefined.PosPrinterStatusUpdatedEventArgs>): void;
    removeEventListener(
        type: "statusupdated",
        listener: undefined.TypedEventHandler<undefined.PosPrinter, undefined.PosPrinterStatusUpdatedEventArgs>): void;

    /**
     * Gets the current status of the power and availability of the point-of-service printer. 
     */
    status: undefined.PosPrinterStatus;

    /**
     * Gets the list of character sets that the point-of-service printer supports. 
     */
    supportedCharacterSets: undefined.IVectorView<number>;

    /**
     * Gets the fonts and typefaces that the point-of-service printer supports. 
     */
    supportedTypeFaces: undefined.IVectorView<string>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the capabilities of the point-of-service printer. 
 */
declare class PosPrinterCapabilities {

    /**
     * Gets whether the point-of-service printer can map the characters that the application sends (in the character set that the ClaimedPosPrinter.CharacterSet property defines) to the character sets that the PosPrinter.SupportedCharacterSets property defines. 
     */
    canMapCharacterSet: boolean;

    /**
     * Gets the character set that the point-of-service printer uses by default. 
     */
    defaultCharacterSet: number;

    /**
     * Gets whether the point-of-service printer has a sensor that detects if the printer cover is open. 
     */
    hasCoverSensor: boolean;

    /**
     * Gets whether the point-of-service printer supports reporting statistics. 
     */
    isStatisticsReportingSupported: boolean;

    /**
     * Gets whether the point-of-service printer supports updating statistics. 
     */
    isStatisticsUpdatingSupported: boolean;

    /**
     * Gets whether the point-of-service printer supports printer transactions. 
     */
    isTransactionSupported: boolean;

    /**
     * Gets the capabilities of the journal station for the point-of-service printer. 
     */
    journal: undefined.JournalPrinterCapabilities;

    /**
     * Gets the power reporting capabilities of the point-of-service printer. 
     */
    powerReportingType: undefined.UnifiedPosPowerReportingType;

    /**
     * Gets the capabilities of the receipt station for the point-of-service printer. 
     */
    receipt: undefined.ReceiptPrinterCapabilities;

    /**
     * Gets the capabilities of the slip station for the point-of-service printer. 
     */
    slip: undefined.SlipPrinterCapabilities
}


/**
 * Represents the set of identifiers for the character sets that a point-of-service printer can use. 
 */
declare class PosPrinterCharacterSetIds {

    /**
     * Gets the identifier for the ANSI character set. 
     */
    ansi: number;

    /**
     * Gets the identifier for the ASCII character set. 
     */
    ascii: number;

    /**
     * Gets the identifier for the UTF16LE character set. 
     */
    utf16LE: number
}


/**
 * Provides information about the ClaimedPosPrinter.ReleaseDeviceRequested event that occurs when a point-of-service printer gets a request to release its exclusive claim. 
 */
declare class PosPrinterReleaseDeviceRequestedEventArgs {}


/**
 * Provides information about the status of a point-of-service printer, such as the power state of the printer. 
 */
declare class PosPrinterStatus {

    /**
     * Gets extended information about the power state of the point-of-service printer that the original equipment manufacturer (OEM) defines. Value is only valid if the PosPrinterStatus.StatusKind property is PosPrinterStatusKind.Extended. 
     */
    extendedStatus: number;

    /**
     * Gets the power state of a point-of-service printer. 
     */
    statusKind: undefined.PosPrinterStatusKind
}


/**
 * Provides information about the PosPrinter.StatusUpdated event that occurs when the status of a point-of-service printer changes. 
 */
declare class PosPrinterStatusUpdatedEventArgs {

    /**
     * Gets the new status of the point-of-service printer after the status of the printer changes. 
     */
    status: undefined.PosPrinterStatus
}


/**
 * Represents a set of printing instructions that you want to run on the receipt printer. 
 */
declare class ReceiptPrintJob {

    /**
     * Adds an instruction to the printer job to cut the receipt paper completely. 
     */
    cutPaper(): void;

    /**
     * Adds an instruction to the printer job to cut the specified percentage of the receipt paper.
     * @param percentage Decimal representation of the percentage of the receipt that the receipt printer should cut.
     */
    cutPaper(percentage: number): void;

    /**
     * Adds an instruction to the print job to print a drawn, ruled line on the paper of the receipt printer station.
     * @param positionList The position parameters for the ruled line. The character string for positionList differs depending on whether lineDirection specifies a horizontal ruled line or a vertical ruled line.
     * @param lineDirection The direction in which to print the ruled line.
     * @param lineWidth The width of the ruled line that the print should print. The unit of width is dot. If an unsupported value is specified, the best fit value for the printer is used.
     * @param lineStyle The appearance of the ruled line, such as whether it is solid or broken, or single or double.
     * @param lineColor The color of the ruled line, as an integer value that is equal to the value of the cartridge constant used in the ClaimedReceiptPrinter.ColorCartridge property. If an unsupported value is specified, the printing results may be unpredictable.
     */
    drawRuledLine(
        positionList: string,
        lineDirection: undefined.PosPrinterLineDirection,
        lineWidth: number,
        lineStyle: undefined.PosPrinterLineStyle,
        lineColor: number): void;

    /**
     * Runs the print job on the receipt printer station asynchronously.
     * @return  The operation to run the print job. This operation returns true if the print job succeeds; otherwise, the operation returns false.
     */
    executeAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Adds an instruction to the printer job to use the mark sensor of the receipt printer station to position the receipt paper.
     * @param kind An enumeration value that specifies how to position the receipt paper.
     */
    markFeed(kind: undefined.PosPrinterMarkFeedKind): void;

    /**
     * Adds an instruction to the print job to print the specified text on the receipt printer station.
     * @param data The text to print on the receipt printer station.
     */
    print(data: string): void;

    /**
     * Adds an instruction to the print job to print a barcode with the specified data and symbology on the receipt printer station.
     * @param data The data to be represented as a barcode.
     * @param symbology The symbology (encoding) of the barcode. This can be determined based on the BarcodeSymbologies class static methods.
     * @param height The height of the barcode, in pixels.
     * @param width The width of the barcode, in pixels.
     * @param textPosition The vertical position of the barcode text relative to the barcode.
     * @param alignment The horizontal alignment of the barcode on the page.
     */
    printBarcode(
        data: string,
        symbology: number,
        height: number,
        width: number,
        textPosition: undefined.PosPrinterBarcodeTextPosition,
        alignment: undefined.PosPrinterAlignment): void;

    /**
     * Adds an instruction to the print job to print a barcode with the specified data, symbology, and custom alignment on the receipt printer station.
     * @param data The data to be represented as a barcode.
     * @param symbology The symbology (encoding) of the barcode.
     * @param height The height of the barcode, in pixels.
     * @param width The width of the barcode, in pixels.
     * @param textPosition The vertical position of the barcode text relative to the barcode.
     * @param alignmentDistance The distance from the leftmost print column to the start of the barcode, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    printBarcodeCustomAlign(
        data: string,
        symbology: number,
        height: number,
        width: number,
        textPosition: undefined.PosPrinterBarcodeTextPosition,
        alignmentDistance: number): void;

    /**
     * Adds an instruction to the print job to print the specified bitmap with the specified width and a standard horizontal placement on the receipt printer station.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
     * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    printBitmap(
        bitmap: undefined.BitmapFrame,
        alignment: undefined.PosPrinterAlignment,
        width: number): void;

    /**
     * Adds an instruction to the print job to print the specified bitmap with the specified standard horizontal placement on the receipt printer station.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
     */
    printBitmap(bitmap: undefined.BitmapFrame, alignment: undefined.PosPrinterAlignment): void;

    /**
     * Adds an instruction to the print job to print the specified bitmap at the specified distance from the leftmost print column on the receipt printer station.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    printCustomAlignedBitmap(bitmap: undefined.BitmapFrame, alignmentDistance: number): void;

    /**
     * Adds an instruction to the print job to print the specified bitmap with the specified width and at the specified distance from the leftmost print column on the receipt printer station.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPriinter.MapMode property.
     */
    printCustomAlignedBitmap(bitmap: undefined.BitmapFrame, alignmentDistance: number, width: number): void;

    /**
     * Adds an instruction to the print job to print a line of text on the receipt printer station.
     * @param data The line of text to print.
     */
    printLine(data: string): void;

    /**
     * Adds an instruction to the print job to print a newline character on the receipt printer station. 
     */
    printLine(): void;

    /**
     * Adds an instruction to the print job to print a bitmap on the receipt printer station by using the bitmap and information saved to the printer via SetBitmap or SetCustomAlignedBitmap .
     * @param bitmapNumber The number that you assigned to the bitmap that you want to print when you called SetBitmap or SetCustomAlignedBitmap .
     */
    printSavedBitmap(bitmapNumber: number): void;

    /**
     * Sets the rotation of the barcode on the page on the receipt printer station.
     * @param value The rotation of the barcode on the page.
     */
    setBarcodeRotation(value: undefined.PosPrinterRotation): void;

    /**
     * Saves information about a bitmap and a standard horizontal placement that you want to use to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
     * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
     */
    setBitmap(
        bitmapNumber: number,
        bitmap: undefined.BitmapFrame,
        alignment: undefined.PosPrinterAlignment): void;

    /**
     * Saves information about a bitmap, along with the width and a standard horizontal placement that you want to use to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
     * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
     * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    setBitmap(
        bitmapNumber: number,
        bitmap: undefined.BitmapFrame,
        alignment: undefined.PosPrinterAlignment,
        width: number): void;

    /**
     * Saves information about a bitmap and the distance from the leftmost print column at which you want to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
     * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    setCustomAlignedBitmap(
        bitmapNumber: number,
        bitmap: undefined.BitmapFrame,
        alignmentDistance: number): void;

    /**
     * Saves information about a bitmap, along with the width and the distance from the leftmost print column that you want to use to print that bitmap on the receipt printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
     * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    setCustomAlignedBitmap(
        bitmapNumber: number,
        bitmap: undefined.BitmapFrame,
        alignmentDistance: number,
        width: number): void;

    /**
     * Sets the area of the page on which the receipt printer station can print the job.
     * @param value The area of the page on which the receipt printer can print the job.
     */
    setPrintArea(value: undefined.Rect): void;

    /**
     * Sets the rotation of the text or image on the page for the receipt printer station.
     * @param value The rotation of the text or image on the page for the receipt printer station.
     * @param includeBitmaps Whether bitmaps should also be rotated. This setting takes effect only for subsequent calls to PrintBitmap , and may not apply to saved bitmaps that you print using PrintSavedBitmap .
     */
    setPrintRotation(value: undefined.PosPrinterRotation, includeBitmaps: boolean): void
}


/**
 * Represents the capabilities of receipt station of a point-of-service printer. 
 */
declare class ReceiptPrinterCapabilities {

    /**
     * Gets whether the receipt printer station can perform paper cuts. 
     */
    canCutPaper: boolean;

    /**
     * Gets information about the sensors that the receipt printer station has available to report the status of the printer station. 
     */
    cartridgeSensors: undefined.PosPrinterCartridgeSensors;

    /**
     * Gets the color cartridges that the receipt printer station can use to print in color. 
     */
    colorCartridgeCapabilities: undefined.PosPrinterColorCapabilities;

    /**
     * Gets whether the receipt printer station can print in a rotated upside-down mode. 
     */
    is180RotationSupported: boolean;

    /**
     * Gets whether the receipt printer station can print barcodes. 
     */
    isBarcodeSupported: boolean;

    /**
     * Gets whether the receipt printer station can print bitmaps. 
     */
    isBitmapSupported: boolean;

    /**
     * Gets whether the receipt printer station can print bold characters. 
     */
    isBoldSupported: boolean;

    /**
     * Gets whether the receipt printer station can print characters that are both double-high and double-wide. 
     */
    isDoubleHighDoubleWidePrintSupported: boolean;

    /**
     * Gets whether the receipt printer station can print double-high characters. 
     */
    isDoubleHighPrintSupported: boolean;

    /**
     * Gets whether the receipt printer station can print double-wide characters. 
     */
    isDoubleWidePrintSupported: boolean;

    /**
     * Gets whether the receipt printer station can print a dark color plus an alternate color. 
     */
    isDualColorSupported: boolean;

    /**
     * Gets whether the receipt printer station can print italic characters. 
     */
    isItalicSupported: boolean;

    /**
     * Gets whether the receipt printer station can print information rotated 90 degrees to the left. 
     */
    isLeft90RotationSupported: boolean;

    /**
     * Gets whether the receipt printer station has an out-of-paper sensor. 
     */
    isPaperEmptySensorSupported: boolean;

    /**
     * Gets whether the receipt printer station has a low-paper sensor. 
     */
    isPaperNearEndSensorSupported: boolean;

    /**
     * Gets whether the receipt printer station supports setting a custom size for the area of the page on which the printer should print. 
     */
    isPrintAreaSupported: boolean;

    /**
     * Gets whether a point-of-service printer with a station that prints receipts is present. 
     */
    isPrinterPresent: boolean;

    /**
     * Gets whether the receipt printer station can print information rotated 90 degrees to the right. 
     */
    isRight90RotationSupported: boolean;

    /**
     * Gets whether the receipt printer station has a stamp capability. 
     */
    isStampSupported: boolean;

    /**
     * Gets whether the receipt printer station can underline characters. 
     */
    isUnderlineSupported: boolean;

    /**
     * Gets the type of mark-sensed paper handling that is available for the receipt printer station. 
     */
    markFeedCapabilities: undefined.PosPrinterMarkFeedCapabilities;

    /**
     * Gets information about the capabilities of the receipt printer station to draw ruled lines. 
     */
    ruledLineCapabilities: undefined.PosPrinterRuledLineCapabilities;

    /**
     * Gets a list of the directions in which the receipt printer station can rotate a barcode when printing. 
     */
    supportedBarcodeRotations: undefined.IVectorView<undefined.PosPrinterRotation>;

    /**
     * Gets a list of the directions in which the receipt printer station can rotate a bitmap when printing. 
     */
    supportedBitmapRotations: undefined.IVectorView<undefined.PosPrinterRotation>;

    /**
     * Gets a collection of the line widths in characters per line that the receipt printer station supports. 
     */
    supportedCharactersPerLine: undefined.IVectorView<number >
}


/**
 * Represents a set of printing instructions that you want to run on the slip printer station. 
 */
declare class SlipPrintJob {

    /**
     * Adds an instruction to the print job to print a drawn, ruled line on the paper of the slip printer station.
     * @param positionList The position parameters for the ruled line. The character string for positionList differs depending on whether lineDirection specifies a horizontal ruled line or a vertical ruled line.
     * @param lineDirection The direction in which to print the ruled line.
     * @param lineWidth The width of the ruled line that the print should print. The unit of width is dot. If an unsupported value is specified, the best fit value for the printer is used.
     * @param lineStyle The appearance of the ruled line, such as whether it is solid or broken, or single or double.
     * @param lineColor The color of the ruled line, as an integer value that is equal to the value of the cartridge constant used in the ClaimedSlipPrinter.ColorCartridge property. If an unsupported value is specified, the printing results may be unpredictable.
     */
    drawRuledLine(
        positionList: string,
        lineDirection: undefined.PosPrinterLineDirection,
        lineWidth: number,
        lineStyle: undefined.PosPrinterLineStyle,
        lineColor: number): void;

    /**
     * Runs the print job on the slip printer station asynchronously.
     * @return  The operation to run the print job. This operation returns true if the print job succeeds; otherwise, the operation returns false.
     */
    executeAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Adds an instruction to the print job to print the specified text on the slip printer station.
     * @param data The text to print on the slip printer station.
     */
    print(data: string): void;

    /**
     * Adds an instruction to the print job to print a barcode on the slip printer station with the specified data and symbology.
     * @param data The data to represent as a barcode.
     * @param symbology The symbology (encoding) of the barcode.
     * @param height The height of the barcode, in pixels.
     * @param width The width of the barcode, in pixels.
     * @param textPosition The vertical position of the barcode text relative to the barcode.
     * @param alignment The horizontal alignment of the barcode on the page.
     */
    printBarcode(
        data: string,
        symbology: number,
        height: number,
        width: number,
        textPosition: undefined.PosPrinterBarcodeTextPosition,
        alignment: undefined.PosPrinterAlignment): void;

    /**
     * Adds an instruction to the print job to print a barcode on the slip printer station with the specified data, symbology, and custom alignment.
     * @param data The data to represent as a barcode.
     * @param symbology The symbology (encoding) of the barcode.
     * @param height The height of the barcode, in pixels.
     * @param width The width of the barcode, in pixels.
     * @param textPosition The vertical position of the barcode text relative to the barcode.
     * @param alignmentDistance The distance from the leftmost print column to the start of the barcode, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    printBarcodeCustomAlign(
        data: string,
        symbology: number,
        height: number,
        width: number,
        textPosition: undefined.PosPrinterBarcodeTextPosition,
        alignmentDistance: number): void;

    /**
     * Adds an instruction to the print job to print the specified bitmap with the specified width and a standard horizontal placement on the slip printer station.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
     * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    printBitmap(
        bitmap: undefined.BitmapFrame,
        alignment: undefined.PosPrinterAlignment,
        width: number): void;

    /**
     * Adds an instruction to the print job to print the specified bitmap with the specified standard horizontal placement on the slip printer station.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
     */
    printBitmap(bitmap: undefined.BitmapFrame, alignment: undefined.PosPrinterAlignment): void;

    /**
     * Adds an instruction to the print job to print the specified bitmap at the specified distance from the leftmost print column on the slip printer station.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    printCustomAlignedBitmap(bitmap: undefined.BitmapFrame, alignmentDistance: number): void;

    /**
     * Adds an instruction to the print job to print the specified bitmap with the specified width and at the specified distance from the leftmost print column on the slip printer station.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    printCustomAlignedBitmap(bitmap: undefined.BitmapFrame, alignmentDistance: number, width: number): void;

    /**
     * Adds an instruction to the print job to print a line of text on the slip printer station.
     * @param data The line of text to print.
     */
    printLine(data: string): void;

    /**
     * Adds an instruction to the print job to print a newline character on the slip printer station. 
     */
    printLine(): void;

    /**
     * Adds an instruction to the print job to print a bitmap on the slip printer station by using the information that you saved about the bitmap and how to print it when you called the SetBitmap or SetCustomAlignedBitmap method.
     * @param bitmapNumber The number that you assigned to the bitmap that you want to print when you called SetBitmap or SetCustomAlignedBitmap .
     */
    printSavedBitmap(bitmapNumber: number): void;

    /**
     * Sets the rotation of the barcode on the page on the slip printer station.
     * @param value The rotation of the barcode on the page on the slip printer station.
     */
    setBarcodeRotation(value: undefined.PosPrinterRotation): void;

    /**
     * Saves information about a bitmap and a standard horizontal placement that you want to use to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
     * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
     */
    setBitmap(
        bitmapNumber: number,
        bitmap: undefined.BitmapFrame,
        alignment: undefined.PosPrinterAlignment): void;

    /**
     * Saves information about a bitmap, along with the width and a standard horizontal placement that you want to use to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
     * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignment An enumeration value that specifies a standard horizontal placement on the page for the bitmap, such as left-aligned, centered, or right-aligned.
     * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    setBitmap(
        bitmapNumber: number,
        bitmap: undefined.BitmapFrame,
        alignment: undefined.PosPrinterAlignment,
        width: number): void;

    /**
     * Saves information about a bitmap and the distance from the leftmost print column at which you want to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
     * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    setCustomAlignedBitmap(
        bitmapNumber: number,
        bitmap: undefined.BitmapFrame,
        alignmentDistance: number): void;

    /**
     * Saves information about a bitmap, along with the width and the distance from the leftmost print column that you want to use to print that bitmap on the slip printer station, so that you can use the PrintSavedBitmap method to add that information to the print job later.
     * @param bitmapNumber The number that you want to assign to this bitmap. You can set two bitmaps, numbered 1 and 2. Use this number with the PrintSavedBitmap method later to add the print instructions to the print job.
     * @param bitmap Information about the bitmap that you want to print.
     * @param alignmentDistance The distance from the leftmost print column to the start of the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     * @param width The width to use for printing the bitmap, expressed in the unit of measurement indicated by the ClaimedPosPrinter.MapMode property.
     */
    setCustomAlignedBitmap(
        bitmapNumber: number,
        bitmap: undefined.BitmapFrame,
        alignmentDistance: number,
        width: number): void;

    /**
     * Sets the area of the page on which the slip printer station can print the job.
     * @param value The area of the page on which the slip printer station can print the job.
     */
    setPrintArea(value: undefined.Rect): void;

    /**
     * Sets the rotation of the text or image on the page on the slip printer station.
     * @param value The rotation of the text or image on the page.
     * @param includeBitmaps Whether bitmaps should also be rotated. This setting takes effect only for subsequent calls to PrintBitmap , and may not apply to saved bitmaps that you print using PrintSavedBitmap .
     */
    setPrintRotation(value: undefined.PosPrinterRotation, includeBitmaps: boolean): void
}


/**
 * Represents the capabilities of slip station of a point-of-service printer. 
 */
declare class SlipPrinterCapabilities {

    /**
     * Gets information about the sensors that the slip printer station has available to report the status of the printer station. 
     */
    cartridgeSensors: undefined.PosPrinterCartridgeSensors;

    /**
     * Gets the color cartridges that the slip printer station can use to print in color. 
     */
    colorCartridgeCapabilities: undefined.PosPrinterColorCapabilities;

    /**
     * Gets whether the slip printer station can print in a rotated upside-down mode. 
     */
    is180RotationSupported: boolean;

    /**
     * Gets whether the slip printer station can print barcodes. 
     */
    isBarcodeSupported: boolean;

    /**
     * Gets whether the slip printer station can print bitmaps. 
     */
    isBitmapSupported: boolean;

    /**
     * Gets whether the slip printer station can print bold characters. 
     */
    isBoldSupported: boolean;

    /**
     * Gets whether the slip printer station supports printing on both sides of the document. 
     */
    isBothSidesPrintingSupported: boolean;

    /**
     * Gets whether the slip printer station can print characters that are both double-high and double-wide. 
     */
    isDoubleHighDoubleWidePrintSupported: boolean;

    /**
     * Gets whether the slip printer station can print double-high characters. 
     */
    isDoubleHighPrintSupported: boolean;

    /**
     * Gets whether the slip printer station can print double-wide characters. 
     */
    isDoubleWidePrintSupported: boolean;

    /**
     * Gets whether the slip printer station can print a dark color plus an alternate color. 
     */
    isDualColorSupported: boolean;

    /**
     * Gets whether the slip printer station can print full-length forms. 
     */
    isFullLengthSupported: boolean;

    /**
     * Gets whether the slip printer station can print italic characters. 
     */
    isItalicSupported: boolean;

    /**
     * Gets whether the slip printer station can print information rotated 90 degrees to the left. 
     */
    isLeft90RotationSupported: boolean;

    /**
     * Gets whether the slip printer station has an out-of-paper sensor. 
     */
    isPaperEmptySensorSupported: boolean;

    /**
     * Gets whether the slip printer station has a low-paper sensor. 
     */
    isPaperNearEndSensorSupported: boolean;

    /**
     * Gets whether the slip printer station supports setting a custom size for the area of the page on which the printer station should print. 
     */
    isPrintAreaSupported: boolean;

    /**
     * Gets whether a point-of-service printer with a station that prints forms such as checks or credit card slips is present. 
     */
    isPrinterPresent: boolean;

    /**
     * Gets whether the slip printer station can print information rotated 90 degrees to the right. 
     */
    isRight90RotationSupported: boolean;

    /**
     * Gets whether the slip printer station can underline characters. 
     */
    isUnderlineSupported: boolean;

    /**
     * Gets information about the capabilities of the slip printer station to draw ruled lines. 
     */
    ruledLineCapabilities: undefined.PosPrinterRuledLineCapabilities;

    /**
     * Gets a list of the directions in which the slip printer station can rotate a barcode when printing. 
     */
    supportedBarcodeRotations: undefined.IVectorView<undefined.PosPrinterRotation>;

    /**
     * Gets a list of the directions in which the slip printer station can rotate a bitmap when printing. 
     */
    supportedBitmapRotations: undefined.IVectorView<undefined.PosPrinterRotation>;

    /**
     * Gets a collection of the line widths in characters per line that the slip printer station supports. 
     */
    supportedCharactersPerLine: undefined.IVectorView<number >
}


/**
 * Provides error information. 
 */
declare class UnifiedPosErrorData {

    /**
     * Gets the vendor specific error information. 
     */
    extendedReason: number;

    /**
     * Gets the error message. 
     */
    message: string;

    /**
     * Gets the cause of the error. 
     */
    reason: undefined.UnifiedPosErrorReason;

    /**
     * Gets the error severity. 
     */
    severity: undefined.UnifiedPosErrorSeverity
}


/**
 * Provides methods for identifying a device service for a portable device that supports WPD (Windows Portable Devices) for device enumeration. 
 */
declare class ServiceDevice {

    /**
     * Returns an Advanced Query Syntax (AQS) string that is used to enumerate device services of the specified ServiceDeviceType . This string is passed to the FindAllAsync or CreateWatcher method.
     * @param serviceType The type of service to identify.
     * @return  The AQS string.
     */
    getDeviceSelector(serviceType: undefined.ServiceDeviceType): string;

    /**
     * An Advanced Query Syntax (AQS) string for identifying a device service by its GUIDs. This string is passed to the FindAllAsync or CreateWatcher method.
     * @param serviceId The service identifier.
     * @return  The AQS string.
     */
    getDeviceSelectorFromServiceId(serviceId: string): string
}


/**
 * Provides methods for accessing the storage functionality of a portable device that supports WPD. 
 */
declare class StorageDevice {

    /**
     * Gets a StorageFolder object from a DeviceInformation Id for a removable storage device.
     * @param DeviceId The DeviceInformation ID that identifies the removable storage device. This id can be retrieved from Windows.Devices.Enumeration or the DeviceInformationId property of the AutoPlay device event arguments. For more information, see Quickstart: Register an app for an AutoPlay device. In order for FromId to succeed, the app must declare both the removableStorage capability as shown in the App capability declarations and file type associations for the files it wishes to access on the device as shown in How to handle file activation. For more information, see the Removable Storage sample.
     * @return  The storage folder object that represents the removable storage device and provides access to content on the device.
     */
    fromId(DeviceId: string): undefined.StorageFolder;

    /**
     * An Advanced Query Syntax (AQS) string for identifying removable storage devices. This string is passed to the FindAllAsync or CreateWatcher method.
     * @return  An AQS string for identifying storage devices.
     */
    getDeviceSelector(): string
}


/**
 * Provides information about a battery controller that is currently connected to the device. For more info, see Get battery information. 
 */
declare class Battery {

    /**
     * Gets a Battery object that represents all battery controllers connected to the device. 
     */
    aggregateBattery: undefined.Battery;

    /**
     * Gets a Battery object that represents an individual battery controller connected to the device.
     * @param deviceId The device ID of the battery controller ( DeviceId ).
     * @return  A Battery object that corresponds to the specified battery controller.
     */
    fromIdAsync(deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.Battery>;

    /**
     * Gets an Advanced Query Syntax (AQS) string that can be used to find all battery controllers that are connected to the device.
     * @return  An AQS string that can be used to find all battery controllers connected to the device.
     */
    getDeviceSelector(): string;

    /**
     * Gets the identifier (ID) for an individual battery controller. 
     */
    deviceId: string;

    /**
     * Gets a BatteryReport object that indicates the charge, capacity, and status of the battery or aggregate.
     * @return  Indicates the charge, capacity, and status of the battery or aggregate.
     */
    getReport(): undefined.BatteryReport;

    /**
     * Occurs when the charge, capacity, or status of a battery changes. 
     */
    onreportupdated: undefined.TypedEventHandler<undefined.Battery, any>;
    addEventListener(
        type: "reportupdated",
        listener: undefined.TypedEventHandler<undefined.Battery, any>): void;
    removeEventListener(
        type: "reportupdated",
        listener: undefined.TypedEventHandler<undefined.Battery, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides properties that indicate the charge, capacity, and status of the battery. For more info, see Get battery information. 
 */
declare class BatteryReport {

    /**
     * Gets the rate that the battery is charging. 
     */
    chargeRateInMilliwatts: number;

    /**
     * Gets the estimated energy capacity of a new battery of this type. 
     */
    designCapacityInMilliwattHours: number;

    /**
     * Gets the fully-charged energy capacity of the battery. 
     */
    fullChargeCapacityInMilliwattHours: number;

    /**
     * Gets the remaining power capacity of the battery. 
     */
    remainingCapacityInMilliwattHours: number;

    /**
     * Gets a BatteryStatus enumeration that indicates the status of the battery. 
     */
    status: undefined.BatteryStatus
}


/**
 * Represents a customized printing experience for a 3D printer. 
 */
declare class Print3DWorkflow {

    /**
     * Gets the device identifier of the 3D printer. 
     */
    deviceID: string;

    /**
     * Gets the model of the 3D object to be printed.
     * @return  The model of the 3D object to be printed.
     */
    getPrintModelPackage(): any;

    /**
     * Gets or sets a value that indicates the 3D object is ready for printing and no further user interaction is required. 
     */
    isPrintReady: boolean;

    /**
     * Occurs when the user initiates printing. 
     */
    onprintrequested: undefined.TypedEventHandler<undefined.Print3DWorkflow, undefined.Print3DWorkflowPrintRequestedEventArgs>;
    addEventListener(
        type: "printrequested",
        listener: undefined.TypedEventHandler<undefined.Print3DWorkflow, undefined.Print3DWorkflowPrintRequestedEventArgs>): void;
    removeEventListener(
        type: "printrequested",
        listener: undefined.TypedEventHandler<undefined.Print3DWorkflow, undefined.Print3DWorkflowPrintRequestedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data about the print request to the app that initiated the request. 
 */
declare class Print3DWorkflowPrintRequestedEventArgs {

    /**
     * Sets the extended status of the print request.
     * @param value The extended status of the print request.
     */
    setExtendedStatus(value: undefined.Print3DWorkflowDetail): void;

    /**
     * Sets the latest model data, including any updates made by the Print3DWorkflow .
     * @param source The latest model data, including any updates made by the Print3DWorkflow .
     */
    setSource(source: any): void;

    /**
     * Indicates if the data model has been updated by the Print3DWorkflow .
     * @param value Returns true if the data model has been updated; otherwise, false.
     */
    setSourceChanged(value: boolean): void;

    /**
     * Gets the status of the print request. 
     */
    status: undefined.Print3DWorkflowStatus
}


/**
 * Provides the context for the printer extension object. 
 */
declare class PrintExtensionContext {

    /**
     * Gets the context for the printer extension object based on the DeviceInformation ID.
     * @param deviceId The device information ID for the print device.
     * @return  Pointer to the context.
     */
    fromDeviceId(deviceId: string): any
}


/**
 * Contains properties that allow a client to access and/or manipulate print event data and print device name information. 
 */
declare class PrintNotificationEventDetails {

    /**
     * Gets or sets the event data for a print notification event. 
     */
    eventData: string;

    /**
     * Gets the name of the print device associated with the print notification. 
     */
    printerName: string
}


/**
 * Allows a client to retrieve the print task extension context, and also to add an event handler to the print task. 
 */
declare class PrintTaskConfiguration {

    /**
     * Raised by the print window for your app to notify the device app that the print ticket must be updated. 
     */
    onsaverequested: undefined.TypedEventHandler<undefined.PrintTaskConfiguration, undefined.PrintTaskConfigurationSaveRequestedEventArgs>;
    addEventListener(
        type: "saverequested",
        listener: undefined.TypedEventHandler<undefined.PrintTaskConfiguration, undefined.PrintTaskConfigurationSaveRequestedEventArgs>): void;
    removeEventListener(
        type: "saverequested",
        listener: undefined.TypedEventHandler<undefined.PrintTaskConfiguration, undefined.PrintTaskConfigurationSaveRequestedEventArgs>): void;

    /**
     * Gets the context for the print task extension. 
     */
    printerExtensionContext: any;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Called when the print dialog for your app raises a SaveRequested event. 
 */
declare class PrintTaskConfigurationSaveRequest {

    /**
     * Called by the device app to cancel the client's request to save the print task configuration. 
     */
    cancel(): void;

    /**
     * Gets the date-time object that provides the deadline information for the print task. 
     */
    deadline: Date;

    /**
     * Called by the device app when it has to complete some asynchronous tasks before it can save the print task configuration information.
     * @return  The object that represents the deferral for the print task configuration save request.
     */
    getDeferral(): undefined.PrintTaskConfigurationSaveRequestedDeferral;

    /**
     * Called by the device app to save the print task configuration.
     * @param printerExtensionContext The object that represents the print task extension context.
     */
    save(printerExtensionContext: any): void
}


/**
 * Called by the device app to provide an update of the status of the deferral. 
 */
declare class PrintTaskConfigurationSaveRequestedDeferral {

    /**
     * Called by the device app when the deferral is completed. 
     */
    complete(): void
}


/**
 * Called to notify the device app that the print task configuration must be saved. 
 */
declare class PrintTaskConfigurationSaveRequestedEventArgs {

    /**
     * Gets the information that is required for updating the print task configuration. 
     */
    request: undefined.PrintTaskConfigurationSaveRequest
}


/**
 * Represents a 3D printer. 
 */
declare class Print3DDevice {

    /**
     * Creates a Print3DDevice object that represents a 3D printer connected to the device.
     * @param deviceId The device ID of the 3D printer.
     * @return  A Print3DDevice object that corresponds to the specified 3D printer.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.Print3DDevice>;

    /**
     * Gets an Advanced Query Syntax (AQS) string that can be used to find all 3D printers that are connected to the device.
     * @return  An AQS string that can be used to find all 3D printers connected to the device.
     */
    getDeviceSelector(): string;

    /**
     * Gets the PrintSchema object for obtaining capabilities and print ticket information. 
     */
    printSchema: undefined.PrintSchema
}


/**
 * Provides APIs to access a 3D printer's capabilities and print tickets. 
 */
declare class PrintSchema {

    /**
     * Gets the 3D printer capabilities.
     * @param constrainTicket The print ticket.
     * @return  An XML PrintCapabilities document containing 3D printer capabilities.
     */
    getCapabilitiesAsync(
        constrainTicket: undefined.IRandomAccessStreamWithContentType): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStreamWithContentType>;

    /**
     * Gets the 3D printer's default print ticket.
     * @return  An XML PrintTicket document containing the 3D printer's default print ticket.
     */
    getDefaultPrintTicketAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStreamWithContentType>;

    /**
     * Creates a new print ticket by merging the user’s selection with the default print ticket and validating that it will work for the device.
     * @param deltaTicket The delta print ticket, specifies the differences between the default print ticket and the user's selections.
     * @return  An XML PrintTicket document containing the suggested print ticket.
     */
    mergeAndValidateWithDefaultPrintTicketAsync(
        deltaTicket: undefined.IRandomAccessStreamWithContentType): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStreamWithContentType >
}



declare class PwmController {
    getControllersAsync: any;
    getDefaultAsync: any;
    actualFrequency: any;
    maxFrequency: any;
    minFrequency: any;
    openPin: any;
    pinCount: any;
    setDesiredFrequency: any
}

declare class PwmPin {
    close: any;
    controller: any;
    getActiveDutyCyclePercentage: any;
    isStarted: any;
    polarity: any;
    setActiveDutyCyclePercentage: any;
    start: any;
    stop: any
}

declare
var activeHigh: any;

declare
var activeLow: any;


/**
 * Represents a radio device on the system. 
 */
declare class Radio {

    /**
     * A static method that retrieves a Radio object corresponding to a device Id obtained through Windows.Devices.Enumeration.DeviceInformation.FindAllAsync and related APIs.
     * @param deviceId A string that identifies a particular radio device.
     * @return  An asynchronous retrieval operation. On successful completion, it contains a Radio object that represents the specified radio device.
     */
    fromIdAsync(deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.Radio>;

    /**
     * A static method that returns an Advanced Query Syntax (AQS) string to be used to enumerate or monitor Radio devices with Windows.Devices.Enumeration.DeviceInformation.FindAllAsync and related methods.
     * @return  An identifier to be used to enumerate radio devices.
     */
    getDeviceSelector(): string;

    /**
     * A static, asynchronous method that retrieves a collection of Windows.Devices.Radios.Radio objects representing radio devices existing on the system.
     * @return  An asynchronous retrieval operation. When the operation is complete, contains a list of Windows.Devices.Radios.Radio objects describing available radios.
     */
    getRadiosAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * An asynchronous method that retrieves a value indicating what access the current user has to the radio represented by this object. In circumstances where user permission is required to access the radio, this method prompts the user for permission. Consequently, always call this method on the UI thread.
     * @return  An asynchronous status retrieval operation. On successful completion, contains an enumeration value describing the current user's access to this radio.
     */
    requestAccessAsync(): undefined.IPromiseWithIAsyncOperation<undefined.RadioAccessStatus>;

    /**
     * Gets an enumeration value that describes what kind of radio this object represents. 
     */
    kind: undefined.RadioKind;

    /**
     * Gets the name of the radio represented by this object. 
     */
    name: string;

    /**
     * Event raised by a state change in the radio represented by this object. 
     */
    onstatechanged: undefined.TypedEventHandler<undefined.Radio, any>;
    addEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.Radio, any>): void;
    removeEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.Radio, any>): void;

    /**
     * An asynchronous operation that attempts to set the state of the radio represented by this object.
     * @param value The desired radio state.
     * @return  An asynchronous state setting operation. On successful completion, contains an enumeration value describing status of the state change request.
     */
    setStateAsync(
        value: undefined.RadioState): undefined.IPromiseWithIAsyncOperation<undefined.RadioAccessStatus>;

    /**
     * Gets the current state of the radio represented by this object. 
     */
    state: undefined.RadioState;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the properties of images to scan. 
 */
declare class ImageScanner {

    /**
     * Creates an instance of a ImageScanner object based on a scanners device information ID. This method is required for broker device enumeration.
     * @param deviceId The device information ID. See DeviceInformation.Id property.
     * @return  The ImageScanner object.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.ImageScanner>;

    /**
     * Returns the class selection string that apps can use to enumerate scanner devices. This method is required for the brokered device enumeration.
     * @return  The class selection.
     */
    getDeviceSelector(): string;

    /**
     * Gets and sets the scan settings of the auto-configured scan unit, like the file format, including compression to deliver the scanned data in. This property is ignored if the scanner is not capable of auto-configuration. 
     */
    autoConfiguration: undefined.ImageScannerAutoConfiguration;

    /**
     * Gets the default scan source chosen for this scanner device. 
     */
    defaultScanSource: undefined.ImageScannerScanSource;

    /**
     * Gets the PnP device identifier of this scanner device. 
     */
    deviceId: string;

    /**
     * Gets or sets the scan settings of the Feeder scan unit, like page size, orientation, and scan resolution. 
     */
    feederConfiguration: undefined.ImageScannerFeederConfiguration;

    /**
     * Gets and sets the scan settings of the Flatbed scan unit, like scan resolution and color mode. 
     */
    flatbedConfiguration: undefined.ImageScannerFlatbedConfiguration;

    /**
     * Determines if the specified scan source supports scan preview.
     * @param scanSource The scan source.
     * @return  Returns True if the specified scan source supports preview; otherwise False.
     */
    isPreviewSupported(scanSource: undefined.ImageScannerScanSource): boolean;

    /**
     * Determines if the specified scan source is available on the scanner.
     * @param value The scan source.
     * @return  True if the scan source, Flatbed or Feeder, is available; otherwise False.
     */
    isScanSourceSupported(value: undefined.ImageScannerScanSource): boolean;

    /**
     * Starts a scan job with the specified scan source and writes one or multiple images to one multi-page file like TIFF, XPS, and PDF; or one or multiple single-page files like DIB, PNG, JPG, and TIFF to the specified folder location. Returns the progress of the scan.
     * @param scanSource The image scan source.
     * @param storageFolder The target folder location of the scanned file.
     * @return  The list of scanned image files from ImageScannerScanResult and the progress of the WIA scan job from UInt32, which indicates how many files were transferred to the target folder.
     */
    scanFilesToFolderAsync(
        scanSource: undefined.ImageScannerScanSource,
        storageFolder: undefined.StorageFolder): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.ImageScannerScanResult, number>;

    /**
     * Scans one image from the specified scan source and applies the lowest scan resolution with the selected image file format.
     * @param scanSource The image scan source.
     * @param targetStream The scanned image file.
     * @return  The progress of the scan and the scanned file format.
     */
    scanPreviewToStreamAsync(
        scanSource: undefined.ImageScannerScanSource,
        targetStream: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncOperation<undefined.ImageScannerPreviewResult >
}


/**
 * Represents the auto-configured scan source of the scanner. 
 */
declare class ImageScannerAutoConfiguration {

    /**
     * The default file format for the scan source at the beginning of a new scan session. 
     */
    defaultFormat: undefined.ImageScannerFormat;

    /**
     * Gets or sets the current file transfer format for image data acquisition from the device to the client app. 
     */
    format: undefined.ImageScannerFormat;

    /**
     * Determines if the input scanner supports the specified file format.
     * @param value The file type.
     * @return  True if the specified file type is supported; otherwise False.
     */
    isFormatSupported(value: undefined.ImageScannerFormat): boolean
}


/**
 * Represents the Feeder scan source of the scanner. 
 */
declare class ImageScannerFeederConfiguration {

    /**
     * Gets the actual horizontal and vertical scan resolution for the scanner's Feeder, in DPI. 
     */
    actualResolution: undefined.ImageScannerResolution;

    /**
     * Gets or sets the automatic crop mode. 
     */
    autoCroppingMode: undefined.ImageScannerAutoCroppingMode;

    /**
     * Gets or sets the page size automatic detection feature for the scanner's Feeder. 
     */
    autoDetectPageSize: boolean;

    /**
     * Gets or sets the current brightness level for capturing image data from the scanner's Feeder. At the beginning of a new scan session, this property is set to the DefaultBrightness property. 
     */
    brightness: number;

    /**
     * Gets the step size at which the brightness levels of the data source can be increased or decreased between the minimum and maximum values. 
     */
    brightnessStep: number;

    /**
     * Returns True if the device can automatically detect at scan time the size of the document pages scanned through the Feeder; otherwise returns False. 
     */
    canAutoDetectPageSize: boolean;

    /**
     * Gets whether the scanner device is capable of scanning ahead from its Feeder. 
     */
    canScanAhead: boolean;

    /**
     * Gets whether the scanner's Feeder is capable of duplex scanning (scanning both document page sides, front and back). When scanning in duplex mode the same scan settings (such as color mode and scan resolution) are applied to scan both page sides. 
     */
    canScanDuplex: boolean;

    /**
     * Gets or sets the color mode for the scanner's Feeder. 
     */
    colorMode: undefined.ImageScannerColorMode;

    /**
     * Sets or gets the current contrast level for capturing image data from the scanner's Feeder. At the beginning of a new scan session this property is set to the DefaultContrast property. 
     */
    contrast: number;

    /**
     * Gets the step size at which the contrast levels of the data source can increase or decrease between the minimum and maximum values. 
     */
    contrastStep: number;

    /**
     * Gets the default brightness level for the scanner's Feeder. 
     */
    defaultBrightness: number;

    /**
     * Gets the default color mode for the scanner's Feeder. 
     */
    defaultColorMode: undefined.ImageScannerColorMode;

    /**
     * Gets the default contrast level for the scanner's Feeder. 
     */
    defaultContrast: number;

    /**
     * Gets the default file format for the scanner's Feeder at the beginning of a new scan session. 
     */
    defaultFormat: undefined.ImageScannerFormat;

    /**
     * Gets or sets the horizontal and vertical scan resolution for the scanner's Feeder that the app requests, in DPI. 
     */
    desiredResolution: undefined.ImageScannerResolution;

    /**
     * Indicates whether the scanner's Feeder can scan both document page sides. 
     */
    duplex: boolean;

    /**
     * Gets or sets the current file transfer format for image data acquisition from the scanner's Feeder to the client app. 
     */
    format: undefined.ImageScannerFormat;

    /**
     * Returns whether the scanner's Feeder supports the specified ImageScannerAutoCroppingMode .
     * @param value The auto crop mode of the image to scan.
     * @return  Indicates whether the device supports value mode.
     */
    isAutoCroppingModeSupported(value: undefined.ImageScannerAutoCroppingMode): boolean;

    /**
     * Returns whether the scanner's Feeder can scan and transfer images in the specified color mode.
     * @param value The color mode.
     * @return  Indicates whether the scanner can scan images in value mode.
     */
    isColorModeSupported(value: undefined.ImageScannerColorMode): boolean;

    /**
     * Determines whether the scanner's Feeder supports the specified file format or not.
     * @param value The file type.
     * @return  Indicates whether the specified file type is supported.
     */
    isFormatSupported(value: undefined.ImageScannerFormat): boolean;

    /**
     * Returns whether the Feeder can scan documents in the specified page size and orientation.
     * @param pageSize The page size.
     * @param pageOrientation The page orientation.
     * @return  Indicates the scanner can scan with pageSize and pageOrientation values.
     */
    isPageSizeSupported(
        pageSize: undefined.PrintMediaSize,
        pageOrientation: undefined.PrintOrientation): boolean;

    /**
     * Gets the maximum brightness level supported by the scanner's Feeder. 
     */
    maxBrightness: number;

    /**
     * Gets the maximum contrast level supported by the scanner's Feeder. 
     */
    maxContrast: number;

    /**
     * Gets or sets the maximum number of pages-not images, the app can scan in one scan job, before the scanner stops. 
     */
    maxNumberOfPages: number;

    /**
     * Gets the maximum horizontal and vertical scan resolution of the scanner's Feeder in DPI. 
     */
    maxResolution: undefined.ImageScannerResolution;

    /**
     * Gets the maximum scan area dimensions in inches. The maximum scan width is the widest a document can be in order for the scanner's Feeder to scan it. 
     */
    maxScanArea: undefined.Size;

    /**
     * Gets the minimum brightness level supported by the scanner's Feeder. 
     */
    minBrightness: number;

    /**
     * Gets the minimum contrast level supported by the scanner's Feeder. 
     */
    minContrast: number;

    /**
     * Gets the minimum horizontal and vertical scan resolution of the scanner's Feeder in DPI. 
     */
    minResolution: undefined.ImageScannerResolution;

    /**
     * Gets the minimum scan area in inches. The minimum scan area is the smallest size a document can have in order for a Feeder to scan it. 
     */
    minScanArea: undefined.Size;

    /**
     * Gets the optical horizontal and vertical scan resolution of the scanner's Feeder in DPI. 
     */
    opticalResolution: undefined.ImageScannerResolution;

    /**
     * Gets or sets the currently selected page orientation that tells how to place the documents in the scanner's Feeder input tray. 
     */
    pageOrientation: undefined.PrintOrientation;

    /**
     * Gets or sets the currently selected page size to scan from the Feeder. 
     */
    pageSize: undefined.PrintMediaSize;

    /**
     * Gets the dimensions (width and height) and orientation of the selected page size, in mil units (1/1000"). 
     */
    pageSizeDimensions: undefined.Size;

    /**
     * Indicates whether or not to scan ahead. 
     */
    scanAhead: boolean;

    /**
     * Gets or sets the origin coordinates (horizontal and vertical) and dimensions (width and height) of the selected scan area, in inches. This property is ignored when the AutoCroppingMode property is not Disabled. 
     */
    selectedScanRegion: undefined.Rect
}


/**
 * Represents the Flatbed scan source of the scanner. 
 */
declare class ImageScannerFlatbedConfiguration {

    /**
     * Gets the actual horizontal and vertical scan resolution for the Flatbed scanner, in DPI. 
     */
    actualResolution: undefined.ImageScannerResolution;

    /**
     * Gets or sets the automatic crop mode. 
     */
    autoCroppingMode: undefined.ImageScannerAutoCroppingMode;

    /**
     * Gets or sets the current brightness level for capturing image data from the scanner's Flatbed. At the beginning of a new scan session, this property is set to the DefaultBrightness property. 
     */
    brightness: number;

    /**
     * Gets the step size at which the brightness levels of the data source can be increased or decreased between the minimum and maximum values. 
     */
    brightnessStep: number;

    /**
     * Gets or sets the color mode for the Flatbed scanner. 
     */
    colorMode: undefined.ImageScannerColorMode;

    /**
     * Sets or gets the current contrast level for capturing image data from the scan source. At the beginning of a new scan session this property is set to the DefaultContrast property. 
     */
    contrast: number;

    /**
     * Gets the step size at which the contrast levels of the data source can increase or decrease between the minimum and maximum values. 
     */
    contrastStep: number;

    /**
     * Gets the default brightness level for the scanner's Flatbed. 
     */
    defaultBrightness: number;

    /**
     * Gets the default color mode for the scanner's Flatbed. 
     */
    defaultColorMode: undefined.ImageScannerColorMode;

    /**
     * Gets the default contrast level for the scanner's Flatbed. 
     */
    defaultContrast: number;

    /**
     * Gets the default file format for the scanner's Flatbed at the beginning of a new scan session. 
     */
    defaultFormat: undefined.ImageScannerFormat;

    /**
     * Gets or sets the horizontal and vertical scan resolution for the scanner's Flatbed that the app requests, in DPI. 
     */
    desiredResolution: undefined.ImageScannerResolution;

    /**
     * Gets or sets the current file transfer format for image data acquisition from the scanner's Flatbed to the client app. 
     */
    format: undefined.ImageScannerFormat;

    /**
     * Returns whether the scanner's Flatbed supports the specified ImageScannerAutoCroppingMode .
     * @param value The auto crop mode of the image to scan.
     * @return  Indicates whether the device supports value mode.
     */
    isAutoCroppingModeSupported(value: undefined.ImageScannerAutoCroppingMode): boolean;

    /**
     * Returns whether the scanner's Flatbed can scan and transfer images in the specified color mode.
     * @param value The color mode.
     * @return  Indicates whether the scanner can scan images in value mode.
     */
    isColorModeSupported(value: undefined.ImageScannerColorMode): boolean;

    /**
     * Determines whether the scanner's Flatbed supports the specified file format or not.
     * @param value The file type.
     * @return  Indicates whether the specified file type is supported.
     */
    isFormatSupported(value: undefined.ImageScannerFormat): boolean;

    /**
     * Gets the maximum brightness level supported by the scanner's Flatbed. 
     */
    maxBrightness: number;

    /**
     * Gets the maximum contrast level supported by the scanner's Flatbed. 
     */
    maxContrast: number;

    /**
     * Gets the maximum horizontal and vertical scan resolution of the scanner's Flatbed in DPI. 
     */
    maxResolution: undefined.ImageScannerResolution;

    /**
     * Gets the maximum scan area dimensions in inches. The maximum scan width is the widest a document can be in order for the scanner's Flatbed to scan it. 
     */
    maxScanArea: undefined.Size;

    /**
     * Gets the minimum brightness level supported by the scanner's Flatbed. 
     */
    minBrightness: number;

    /**
     * Gets the minimum contrast level supported by the scanner's Flatbed. 
     */
    minContrast: number;

    /**
     * Gets the minimum horizontal and vertical scan resolution of the scanner's Flatbed in DPI. 
     */
    minResolution: undefined.ImageScannerResolution;

    /**
     * Gets the minimum scan area in inches. The minimum scan area is the smallest size a document can have in order for a Flatbed to scan it. 
     */
    minScanArea: undefined.Size;

    /**
     * Gets the optical scan resolution of the Flatbed scanner in DPI. 
     */
    opticalResolution: undefined.ImageScannerResolution;

    /**
     * Gets or sets the origin coordinates (horizontal and vertical) and dimensions (width and height) of the selected scan area, in inches. This property is ignored when the AutoCroppingMode property is not Disabled. 
     */
    selectedScanRegion: undefined.Rect
}


/**
 * Represents the result of a preview scan job. 
 */
declare class ImageScannerPreviewResult {

    /**
     * Gets the format of the data for the scan preview. After preview this property is restored to the value before preview. 
     */
    format: undefined.ImageScannerFormat;

    /**
     * Gets whether the scan preview was successful. 
     */
    succeeded: boolean
}


/**
 * Represents the result of a scan job. 
 */
declare class ImageScannerScanResult {

    /**
     * Gets the list of scanned image files that was produced by the completed scan job. 
     */
    scannedFiles: undefined.IVectorView<undefined.StorageFile >
}


/**
 * Specifies the scan resolution. 
 */
declare interface Scanners$ImageScannerResolution {

    /**
     * The horizontal size. 
     */
    dpiX: number,

        /**
         * The vertical size. 
         */
        dpiY: number
}


/**
 * Represents an accelerometer sensor. 
 */
declare class Accelerometer {

    /**
     * Returns the default accelerometer.
     * @return  The default accelerometer or null if no integrated accelerometers are found.
     */
    getDefault(): undefined.Accelerometer;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Gets the current accelerometer reading.
     * @return  This method has no parameters.
     */
    getCurrentReading(): undefined.AccelerometerReading;

    /**
     * Gets the maximum number of events that can be batched by the sensor. 
     */
    maxBatchSize: number;

    /**
     * Gets the minimum report interval supported by the accelerometer. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the accelerometer reports a new sensor reading. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.Accelerometer, undefined.AccelerometerReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Accelerometer, undefined.AccelerometerReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Accelerometer, undefined.AccelerometerReadingChangedEventArgs>): void;

    /**
     * Occurs when the accelerometer detects that the PC has been shaken. 
     */
    onshaken: undefined.TypedEventHandler<undefined.Accelerometer, undefined.AccelerometerShakenEventArgs>;
    addEventListener(
        type: "shaken",
        listener: undefined.TypedEventHandler<undefined.Accelerometer, undefined.AccelerometerShakenEventArgs>): void;
    removeEventListener(
        type: "shaken",
        listener: undefined.TypedEventHandler<undefined.Accelerometer, undefined.AccelerometerShakenEventArgs>): void;

    /**
     * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data. 
     */
    readingTransform: undefined.DisplayOrientations;

    /**
     * Gets or sets the current report interval for the accelerometer. 
     */
    reportInterval: number;

    /**
     * Gets or sets the delay between batches of sensor information. 
     */
    reportLatency: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an accelerometer reading. 
 */
declare class AccelerometerReading {

    /**
     * Gets the g-force acceleration along the x-axis. 
     */
    accelerationX: number;

    /**
     * Gets the g-force acceleration along the y-axis. 
     */
    accelerationY: number;

    /**
     * Gets the g-force acceleration along the z-axis. 
     */
    accelerationZ: number;

    /**
     * Gets the time at which the sensor reported the reading. 
     */
    timestamp: Date
}


/**
 * Provides data for the accelerometer reading–changed event. 
 */
declare class AccelerometerReadingChangedEventArgs {

    /**
     * Gets the most recent accelerometer reading. 
     */
    reading: undefined.AccelerometerReading
}


/**
 * Provides data for the accelerometer-shaken event. 
 */
declare class AccelerometerShakenEventArgs {

    /**
     * Gets the time at which the sensor reported the shaken event. 
     */
    timestamp: Date
}


/**
 * Represents an activity sensor that provides the activity and status of a sensor. 
 */
declare class ActivitySensor {

    /**
     * Asynchronously obtains the sensor from its identifier.
     * @param deviceId The sensor identifier.
     * @return  Returns the ActivitySensor object from its identifier.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.ActivitySensor>;

    /**
     * Asynchronously obtains the default sensor.
     * @return  Asynchronously returns a ActivitySensor object that represents the default sensor.
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ActivitySensor>;

    /**
     * Gets the device selector.
     * @return  Returns the device selector, if it exists; otherwise, null.
     */
    getDeviceSelector(): string;

    /**
     * Asynchronously gets sensor readings from a specific time.
     * @param fromTime The time at which to get sensor readings.
     * @return  Asynchronously returns a list of ActivitySensorReading objects that represent info about the sensor.
     */
    getSystemHistoryAsync(
        fromTime: Date): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously gets sensor readings from a specific time and duration.
     * @param fromTime The time at which to get sensor readings.
     * @param duration The time span during which to get sensor readings.
     * @return  Asynchronously returns a list of ActivitySensorReading objects that represent info about the sensor.
     */
    getSystemHistoryAsync(
        fromTime: Date,
        duration: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Asynchronously gets the current sensor reading.
     * @return  Asynchronously returns a ActivitySensorReading object that represents info about the sensor.
     */
    getCurrentReadingAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ActivitySensorReading>;

    /**
     * Gets the minimum report interval supported by the sensor. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the sensor reports a new sensor reading. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.ActivitySensor, undefined.ActivitySensorReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.ActivitySensor, undefined.ActivitySensorReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.ActivitySensor, undefined.ActivitySensorReadingChangedEventArgs>): void;

    /**
     * Gets the power in milliwatts that the sensor consumes. 
     */
    powerInMilliwatts: number;

    /**
     * Gets the list of activity types that the sensor pledges to perform. 
     */
    subscribedActivities: undefined.IVector<undefined.ActivityType>;

    /**
     * Gets the list of activity types that the sensor supports. 
     */
    supportedActivities: undefined.IVectorView<undefined.ActivityType>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the reading of an activity sensor that provides readings for the sensor. 
 */
declare class ActivitySensorReading {

    /**
     * Gets the activity type for the sensor. 
     */
    activity: undefined.ActivityType;

    /**
     * Gets the reading confidence for the sensor. 
     */
    confidence: undefined.ActivitySensorReadingConfidence;

    /**
     * Gets the time at which the sensor reported the reading. 
     */
    timestamp: Date
}


/**
 * Represents data for the sensor trigger. 
 */
declare class ActivitySensorReadingChangeReport {

    /**
     * Gets the reading of the sensor when it's triggered. 
     */
    reading: undefined.ActivitySensorReading
}


/**
 * Represents data for the reading–changed event of the sensor. 
 */
declare class ActivitySensorReadingChangedEventArgs {

    /**
     * Gets the most recent sensor reading. 
     */
    reading: undefined.ActivitySensorReading
}


/**
 * Represents details about the sensor triggering. 
 */
declare class ActivitySensorTriggerDetails {

    /**
     * Reads reports about the sensor triggering.
     * @return  Returns a list of ActivitySensorReadingChangeReport objects that provides data for the sensor trigger.
     */
    readReports(): undefined.IVectorView<undefined.ActivitySensorReadingChangeReport >
}


/**
 * Provides an interface for an altimetric sensor to measure the relative altitude. 
 */
declare class Altimeter {

    /**
     * Returns the default altimeter sensor.
     * @return  The default altimeter.
     */
    getDefault(): undefined.Altimeter;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Gets the current reading for the altimeter.
     * @return  The current alititude reading for this sensor.
     */
    getCurrentReading(): undefined.AltimeterReading;

    /**
     * The smallest report interval that is supported by this altimeter sensor. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the altimeter sensor reports a new value. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.Altimeter, undefined.AltimeterReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Altimeter, undefined.AltimeterReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Altimeter, undefined.AltimeterReadingChangedEventArgs>): void;

    /**
     * Gets or sets the current report interval for the altimeter. 
     */
    reportInterval: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an altimeter reading. 
 */
declare class AltimeterReading {

    /**
     * Gets the current altitude determined by the altimeter sensor. 
     */
    altitudeChangeInMeters: number;

    /**
     * Gets the time for the most recent altimeter reading. 
     */
    timestamp: Date
}


/**
 * Provides data for the altimeter reading–changed event. 
 */
declare class AltimeterReadingChangedEventArgs {

    /**
     * Gets the most recent barometer reading. 
     */
    reading: undefined.AltimeterReading
}


/**
 * Provides an interface for a barometric sensor to measure atmospheric pressure. 
 */
declare class Barometer {

    /**
     * Returns the default barometer sensor.
     * @return  The default barometer.
     */
    getDefault(): undefined.Barometer;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Gets the current reading for the barometer.
     * @return  The current atmospheric pressure according to this sensor.
     */
    getCurrentReading(): undefined.BarometerReading;

    /**
     * The smallest report interval that is supported by this barometer sensor. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the barometer sensor reports a new value. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.Barometer, undefined.BarometerReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Barometer, undefined.BarometerReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Barometer, undefined.BarometerReadingChangedEventArgs>): void;

    /**
     * Gets or sets the current report interval for the barometer. 
     */
    reportInterval: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a barometer reading. 
 */
declare class BarometerReading {

    /**
     * Gets the barometric pressure determined by the barometer sensor. 
     */
    stationPressureInHectopascals: number;

    /**
     * Gets the time for the most recent barometer reading. 
     */
    timestamp: Date
}


/**
 * Provides data for the barometer reading–changed event. 
 */
declare class BarometerReadingChangedEventArgs {

    /**
     * Gets the most recent barometer reading. 
     */
    reading: undefined.BarometerReading
}


/**
 * Represents a compass sensor. 
 */
declare class Compass {

    /**
     * Returns the default compass.
     * @return  The default compass or null if no integrated compasses are found.
     */
    getDefault(): undefined.Compass;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Gets the current compass reading.
     * @return  The current compass reading.
     */
    getCurrentReading(): undefined.CompassReading;

    /**
     * Gets the minimum report interval supported by the compass. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the compass reports a new sensor reading. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.Compass, undefined.CompassReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Compass, undefined.CompassReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Compass, undefined.CompassReadingChangedEventArgs>): void;

    /**
     * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data. 
     */
    readingTransform: undefined.DisplayOrientations;

    /**
     * Gets or sets the current report interval for the compass. 
     */
    reportInterval: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a compass reading. 
 */
declare class CompassReading {

    /**
     * Gets the compass's heading accuracy. 
     */
    headingAccuracy: undefined.MagnetometerAccuracy;

    /**
     * Gets the heading in degrees relative to magnetic-north. 
     */
    headingMagneticNorth: number;

    /**
     * Gets the heading in degrees relative to geographic true-north. 
     */
    headingTrueNorth: number;

    /**
     * Gets the time at which the sensor reported the reading. 
     */
    timestamp: Date
}


/**
 * Provides data for the compass reading–changed event. 
 */
declare class CompassReadingChangedEventArgs {

    /**
     * Gets the current compass reading. 
     */
    reading: undefined.CompassReading
}


/**
 * Represents a custom sensor. 
 */
declare class CustomSensor {

    /**
     * Asynchronously obtains the sensor from its identifier.
     * @param sensorId The sensor identifier.
     * @return  Returns the CustomSensor object from its identifier.
     */
    fromIdAsync(
        sensorId: string): undefined.IPromiseWithIAsyncOperation<undefined.CustomSensor>;

    /**
     * Gets the device selector from the given interface identifier.
     * @param interfaceId The interface Guid that is associated with the custom sensor. This Guid is defined and registered by the sensor.
     * @return  Returns the device selector, if it exists; otherwise, null.
     */
    getDeviceSelector(interfaceId: string): string;

    /**
     * Gets the device identifier of the sensor. 
     */
    deviceId: string;

    /**
     * Gets the current sensor reading.
     * @return  The current sensor reading.
     */
    getCurrentReading(): undefined.CustomSensorReading;

    /**
     * Gets the minimum report interval that is supported by the sensor. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the sensor reports a new sensor reading. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.CustomSensor, undefined.CustomSensorReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.CustomSensor, undefined.CustomSensorReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.CustomSensor, undefined.CustomSensorReadingChangedEventArgs>): void;

    /**
     * Gets or sets the current report interval for the sensor. 
     */
    reportInterval: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a property set of key/value pairs that contain the custom data sent from the sensor’s driver to the app. 
 */
declare class CustomSensorReading {

    /**
     * Gets the property set for the sensor. 
     */
    properties: undefined.IMapView<string, any>;

    /**
     * Gets the time at which the sensor reported the reading. 
     */
    timestamp: Date
}


/**
 * Represents data for the reading–changed event of the custom sensor. 
 */
declare class CustomSensorReadingChangedEventArgs {

    /**
     * Gets the most recent sensor reading. 
     */
    reading: undefined.CustomSensorReading
}


/**
 * Represents a gyrometer sensor. 
 */
declare class Gyrometer {

    /**
     * Returns the default gyrometer.
     * @return  The default gyrometer or null if no integrated gyrometers are found.
     */
    getDefault(): undefined.Gyrometer;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Gets the current gyrometer reading.
     * @return  This method has no parameters.
     */
    getCurrentReading(): undefined.GyrometerReading;

    /**
     * Gets the minimum report interval supported by the gyrometer. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the gyrometer reports the current sensor reading. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.Gyrometer, undefined.GyrometerReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Gyrometer, undefined.GyrometerReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Gyrometer, undefined.GyrometerReadingChangedEventArgs>): void;

    /**
     * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data. 
     */
    readingTransform: undefined.DisplayOrientations;

    /**
     * Gets or sets the current report interval for the gyrometer. 
     */
    reportInterval: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a gyrometer reading. 
 */
declare class GyrometerReading {

    /**
     * Gets the angular velocity, in degrees per second, about the x-axis. 
     */
    angularVelocityX: number;

    /**
     * Gets the angular velocity, in degrees per second, about the y-axis. 
     */
    angularVelocityY: number;

    /**
     * Gets the angular velocity, in degrees per second, about the z-axis. 
     */
    angularVelocityZ: number;

    /**
     * Gets the time at which the sensor reported the reading. 
     */
    timestamp: Date
}


/**
 * Provides data for the gyrometer reading–changed event. 
 */
declare class GyrometerReadingChangedEventArgs {

    /**
     * Gets the current gyrometer reading. 
     */
    reading: undefined.GyrometerReading
}


/**
 * Represents an inclinometer sensor. 
 */
declare class Inclinometer {

    /**
     * Returns the default inclinometer.
     * @return  The default inclinometer or null if no inclinometers are found.
     */
    getDefault(): undefined.Inclinometer;

    /**
     * Returns the default inclinometer.
     * @return  The default inclinometer or null if no inclinometers are found.
     */
    getDefaultForRelativeReadings(): undefined.Inclinometer;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Gets the current inclinometer reading.
     * @return  The current inclinometer reading.
     */
    getCurrentReading(): undefined.InclinometerReading;

    /**
     * Gets the minimum report interval supported by the inclinometer. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the inclinometer reports a new sensor reading. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.Inclinometer, undefined.InclinometerReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Inclinometer, undefined.InclinometerReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Inclinometer, undefined.InclinometerReadingChangedEventArgs>): void;

    /**
     * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data. 
     */
    readingTransform: undefined.DisplayOrientations;

    /**
     * Gets the sensor reading type. 
     */
    readingType: undefined.SensorReadingType;

    /**
     * Gets or sets the current report interval for the inclinometer. 
     */
    reportInterval: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an inclinometer reading. 
 */
declare class InclinometerReading {

    /**
     * Gets the rotation in degrees around the x-axis. 
     */
    pitchDegrees: number;

    /**
     * Gets the rotation in degrees around the y-axis. 
     */
    rollDegrees: number;

    /**
     * Gets the time at which the sensor reported the reading. 
     */
    timestamp: Date;

    /**
     * Gets the inclinometer's z-axis accuracy. 
     */
    yawAccuracy: undefined.MagnetometerAccuracy;

    /**
     * Gets the rotation in degrees around the z-axis. 
     */
    yawDegrees: number
}


/**
 * Provides data for the inclinometer reading–changed event. 
 */
declare class InclinometerReadingChangedEventArgs {

    /**
     * Gets the current inclinometer reading. 
     */
    reading: undefined.InclinometerReading
}


/**
 * Represents an ambient-light sensor. 
 */
declare class LightSensor {

    /**
     * Returns the default ambient-light sensor.
     * @return  The default ambient-light sensor or null if no integrated light sensors are found.
     */
    getDefault(): undefined.LightSensor;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Gets the current ambient-light sensor reading.
     * @return  The current ambient-light sensor reading.
     */
    getCurrentReading(): undefined.LightSensorReading;

    /**
     * Gets the minimum report interval supported by the sensor. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the ambient-light sensor reports a new sensor reading. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.LightSensor, undefined.LightSensorReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.LightSensor, undefined.LightSensorReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.LightSensor, undefined.LightSensorReadingChangedEventArgs>): void;

    /**
     * Gets or sets the current report interval for the ambient light sensor. 
     */
    reportInterval: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an ambient light–sensor reading. 
 */
declare class LightSensorReading {

    /**
     * Gets the illuminance level in lux. 
     */
    illuminanceInLux: number;

    /**
     * Gets the time at which the sensor reported the reading. 
     */
    timestamp: Date
}


/**
 * Provides data for the ambient-light sensor reading-changed event. 
 */
declare class LightSensorReadingChangedEventArgs {

    /**
     * Gets the current ambient light-sensor reading. 
     */
    reading: undefined.LightSensorReading
}


/**
 * Represents a magnetic sensor. 
 */
declare class Magnetometer {

    /**
     * Returns the default magnetometer.
     * @return  The default magnetometer.
     */
    getDefault(): undefined.Magnetometer;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Gets the current magnetometer reading.
     * @return  The current magnetometer reading.
     */
    getCurrentReading(): undefined.MagnetometerReading;

    /**
     * Gets the minimum report interval supported by the magnetometer. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the compass reports a new sensor reading. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.Magnetometer, undefined.MagnetometerReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Magnetometer, undefined.MagnetometerReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Magnetometer, undefined.MagnetometerReadingChangedEventArgs>): void;

    /**
     * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data. 
     */
    readingTransform: undefined.DisplayOrientations;

    /**
     * Gets or sets the current report interval for the magnetometer. 
     */
    reportInterval: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a magnetometer reading. 
 */
declare class MagnetometerReading {

    /**
     * Gets the magnetometer's directional accuracy. 
     */
    directionalAccuracy: undefined.MagnetometerAccuracy;

    /**
     * Gets the magnetic field strength in microteslas along the X axis. 
     */
    magneticFieldX: number;

    /**
     * Gets the magnetic field strength in microteslas along the Y axis. 
     */
    magneticFieldY: number;

    /**
     * Gets the magnetic field strength in microteslas along the Z axis. 
     */
    magneticFieldZ: number;

    /**
     * Gets the time at which the sensor reported the reading. 
     */
    timestamp: Date
}


/**
 * Provides data for the magnetometer reading–changed event. 
 */
declare class MagnetometerReadingChangedEventArgs {

    /**
     * Gets the current magnetometer reading. 
     */
    reading: undefined.MagnetometerReading
}


/**
 * Represents an orientation sensor. 
 */
declare class OrientationSensor {

    /**
     * Gets the default orientation sensor.
     * @return  The default orientation sensor or null if no orientation sensors are found.
     */
    getDefault(): undefined.OrientationSensor;

    /**
     * Gets the default orientation sensor.
     * @return  The default orientation sensor or null if no orientation sensors are found.
     */
    getDefaultForRelativeReadings(): undefined.OrientationSensor;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Gets the current sensor reading.
     * @return  The current sensor reading.
     */
    getCurrentReading(): undefined.OrientationSensorReading;

    /**
     * Gets the minimum report interval supported by the sensor. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the orientation sensor reports a new sensor reading. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.OrientationSensor, undefined.OrientationSensorReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.OrientationSensor, undefined.OrientationSensorReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.OrientationSensor, undefined.OrientationSensorReadingChangedEventArgs>): void;

    /**
     * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data. 
     */
    readingTransform: undefined.DisplayOrientations;

    /**
     * Gets the sensor reading type. 
     */
    readingType: undefined.SensorReadingType;

    /**
     * Gets or sets the report interval supported by the sensor. 
     */
    reportInterval: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an orientation-sensor reading. 
 */
declare class OrientationSensorReading {

    /**
     * Gets the Quaternion for the current orientation-sensor reading. 
     */
    quaternion: undefined.SensorQuaternion;

    /**
     * Gets the rotation matrix for the current orientation-sensor reading. 
     */
    rotationMatrix: undefined.SensorRotationMatrix;

    /**
     * Gets the time at which the sensor reported the reading. 
     */
    timestamp: Date;

    /**
     * Gets the orientation sensor's z-axis accuracy. 
     */
    yawAccuracy: undefined.MagnetometerAccuracy
}


/**
 * Provides data for the orientation-sensor reading-changed event. 
 */
declare class OrientationSensorReadingChangedEventArgs {

    /**
     * Gets the current reading which includes a Quaternion, a RotationMatrix, and a timestamp. 
     */
    reading: undefined.OrientationSensorReading
}


/**
 * Provides an interface for a pedometer to measure the number of steps taken. 
 */
declare class Pedometer {

    /**
     * Obtains the pedometer from its identifier.
     * @param deviceId The sensor identifier.
     * @return  Returns the Pedometer object from its identifier.
     */
    fromIdAsync(deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.Pedometer>;

    /**
     * Asynchronously obtains the default pedometer.
     * @return  Asynchronously returns a Pedometer object that represents the default sensor.
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.Pedometer>;

    /**
     * Gets the device selector.
     * @return  Returns the device selector, if it exists; otherwise null.
     */
    getDeviceSelector(): string;
    getReadingsFromTriggerDetails: any;

    /**
     * Asynchronously gets sensor readings from a specific time.
     * @param fromTime The time for which you want to retrieve the reading.
     * @return  Asynchronously returns a list of PedometerReading objects that represent info about the sensor.
     */
    getSystemHistoryAsync(
        fromTime: Date): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously gets pedometer readings from a specific time and duration.
     * @param fromTime The time for which you want to retrieve the reading.
     * @param duration The duration over which you want to retrieve data.
     * @return  Asynchronously returns a list of PedometerReading objects that represent info about the sensor.
     */
    getSystemHistoryAsync(
        fromTime: Date,
        duration: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;
    getCurrentReadings: any;

    /**
     * The smallest report interval that is supported by this pedometer. 
     */
    minimumReportInterval: number;

    /**
     * Occurs each time the pedometer reports a new value. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.Pedometer, undefined.PedometerReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Pedometer, undefined.PedometerReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.Pedometer, undefined.PedometerReadingChangedEventArgs>): void;

    /**
     * Gets the power that the sensor consumes. 
     */
    powerInMilliwatts: number;

    /**
     * Gets or sets the current report interval for the pedometer. 
     */
    reportInterval: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * A threshold for the Pedometer sensor. When the threshold conditions are met, the sensor trigger will activate. 
 */
declare class PedometerDataThreshold {

    /**
     * Creates a PedometerDataThreshold object.
     * @param sensor The pedometer sensor.
     * @param stepGoal The number of steps before the threshold is exceeded and the background task is activated.
     */
    constructor(sensor: undefined.Pedometer, stepGoal: number): this
}


/**
 * Represents a pedometer reading. 
 */
declare class PedometerReading {

    /**
     * Gets the total number of steps taken for this pedometer reading. 
     */
    cumulativeSteps: number;

    /**
     * Gets the amount of time that has elapsed for this pedometer reading. 
     */
    cumulativeStepsDuration: number;

    /**
     * Indicates the type of steps taken for this pedometer reading. 
     */
    stepKind: undefined.PedometerStepKind;

    /**
     * Gets the time for the most recent pedometer reading. 
     */
    timestamp: Date
}


/**
 * Provides data for the pedometer reading–changed event. 
 */
declare class PedometerReadingChangedEventArgs {

    /**
     * Gets the most recent pedometer reading. 
     */
    reading: undefined.PedometerReading
}


/**
 * Provides an interface for a proximity sensor to determine whether or not an object is detected. 
 */
declare class ProximitySensor {

    /**
     * Obtains the proximity sensor from its identifier.
     * @param sensorId The sensor identifier.
     * @return  Returns the ProximitySensor object from its identifier.
     */
    fromId(sensorId: string): undefined.ProximitySensor;

    /**
     * Gets the device selector.
     * @return  Returns the device selector. If no device selector is available, this method returns null.
     */
    getDeviceSelector(): string;

    /**
     * Gets readings from the trigger details in background task.
     * @param triggerDetails The trigger details received from the background task.
     * @return  The collection of proximity data retrieved from the trigger details.
     */
    getReadingsFromTriggerDetails(
        triggerDetails: undefined.SensorDataThresholdTriggerDetails): undefined.IVectorView<undefined.ProximitySensorReading>;

    /**
     * Creates a controller responsible for turning the display on or off based on the ProximitySensorReading .
     * @return  The controller for the phone display.
     */
    createDisplayOnOffController(): undefined.ProximitySensorDisplayOnOffController;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Gets the current reading for the proximity sensor.
     * @return  Indicates whether or not the proximity sensor detects an object, and if so, the distance to that object.
     */
    getCurrentReading(): undefined.ProximitySensorReading;

    /**
     * The largest distance where the proximity sensor can detect an object. 
     */
    maxDistanceInMillimeters: number;

    /**
     * The shortest distance where the proximity sensor can detect an object. 
     */
    minDistanceInMillimeters: number;

    /**
     * Occurs each time the proximity sensor reports a new value. 
     */
    onreadingchanged: undefined.TypedEventHandler<undefined.ProximitySensor, undefined.ProximitySensorReadingChangedEventArgs>;
    addEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.ProximitySensor, undefined.ProximitySensorReadingChangedEventArgs>): void;
    removeEventListener(
        type: "readingchanged",
        listener: undefined.TypedEventHandler<undefined.ProximitySensor, undefined.ProximitySensorReadingChangedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * A threshold for the ProximitySensor . When the threshold conditions are met, the sensor trigger will activate. 
 */
declare class ProximitySensorDataThreshold {

    /**
     * Creates a ProximitySensorDataThreshold object.
     * @param sensor The proximity sensor.
     */
    constructor(sensor: undefined.ProximitySensor): this
}


/**
 * Provides a controller responsible for turning on or off the phone display based on the readings from the ProximitySensor . 
 */
declare class ProximitySensorDisplayOnOffController {

    /**
     * Disconnects this ProximitySensorDisplayOnOffController instance from the service and frees all the allocated resources. 
     */
    close(): void
}


/**
 * Represents a reading from the proximity sensor. 
 */
declare class ProximitySensorReading {

    /**
     * Gets the distance from the proximity sensor to the detected object. 
     */
    distanceInMillimeters: number;

    /**
     * Gets whether or not an object is detected by the proximity sensor. 
     */
    isDetected: boolean;

    /**
     * Gets the time for the most recent proximity sensor reading. 
     */
    timestamp: Date
}


/**
 * Provides data for the reading–changed event of the proximity sensor. 
 */
declare class ProximitySensorReadingChangedEventArgs {

    /**
     * Gets or sets the most recent proximity sensor reading. 
     */
    reading: undefined.ProximitySensorReading
}


/**
 * Provides data for what sensor triggered the data threshold monitoring task. 
 */
declare class SensorDataThresholdTriggerDetails {

    /**
     * Gets the device identifier for the device that activated the threshold trigger. 
     */
    deviceId: string;

    /**
     * Gets the type of sensor associated with the threshold trigger. 
     */
    sensorType: undefined.SensorType
}


/**
 * Represents a Quaternion. 
 */
declare class SensorQuaternion {

    /**
     * Gets the w-value of the Quaternion. 
     */
    w: number;

    /**
     * Gets the x-value of the Quaternion. 
     */
    x: number;

    /**
     * Gets the y-value of the Quaternion. 
     */
    y: number;

    /**
     * Gets the z-value of the Quaternion. 
     */
    z: number
}


/**
 * Represents a 3x3 rotation matrix. 
 */
declare class SensorRotationMatrix {

    /**
     * Gets the value at row 1, column 1 of the given rotation matrix. 
     */
    m11: number;

    /**
     * Gets the value at row 1, column 2 of the given rotation matrix. 
     */
    m12: number;

    /**
     * Gets the value at row 1, column 3 of the given rotation matrix. 
     */
    m13: number;

    /**
     * Gets the value at row 2, column 1 of the given rotation matrix. 
     */
    m21: number;

    /**
     * Gets the value at row 2, column 2 of the given rotation matrix. 
     */
    m22: number;

    /**
     * Gets the value at row 2, column 3 of the given rotation matrix. 
     */
    m23: number;

    /**
     * Gets the value at row 3, column 1 of the given rotation matrix. 
     */
    m31: number;

    /**
     * Gets the value at row 3, column 2 of the given rotation matrix. 
     */
    m32: number;

    /**
     * Gets the value at row 3, column 3 of the given rotation matrix. 
     */
    m33: number
}


/**
 * Represents a simple orientation sensor. 
 */
declare class SimpleOrientationSensor {

    /**
     * Gets the default simple orientation sensor.
     * @return  The default simple orientation sensor or null if no simple orientation sensors are found.
     */
    getDefault(): undefined.SimpleOrientationSensor;

    /**
     * Gets the device identifier. 
     */
    deviceId: string;

    /**
     * Gets the default simple orientation sensor.
     * @return  The default simple orientation sensor.
     */
    getCurrentOrientation(): undefined.SimpleOrientation;

    /**
     * Occurs each time the simple orientation sensor reports a new sensor reading 
     */
    onorientationchanged: undefined.TypedEventHandler<undefined.SimpleOrientationSensor, undefined.SimpleOrientationSensorOrientationChangedEventArgs>;
    addEventListener(
        type: "orientationchanged",
        listener: undefined.TypedEventHandler<undefined.SimpleOrientationSensor, undefined.SimpleOrientationSensorOrientationChangedEventArgs>): void;
    removeEventListener(
        type: "orientationchanged",
        listener: undefined.TypedEventHandler<undefined.SimpleOrientationSensor, undefined.SimpleOrientationSensorOrientationChangedEventArgs>): void;

    /**
     * Gets or sets the transformation that needs to be applied to sensor data. Transformations to be applied are tied to the display orientation with which to align the sensor data. 
     */
    readingTransform: undefined.DisplayOrientations;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the sensor reading–changed event. 
 */
declare class SimpleOrientationSensorOrientationChangedEventArgs {

    /**
     * Gets the current sensor orientation. 
     */
    orientation: undefined.SimpleOrientation;

    /**
     * Gets the time of the current sensor reading. 
     */
    timestamp: Date
}


/**
 * Identifies a threshold for sensor data. When this threshold is crossed, the sensor trigger will activate. 
 */
declare type Sensors$ISensorDataThreshold = {} & Windows$IInspectable



/**
 * Represents the object that is passed as a parameter to the event handler that is invoked when error occurs on the serial port. 
 */
declare class ErrorReceivedEventArgs {

    /**
     * Gets the character type received that caused the event on the serial port. 
     */
    error: undefined.SerialError
}


/**
 * Represents the object that is passed as a parameter to the event handler that is invoked when the state of a signal line changes on the serial port. 
 */
declare class PinChangedEventArgs {

    /**
     * Gets the type of signal change that caused the event on the serial port. 
     */
    pinChange: undefined.SerialPinChange
}


/**
 * Represents a serial port. The object provides methods and properties that an app can use to find the port (in the system). 
 */
declare class SerialDevice {

    /**
     * Starts an asynchronous operation that creates a SerialDevice object.
     * @param deviceId The device instance path of the device. To obtain that value, get the DeviceInformation.Id property value.
     * @return  Returns an IAsyncOperation(SerialDevice) object that returns the results of the operation.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.SerialDevice>;

    /**
     * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find a serial device by specifying its port name.
     * @param portName The serial port name. For example, "COM1".
     * @return  String formatted as an AQS query.
     */
    getDeviceSelector(portName: string): string;

    /**
     * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find all serial devices on the system.
     * @return  String formatted as an AQS query.
     */
    getDeviceSelector(): string;

    /**
     * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find a specific Serial-to-USB device by specifying it's VID and PID.
     * @param vendorId Specifies the vendor identifier for the device as assigned by the USB specification committee. Possible values are 0 through 0xffff.
     * @param productId Specifies the product identifier. This value is assigned by the manufacturer and is device-specific. Possible values are 0 through 0xffff.
     * @return  String formatted as an AQS query.
     */
    getDeviceSelectorFromUsbVidPid(vendorId: number, productId: number): string;

    /**
     * Gets or sets the baud rate. 
     */
    baudRate: number;

    /**
     * Gets or sets the break signal state. 
     */
    breakSignalState: boolean;

    /**
     * Represents the number of bytes received by the last read operation of the input stream. 
     */
    bytesReceived: number;

    /**
     * Gets the state of the Carrier Detect (CD) line. 
     */
    carrierDetectState: boolean;

    /**
     * Gets the state of the Clear-to-Send (CTS) line. 
     */
    clearToSendState: boolean;

    /**
     * Releases the reference to the SerialDevice object that was previously obtained by calling FromIdAsync . 
     */
    close(): void;

    /**
     * The number of data bits in each character value that is transmitted or received, and does not include parity bits or stop bits. 
     */
    dataBits: number;

    /**
     * Gets the state of the Data Set Ready (DSR) signal. 
     */
    dataSetReadyState: boolean;

    /**
     * Gets or sets the handshaking protocol for flow control. 
     */
    handshake: undefined.SerialHandshake;

    /**
     * Input stream that contains the data received on the serial port. 
     */
    inputStream: undefined.IInputStream;

    /**
     * Gets or sets a value that enables the Data Terminal Ready (DTR) signal. 
     */
    isDataTerminalReadyEnabled: boolean;

    /**
     * Gets or sets a value that enables the Request to Send (RTS) signal. 
     */
    isRequestToSendEnabled: boolean;

    /**
     * Event handler that is invoked when error occurs on the serial port. 
     */
    onerrorreceived: undefined.TypedEventHandler<undefined.SerialDevice, undefined.ErrorReceivedEventArgs>;
    addEventListener(
        type: "errorreceived",
        listener: undefined.TypedEventHandler<undefined.SerialDevice, undefined.ErrorReceivedEventArgs>): void;
    removeEventListener(
        type: "errorreceived",
        listener: undefined.TypedEventHandler<undefined.SerialDevice, undefined.ErrorReceivedEventArgs>): void;

    /**
     * Event handler that is invoked when the state of a signal or line changes on the serial port. 
     */
    onpinchanged: undefined.TypedEventHandler<undefined.SerialDevice, undefined.PinChangedEventArgs>;
    addEventListener(
        type: "pinchanged",
        listener: undefined.TypedEventHandler<undefined.SerialDevice, undefined.PinChangedEventArgs>): void;
    removeEventListener(
        type: "pinchanged",
        listener: undefined.TypedEventHandler<undefined.SerialDevice, undefined.PinChangedEventArgs>): void;

    /**
     * Gets an output stream to which the app can write data to transmit through the serial port. 
     */
    outputStream: undefined.IOutputStream;

    /**
     * Gets or sets the parity bit for error-checking. 
     */
    parity: undefined.SerialParity;

    /**
     * Gets the port name for serial communications. 
     */
    portName: string;

    /**
     * Gets or sets the time-out value for a read operation. 
     */
    readTimeout: number;

    /**
     * Gets or sets the standard number of stop bits per byte. 
     */
    stopBits: undefined.SerialStopBitCount;

    /**
     * Gets the idProduct field of the USB device descriptor. This value indicates the device-specific product identifier and is assigned by the manufacturer. 
     */
    usbProductId: number;

    /**
     * Gets the idVendor field of the USB device descriptor. The value indicates the vendor identifier for the device as assigned by the USB specification committee. 
     */
    usbVendorId: number;

    /**
     * Gets or sets the time-out value for a write operation. 
     */
    writeTimeout: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the CardAdded event. 
 */
declare class CardAddedEventArgs {

    /**
     * Gets info about the smart card that was inserted into the smart card reader. 
     */
    smartCard: undefined.SmartCard
}


/**
 * Provides data for the CardRemoved event. 
 */
declare class CardRemovedEventArgs {

    /**
     * Gets info about the smart card that was taken out of the smart card reader. 
     */
    smartCard: undefined.SmartCard
}


/**
 * Represents info about a smart card. 
 */
declare class SmartCard {

    /**
     * Establishes a connection to the smart card and returns a SmartCardConnection object representing the connection.
     * @return  Asynchronous operation that, when complete, returns the SmartCardConnection object representing the connection.
     */
    connectAsync(): undefined.IPromiseWithIAsyncOperation<undefined.SmartCardConnection>;

    /**
     * Returns the smart card's Answer to Reset (ATR), a standard series of bytes that contains info about the smart card's characteristics, behaviors, and state.
     * @return  The smart card's ATR byte set.
     */
    getAnswerToResetAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Returns the smart card's status.
     * @return  One of the SmartCardStatus enumeration values, representing the smart card's status.
     */
    getStatusAsync(): undefined.IPromiseWithIAsyncOperation<undefined.SmartCardStatus>;

    /**
     * Gets info about the smart card reader into which the smart card is inserted. 
     */
    reader: undefined.SmartCardReader
}


/**
 * Represents a smart card authentication challenge/response operation. 
 */
declare class SmartCardChallengeContext {

    /**
     * Gets the smart card's challenge value. 
     */
    challenge: undefined.IBuffer;

    /**
     * Changes the smart card's admin key (also known as an administrator PIN or unblock PIN).
     * @param response The response to a smart card authentication challenge/response operation.
     * @param newAdministrativeKey The new smart card admin key.
     * @return  An asynchronous action that completes after the admin key change attempt is done.
     */
    changeAdministrativeKeyAsync(
        response: undefined.IBuffer,
        newAdministrativeKey: undefined.IBuffer): undefined.IPromiseWithIAsyncAction;

    /**
     * Completes the smart card authentication challenge/response operation and frees associated system resources. 
     */
    close(): void;

    /**
     * Reconfigures an existing, configured smart card with a new response. Optionally, formats the smart card.
     * @param response The new response to a smart card authentication challenge/response operation.
     * @param formatCard True to format the smart card; otherwise false.
     * @return  An asynchronous action that completes after the smart card reconfiguration attempt is done.
     */
    provisionAsync(
        response: undefined.IBuffer,
        formatCard: boolean): undefined.IPromiseWithIAsyncAction;

    /**
     * Reconfigures an existing, configured smart card with a new response and ID. Optionally, formats the smart card.
     * @param response The new response to a smart card authentication challenge/response operation.
     * @param formatCard True to format the smart card; otherwise false.
     * @param newCardId The new smart card ID.
     * @return  An asynchronous action that completes after the smart card reconfiguration attempt is done.
     */
    provisionAsync(
        response: undefined.IBuffer,
        formatCard: boolean,
        newCardId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Verifies the response to the smart card challenge request.
     * @param response The response to the smart card challenge request.
     * @return  After the verification attempt is done, true if the response was successfully verified; otherwise false.
     */
    verifyResponseAsync(response: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<boolean >
}


/**
 * Represents a connection to a smart card. 
 */
declare class SmartCardConnection {

    /**
     * Completes the smart card authentication challenge/response operation and frees associated system resources. 
     */
    close(): void;

    /**
     * Asynchronously transmits the supplied application protocol data unit (APDU) command and returns the response.
     * @param command The APDU command to transmit to the smart card.
     * @return  An asynchronous operation that, when completed, returns the response to the command that was transmitted.
     */
    transmitAsync(
        command: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer >
}


/**
 * Represents a set of personal identification number (PIN) rules on a Trusted Platform Module (TPM) virtual smart card. 
 */
declare class SmartCardPinPolicy {

    /**
     * Creates and initializes a new instance of a set of personal identification number (PIN) rules on a Trusted Platform Module (TPM) virtual smart card. 
     */
    constructor(): this;

    /**
     * Gets or sets whether number characters are allowed for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card. 
     */
    digits: undefined.SmartCardPinCharacterPolicyOption;

    /**
     * Gets or sets whether lowercase letter characters are allowed for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card. 
     */
    lowercaseLetters: undefined.SmartCardPinCharacterPolicyOption;

    /**
     * Gets or sets the maximum character length for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card. 
     */
    maxLength: number;

    /**
     * Gets or sets the minimum character length for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card. 
     */
    minLength: number;

    /**
     * Gets or sets whether special characters are allowed for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card. 
     */
    specialCharacters: undefined.SmartCardPinCharacterPolicyOption;

    /**
     * Gets or sets whether uppercase letter characters are allowed for a personal identification number (PIN) on a Trusted Platform Module (TPM) virtual smart card. 
     */
    uppercaseLetters: undefined.SmartCardPinCharacterPolicyOption
}


/**
 * Represents a wait time for a requested smart card personal identification number (PIN) reset. 
 */
declare class SmartCardPinResetDeferral {

    /**
     * Returns a wait time completion for a smart card personal identification number (PIN) reset. 
     */
    complete(): void
}


/**
 * Represents a smart card personal identification number (PIN) reset request. 
 */
declare class SmartCardPinResetRequest {

    /**
     * Gets the smart card's challenge value. 
     */
    challenge: undefined.IBuffer;

    /**
     * Gets the length of time to wait before requesting the smart card personal identification number (PIN) reset. 
     */
    deadline: Date;

    /**
     * Gets an instance of a wait time for a requested smart card personal identification number (PIN) reset.
     * @return  An instance of a wait time for a requested smart card PIN reset.
     */
    getDeferral(): undefined.SmartCardPinResetDeferral;

    /**
     * Sets the response to a smart card authentication challenge/response operation.
     * @param response The response to a smart card authentication challenge/response operation.
     */
    setResponse(response: undefined.IBuffer): void
}


/**
 * Represents info about, and operations for, configuring smart cards. 
 */
declare class SmartCardProvisioning {

    /**
     * Returns a smart card to be configured.
     * @param card The specified smart card.
     * @return  An instance of SmartCardProvisioning , representing the smart card to be configured.
     */
    fromSmartCardAsync(
        card: undefined.SmartCard): undefined.IPromiseWithIAsyncOperation<undefined.SmartCardProvisioning>;
    requestAttestedVirtualSmartCardCreationAsync: any;

    /**
     * Creates a Trusted Platform Module (TPM) virtual smart card with a given human-readable name, admin key, personal identification number (PIN) rules set, and ID.
     * @param friendlyName The smart card's human-readable name.
     * @param administrativeKey The smart card's admin key (also known as an administrator PIN or unblock PIN).
     * @param pinPolicy The smart card's PIN rules set.
     * @param cardId The smart card's ID.
     * @return  After the operation completes, returns an instance of SmartCardProvisioning , representing the configured TPM virtual smart card.
     */
    requestVirtualSmartCardCreationAsync(
        friendlyName: string,
        administrativeKey: undefined.IBuffer,
        pinPolicy: undefined.SmartCardPinPolicy,
        cardId: string): undefined.IPromiseWithIAsyncOperation<undefined.SmartCardProvisioning>;

    /**
     * Creates a Trusted Platform Module (TPM) virtual smart card with a given human-readable name, admin key, and personal identification number (PIN) rules set.
     * @param friendlyName The smart card's human-readable name.
     * @param administrativeKey The smart card's admin key (also known as an administrator PIN or unblock PIN).
     * @param pinPolicy The smart card's PIN rules set.
     * @return  After the operation completes, returns an instance of SmartCardProvisioning , representing the configured TPM virtual smart card.
     */
    requestVirtualSmartCardCreationAsync(
        friendlyName: string,
        administrativeKey: undefined.IBuffer,
        pinPolicy: undefined.SmartCardPinPolicy): undefined.IPromiseWithIAsyncOperation<undefined.SmartCardProvisioning>;

    /**
     * Deletes a Trusted Platform Module (TPM) virtual smart card.
     * @param card The TPM virtual smart card to delete.
     * @return  After the deletion attempt completes, returns true if the TPM virtual smart card was successfully deleted; otherwise false.
     */
    requestVirtualSmartCardDeletionAsync(card: undefined.SmartCard): undefined.IPromiseWithIAsyncOperation<boolean>;
    getAuthorityKeyContainerNameAsync: any;

    /**
     * Returns a smart card's authentication challenge/response context.
     * @return  After the asynchronous operation completes, returns an instance of SmartCardChalllengeContext , representing the smart card's authentication challenge/response context.
     */
    getChallengeContextAsync(): undefined.IPromiseWithIAsyncOperation<undefined.SmartCardChallengeContext>;

    /**
     * Returns the smart card's ID.
     * @return  After the asynchronous operation completes, returns the smart card's ID.
     */
    getIdAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Returns the smart card's minidriver name.
     * @return  After the asynchronous operation completes, returns the smart card's name.
     */
    getNameAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Changes a smart card's personal identification number (PIN).
     * @return  After the smart card PIN change attempt completes, returns true if the smart card's PIN was successfully changed; otherwise false.
     */
    requestPinChangeAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Resets a smart card's personal identification number (PIN).
     * @param handler The method that handles the smart card PIN reset.
     * @return  After the smart card PIN reset attempt completes, returns true if the smart card's PIN was successfully reset; otherwise false.
     */
    requestPinResetAsync(
        handler: undefined.SmartCardPinResetHandler): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets the configured smart card. 
     */
    smartCard: undefined.SmartCard
}


/**
 * Represents info about a smart card reader. 
 */
declare class SmartCardReader {

    /**
     * Returns a smart card reader that matches the specified device ID.
     * @param deviceId The smart card reader's device ID.
     * @return  The matching smart card reader.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.SmartCardReader>;

    /**
     * Returns an Advanced Query Syntax (AQS) string representing a set of a specific type of smart card readers connected to the device. This string is passed to the FindAllAsync method to enumerate the given set of smart card readers.
     * @param kind One of the enumeration values, representing a specific smart card reader type.
     * @return  The Advanced Query Syntax (AQS) string representing a set of the specified type of smart card readers connected to the device.
     */
    getDeviceSelector(kind: undefined.SmartCardReaderKind): string;

    /**
     * Returns an Advanced Query Syntax (AQS) string representing all smart card readers connected to the device. This string is passed to the FindAllAsync method to enumerate the given set of smart card readers.
     * @return  The Advanced Query Syntax (AQS) string representing all smart card readers connected to the device.
     */
    getDeviceSelector(): string;

    /**
     * Gets the smart card reader's device ID. 
     */
    deviceId: string;

    /**
     * Returns a list of info about all smart cards that are connected to the smart card reader.
     * @return  After the operation completes, returns the list of info about all smart cards that are connected to the smart card reader.
     */
    findAllCardsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Returns the smart card reader's status.
     * @return  After the status request completes, returns one of the SmartCardReaderStatus enumeration values, representing the smart card reader's status.
     */
    getStatusAsync(): undefined.IPromiseWithIAsyncOperation<undefined.SmartCardReaderStatus>;

    /**
     * Gets the smart card reader's type. 
     */
    kind: undefined.SmartCardReaderKind;

    /**
     * Gets the smart card reader's device name. 
     */
    name: string;

    /**
     * Occurs when a smart card is inserted into the smart card reader or tapped on an NFC reader. 
     */
    oncardadded: undefined.TypedEventHandler<undefined.SmartCardReader, undefined.CardAddedEventArgs>;
    addEventListener(
        type: "cardadded",
        listener: undefined.TypedEventHandler<undefined.SmartCardReader, undefined.CardAddedEventArgs>): void;
    removeEventListener(
        type: "cardadded",
        listener: undefined.TypedEventHandler<undefined.SmartCardReader, undefined.CardAddedEventArgs>): void;

    /**
     * Occurs when a smart card is taken out of the smart card reader. 
     */
    oncardremoved: undefined.TypedEventHandler<undefined.SmartCardReader, undefined.CardRemovedEventArgs>;
    addEventListener(
        type: "cardremoved",
        listener: undefined.TypedEventHandler<undefined.SmartCardReader, undefined.CardRemovedEventArgs>): void;
    removeEventListener(
        type: "cardremoved",
        listener: undefined.TypedEventHandler<undefined.SmartCardReader, undefined.CardRemovedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a method that handles a smart card personal identification number (PIN) reset. 
 */
declare type SmartCards$SmartCardPinResetHandler = (
    sender: undefined.SmartCardProvisioning,
    request: undefined.SmartCardPinResetRequest) => void;


/**
 * Enables start, track, and end an asynchronous message delete operation for a single message. 
 */
declare class DeleteSmsMessageOperation {

    /**
     * Cancels the asynchronous SMS message delete operation. 
     */
    cancel(): void;

    /**
     * Closes the asynchronous SMS message delete operation. 
     */
    close(): void;

    /**
     * Specifies whether the asynchronous SMS message delete operation has completed or not. 
     */
    completed: undefined.AsyncActionCompletedHandler;

    /**
     * Specifies the error code for the asynchronous SMS message delete operation. 
     */
    errorCode: Windows$WinRTError;

    /**
     * Retrieves the result of the asynchronous SMS message delete operation. 
     */
    getResults(): void;

    /**
     * Specifies the ID of the asynchronous SMS message delete operation. 
     */
    id: number;

    /**
     * Specifies the status of the asynchronous SMS message delete operation. 
     */
    status: undefined.AsyncStatus
}


/**
 * Enables start, track, and end asynchronous SMS message delete operations for multiple messages. 
 */
declare class DeleteSmsMessagesOperation {

    /**
     * Cancels the asynchronous SMS message delete operations. 
     */
    cancel(): void;

    /**
     * Closes the asynchronous SMS message delete operations. 
     */
    close(): void;

    /**
     * Specifies whether the asynchronous SMS message delete operations have completed or not. 
     */
    completed: undefined.AsyncActionCompletedHandler;

    /**
     * Specifies the error code for the asynchronous SMS message delete operations. 
     */
    errorCode: Windows$WinRTError;

    /**
     * Retrieves the result of the asynchronous message operations. 
     */
    getResults(): void;

    /**
     * Specifies the ID of the asynchronous SMS message delete operations. 
     */
    id: number;

    /**
     * Specifies the status of the asynchronous SMS message delete operations. 
     */
    status: undefined.AsyncStatus
}


/**
 * Retrieves an SmsDevice object asynchronously. 
 */
declare class GetSmsDeviceOperation {

    /**
     * Cancels the asynchronous SmsDevice object retrieval. 
     */
    cancel(): void;

    /**
     * Closes the asynchronous SmsDevice object retrieval operation. 
     */
    close(): void;

    /**
     * Specifies whether the asynchronous SmsDevice object retrieval operation has completed or not. 
     */
    completed: undefined.AsyncOperationCompletedHandler<undefined.SmsDevice>;

    /**
     * Specifies the error code for the asynchronous SmsDevice object retrieval operation 
     */
    errorCode: Windows$WinRTError;

    /**
     * Gets the results of the asynchronous SmsDevice object retrieval operation.
     * @return  A reference to an SmsDevice object.
     */
    getResults(): undefined.SmsDevice;

    /**
     * Specifies the ID of the asynchronous SmsDevice object retrieval operation. 
     */
    id: number;

    /**
     * Specifies the status of the asynchronous SmsDevice object retrieval operation. 
     */
    status: undefined.AsyncStatus
}


/**
 * Supports the retrieval of a message from the SMS message store. 
 */
declare class GetSmsMessageOperation {

    /**
     * Cancels the asynchronous SMS message retrieval operation. 
     */
    cancel(): void;

    /**
     * Closes the asynchronous SMS message retrieval operation. 
     */
    close(): void;

    /**
     * A handler for the completed event of an asynchronous SMS message retrieval operation. 
     */
    completed: undefined.AsyncOperationCompletedHandler<undefined.ISmsMessage>;

    /**
     * Specifies the error code for the asynchronous SMS message retrieval operation. 
     */
    errorCode: Windows$WinRTError;

    /**
     * Retrieves the result of the asynchronous SMS message retrieval operation.
     * @return  An interface that accesses the retrieved message.
     */
    getResults(): undefined.ISmsMessage;

    /**
     * Specifies the ID of the asynchronous SMS message retrieval operation. 
     */
    id: number;

    /**
     * Specifies the status of the asynchronous SMS message retrieval operation. 
     */
    status: undefined.AsyncStatus
}


/**
 * Supports the retrieval of messages. 
 */
declare class GetSmsMessagesOperation {

    /**
     * Cancels the asynchronous operations. 
     */
    cancel(): void;

    /**
     * Closes the asynchronous operations. 
     */
    close(): void;

    /**
     * Specifies whether the asynchronous message retrieval operation has completed or not. 
     */
    completed: undefined.AsyncOperationWithProgressCompletedHandler<undefined.IVectorView<any>, number>;

    /**
     * Specifies the error code for the asynchronous message operation. 
     */
    errorCode: Windows$WinRTError;

    /**
     * Retrieves the result of the asynchronous message retrieval operation.
     * @return  A reference to the SMS messages retrieved.
     */
    getResults(): undefined.IVectorView<undefined.ISmsMessage>;

    /**
     * Indicates the ID of the asynchronous message operation. 
     */
    id: number;

    /**
     * Specifies the progress status of the asynchronous message operation. 
     */
    progress: undefined.AsyncOperationProgressHandler<undefined.IVectorView<any>, number>;

    /**
     * Specifies the status of the asynchronous message operations. 
     */
    status: undefined.AsyncStatus
}


/**
 * Enables the sending of a message. 
 */
declare class SendSmsMessageOperation {

    /**
     * Cancels the asynchronous operation. 
     */
    cancel(): void;

    /**
     * Closes the asynchronous operation. 
     */
    close(): void;

    /**
     * A handler for the completed event of an asynchronous action. 
     */
    completed: undefined.AsyncActionCompletedHandler;

    /**
     * Specifies the error code for the asynchronous message operation. 
     */
    errorCode: Windows$WinRTError;

    /**
     * Retrieves the result of the asynchronous operation. 
     */
    getResults(): void;

    /**
     * Indicates the ID of the asynchronous message operation. 
     */
    id: number;

    /**
     * Specifies the status of the asynchronous message operation. 
     */
    status: undefined.AsyncStatus
}


/**
 * The interface for manipulating an SMS Application message. Application messages are those which cannot be characterized as any other message type. 
 */
declare class SmsAppMessage {

    /**
     * Constructor. Used to create an SmsAppMessage prior to sending it. 
     */
    constructor(): this;

    /**
     * Reads or writes the binary part of the Application message. 
     */
    binaryBody: undefined.IBuffer;

    /**
     * The plain text body of the message. 
     */
    body: string;

    /**
     * The number to be dialed in reply to a received SMS message. 
     */
    callbackNumber: string;

    /**
     * The class of the cellular device that received the message. 
     */
    cellularClass: undefined.CellularClass;

    /**
     * The device ID of the device that received the message. 
     */
    deviceId: string;

    /**
     * The encoding used to send the message. 
     */
    encoding: undefined.SmsEncoding;

    /**
     * The telephone number of the sender of the message. 
     */
    from: string;

    /**
     * Indicates whether an SMS delivery status report was sent by the SMSC. 
     */
    isDeliveryNotificationEnabled: boolean;

    /**
     * The message class of the message. 
     */
    messageClass: undefined.SmsMessageClass;

    /**
     * The message type of the message. 
     */
    messageType: undefined.SmsMessageType;

    /**
     * The port number of the message. 
     */
    portNumber: number;

    /**
     * The Protocol identifier for the message. 
     */
    protocolId: number;

    /**
     * The retry attempt count for the message. 
     */
    retryAttemptCount: number;

    /**
     * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message. 
     */
    simIccId: string;

    /**
     * The Teleservice identifier for the message. 
     */
    teleserviceId: number;

    /**
     * The timestamp of the message. 
     */
    timestamp: Date;

    /**
     * The telephone number of the recipient of this message. 
     */
    to: string
}


/**
 * Represents an SMS message in raw PDU format. The data format differs depending on whether the message format (indicated by the value of the Format property) is GSM or CDMA. 
 */
declare class SmsBinaryMessage {

    /**
     * Creates an instance of the SmsBinaryMessage class. 
     */
    constructor(): this;

    /**
     * Retrieves the detected protocol description unit (PDU) format of this message. 
     */
    format: undefined.SmsDataFormat;

    /**
     * Returns the raw buffer of the message in binary protocol description unit (PDU) format as a byte array.
     * @return  A byte array representing message data. If there is no message data, the returned array is empty.
     */
    getData(): number[];

    /**
     * Indicates the ID of the asynchronous message operation. 
     */
    id: number;

    /**
     * Returns the message class, as determined by the operator's message network. The two most common classes are None (normal message) or Class0 (special operator message, such as a roaming warning that must be shown immediately to the user). A typical client for end-user messages ignores Class0 messages. 
     */
    messageClass: undefined.SmsMessageClass;

    /**
     * Specifies the raw binary payload of the SMS message. It should be formatted according to the protocol description unit (PDU) standard.
     * @param value A byte array representing message data. If there is no message data, the returned array is empty.
     */
    setData(value: number[]): void
}


/**
 * Represents a broadcast SMS message. 
 */
declare class SmsBroadcastMessage {

    /**
     * Gets the body of the broadcast SMS message. 
     */
    body: string;

    /**
     * Gets the type of this broadcast SMS message. 
     */
    broadcastType: undefined.SmsBroadcastType;

    /**
     * Gets the cellular class of this broadcast message. 
     */
    cellularClass: undefined.CellularClass;

    /**
     * Gets the channel associated with the broadcast SMS message. 
     */
    channel: number;

    /**
     * Gets the device ID of the device that received the broadcast SMS message. 
     */
    deviceId: string;

    /**
     * Gets the geographical scope associated with this broadcast SMS message. 
     */
    geographicalScope: undefined.SmsGeographicalScope;

    /**
     * True when the broadcast SMS message is an emergency alert. 
     */
    isEmergencyAlert: boolean;

    /**
     * True when a user popup is requested by this broadcast SMS message. 
     */
    isUserPopupRequested: boolean;

    /**
     * Gets the message class associated with this broadcast SMS message. 
     */
    messageClass: undefined.SmsMessageClass;

    /**
     * Gets a code value associated with this broadcast SMS message. 
     */
    messageCode: number;

    /**
     * Gets the message type of the broadcast SMS message. 
     */
    messageType: undefined.SmsMessageType;

    /**
     * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message. 
     */
    simIccId: string;

    /**
     * Gets the timestamp of the broadcast SMS message. 
     */
    timestamp: Date;

    /**
     * Gets the recipient phone number of the broadcast SMS message. 
     */
    to: string;

    /**
     * Gets the update number associated with this broadcast SMS message. 
     */
    updateNumber: number
}


/**
 * Supports the operation of a mobile broadband SMS device. 
 */
declare class SmsDevice {

    /**
     * Creates an instance of SmsDevice for the device that received the SMS message.
     * @param deviceId A string representation of the DeviceInformation ID of the SMS device that received the SMS message.
     * @return  The SMS device operation object.
     */
    fromIdAsync(deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.SmsDevice>;

    /**
     * Creates an instance of SmsDevice for the specified Mobile Broadband network account ID.
     * @param networkAccountId The Mobile Broadband network account ID to use to select the corresponding mobile broadband device to use for the SMS device
     * @return  When this method completes, it returns the SmsDevice for the specified Mobile Broadband network account ID.
     */
    fromNetworkAccountIdAsync(
        networkAccountId: string): undefined.IPromiseWithIAsyncOperation<undefined.SmsDevice>;

    /**
     * Creates an instance of an SmsDevice object associated with the default SMS device. Because the device might be busy, the operation executes asynchronously. The asynchronous operation object returns immediately.
     * @return  A reference to an IAsyncOperation(SmsDevice) object that supports asynchronous SmsDevice object retrieval.
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.SmsDevice>;

    /**
     * Retrieves the class selection string that can be used to enumerate SMS devices.
     * @return  A reference to an Advanced Query Syntax (AQS) string that identifies an SMS device.
     */
    getDeviceSelector(): string;

    /**
     * Returns the phone number associated with the SMS device. The phone number can be used to associate incoming messages with the account and possibly an external storage mechanism such as an account inbox. 
     */
    accountPhoneNumber: string;

    /**
     * Estimates the transmitted message length of the specified text message. The estimate can be useful to clients who want to give an indication of how many messages will be sent on the network to carry the text of the full message.
     * @param message A reference to the SMS text message to measure.
     * @return  A reference to an SmsEncodedLength structure that is populated with the length information.
     */
    calculateLength(message: undefined.SmsTextMessage): undefined.SmsEncodedLength;

    /**
     * Returns the cellular class of the SMS device. The class can be used to determine which encodings are appropriate or which device limitations are in effect. 
     */
    cellularClass: undefined.CellularClass;

    /**
     * Returns the SMS device's status, which indicates whether the device is ready, or not. It also indicates what type of problem exists if the device is not ready. 
     */
    deviceStatus: undefined.SmsDeviceStatus;

    /**
     * Accesses the on-device message store. The store holds messages until a client can retrieve them. On some devices, for example, the store may correspond to the SIM storage for SMS messages. 
     */
    messageStore: undefined.SmsDeviceMessageStore;

    /**
     * Sets an event handler to be called when the status of the SMS device changes. 
     */
    onsmsdevicestatuschanged: undefined.SmsDeviceStatusChangedEventHandler;
    addEventListener(
        type: "smsdevicestatuschanged",
        listener: undefined.SmsDeviceStatusChangedEventHandler): void;
    removeEventListener(
        type: "smsdevicestatuschanged",
        listener: undefined.SmsDeviceStatusChangedEventHandler): void;

    /**
     * Sets an event handler to be called when the device receives a new text message. 
     */
    onsmsmessagereceived: undefined.SmsMessageReceivedEventHandler;
    addEventListener(
        type: "smsmessagereceived",
        listener: undefined.SmsMessageReceivedEventHandler): void;
    removeEventListener(
        type: "smsmessagereceived",
        listener: undefined.SmsMessageReceivedEventHandler): void;

    /**
     * Asynchronously sends a message using the SMS device. The method is asynchronous because the send operation might not occur instantaneously. The message operation object is returned immediately.
     * @param message A reference to an ISmsMessage object. The message can be in text or binary format.
     * @return  The message operation object.
     */
    sendMessageAsync(
        message: undefined.ISmsMessage): undefined.IPromiseWithOperation<any, undefined.SendSmsMessageOperation>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Extends the SmsDevice class, and supports the operation of a mobile broadband SMS device. 
 */
declare class SmsDevice2 {

    /**
     * Creates an instance of SmsDevice2 for a device that received an SMS message.
     * @param deviceId A string representation of the device ID of the device that received an SMS message.
     * @return  An instance of SmsDevice2 initialized for the device with the given ID.
     */
    fromId(deviceId: string): undefined.SmsDevice2;

    /**
     * Creates an instance of SmsDevice2 for a device, given the device ID of the parent device.
     * @param parentDeviceId The device ID of the parent device.
     * @return  An instance of SmsDevice2 initialized for the device with the given parent ID.
     */
    fromParentId(parentDeviceId: string): undefined.SmsDevice2;

    /**
     * Creates an instance of SmsDevice2 associated with the default SMS device.
     * @return  An instance of SmsDevice2 initialized for the default SMS device.
     */
    getDefault(): undefined.SmsDevice2;

    /**
     * Retrieves the class selection string that can be used to enumerate SMS devices.
     * @return  A reference to an Advanced Query Syntax (AQS) string that identifies an SMS device.
     */
    getDeviceSelector(): string;

    /**
     * Gets the phone number associated with the SMS device. The phone number can be used to associate incoming messages with the account and possibly an external storage mechanism such as an account inbox. 
     */
    accountPhoneNumber: string;

    /**
     * Estimates the transmitted message length of the specified text message. The estimate can be useful to clients that want to give an indication of how many messages will be sent on the network to carry the text of the full message.
     * @param message A reference to the SMS text message to measure.
     * @return  A reference to an SmsEncodedLength structure that is populated with the length information.
     */
    calculateLength(message: undefined.ISmsMessageBase): undefined.SmsEncodedLength;

    /**
     * Returns the cellular class of the SMS device. The class can be used to determine which encodings are appropriate or which device limitations are in effect. 
     */
    cellularClass: undefined.CellularClass;

    /**
     * The device ID of the device represented by this instance. 
     */
    deviceId: string;

    /**
     * Returns the SMS device's status, which indicates whether the device is ready, or not. It also indicates what type of problem exists if the device is not ready. 
     */
    deviceStatus: undefined.SmsDeviceStatus;

    /**
     * Sets an event handler to be called when the status of the SMS device changes. 
     */
    ondevicestatuschanged: undefined.TypedEventHandler<undefined.SmsDevice2, any>;
    addEventListener(
        type: "devicestatuschanged",
        listener: undefined.TypedEventHandler<undefined.SmsDevice2, any>): void;
    removeEventListener(
        type: "devicestatuschanged",
        listener: undefined.TypedEventHandler<undefined.SmsDevice2, any>): void;

    /**
     * The parent device ID of this device. 
     */
    parentDeviceId: string;

    /**
     * Asynchronously sends a message using the SMS device. The method is asynchronous because the send operation might not occur instantaneously. The message operation object is returned immediately.
     * @param message A reference to an object that implements the ISmsMessageBase interface. The message can be in text or binary format.
     * @return  The message operation object.
     */
    sendMessageAndGetResultAsync(
        message: undefined.ISmsMessageBase): undefined.IPromiseWithIAsyncOperation<undefined.SmsSendMessageResult>;

    /**
     * Gets or sets the SMSC address of this device. 
     */
    smscAddress: string;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides access to the messages stored on an SMS Device and information about the message store. 
 */
declare class SmsDeviceMessageStore {

    /**
     * Deletes the message with the specified ID. Because the device might be busy, the operation executes asynchronously. The asynchronous operation object returns immediately.
     * @param messageId Integer ID of the message to delete, which was previously read from an SmsTextMessage object obtained from the device message store.
     * @return  A new message operation object that is used to start and track the asynchronous operation.
     */
    deleteMessageAsync(messageId: number): undefined.IPromiseWithIAsyncAction;

    /**
     * Deletes the messages to which the filter applies. The filter can be used to delete all messages, or only messages that are read, unread, sent, or in a draft state. Because the operation might not be instantaneous, it executes asynchronously. The asynchronous operation object returns immediately.
     * @param messageFilter A search filter that specifies which messages to delete.
     * @return  A new message operation object that is used to start and track the asynchronous operation.
     */
    deleteMessagesAsync(messageFilter: undefined.SmsMessageFilter): undefined.IPromiseWithIAsyncAction;

    /**
     * Retrieves the message with the specified ID. The device might be busy, so the method executes asynchronously. The asynchronous operation object returns immediately.
     * @param messageId ID of the message to retrieve.
     * @return  Returns a new message operation object that is used to start and track the asynchronous operation.
     */
    getMessageAsync(
        messageId: number): undefined.IPromiseWithIAsyncOperation<undefined.ISmsMessage>;

    /**
     * Retrieves a list of messages that match the conditions specified in a filter. The messages can be filtered as read, unread, sent, or in the draft state.
     * @param messageFilter ID of the message to retrieve.
     * @return  Returns a new message operation object that is used to start and track the asynchronous operation.
     */
    getMessagesAsync(
        messageFilter: undefined.SmsMessageFilter): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IVectorView<any>, number>;

    /**
     * Indicates the maximum number of messages that can be stored in the device store. The client can use this value to determine how to maintain enough space in the device store to receive new messages from the network. 
     */
    maxMessages: number
}


/**
 * Describes an SMS filtering rule. 
 */
declare class SmsFilterRule {

    /**
     * Creates a new, empty SmsFilterRule .
     * @param messageType An enumeration value specifying the message type that will match this rule.
     */
    constructor(messageType: undefined.SmsMessageType): this;

    /**
     * A list of broadcast channels that match this rule. 
     */
    broadcastChannels: undefined.IVector<number>;

    /**
     * Gets a list of broadcast types for an SMS message that matches this rule. 
     */
    broadcastTypes: undefined.IVector<undefined.SmsBroadcastType>;

    /**
     * The cellular class identifier for SMS messages that match this rule. 
     */
    cellularClass: undefined.CellularClass;

    /**
     * Gets a list of device identifiers for an SMS message that matches this rule. 
     */
    deviceIds: undefined.IVector<string>;

    /**
     * Gets the IMSI prefixes for an SMS message that matches this rule. 
     */
    imsiPrefixes: undefined.IVector<string>;

    /**
     * Gets the message type of an SMS message that matches this filter rule. 
     */
    messageType: undefined.SmsMessageType;

    /**
     * Gets a list of port numbers associated with the SMS message that matches this rule. 
     */
    portNumbers: undefined.IVector<number>;

    /**
     * Gets a list of protocol identifiers associated with the SMS message that matches this rule.. 
     */
    protocolIds: undefined.IVector<number>;

    /**
     * Gets the sender numbers associated with an SMS message that matches this rule. 
     */
    senderNumbers: undefined.IVector<string>;

    /**
     * Gets the list of teleservice identifiers for an SMS message that matches this rule. 
     */
    teleserviceIds: undefined.IVector<number>;

    /**
     * Gets a list of the text message prefixes for an SMS message that matches this filter. 
     */
    textMessagePrefixes: undefined.IVector<string>;

    /**
     * Gets a list of WAP application identifiers for the SMS message that matches this rule. 
     */
    wapApplicationIds: undefined.IVector<string>;

    /**
     * Gets a list of WAP content types for the SMS message that matches this rule. 
     */
    wapContentTypes: undefined.IVector<string >
}


/**
 * A collection of SmsFilterRule instances. 
 */
declare class SmsFilterRules {

    /**
     * Creates an instance of SmsFilterRules .
     * @param actionType An enumeration value that specifies which action type is to be associated with the rules for this instance. Action type determines the order in which rules are evaluated, as well as the action to be taken when a rule is matched.
     */
    constructor(actionType: undefined.SmsFilterActionType): this;

    /**
     * The SmsFilterActionType for this set of filter rules. 
     */
    actionType: undefined.SmsFilterActionType;

    /**
     * Gets the list of rules in this SmsFilterRules instance. 
     */
    rules: undefined.IVector<undefined.SmsFilterRule >
}


/**
 * Provides data for ISmsBinaryMessage event handlers. 
 */
declare class SmsMessageReceivedEventArgs {

    /**
     * Retrieves an object that holds the binary representation of the message. This is of interest only to clients who want to pass binary messages on directly or do their own interpretation of the binary message contents. 
     */
    binaryMessage: undefined.SmsBinaryMessage;

    /**
     * Retrieves an object that holds the text representation of the message. If the message is not successfully decoded, an error is returned. 
     */
    textMessage: undefined.SmsTextMessage
}


/**
 * Contains event details for the event raised when an SMS message is received. 
 */
declare class SmsMessageReceivedTriggerDetails {

    /**
     * Delivers the filtered message to the messaging app. 
     */
    accept(): void;

    /**
     * When MessageType is App, the message details for the message. 
     */
    appMessage: undefined.SmsAppMessage;

    /**
     * When MessageType is Broadcast, the message details for the message. 
     */
    broadcastMessage: undefined.SmsBroadcastMessage;

    /**
     * Drops the filtered message, so that it is not passed on to the messaging app. 
     */
    drop(): void;

    /**
     * The SmsMessageType of the received message. 
     */
    messageType: undefined.SmsMessageType;

    /**
     * When MessageType is Status, the message details for the message. 
     */
    statusMessage: undefined.SmsStatusMessage;

    /**
     * When MessageType is Text, the message details for the message. 
     */
    textMessage: undefined.SmsTextMessage2;

    /**
     * When MessageType is Voicemail, the message details for the message. 
     */
    voicemailMessage: undefined.SmsVoicemailMessage;

    /**
     * When MessageType is Wap, the message details for the message. 
     */
    wapMessage: undefined.SmsWapMessage
}


/**
 * Class used to represent registered message filters. 
 */
declare class SmsMessageRegistration {

    /**
     * Static property that gets a list of currently registered message filters.. 
     */
    allRegistrations: undefined.IVectorView<undefined.SmsMessageRegistration>;

    /**
     * Registers a message filter.
     * @param id Identifier used to describe this message filter.
     * @param filterRules An object that represents the filter rules to be used for this registered message filter.
     * @return  On successful completion, the SmsMessageRegistration object that represents this registered message filter.
     */
    register(
        id: string,
        filterRules: undefined.SmsFilterRules): undefined.SmsMessageRegistration;

    /**
     * Gets an identifier for this registered message filter. 
     */
    id: string;

    /**
     * Event signaled when a message has been received that meets the filter criteria set in a registered message filter. 
     */
    onmessagereceived: undefined.TypedEventHandler<undefined.SmsMessageRegistration, undefined.SmsMessageReceivedTriggerDetails>;
    addEventListener(
        type: "messagereceived",
        listener: undefined.TypedEventHandler<undefined.SmsMessageRegistration, undefined.SmsMessageReceivedTriggerDetails>): void;
    removeEventListener(
        type: "messagereceived",
        listener: undefined.TypedEventHandler<undefined.SmsMessageRegistration, undefined.SmsMessageReceivedTriggerDetails>): void;

    /**
     * Unregisters a previously-registered message filter. The filter will no longer be applied to incoming messages. 
     */
    unregister(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Presents the details of SMS message events to the background work item that handles messages while your app is suspended. 
 */
declare class SmsReceivedEventDetails {

    /**
     * Gets the binary message object for the SMS message received by the background task. 
     */
    binaryMessage: undefined.SmsBinaryMessage;

    /**
     * Returns the DeviceInformation ID of the network interface that received the SMS message. This ID can be passed to SmsDevice.FromIdAsync to activate the device and retrieve additional message details. 
     */
    deviceId: string;

    /**
     * Gets the message class for the SMS message received by the background task. 
     */
    messageClass: undefined.SmsMessageClass;

    /**
     * Returns the index of the new message that raised the event. You can pass this to SmsDevice.GetMessageAsync to retrieve the new message itself. 
     */
    messageIndex: number
}


/**
 * Encapsulates the results of calling SmsDevice2.SendMessageAndGetResultAsync . 
 */
declare class SmsSendMessageResult {

    /**
     * Gets the cellular class used in the send operation. 
     */
    cellularClass: undefined.CellularClass;

    /**
     * Gets a boolean value indicating whether the send operation has encountered a transient error. 
     */
    isErrorTransient: boolean;

    /**
     * Gets a value indicating whether the send operation was successful. 
     */
    isSuccessful: boolean;

    /**
     * Gets a list of message numbers sent. 
     */
    messageReferenceNumbers: undefined.IVectorView<number>;

    /**
     * Gets the error code for a modem error associated with the send operation. 
     */
    modemErrorCode: undefined.SmsModemErrorCode;

    /**
     * Gets the error code for a network error associated with the send operation. 
     */
    networkCauseCode: number;

    /**
     * Gets the error code for a transport failure associated with the send operation. 
     */
    transportFailureCause: number
}


/**
 * Encapsulates an SMS status message. 
 */
declare class SmsStatusMessage {

    /**
     * Gets the body of the status message. 
     */
    body: string;

    /**
     * Gets the cellular class of the message. 
     */
    cellularClass: undefined.CellularClass;

    /**
     * Gets the device identifier associated with the status message. 
     */
    deviceId: string;

    /**
     * The discharge time of the status message. 
     */
    dischargeTime: Date;

    /**
     * Gets the phone number that sent the status message. 
     */
    from: string;

    /**
     * Gets the message class of the status message. 
     */
    messageClass: undefined.SmsMessageClass;

    /**
     * Gets the reference number of the status message. 
     */
    messageReferenceNumber: number;

    /**
     * Gets the message type of the status message. 
     */
    messageType: undefined.SmsMessageType;

    /**
     * Gets the service center timestamp of the status message. 
     */
    serviceCenterTimestamp: Date;

    /**
     * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message. 
     */
    simIccId: string;

    /**
     * The status code associated with this message. 
     */
    status: number;

    /**
     * Gets the phone number the status message was sent to. 
     */
    to: string
}


/**
 * Manages a decoded SMS text message, providing direct access to the plain text body of the message, as well as key header properties, such as time stamp. 
 */
declare class SmsTextMessage {

    /**
     * Decodes a binary message and places the results in a new instance of a text message. This method represents the binary message as a reference to a buffer of bytes and a selection of how the buffer is encoded. Therefore, it can be used when the message did not originate directly from the device or as an instance of an SmsBinaryMessage class.
     * @param format An SmsDataFormat enumerated value that identifies the format of a particular protocol description unit (PDU) buffer.
     * @param value An array of bytes containing the binary data to decode.
     * @return  A new SmsTextMessage object if the decoding was successful.
     */
    fromBinaryData(format: undefined.SmsDataFormat, value: number[]): undefined.SmsTextMessage;

    /**
     * Reads a binary message and decodes it. The results are placed in a new instance of a text message.
     * @param binaryMessage An instance of a binary message to decode.
     * @return  A new SmsTextMessage object.
     */
    fromBinaryMessage(binaryMessage: undefined.SmsBinaryMessage): undefined.SmsTextMessage;

    /**
     * Creates an instance of the SmsTextMessage class. 
     */
    constructor(): this;

    /**
     * Specifies the plain text body of the message. 
     */
    body: string;

    /**
     * Specifies the encoding type that has been set to use when sending this message. 
     */
    encoding: undefined.SmsEncoding;

    /**
     * Specifies the phone number of the sender of the message. 
     */
    from: string;

    /**
     * Indicates the ID of the SMS text message. 
     */
    id: number;

    /**
     * Specifies the message class of a message. This message class typically originates on the network, not the mobile device. 
     */
    messageClass: undefined.SmsMessageClass;

    /**
     * Indicates the total number of parts in the original message if the message is part of a multi-part message. 
     */
    partCount: number;

    /**
     * Indicates the part number of a multi-part message if this message is part of a multi-part message. It can be used to reconstruct the original message by joining the parts together, in conjunction with the PartReferenceId and PartCount properties. 
     */
    partNumber: number;

    /**
     * Indicates a reference value that can be used if the message is part of a multi-part message. If this message belongs to a multi-part message, the PartNumber value can be used to reconstruct the full original message, and each part of that message will have the same value for PartReferenceId. 
     */
    partReferenceId: number;

    /**
     * Indicates the timestamp of the message. It is determined locally for a constructed message instance or from the service center timestamp of a received message. 
     */
    timestamp: Date;

    /**
     * Indicates the recipient phone number of this message. 
     */
    to: string;

    /**
     * Reads a message in the specified format and places the results in a new instance of a binary message.
     * @param format A value from the SmsDataFormat enumeration.
     * @return  The new binary message that holds the result of this method call.
     */
    toBinaryMessages(
        format: undefined.SmsDataFormat): undefined.IVectorView<undefined.ISmsBinaryMessage >
}


/**
 * Encapsulates a decoded SMS text message. Prefer this class to the older SmsTextMessage class. 
 */
declare class SmsTextMessage2 {

    /**
     * Constructs a new, default instance of this class. 
     */
    constructor(): this;

    /**
     * Gets or sets the body of the text message. 
     */
    body: string;

    /**
     * Gets or sets the callback number for the message. 
     */
    callbackNumber: string;

    /**
     * Gets the cellular class of the message. 
     */
    cellularClass: undefined.CellularClass;

    /**
     * Gets the device identifier for the device associated with the SMS text message. 
     */
    deviceId: string;

    /**
     * Gets or sets the encoding scheme used for the message. 
     */
    encoding: undefined.SmsEncoding;

    /**
     * gets the phone number of the sender of the message. 
     */
    from: string;

    /**
     * Gets or sets whether text message delivery notification is enabled for this message. 
     */
    isDeliveryNotificationEnabled: boolean;

    /**
     * Gets the message class of the message. 
     */
    messageClass: undefined.SmsMessageClass;

    /**
     * Gets the message type of the message. 
     */
    messageType: undefined.SmsMessageType;

    /**
     * Gets the protocol identifier for the message. 
     */
    protocolId: number;

    /**
     * Gets or sets the number of retry attempts for the message. 
     */
    retryAttemptCount: number;

    /**
     * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message. 
     */
    simIccId: string;

    /**
     * Gets the teleservice identifier associated with this message. 
     */
    teleserviceId: number;

    /**
     * The timestamp of this message. 
     */
    timestamp: Date;

    /**
     * Gets or sets the recipient phone number for the message. 
     */
    to: string
}


/**
 * Encapsulates an SMS voicemail message. 
 */
declare class SmsVoicemailMessage {

    /**
     * Gets the body of the voicemail message. 
     */
    body: string;

    /**
     * Gets the cellular class of the message. 
     */
    cellularClass: undefined.CellularClass;

    /**
     * Gets the unique device identifier associated with the message. 
     */
    deviceId: string;

    /**
     * Gets the message class of the message. 
     */
    messageClass: undefined.SmsMessageClass;

    /**
     * Gets the number of available messages. 
     */
    messageCount: number;

    /**
     * Gets the type of the message. 
     */
    messageType: undefined.SmsMessageType;

    /**
     * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message. 
     */
    simIccId: string;

    /**
     * The timestamp of the message. 
     */
    timestamp: Date;

    /**
     * The phone number the message was sent to. 
     */
    to: string
}


/**
 * Represents an SMS WAP push message. 
 */
declare class SmsWapMessage {

    /**
     * Gets the value of the X-Wap-Application-Id header of the SmsWapMessage . 
     */
    applicationId: string;

    /**
     * Gets the binary body of the blob in the SmsWapMessage . 
     */
    binaryBody: undefined.IBuffer;

    /**
     * Gets the cellular class of the SMS device that received the message. 
     */
    cellularClass: undefined.CellularClass;

    /**
     * Gets the value of the Content-Type header in the SmsWapMessage . Parameters are presents in the Headers property. 
     */
    contentType: string;

    /**
     * Gets the device information ID of the SmsDevice that receives the SmsWapMessage . 
     */
    deviceId: string;

    /**
     * Gets the phone number of the sender of the SmsWapMessage . 
     */
    from: string;

    /**
     * Gets the header name-value pairs of the WAP push message. 
     */
    headers: undefined.IMap<string, string>;

    /**
     * Gets the message class of the SmsWapMessage . 
     */
    messageClass: undefined.SmsMessageClass;

    /**
     * Gets the message type of the SmsWapMessage . 
     */
    messageType: undefined.SmsMessageType;

    /**
     * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message. 
     */
    simIccId: string;

    /**
     * Gets the timestamp of the SmsWapMessage . 
     */
    timestamp: Date;

    /**
     * Gets the recipient phone number of this SmsWapMessage . 
     */
    to: string
}


/**
 * This interface is implemented by all types of SMS messages that are supported. 
 */
declare interface Sms$ISmsMessage {

    /**
     * Retrieves an ID for the message, which can later be specified in calling message store methods in order to get or delete the message. 
     */
    id: number,

        /**
         * Returns the message class, as determined by the operator's message network. The two most common classes are None (normal message) or Class0 (special operator message, such as a roaming warning that must be shown immediately to the user). A typical client for end-user messages ignores Class0 messages. 
         */
        messageClass: undefined.SmsMessageClass
}


/**
 * This structure represents information about the length of an SmsTextMessage object when it is encoded as a PDU. 
 */
declare interface Sms$SmsEncodedLength {

    /**
     * The number of bytes in the last segment of the encoded message. 
     */
    byteCountLastSegment: number,

        /**
         * The number of bytes in each segment of the message. 
         */
        bytesPerSegment: number,

        /**
         * The number of characters in the last segment of the encoded message. 
         */
        characterCountLastSegment: number,

        /**
         * The estimated number of characters that can fit in one segment of the message. 
         */
        charactersPerSegment: number,

        /**
         * The number of segments needed to encode the message. 
         */
        segmentCount: number
}


/**
 * This handler is called when the status on the SMS device changes. Callers should implement this when they want to be notified when a significant state change occurs on the device. For example, the caller might want to know when the device is ready to send and receive messages. 
 */
declare type Sms$SmsDeviceStatusChangedEventHandler = (ev: Windows$WinRTEvent<undefined.SmsDevice>) => void;


/**
 * This event handler is called when a new binary message is received. Callers should implement this when they want to handle new binary messages from a given SMS device. 
 */
declare type Sms$SmsMessageReceivedEventHandler = (
    ev: undefined.SmsMessageReceivedEventArgs & Windows$WinRTEvent<undefined.SmsDevice>) => void;


/**
 * This interface specifies base functionality for all SMS message types. 
 */
declare interface Sms$ISmsMessageBase {

    /**
     * Gets the cellular class of the message. 
     */
    cellularClass: undefined.CellularClass,

        /**
         * Gets the unique device identifier associated with this message. 
         */
        deviceId: string,

        /**
         * Gets the message class of this message. 
         */
        messageClass: undefined.SmsMessageClass,

        /**
         * Gets the message type of this message. 
         */
        messageType: undefined.SmsMessageType,

        /**
         * Gets the ICCID (Integrated Circuit Card Identifier) of the SIM that received the message. 
         */
        simIccId: string
}


/**
 * This interface provides access to the raw binary format of an SMS message. The message is stored in the industry standard protocol description unit (PDU) format (see the SMS specification GSM 03.40). 
 */
declare type Sms$ISmsBinaryMessage = {

    /**
     * Returns the raw buffer of the message in binary protocol description unit (PDU) format as a byte array.
     * @return  A byte array representing message data. If there is no message data, the returned array is empty.
     */
    getData(): Array<number>,

    /**
     * Specifies the raw binary payload of the SMS message. It should be formatted according to the protocol description unit (PDU) standard.
     * @param value A byte array representing message data, formatted according to the protocol description unit (PDU) standard.
     */
    setData(value: Array<number>): void,

    /**
     * Retrieves the detected protocol description unit (PDU) format of this message. 
     */
    format: undefined.SmsDataFormat
}

declare class ProviderSpiConnectionSettings {
    chipSelectLine: any;
    clockFrequency: any;
    dataBitLength: any;
    mode: any;
    sharingMode: any
}

declare
var mode0: any;

declare
var mode1: any;

declare
var mode2: any;

declare
var mode3: any;

declare
var exclusive: any;

declare
var shared: any;


/**
 * Represents actions common to SPI controller providers. 
 */
declare interface Provider$ISpiProvider {
    getControllersAsync: any
}


/**
 * Represents the info about a SPI bus. 
 */
declare class SpiBusInfo {

    /**
     * Gets the number of chip select lines available on the bus. 
     */
    chipSelectLineCount: number;

    /**
     * Maximum clock cycle frequency of the bus. 
     */
    maxClockFrequency: number;

    /**
     * Minimum clock cycle frequency of the bus. 
     */
    minClockFrequency: number;

    /**
     * Gets the bit lengths that can be used on the bus for transmitting data. 
     */
    supportedDataBitLengths: undefined.IVectorView<number >
}


/**
 * Represents the settings for the connection with a device. 
 */
declare class SpiConnectionSettings {

    /**
     * Initializes new instance of SpiConnectionSettings .
     * @param chipSelectLine The chip select line on which the connection will be made.
     */
    constructor(chipSelectLine: number): this;

    /**
     * Gets or sets the chip select line for the connection to the SPI device. 
     */
    chipSelectLine: number;

    /**
     * Gets or sets the clock frequency for the connection. 
     */
    clockFrequency: number;

    /**
     * Gets or sets the bit length for data on this connection. 
     */
    dataBitLength: number;

    /**
     * Gets or sets the SpiMode for this connection. 
     */
    mode: undefined.SpiMode;

    /**
     * Gets or sets the sharing mode for the SPI connection. 
     */
    sharingMode: undefined.SpiSharingMode
}


/**
 * Represents the SPI controller on the system. 
 */
declare class SpiController {

    /**
     * Gets all the SPI controllers that are on the system.
     * @param provider The SPI provider for the controllers on the system.
     * @return  When the method completes successfully, it returns a list of values that represent the available SPI controllers on the system.
     */
    getControllersAsync(
        provider: undefined.ISpiProvider): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the default SPI controller on the system.
     * @return  The default SPI controller on the system, or null if the system has no SPI controller.
     */
    getDefaultAsync(): undefined.IPromiseWithIAsyncOperation<undefined.SpiController>;

    /**
     * Gets the SPI device with the specified settings.
     * @param settings The desired connection settings.
     * @return  The SPI device.
     */
    getDevice(settings: undefined.SpiConnectionSettings): undefined.SpiDevice
}


/**
 * Represents a device connected through the SPI bus. 
 */
declare class SpiDevice {

    /**
     * Opens a device with the connection settings provided.
     * @param busId The id of the bus.
     * @param settings The connection settings.
     * @return  The SPI device requested.
     */
    fromIdAsync(
        busId: string,
        settings: undefined.SpiConnectionSettings): undefined.IPromiseWithIAsyncOperation<undefined.SpiDevice>;

    /**
     * Retrieves the info about a certain bus.
     * @param busId The id of the bus.
     * @return  The bus info requested.
     */
    getBusInfo(busId: string): undefined.SpiBusInfo;

    /**
     * Gets all the SPI buses found on the system that match the input parameter.
     * @param friendlyName Input parameter specifying an identifying name for the desired bus. This usually corresponds to a name on the schematic.
     * @return  String containing all the buses that have the input in the name.
     */
    getDeviceSelector(friendlyName: string): string;

    /**
     * Gets all the SPI buses found on the system.
     * @return  String containing all the buses found on the system.
     */
    getDeviceSelector(): string;

    /**
     * Closes the connection to the device. 
     */
    close(): void;

    /**
     * Gets the connection settings for the device. 
     */
    connectionSettings: undefined.SpiConnectionSettings;

    /**
     * Gets the unique ID associated with the device. 
     */
    deviceId: string;

    /**
     * Reads from the connected device.
     * @return  Array containing data read from the device.
     */
    read(): number[];

    /**
     * Transfer data using a full duplex communication system. Full duplex allows both the master and the slave to communicate simultaneously.
     * @param writeBuffer Array containing data to write to the device.
     * @return  Array containing data read from the device.
     */
    transferFullDuplex(writeBuffer: number[]): number[];

    /**
     * Transfer data sequentially to the device.
     * @param writeBuffer Array containing data to write to the device.
     * @return  Array containing data read from the device.
     */
    transferSequential(writeBuffer: number[]): number[];

    /**
     * Writes to the connected device.
     * @param buffer Array containing the data to write to the device.
     */
    write(buffer: number[]): void
}


/**
 * The endpoint descriptor for a USB bulk IN endpoint. The descriptor specifies the endpoint type, direction, number and also the maximum number of bytes that can be read from the endpoint, in a single transfer. 
 */
declare class UsbBulkInEndpointDescriptor {

    /**
     * Gets the USB endpoint number of the bulk IN endpoint. 
     */
    endpointNumber: number;

    /**
     * Gets the maximum number of bytes that can be sent to or received from this endpoint, in a single packet. 
     */
    maxPacketSize: number;

    /**
     * Gets the object that represents the pipe that the host opens to communicate with the bulk IN endpoint. 
     */
    pipe: undefined.UsbBulkInPipe
}


/**
 * Represents the pipe that the underlying USB driver opens to communicate with a USB bulk IN endpoint of the device. The app can get an input stream from the pipe and access data is being read from the endpoint. 
 */
declare class UsbBulkInPipe {

    /**
     * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB bulk IN endpoint that is associated with the pipe.
     * @return  An IAsyncAction object that is used to control the asynchronous operation.
     */
    clearStallAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the object that represents endpoint descriptor associated with the USB bulk IN endpoint. 
     */
    endpointDescriptor: undefined.UsbBulkInEndpointDescriptor;

    /**
     * Discards any data that is cached in the bulk IN pipe. 
     */
    flushBuffer(): void;

    /**
     * Input stream that stores the data that the bulk IN pipe received from the endpoint. 
     */
    inputStream: undefined.IInputStream;

    /**
     * Gets the maximum number of bytes that can be read from the bulk IN pipe in a single transfer. 
     */
    maxTransferSizeBytes: number;

    /**
     * Gets or sets configuration flags that controls the behavior of the pipe that reads data from a USB bulk IN endpoint. 
     */
    readOptions: undefined.UsbReadOptions
}


/**
 * The endpoint descriptor for a USB bulk OUT endpoint. The descriptor specifies the endpoint type, direction, number and also the maximum number of bytes that can be written to the endpoint, in a single transfer. 
 */
declare class UsbBulkOutEndpointDescriptor {

    /**
     * Gets the USB endpoint number of the bulk OUT endpoint. 
     */
    endpointNumber: number;

    /**
     * Gets the maximum number of bytes that can be sent to or received from this endpoint. 
     */
    maxPacketSize: number;

    /**
     * Gets the object that represents the pipe that the host opens to communicate with the bulk IN endpoint. 
     */
    pipe: undefined.UsbBulkOutPipe
}


/**
 * Represents the pipe that the underlying USB driver opens to communicate with a USB bulk OUT endpoint of the device. The object provides access to an output stream to which the app can write data to send to the endpoint. 
 */
declare class UsbBulkOutPipe {

    /**
     * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB bulk OUT endpoint that is associated with the pipe.
     * @return  An IAsyncAction object that is used to control the asynchronous operation.
     */
    clearStallAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the object that represents the endpoint descriptor associated with the USB bulk OUT endpoint. 
     */
    endpointDescriptor: undefined.UsbBulkOutEndpointDescriptor;

    /**
     * Gets an output stream to which the app can write data to send to the endpoint. 
     */
    outputStream: undefined.IOutputStream;

    /**
     * Gets or sets configuration flags that controls the behavior of the pipe that writes data to a USB bulk IN endpoint. 
     */
    writeOptions: undefined.UsbWriteOptions
}


/**
 * Provides information about a USB configuration, its descriptors and the interfaces defined within that configuration. For an explanation of a USB configuration, see Section 9.6.3 in the Universal Serial Bus (USB) specification. 
 */
declare class UsbConfiguration {

    /**
     * Gets the object that contains the first 9 bytes of the descriptor associated with the USB configuration. 
     */
    configurationDescriptor: undefined.UsbConfigurationDescriptor;

    /**
     * Gets an array of objects that represent the full set of descriptors associated with a USB configuration. 
     */
    descriptors: undefined.IVectorView<undefined.UsbDescriptor>;

    /**
     * Gets an array of USB interfaces available in the USB configuration. 
     */
    usbInterfaces: undefined.IVectorView<undefined.UsbInterface >
}


/**
 * Derives information from the first 9 bytes of a USB configuration descriptor. The information includes the power capabilities of the device when the configuration is active and the number of interfaces included in that configuration. For an explanation of a configuration descriptor, Section 9.6.3 Universal Serial Bus Specification. For information about descriptor fields, see: 
 */
declare class UsbConfigurationDescriptor {

    /**
     * Parses the specified USB descriptor and returns fields of a USB configuration descriptor.
     * @param descriptor A UsbDescriptor object that contains first 9 bytes of the USB configuration descriptor.
     * @return  A UsbConfigurationDescriptor object that contains fields of a USB configuration descriptor.
     */
    parse(descriptor: undefined.UsbDescriptor): undefined.UsbConfigurationDescriptor;

    /**
     * Retrieves the first 9 bytes of a USB configuration descriptor in a UsbConfigurationDescriptor object that is contained in a UsbDescriptor object.
     * @param descriptor The UsbDescriptor object to parse.
     */
    tryParse(
        descriptor: undefined.UsbDescriptor): {
        parsed: undefined.UsbConfigurationDescriptor,
        returnValue: boolean
    };

    /**
     * Gets the bConfigurationValue field of a USB configuration descriptor. The value is the number that identifies the configuration. 
     */
    configurationValue: number;

    /**
     * Gets the bMaxPower field of a USB configuration descriptor. The value indicates the maximum power (in milliamp units) that the device can draw from the bus, when the device is bus-powered. 
     */
    maxPowerMilliamps: number;

    /**
     * Gets the D5 bit value of the bmAttributes field in the USB configuration descriptor. The value indicates whether the device can send a resume signal to wake up itself or the host system from a low power state. 
     */
    remoteWakeup: boolean;

    /**
     * Gets the D6 bit of the bmAttributes field in the USB configuration. This value indicates whether the device is drawing power from a local source or the bus. 
     */
    selfPowered: boolean
}


/**
 * Provides information about the USB control transfer, the type of control request, whether the data is sent from or to the host, and the recipient of the request in the device. 
 */
declare class UsbControlRequestType {

    /**
     * Creates a UsbControlRequestType object. 
     */
    constructor(): this;

    /**
     * Gets or sets the bmRequestType value as a byte. 
     */
    asByte: number;

    /**
     * Gets or sets the type of USB control transfer: standard, class, or vendor. 
     */
    controlTransferType: undefined.UsbControlTransferType;

    /**
     * Gets or sets the direction of the USB control transfer. 
     */
    direction: undefined.UsbTransferDirection;

    /**
     * Gets or sets the recipient of the USB control transfer. 
     */
    recipient: undefined.UsbControlRecipient
}


/**
 * Provides information about the type of descriptor, its size (in bytes), and gets the descriptor data. 
 */
declare class UsbDescriptor {

    /**
     * Gets the type of descriptor. 
     */
    descriptorType: number;

    /**
     * Gets the length of the descriptor. 
     */
    length: number;

    /**
     * Reads descriptor data in the caller-supplied buffer.
     * @param buffer A caller-supplied buffer that receives descriptor data.
     */
    readDescriptorBuffer(buffer: undefined.IBuffer): void
}


/**
 * Represents a USB device. The object provides methods and properties that an app can use to find the device (in the system) with which the app wants to communicate, and sends IN and OUT control transfers to the device. 
 */
declare class UsbDevice {

    /**
     * Starts an asynchronous operation that creates a UsbDevice object.
     * @param deviceId The device instance path of the device. To obtain that value, get the DeviceInformation.Id property value.
     * @return  Returns an IAsyncOperation(UsbDevice) object that returns the results of the operation.
     */
    fromIdAsync(deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.UsbDevice>;

    /**
     * Gets an Advanced Query Syntax (AQS) string that the app can pass to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
     * @param usbClass A UsbDeviceClass object for the device class specified by the app.
     * @return  String formatted as an AQS query.
     */
    getDeviceClassSelector(usbClass: undefined.UsbDeviceClass): string;

    /**
     * Gets an Advanced Query Syntax (AQS) string, based on vendor and product identifiers, specified by the app. The app passes the string to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
     * @param vendorId Specifies the vendor identifier for the device as assigned by the USB specification committee. Possible values are 0 through 0xffff.
     * @param productId Specifies the product identifier. This value is assigned by the manufacturer and is device-specific. Possible values are 0 through 0xffff.
     * @return  String formatted as an AQS query.
     */
    getDeviceSelector(vendorId: number, productId: number): string;

    /**
     * Gets an Advanced Query Syntax (AQS) string, based on the device interface GUID identifier, specified by the app. The app passes the string to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
     * @param winUsbInterfaceClass The device interface GUID exposed by the Winusb.sys driver. See the remarks section.
     * @return  String formatted as an AQS query.
     */
    getDeviceSelector(winUsbInterfaceClass: string): string;

    /**
     * Gets an Advanced Query Syntax (AQS) string, based on vendor, product, and device interface GUID identifiers, specified by the app. The app passes the string to DeviceInformation.FindAllAsync in order to find a specific type of USB device.
     * @param vendorId Specifies the vendor identifier for the device as assigned by the USB specification committee. Possible values are 0 through 0xffff.
     * @param productId Specifies the product identifier. This value is assigned by the manufacturer and is device-specific. Possible values are 0 through 0xffff.
     * @param winUsbInterfaceClass The device interface GUID exposed by the Winusb.sys driver. See the remarks section.
     * @return  String formatted as an AQS query.
     */
    getDeviceSelector(vendorId: number, productId: number, winUsbInterfaceClass: string): string;

    /**
     * Releases the reference to the UsbDevice object that was previously obtained by calling FromIdAsync . 
     */
    close(): void;

    /**
     * Gets an object that represents a USB configuration including all interfaces and their endpoints. 
     */
    configuration: undefined.UsbConfiguration;

    /**
     * Gets the object that represents the default or the first interface in a USB configuration. 
     */
    defaultInterface: undefined.UsbInterface;

    /**
     * Gets the object that represents the USB device descriptor. 
     */
    deviceDescriptor: undefined.UsbDeviceDescriptor;

    /**
     * Starts a USB control transfer to receive data from the default control endpoint of the device.
     * @param setupPacket A UsbSetupPacket object that contains the setup packet for the control transfer.
     * @param buffer A caller-supplied buffer that contains transfer data.
     * @return  Returns an IAsyncOperation(IBuffer) object that returns the results of the operation.
     */
    sendControlInTransferAsync(
        setupPacket: undefined.UsbSetupPacket,
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Starts a zero-length USB control transfer that reads from the default control endpoint of the device.
     * @param setupPacket A UsbSetupPacket object that contains the setup packet for the control transfer.
     * @return  Returns an IAsyncOperation(IBuffer) object that returns the results of the operation.
     */
    sendControlInTransferAsync(
        setupPacket: undefined.UsbSetupPacket): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Starts a zero-length USB control transfer that writes to the default control endpoint of the device.
     * @param setupPacket A UsbSetupPacket object that contains the setup packet for the control transfer.
     * @return  Returns an IAsyncOperation(UInt32) object that returns the results of the operation.
     */
    sendControlOutTransferAsync(
        setupPacket: undefined.UsbSetupPacket): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Starts a USB control transfer to send data to the default control endpoint of the device.
     * @param setupPacket A UsbSetupPacket object that contains the setup packet for the control transfer.
     * @param buffer A caller-supplied buffer that contains the transfer data.
     * @return  Returns an IAsyncOperation(UInt32) object that returns the results of the operation.
     */
    sendControlOutTransferAsync(
        setupPacket: undefined.UsbSetupPacket,
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<number >
}


/**
 * Provides a way for the app to get an Advanced Query Syntax (AQS) string by specifying the class code, subclass code, and the protocol code defined by the device. The properties in this class are passed in the call to GetDeviceClassSelector . 
 */
declare class UsbDeviceClass {

    /**
     * Creates a UsbDeviceClass object. 
     */
    constructor(): this;

    /**
     * Gets or sets the class code of the device. 
     */
    classCode: number;

    /**
     * Gets or sets the protocol code of the device. 
     */
    protocolCode: number;

    /**
     * Gets or sets the subclass code of the device. 
     */
    subclassCode: number
}


/**
 * Provides a way for the app to create a UsbDeviceClass object by specifying the USB device class of the device. The properties defined in this class represent the supported USB device classes and are passed in the constructor call to instantiate UsbDeviceClass. For information about USB device classes, see the official USB Website for Approved Class Specification Documents. 
 */
declare class UsbDeviceClasses {

    /**
     * Gets the device class object for the device that conforms to the Active Sync device class. 
     */
    activeSync: undefined.UsbDeviceClass;

    /**
     * Gets the device class object for the device that conforms to the Communication Device Class (CDC). 
     */
    cdcControl: undefined.UsbDeviceClass;

    /**
     * Gets the device class object for the device that conforms to the Device Firmware Update device class. 
     */
    deviceFirmwareUpdate: undefined.UsbDeviceClass;

    /**
     * Gets the device class object for an infrared transceiver that conforms to the IrDA class defined as per the IrDA Bridge Device Definition 1.0 specification. 
     */
    irda: undefined.UsbDeviceClass;

    /**
     * Gets the device class object for a device that conforms to the USB test and measurement class (USBTMC). 
     */
    measurement: undefined.UsbDeviceClass;

    /**
     * Gets the device class object for the device that conforms to the Palm Sync device class. 
     */
    palmSync: undefined.UsbDeviceClass;

    /**
     * Gets the device class object for a device that conforms to the USB Personal Healthcare Device Class (PHDC). 
     */
    personalHealthcare: undefined.UsbDeviceClass;

    /**
     * Gets the device class object for a device that conforms to the Physical Interface Devices (PID) specification. 
     */
    physical: undefined.UsbDeviceClass;

    /**
     * Gets the device class object for a custom device that has 0xFF class code. This indicates that the device does not belong to a class approved by USB-IF. 
     */
    vendorSpecific: undefined.UsbDeviceClass
}


/**
 * Derives information from the USB device descriptor of the device. For an explanation of the device descriptor, see Table 9.8 in the Universal Serial Bus Specification. 
 */
declare class UsbDeviceDescriptor {

    /**
     * Gets the bcdDeviceRevision field of the USB device descriptor. The value indicates the revision number defined by the device and is a binary-coded decimal number. 
     */
    bcdDeviceRevision: number;

    /**
     * Gets the bcdUSB field of the USB device descriptor. The value indicates the version of the USB specification to which the device conforms. 
     */
    bcdUsb: number;

    /**
     * Gets the bMaxPacketSize0 field of the USB device descriptor. The value indicates the maximum packet size, in bytes, for endpoint zero of the device. This value can be 8, 16, 32, or 64. 
     */
    maxPacketSize0: number;

    /**
     * Gets the bNumConfigurations field of the USB device descriptor. The value indicates the total count of USB configurations supported by the device. 
     */
    numberOfConfigurations: number;

    /**
     * Gets the idProduct field of the USB device descriptor. This value indicates the device-specific product identifier and is assigned by the manufacturer. 
     */
    productId: number;

    /**
     * Gets the idVendor field of the USB device descriptor. The value indicates the vendor identifier for the device as assigned by the USB specification committee. 
     */
    vendorId: number
}


/**
 * Derives information from the USB endpoint descriptor of the endpoint, such as type, direction, and endpoint number. This object also gets the specific endpoint descriptors based on the type of endpoint. For an explanation of an endpoint descriptor, see Section 9.6.5 in the Universal Serial Bus Specification: 
 */
declare class UsbEndpointDescriptor {

    /**
     * Parses the specified USB descriptor and returns the USB endpoint descriptor in a UsbEndpointDescriptor object.
     * @param descriptor A UsbDescriptor object that contains the USB endpoint descriptor.
     * @return  A UsbEndpointDescriptor object that contains the USB endpoint descriptor.
     */
    parse(descriptor: undefined.UsbDescriptor): undefined.UsbEndpointDescriptor;

    /**
     * Retrieves the USB endpoint descriptor in a UsbEndpointDescriptor object that is contained in a UsbDescriptor object.
     * @param descriptor The UsbDescriptor object to parse.
     */
    tryParse(
        descriptor: undefined.UsbDescriptor): {
        parsed: undefined.UsbEndpointDescriptor,
        returnValue: boolean
    };

    /**
     * Gets an object that represents the endpoint descriptor for the USB bulk IN endpoint. 
     */
    asBulkInEndpointDescriptor: undefined.UsbBulkInEndpointDescriptor;

    /**
     * Gets an object that represents the endpoint descriptor for the USB bulk OUT endpoint. 
     */
    asBulkOutEndpointDescriptor: undefined.UsbBulkOutEndpointDescriptor;

    /**
     * Gets an object that represents the endpoint descriptor for the USB interrupt IN endpoint. 
     */
    asInterruptInEndpointDescriptor: undefined.UsbInterruptInEndpointDescriptor;

    /**
     * Gets an object that represents the endpoint descriptor for the USB interrupt OUT endpoint. 
     */
    asInterruptOutEndpointDescriptor: undefined.UsbInterruptOutEndpointDescriptor;

    /**
     * Gets the direction of the USB endpoint. 
     */
    direction: undefined.UsbTransferDirection;

    /**
     * Gets the USB endpoint number. 
     */
    endpointNumber: number;

    /**
     * Gets the type of USB endpoint. 
     */
    endpointType: undefined.UsbEndpointType
}


/**
 * Provides information about the USB interface including its endpoints, the number of alternate settings the interface supports, and gets the entire descriptor set for those settings. It also obtains pipes associated with the endpoints that the interface supports. 
 */
declare class UsbInterface {

    /**
     * Gets an array of objects that represent pipes that the host opened to communicate with bulk IN endpoints defined in the current setting of the USB interface setting. 
     */
    bulkInPipes: undefined.IVectorView<undefined.UsbBulkInPipe>;

    /**
     * Gets an array of objects that represent pipes that the host opened to communicate with bulk OUT endpoints defined in the current setting of the USB interface. 
     */
    bulkOutPipes: undefined.IVectorView<undefined.UsbBulkOutPipe>;

    /**
     * Gets an array of objects that represent descriptors for all alternate settings that are part of this USB interface. 
     */
    descriptors: undefined.IVectorView<undefined.UsbDescriptor>;

    /**
     * Gets the interface number that identifies the USB interface. This value is the bInterfaceNumber field of a standard USB interface descriptor. 
     */
    interfaceNumber: number;

    /**
     * Gets an array of objects that represent alternate settings defined for the USB interface. 
     */
    interfaceSettings: undefined.IVectorView<undefined.UsbInterfaceSetting>;

    /**
     * Gets an array of objects that represent pipes that the host opened to communicate with interrupt IN endpoints defined in the current setting of the USB interface. 
     */
    interruptInPipes: undefined.IVectorView<undefined.UsbInterruptInPipe>;

    /**
     * Gets an array of objects that represent pipes that the host opened to communicate with interrupt OUT endpoints defined in the current setting of the USB interface. 
     */
    interruptOutPipes: undefined.IVectorView<undefined.UsbInterruptOutPipe >
}


/**
 * Describes a USB alternate setting (of an interface) in an interface descriptor. For an explanation of an interface descriptor, see Section 9.6.5 in the Universal Serial Bus Specification: 
 */
declare class UsbInterfaceDescriptor {

    /**
     * Parses the specified USB descriptor and returns alternate setting information in a UsbInterfaceDescriptor object.
     * @param descriptor A UsbDescriptor object that contains the USB interface descriptor.
     * @return  A UsbInterfaceDescriptor object describes the alternate setting.
     */
    parse(descriptor: undefined.UsbDescriptor): undefined.UsbInterfaceDescriptor;

    /**
     * Retrieves information about the alternate setting in a UsbInterfaceDescriptor object that is contained in a UsbDescriptor object.
     * @param descriptor The UsbDescriptor object to parse.
     */
    tryParse(
        descriptor: undefined.UsbDescriptor): {
        parsed: undefined.UsbInterfaceDescriptor,
        returnValue: boolean
    };

    /**
     * Gets the bAlternateSetting field of the USB interface descriptor. The value is a number that identifies the alternate setting defined by the interface. 
     */
    alternateSettingNumber: number;

    /**
     * Gets the bInterfaceClass field of the USB interface descriptor. The value indicates the USB-defined class to which the interface conforms. 
     */
    classCode: number;

    /**
     * Gets the bInterfaceNumber field of the USB interface descriptor. The value is the index that identifies the interface. 
     */
    interfaceNumber: number;

    /**
     * Gets the bInterfaceProtocol field of the interface descriptor. The value is a USB-assigned identifier that specifies a USB-defined protocol to which the interface conforms. 
     */
    protocolCode: number;

    /**
     * Gets the bInterfaceSubClass field of the USB interface descriptor. The value is a USB-assigned identifier that specifies a USB-defined subclass to which the interface. 
     */
    subclassCode: number
}


/**
 * Provides information about an alternate setting and select that setting. The app can get the USB interface descriptors for the setting and its endpoints, and determine whether this setting is currently selected. 
 */
declare class UsbInterfaceSetting {

    /**
     * Gets an array of objects that represent descriptors associated with USB bulk IN endpoints that are defined in the alternate setting. 
     */
    bulkInEndpoints: undefined.IVectorView<undefined.UsbBulkInEndpointDescriptor>;

    /**
     * Gets an array of objects that represent descriptors associated with USB bulk OUT endpoints that are defined in the alternate setting. 
     */
    bulkOutEndpoints: undefined.IVectorView<undefined.UsbBulkOutEndpointDescriptor>;

    /**
     * Gets an array of objects that represent descriptors associated with the alternate setting. 
     */
    descriptors: undefined.IVectorView<undefined.UsbDescriptor>;

    /**
     * Gets an object that represents the descriptor that describes the alternate setting. 
     */
    interfaceDescriptor: undefined.UsbInterfaceDescriptor;

    /**
     * Gets an array of objects that represent descriptors associated with USB interrupt IN endpoints that are defined in the alternate setting. 
     */
    interruptInEndpoints: undefined.IVectorView<undefined.UsbInterruptInEndpointDescriptor>;

    /**
     * Gets an array of objects that represent descriptors associated with USB interrupt OUT endpoints that are defined in the alternate setting. 
     */
    interruptOutEndpoints: undefined.IVectorView<undefined.UsbInterruptOutEndpointDescriptor>;

    /**
     * Selects the alternate setting as the current setting in the USB interface.
     * @return  An IAsyncAction object that is used to control the asynchronous operation.
     */
    selectSettingAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Determines whether the alternate setting is currently selected. 
     */
    selected: boolean
}


/**
 * The endpoint descriptor for a USB interrupt IN endpoint. The descriptor specifies the endpoint type, direction, number and also the maximum number of bytes that can be read from the endpoint, in a single transfer. The app can also get information about how often the host polls the endpoint for data. 
 */
declare class UsbInterruptInEndpointDescriptor {

    /**
     * Gets the USB endpoint number of the interrupt IN endpoint. 
     */
    endpointNumber: number;

    /**
     * Gets the poling interval of the USB interrupt endpoint. 
     */
    interval: number;

    /**
     * Gets the maximum number of bytes that can be sent to or received (in a packet) from this endpoint. 
     */
    maxPacketSize: number;

    /**
     * Gets the object that represents the pipe that the host opens to communicate with the interrupt IN endpoint. 
     */
    pipe: undefined.UsbInterruptInPipe
}


/**
 * Represents the object that is passed as a parameter to the event handler for the DataReceived event. 
 */
declare class UsbInterruptInEventArgs {

    /**
     * Gets data from the interrupt IN endpoint. 
     */
    interruptData: undefined.IBuffer
}


/**
 * Represents the pipe that the underlying USB driver opens to communicate with a USB interrupt IN endpoint of the device. The object also enables the app to specify an event handler. That handler that gets invoked when data is read from the endpoint. 
 */
declare class UsbInterruptInPipe {

    /**
     * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB interrupt IN endpoint that is associated with the pipe.
     * @return  An IAsyncAction object that is used to control the asynchronous operation.
     */
    clearStallAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the object that represents the endpoint descriptor associated with the USB interrupt IN endpoint. 
     */
    endpointDescriptor: undefined.UsbInterruptInEndpointDescriptor;

    /**
     * Raised when the interrupt pipe receives data from the interrupt IN endpoint. 
     */
    ondatareceived: undefined.TypedEventHandler<undefined.UsbInterruptInPipe, undefined.UsbInterruptInEventArgs>;
    addEventListener(
        type: "datareceived",
        listener: undefined.TypedEventHandler<undefined.UsbInterruptInPipe, undefined.UsbInterruptInEventArgs>): void;
    removeEventListener(
        type: "datareceived",
        listener: undefined.TypedEventHandler<undefined.UsbInterruptInPipe, undefined.UsbInterruptInEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * The endpoint descriptor for a USB interrupt OUT endpoint. The descriptor specifies the endpoint type, direction, number and also the maximum number of bytes that can be written to the endpoint, in a single transfer. The app can also get information about how often the host polls the endpoint to send data. 
 */
declare class UsbInterruptOutEndpointDescriptor {

    /**
     * Gets the USB endpoint number of the interrupt OUT endpoint. 
     */
    endpointNumber: number;

    /**
     * Gets the poling interval of the USB interrupt endpoint. 
     */
    interval: number;

    /**
     * Gets the maximum number of bytes that can be sent to or received from this endpoint. 
     */
    maxPacketSize: number;

    /**
     * Gets the object that represents the pipe that the host opens to communicate with the interrupt OUT endpoint. 
     */
    pipe: undefined.UsbInterruptOutPipe
}


/**
 * Represents the pipe that the underlying USB driver opens to communicate with a USB interrupt OUT endpoint of the device. The object provides access to an output stream to which the app can write data to send to the endpoint. 
 */
declare class UsbInterruptOutPipe {

    /**
     * Starts an asynchronous operation to clear a stall condition (endpoint halt) on the USB interrupt OUT endpoint that is associated with the pipe.
     * @return  An IAsyncAction object that is used to control the asynchronous operation.
     */
    clearStallAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the object that represents the endpoint descriptor associated with the USB interrupt OUT endpoint. 
     */
    endpointDescriptor: undefined.UsbInterruptOutEndpointDescriptor;

    /**
     * Gets an output stream to which the app can write data to send to the endpoint. 
     */
    outputStream: undefined.IOutputStream;

    /**
     * Gets or sets configuration flags that controls the behavior of the pipe that writes data to a USB interrupt OUT endpoint. 
     */
    writeOptions: undefined.UsbWriteOptions
}


/**
 * Describes the setup packet for a USB control transfer. For an explanation of the setup packet, see Table 9.2 in the Universal Serial Bus (USB) specification. 
 */
declare class UsbSetupPacket {

    /**
     * Creates a UsbSetupPacket object. 
     */
    constructor(): this;

    /**
     * Creates a UsbSetupPacket object from a formatted buffer (eight bytes) that contains the setup packet.
     * @param eightByteBuffer A caller-supplied buffer that contains the setup packet formatted as per the standard USB specification. The length of the buffer must be eight bytes because that is the size of a setup packet on the bus.
     */
    constructor(eightByteBuffer: undefined.IBuffer): this;

    /**
     * Gets or sets the wIndex field in the setup packet of the USB control transfer. 
     */
    index: number;

    /**
     * Gets the length, in bytes, of the setup packet. 
     */
    length: number;

    /**
     * Gets or sets the bRequest field in the setup packet of the USB control transfer. 
     */
    request: number;

    /**
     * Gets or sets the bmRequestType field in the setup packet of the USB control transfer. That field is represented by a UsbControlRequestType object. 
     */
    requestType: undefined.UsbControlRequestType;

    /**
     * Gets or sets the wValue field in the setup packet of the USB control transfer. 
     */
    value: number
}


/**
 * Use this class to enumerate local Wi-Fi adapters, initiate Wi-Fi scans, enumerate scan results, and to connect or disconnect individual adapters. 
 */
declare class WiFiAdapter {

    /**
     * A static method that initiates an asynchronous operation to enumerate all Wi-Fi adapters in the system.
     * @return  An asynchronous enumeration operation. On successful completion, returns a list of available Wi-Fi adapters.
     */
    findAllAdaptersAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * A static method that initiates an asynchronous operation to get a WiFiAdapter object.
     * @param deviceId The Device ID of the Wi-Fi adapter to be retrieved. Obtain a Device ID through the Windows.Devices.Enumeration namespace.
     * @return  An asynchronous get operation. On successful completion, returns a WiFiAdapter object specific to the requested Device ID.
     */
    fromIdAsync(deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.WiFiAdapter>;

    /**
     * A static method that returns an Advanced Query Syntax (AQS) string to be used to enumerate Wi-Fi adapters using Windows.Devices.Enumeration.DeviceInformation.FindAllAsync and related methods.
     * @return  An identifier to be used to enumerate Wi-Fi devices.
     */
    getDeviceSelector(): string;

    /**
     * A static method for determining whether the current user can access any of the Wi-Fi adapters on this device.
     * @return  An asynchronous access operation. On successful completion, returns a status enumeration value describing whether the current user can access any Wi-Fi adapter.
     */
    requestAccessAsync(): undefined.IPromiseWithIAsyncOperation<undefined.WiFiAccessStatus>;

    /**
     * Connect this Wi-Fi device to the specified network, with the specified reconnection policy.
     * @param availableNetwork Describes the Wi-Fi network to be connected.
     * @param reconnectionKind Specifies how to reconnect if the connection is lost.
     * @return  An asynchronous connect operation. On successful conclusion of the operation, returns an object that describes the result of the connect operation.
     */
    connectAsync(
        availableNetwork: undefined.WiFiAvailableNetwork,
        reconnectionKind: undefined.WiFiReconnectionKind): undefined.IPromiseWithIAsyncOperation<undefined.WiFiConnectionResult>;

    /**
     * Connect this Wi-Fi device to the specified network, with the specified passphrase and reconnection policy.
     * @param availableNetwork Specifies the Wi-Fi network to connect to.
     * @param reconnectionKind Describes how to reconnect to the network if connection is lost.
     * @param passwordCredential The passphrase to be used to connect to the access point.
     * @return  An asynchronous connect operation. On successful conclusion of the operation, returns an object that describes the result of the connect operation.
     */
    connectAsync(
        availableNetwork: undefined.WiFiAvailableNetwork,
        reconnectionKind: undefined.WiFiReconnectionKind,
        passwordCredential: undefined.PasswordCredential): undefined.IPromiseWithIAsyncOperation<undefined.WiFiConnectionResult>;

    /**
     * Connect this Wi-Fi device to a hidden network, with the given passphrase and reconnection policy.
     * @param availableNetwork Describes the Wi-Fi network to connect to.
     * @param reconnectionKind Describes how to reconnect to the network if connection is lost.
     * @param passwordCredential Password or other credential to use to connect to the network.
     * @param ssid When the network SSID is hidden, use this parameter to provide the SSID.
     * @return  An asynchronous connect operation. On successful conclusion of the operation, returns an object that describes the result of the connect operation.
     */
    connectAsync(
        availableNetwork: undefined.WiFiAvailableNetwork,
        reconnectionKind: undefined.WiFiReconnectionKind,
        passwordCredential: undefined.PasswordCredential,
        ssid: string): undefined.IPromiseWithIAsyncOperation<undefined.WiFiConnectionResult>;

    /**
     * Disconnects any active Wi-Fi connection through this adapter. 
     */
    disconnect(): void;

    /**
     * Gets information about a Wi-Fi adapter. 
     */
    networkAdapter: undefined.NetworkAdapter;

    /**
     * Gets a list of available networks populated by the last Wi-Fi scan on this WiFiNetworkAdapter. 
     */
    networkReport: undefined.WiFiNetworkReport;

    /**
     * Event raised when a scan completes on this Wi-Fi adapter. This even cannot be raised from a background task. 
     */
    onavailablenetworkschanged: undefined.TypedEventHandler<undefined.WiFiAdapter, any>;
    addEventListener(
        type: "availablenetworkschanged",
        listener: undefined.TypedEventHandler<undefined.WiFiAdapter, any>): void;
    removeEventListener(
        type: "availablenetworkschanged",
        listener: undefined.TypedEventHandler<undefined.WiFiAdapter, any>): void;

    /**
     * Directs this adapter to initiate an asynchronous network scan.
     * @return  An asynchronous scan operation. On successful completion, returns a list of networks scanned by this adapter.
     */
    scanAsync(): undefined.IPromiseWithIAsyncAction;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Describes an available Wi-Fi network. 
 */
declare class WiFiAvailableNetwork {

    /**
     * Gets the interval between 802.11 Beacon frames used by this network. 
     */
    beaconInterval: number;

    /**
     * Gets the MAC address of the access point. 
     */
    bssid: string;

    /**
     * Gets the channel center frequency of the band on which the 802.11 Beacon or Probe Response was received. 
     */
    channelCenterFrequencyInKilohertz: number;

    /**
     * Gets a value indicating whether this network originates from a Wi-Fi Direct access point. 
     */
    isWiFiDirect: boolean;

    /**
     * Gets a value describing the kind of network being described. 
     */
    networkKind: undefined.WiFiNetworkKind;

    /**
     * Gets the signal strength of the network. 
     */
    networkRssiInDecibelMilliwatts: number;

    /**
     * Gets a value describing the kind of PHY used by this network. 
     */
    phyKind: undefined.WiFiPhyKind;

    /**
     * Gets the security configuration of the network. 
     */
    securitySettings: undefined.NetworkSecuritySettings;

    /**
     * Gets the strength of the signal as a number of bars. 
     */
    signalBars: number;

    /**
     * Gets the SSID (name) of the network. 
     */
    ssid: string;

    /**
     * Gets the uptime value reported by the network. 
     */
    uptime: number
}


/**
 * Describes the results of an attempt to connect to a Wi-Fi network. 
 */
declare class WiFiConnectionResult {

    /**
     * Gets the connection result value. 
     */
    connectionStatus: undefined.WiFiConnectionStatus
}


/**
 * Contains the result of a network scan operation. 
 */
declare class WiFiNetworkReport {

    /**
     * A list of available networks. 
     */
    availableNetworks: undefined.IVectorView<undefined.WiFiAvailableNetwork>;

    /**
     * Contains the result of a network scan operation. 
     */
    timestamp: Date
}

declare
var irect: any;


/**
 * Represents a Wi-Fi Direct service. This class is used by code on a device that seeks to use a Wi-Fi Direct Service, to establish a Wi-Fi Direct Service session with the service provider. 
 */
declare class WiFiDirectService {

    /**
     * Static method that retrieves a WiFiDirectService instance for a Wi-Fi Direct Service offered by the device with a given device ID.
     * @param deviceId Device ID of the device that advertises the desired Wi-Fi Direct Service.
     * @return  An asynchronous retrieval operation. On successful completion, returns an instance of WiFiDirectService specific to the desired service instance, advertised by the indicated device.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.WiFiDirectService>;

    /**
     * Gets an Advanced Query Syntax (AQS) string to be used to find Wi-Fi Direct Service advertisers for a particular service.
     * @param serviceName The service name to be found.
     * @return  The AQS string for the requested advertiser query.
     */
    getSelector(serviceName: string): string;

    /**
     * Gets an Advanced Query Syntax (AQS) string to be used to find Wi-Fi Direct Service advertisers for a particular service, where a given byte sequence appears in the advertiser's service information blob.
     * @param serviceName The service name to be found.
     * @param serviceInfoFilter A byte sequence that must be found in the advertiser's service information blob.
     * @return  The AQS string for the requested advertiser query.
     */
    getSelector(serviceName: string, serviceInfoFilter: undefined.IBuffer): string;

    /**
     * Initiates the establishment of a service session with the Wi-Fi Direct Service represented by this instance.
     * @return  An asynchronous connection operation. When successfully completed, returns an object that represents the session that has been established.
     */
    connectAsync(): undefined.IPromiseWithIAsyncOperation<undefined.WiFiDirectServiceSession>;

    /**
     * Initiates the establishment of a service session with the Wi-Fi Direct Service represented by this instance, using a PIN to configure the session.
     * @param pin The PIN to be used to configure the connection.
     * @return  An asynchronous connection operation. When successfully completed, returns an object that represents the session that has been established.
     */
    connectAsync(
        pin: string): undefined.IPromiseWithIAsyncOperation<undefined.WiFiDirectServiceSession>;

    /**
     * Asynchronously retrieves Wi-Fi Direct Service session provisioning information.
     * @param selectedConfigurationMethod The preferred method of configuring the session.
     * @return  An asynchronous retrieval operation. On successful completion, returns provisioning information.
     */
    getProvisioningInfoAsync(
        selectedConfigurationMethod: undefined.WiFiDirectServiceConfigurationMethod): undefined.IPromiseWithIAsyncOperation<undefined.WiFiDirectServiceProvisioningInfo>;

    /**
     * Event raised when a session request has been deferred. Note that this does not mean that the request has failed or been denied. It is a notification that the server is performing a long operation, such as waiting for a user to enter a PIN. The seeker that receives this message should begin a 120-second wait before it times out the session request, to give the server time to complete its operation. The event arguments include a buffer supplied by the server in the deferral notification with additional information. 
     */
    onsessiondeferred: undefined.TypedEventHandler<undefined.WiFiDirectService, undefined.WiFiDirectServiceSessionDeferredEventArgs>;
    addEventListener(
        type: "sessiondeferred",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectService, undefined.WiFiDirectServiceSessionDeferredEventArgs>): void;
    removeEventListener(
        type: "sessiondeferred",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectService, undefined.WiFiDirectServiceSessionDeferredEventArgs>): void;

    /**
     * Gets or sets a value specifying whether the service instance should choose Wi-Fi Direct Point to Point (P2P) Group Owner (GO) mode. 
     */
    preferGroupOwnerMode: boolean;

    /**
     * Gets the service information blob from this service instance. 
     */
    remoteServiceInfo: undefined.IBuffer;

    /**
     * Error information about the latest attempt to connect to the service. 
     */
    serviceError: undefined.WiFiDirectServiceError;

    /**
     * Gets or sets app-specific session information passed to the server when initiating a session. 
     */
    sessionInfo: undefined.IBuffer;

    /**
     * Gets a list of supported configuration methods, ordered by preference. Your code uses IVector operations to modify the contents of the list. 
     */
    supportedConfigurationMethods: undefined.IVectorView<undefined.WiFiDirectServiceConfigurationMethod>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a Service Advertiser. This class is used by code on a device that advertises Wi-Fi Direct Services, to advertise the service. 
 */
declare class WiFiDirectServiceAdvertiser {

    /**
     * Creates an instance of the WiFiDirectServiceAdvertiser class. To start advertising a Wi-Fi Direct Service, create an instance of this class, set its properties appropriately for your service, and then call its Start method.
     * @param serviceName The name of the service to be advertised. Service names are UTF-8 strings no more than 255 characters long. It is recommended that names use reverse domain name notation, where the service owner's DNS name (such as "contoso.com") is reversed and used as the beginning of the service name (such as "com.contoso.serviceX"). This convention is intended to make it easy to choose unique service names. Service names that start with "org.wi-fi.wfds" are reserved for use by the Wi-Fi Alliance, and you may not use such names for your service.
     */
    constructor(serviceName: string): this;

    /**
     * Gets a value that describes the current status of the advertisement. 
     */
    advertisementStatus: undefined.WiFiDirectServiceAdvertisementStatus;

    /**
     * Gets or sets the Auto Accept property for this service advertisement. 
     */
    autoAcceptSession: boolean;

    /**
     * Accepts a session request by connecting with the given PIN.
     * @param deviceInfo Describes the device to be connected. Pass in the WiFiDirectServiceSessionRequestedEventArgs.DeviceInformation property value.
     * @param pin The PIN to be used to configure the session.
     * @return  An asynchronous connection operation. On successful completion, returns an object that describes the session that has been created.
     */
    connectAsync(
        deviceInfo: undefined.DeviceInformation,
        pin: string): undefined.IPromiseWithIAsyncOperation<undefined.WiFiDirectServiceSession>;

    /**
     * Accepts a session request without requiring a PIN.
     * @param deviceInfo Describes the device to be connected. Pass in the WiFiDirectServiceSessionRequestedEventArgs.DeviceInformation property value.
     * @return  An asynchronous connection operation. On successful completion, returns an object that describes the session that has been created.
     */
    connectAsync(
        deviceInfo: undefined.DeviceInformation): undefined.IPromiseWithIAsyncOperation<undefined.WiFiDirectServiceSession>;

    /**
     * Gets or sets a custom service status code. Only valid if the ServiceStatus property value is Custom. 
     */
    customServiceStatusCode: number;

    /**
     * Gets or sets the service-specific information that is passed to a session requester when establishing a session will not be completed immediately, as when, for example, the service is waiting for user input to complete the request. A requester should implement a 120 second timeout when its request is deferred. 
     */
    deferredSessionInfo: undefined.IBuffer;

    /**
     * Event raised when the AdvertisementStatus property value changes. 
     */
    onadvertisementstatuschanged: undefined.TypedEventHandler<undefined.WiFiDirectServiceAdvertiser, any>;
    addEventListener(
        type: "advertisementstatuschanged",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectServiceAdvertiser, any>): void;
    removeEventListener(
        type: "advertisementstatuschanged",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectServiceAdvertiser, any>): void;

    /**
     * Event raised when the service has automatically accepted a session request. Your event handler should establish socket connections for the endpoint pairs listed in the event arguments object. 
     */
    onautoacceptsessionconnected: undefined.TypedEventHandler<undefined.WiFiDirectServiceAdvertiser, undefined.WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>;
    addEventListener(
        type: "autoacceptsessionconnected",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectServiceAdvertiser, undefined.WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>): void;
    removeEventListener(
        type: "autoacceptsessionconnected",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectServiceAdvertiser, undefined.WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>): void;

    /**
     * Event raised when a Seeker has requested that a session be established with the service associated with this WiFiDirectServiceAdvertiser instance. To accept the request, call WiFiDirectServiceAdvertiser.ConnectAsync in your event handler. 
     */
    onsessionrequested: undefined.TypedEventHandler<undefined.WiFiDirectServiceAdvertiser, undefined.WiFiDirectServiceSessionRequestedEventArgs>;
    addEventListener(
        type: "sessionrequested",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectServiceAdvertiser, undefined.WiFiDirectServiceSessionRequestedEventArgs>): void;
    removeEventListener(
        type: "sessionrequested",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectServiceAdvertiser, undefined.WiFiDirectServiceSessionRequestedEventArgs>): void;

    /**
     * Gets or sets a value indicating whether the service requires that it be the Wi-Fi Direct Peer to Peer (P2P) Group Owner. 
     */
    preferGroupOwnerMode: boolean;

    /**
     * Gets a list (that implements the IVector interface) of preferred session configuration methods. Your code uses IVector operations on the list to add or remove elements from the list. 
     */
    preferredConfigurationMethods: undefined.IVector<undefined.WiFiDirectServiceConfigurationMethod>;

    /**
     * Gets a specific error code when AdvertisementStatus is Aborted. 
     */
    serviceError: undefined.WiFiDirectServiceError;

    /**
     * Gets or sets the service information blob. The format and contents of the blob are determined by the individual service, and are intended to be used by Seekers during service discovery. 
     */
    serviceInfo: undefined.IBuffer;

    /**
     * Gets the service name. 
     */
    serviceName: string;

    /**
     * Gets a list of service name prefixes that should match this service when a seeker is using prefix searching. Your code uses IVector methods to add or remove elements from the list. 
     */
    serviceNamePrefixes: undefined.IVector<string>;

    /**
     * Gets or sets the service status. 
     */
    serviceStatus: undefined.WiFiDirectServiceStatus;

    /**
     * Starts advertising the service, using current property values to set the parameters of the advertisement. 
     */
    start(): void;

    /**
     * Stops advertising the service. This does not affect existing sessions that are connected to the service. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Returned when a WiFiDirectServiceAdvertiser.AutoAcceptSessionConnected event is raised. 
 */
declare class WiFiDirectServiceAutoAcceptSessionConnectedEventArgs {

    /**
     * Gets the WiFiDirectServiceSession that was created when the connection was automatically accepted. 
     */
    session: undefined.WiFiDirectServiceSession;

    /**
     * Gets the session information buffer that corresponds to this automatically accepted connection. 
     */
    sessionInfo: undefined.IBuffer
}


/**
 * Contains provisioning information about a Wi-Fi Direct Service. 
 */
declare class WiFiDirectServiceProvisioningInfo {

    /**
     * Gets a value indicating whether Wi-Fi Direct Point to Point (P2P) group formation is needed. 
     */
    isGroupFormationNeeded: boolean;

    /**
     * Gets a value describing the configuration method in use. 
     */
    selectedConfigurationMethod: undefined.WiFiDirectServiceConfigurationMethod
}


/**
 * Returned when a WiFiDirectServiceSession.RemotePortAdded event is raised. Your event handler should use this information to establish new socket connections to the new port. 
 */
declare class WiFiDirectServiceRemotePortAddedEventArgs {

    /**
     * Gets the endpoint pairs associated with the new remote port. 
     */
    endpointPairs: undefined.IVectorView<undefined.EndpointPair>;

    /**
     * Gets the protocol used to communicate with the new remote port. 
     */
    protocol: undefined.WiFiDirectServiceIPProtocol
}


/**
 * Represents a Wi-Fi Direct Services (WFDS) session. 
 */
declare class WiFiDirectServiceSession {

    /**
     * Adds a DatagramSocket to the session. Your code creates the DatagramSocket before calling this method. Associating a socket to the session causes port information to be sent to the remote device(s) in the session. (In terms of this API, a RemotePortAdded event is raised on each remote device in the session, specifying the UDP protocol.) A remote device can use that information to open a socket and connect back to the local machine.
     * @param value The DatagramSocket instance to associate with this session.
     * @return  An asynchronous association action. Returns on successful completion of the association.
     */
    addDatagramSocketAsync(value: undefined.DatagramSocket): undefined.IPromiseWithIAsyncAction;

    /**
     * Adds a StreamSocketListener to the session. Your code creates the StreamSocketListener before calling this method. Associating a socket to the session causes port information to be sent to the remote device(s) in the session. (In terms of this API, a RemotePortAdded event is raised on each remote device in the session, specifying the TCP protocol.) A remote device can use that information to open a socket and connect back to the local machine.
     * @param value The StreamSocketListener instance to be associated with the session.
     * @return  An asynchronous association action. Returns on successful completion of the association.
     */
    addStreamSocketListenerAsync(value: undefined.StreamSocketListener): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the advertisement ID for the session. 
     */
    advertisementId: number;

    /**
     * Closes the session. 
     */
    close(): void;

    /**
     * Gets the error status of the session. 
     */
    errorStatus: undefined.WiFiDirectServiceSessionErrorStatus;

    /**
     * Gets a list of connection endpoint pairs for the session. Your code uses IVectorView operations to enumerate the endpoint pairs in the list.
     * @return  An immutable snapshot list of endpoint pairs involved in the session.
     */
    getConnectionEndpointPairs(): undefined.IVectorView<undefined.EndpointPair>;

    /**
     * Event raised when a new remote port is added to the session. Your event handler should respond by establishing the appropriate socket connection to the new remote port. 
     */
    onremoteportadded: undefined.TypedEventHandler<undefined.WiFiDirectServiceSession, undefined.WiFiDirectServiceRemotePortAddedEventArgs>;
    addEventListener(
        type: "remoteportadded",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectServiceSession, undefined.WiFiDirectServiceRemotePortAddedEventArgs>): void;
    removeEventListener(
        type: "remoteportadded",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectServiceSession, undefined.WiFiDirectServiceRemotePortAddedEventArgs>): void;

    /**
     * Event raised when the session status changes. 
     */
    onsessionstatuschanged: undefined.TypedEventHandler<undefined.WiFiDirectServiceSession, any>;
    addEventListener(
        type: "sessionstatuschanged",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectServiceSession, any>): void;
    removeEventListener(
        type: "sessionstatuschanged",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectServiceSession, any>): void;

    /**
     * Gets the service address for this session. 
     */
    serviceAddress: string;

    /**
     * Gets the service name of the advertiser service involved in the session. 
     */
    serviceName: string;

    /**
     * Gets the session address for the session. 
     */
    sessionAddress: string;

    /**
     * Gets the session ID. 
     */
    sessionId: number;

    /**
     * Gets the session status. 
     */
    status: undefined.WiFiDirectServiceSessionStatus;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Returned when a WiFiDirectService.SessionDeferred event is raised. 
 */
declare class WiFiDirectServiceSessionDeferredEventArgs {

    /**
     * Gets the service-defined session information returned by the service when it sends a deferral in response to a connection request. Note that a deferral does not indicate that the connection is refused. Rather, it indicates that the server is performing a time-consuming operation such as requesting user input. A seeker should implement a 120-second timeout after getting a deferral before giving up on the request. 
     */
    deferredSessionInfo: undefined.IBuffer
}


/**
 * Describes a Wi-Fi Direct Service session request. 
 */
declare class WiFiDirectServiceSessionRequest {

    /**
     * Closes the session request. Your server code calls this method to reject a session request. 
     */
    close(): void;

    /**
     * Gets device information for the requesting device. 
     */
    deviceInformation: undefined.DeviceInformation;

    /**
     * Gets information about how provisioning should be performed if the session is established. 
     */
    provisioningInfo: undefined.WiFiDirectServiceProvisioningInfo;

    /**
     * Gets the session information blob associated with this request. 
     */
    sessionInfo: undefined.IBuffer
}


/**
 * Returned when a WiFiDirectServiceAdvertiser.SessionRequested event is raised. 
 */
declare class WiFiDirectServiceSessionRequestedEventArgs {

    /**
     * Gets information about the session request that raised a WiFiDirectServiceAdvertiser.SessionRequested event.
     * @return  Information about a new session request.
     */
    getSessionRequest(): undefined.WiFiDirectServiceSessionRequest
}


/**
 * Represent a Wi-Fi Direct advertisement and allows the app to control the listen state and custom information elements in the advertisement. 
 */
declare class WiFiDirectAdvertisement {

    /**
     * Information elements to advertise in the Wi-Fi Direct advertisement. 
     */
    informationElements: undefined.IVector<undefined.WiFiDirectInformationElement>;

    /**
     * Whether autonomous group owner will be enabled. 
     */
    isAutonomousGroupOwnerEnabled: boolean;

    /**
     * Gets the settings object for "legacy" (non-Wi-Fi Direct) connections. 
     */
    legacySettings: undefined.WiFiDirectLegacySettings;

    /**
     * Gets or sets the listen state and whether the Wi-Fi Direct device is discoverable. 
     */
    listenStateDiscoverability: undefined.WiFiDirectAdvertisementListenStateDiscoverability;

    /**
     * Gets a device's supported configuration methods. 
     */
    supportedConfigurationMethods: undefined.IVector<undefined.WiFiDirectConfigurationMethod >
}


/**
 * An object to publish Wi-Fi Direct advertisements. 
 */
declare class WiFiDirectAdvertisementPublisher {

    /**
     * Creates a new WiFiDirectAdvertisementPublisher object. 
     */
    constructor(): this;

    /**
     * Gets the Wi-Fi Direct advertisement to publish. 
     */
    advertisement: undefined.WiFiDirectAdvertisement;

    /**
     * Notification that the status of the WiFiDirectAdvertisementPublisher has changed. 
     */
    onstatuschanged: undefined.TypedEventHandler<undefined.WiFiDirectAdvertisementPublisher, undefined.WiFiDirectAdvertisementPublisherStatusChangedEventArgs>;
    addEventListener(
        type: "statuschanged",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectAdvertisementPublisher, undefined.WiFiDirectAdvertisementPublisherStatusChangedEventArgs>): void;
    removeEventListener(
        type: "statuschanged",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectAdvertisementPublisher, undefined.WiFiDirectAdvertisementPublisherStatusChangedEventArgs>): void;

    /**
     * Starts the Wi-Fi Direct advertisement. 
     */
    start(): void;

    /**
     * Gets the current status of the WiFiDirectAdvertisementPublisher . 
     */
    status: undefined.WiFiDirectAdvertisementPublisherStatus;

    /**
     * Stops the Wi-Fi Direct advertisement. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for a StatusChanged event on a WiFiDirectAdvertisementPublisher . 
 */
declare class WiFiDirectAdvertisementPublisherStatusChangedEventArgs {

    /**
     * Gets the error status for a StatusChanged event on a WiFiDirectAdvertisementPublisher . 
     */
    error: undefined.WiFiDirectError;

    /**
     * Gets the new status of the WiFiDirectAdvertisementPublisher . 
     */
    status: undefined.WiFiDirectAdvertisementPublisherStatus
}


/**
 * Class used to listen for incoming Wi-Fi Direct connection requests. 
 */
declare class WiFiDirectConnectionListener {

    /**
     * Creates a new WiFiDirectConnectionListener object. 
     */
    constructor(): this;

    /**
     * Notification on an incoming Wi-Fi Direct connection request. 
     */
    onconnectionrequested: undefined.TypedEventHandler<undefined.WiFiDirectConnectionListener, undefined.WiFiDirectConnectionRequestedEventArgs>;
    addEventListener(
        type: "connectionrequested",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectConnectionListener, undefined.WiFiDirectConnectionRequestedEventArgs>): void;
    removeEventListener(
        type: "connectionrequested",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectConnectionListener, undefined.WiFiDirectConnectionRequestedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Used by an app to specify the connection parameters for a Wi-Fi Direct connect/pairing operation. 
 */
declare class WiFiDirectConnectionParameters {

    /**
     * Gets a list of the DevicePairingKinds supporting the given configuration method.
     * @param configurationMethod A value specifying a configuration method.
     * @return  A value specifying a pairing kind, for use with the pairing functionality in the Windows.Devices.Enumeration API.
     */
    getDevicePairingKinds(
        configurationMethod: undefined.WiFiDirectConfigurationMethod): undefined.DevicePairingKinds;

    /**
     * Creates a new WiFiDirectConnectionParameters object. 
     */
    constructor(): this;

    /**
     * The group owner intent value used for group owner negotiation in a Wi-Fi Direct connect/pairing operation. 
     */
    groupOwnerIntent: number;

    /**
     * Gets a list of supported configuration methods, in order of preference. 
     */
    preferenceOrderedConfigurationMethods: undefined.IVector<undefined.WiFiDirectConfigurationMethod>;

    /**
     * Gets or sets a value specifying a device's preferred pairing procedure. 
     */
    preferredPairingProcedure: undefined.WiFiDirectPairingProcedure
}


/**
 * A Wi-FI Direct connection request received by a WiFiDirectConnectionListener . 
 */
declare class WiFiDirectConnectionRequest {

    /**
     * Closes the WiFiDirectConnectionRequest object. 
     */
    close(): void;

    /**
     * Gets device information for the endpoint making the Wi-Fi Direct connection request. 
     */
    deviceInformation: undefined.DeviceInformation
}


/**
 * Provides data for a ConnectionRequested event on a WiFiDirectConnectionListener . 
 */
declare class WiFiDirectConnectionRequestedEventArgs {

    /**
     * Retrieves the WiFiDirectConnectionRequest received on a ConnectionRequested event by a WiFiDirectConnectionListener .
     * @return  The Wi-FI Direct connection request.
     */
    getConnectionRequest(): undefined.WiFiDirectConnectionRequest
}


/**
 * Manages connections to associated Wi-Fi Direct devices. 
 */
declare class WiFiDirectDevice {

    /**
     * Creates an instance of the WiFiDirectDevice class for the specified device interface id.
     * @param deviceId The DeviceInformation Id of a Wi-Fi Direct device.
     * @return  An asynchronous operation to retrieve the WiFiDirectDevice that was created.
     */
    fromIdAsync(
        deviceId: string): undefined.IPromiseWithIAsyncOperation<undefined.WiFiDirectDevice>;

    /**
     * Creates an instance of the WiFiDirectDevice class for the specified device interface id with specific connection parameters.
     * @param deviceId The DeviceInformation Id of a Wi-Fi Direct device.
     * @param connectionParameters Connection parameters for a Wi-Fi Direct connect/pairing operation.
     * @return  An asynchronous operation to retrieve the WiFiDirectDevice that was created.
     */
    fromIdAsync(
        deviceId: string,
        connectionParameters: undefined.WiFiDirectConnectionParameters): undefined.IPromiseWithIAsyncOperation<undefined.WiFiDirectDevice>;

    /**
     * Returns the class selection string that you can use to enumerate Wi-Fi Direct devices.
     * @return  The class selection string that you can use to enumerate Wi-Fi Direct devices.
     */
    getDeviceSelector(): string;

    /**
     * Returns the class selection string that you can use to enumerate Wi-Fi Direct devices for a specific Wi-Fi Direct device selector type.
     * @param type A specific Wi-Fi Direct device selector type.
     * @return  The class selection string that you can use to enumerate Wi-Fi Direct devices.
     */
    getDeviceSelector(type: undefined.WiFiDirectDeviceSelectorType): string;

    /**
     * Close the active Wi-Fi Direct device connection. 
     */
    close(): void;

    /**
     * Gets the connection status for the WiFi-Direct device. 
     */
    connectionStatus: undefined.WiFiDirectConnectionStatus;

    /**
     * Gets the DeviceInformation Id for the Wi-Fi Direct device. 
     */
    deviceId: string;

    /**
     * Gets a collection of network addresses for the Wi-Fi Direct device as endpoint pairs.
     * @return  A collection of network addresses for the Wi-Fi Direct device as endpoint pairs.
     */
    getConnectionEndpointPairs(): undefined.IVectorView<undefined.EndpointPair>;

    /**
     * Occurs when a Wi-Fi Direct device connection is connected or disconnected. 
     */
    onconnectionstatuschanged: undefined.TypedEventHandler<undefined.WiFiDirectDevice, any>;
    addEventListener(
        type: "connectionstatuschanged",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectDevice, any>): void;
    removeEventListener(
        type: "connectionstatuschanged",
        listener: undefined.TypedEventHandler<undefined.WiFiDirectDevice, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents information elements in a Wi-Fi Direct packet. 
 */
declare class WiFiDirectInformationElement {

    /**
     * Create an array of information elements from a data buffer.
     * @param buffer The data buffer that contains a information element.
     * @return  A array of information elements created from the buffer.
     */
    createFromBuffer(
        buffer: undefined.IBuffer): undefined.IVector<undefined.WiFiDirectInformationElement>;

    /**
     * Create an array of information elements from a DeviceInformation object.
     * @param deviceInformation The device information object that contains the information elements.
     * @return  A array of information elements created from the device information object.
     */
    createFromDeviceInformation(
        deviceInformation: undefined.DeviceInformation): undefined.IVector<undefined.WiFiDirectInformationElement>;

    /**
     * Creates a new WiFiDirectInformationElement object. 
     */
    constructor(): this;

    /**
     * A three-byte organization identifier used to indicate the organization which defined a vendor extension information element (IE). 
     */
    oui: undefined.IBuffer;

    /**
     * A one byte type value used in a vendor extension information element (IE) to distinguish between different IE formats defined by the same organization. 
     */
    ouiType: number;

    /**
     * The value of the information element. 
     */
    value: undefined.IBuffer
}


/**
 * Settings governing "legacy" mode (non-Wi-Fi Direct connections to the access point being advertised.) 
 */
declare class WiFiDirectLegacySettings {

    /**
     * Gets or sets a value specifying whether "legacy mode" is enabled. When enabled, this mode causes this device to act as a normal Wi-Fi access point, and is intended to support devices which do not support connection via Wi-Fi Direct. 
     */
    isEnabled: boolean;

    /**
     * Gets or sets the pass phrase used by non-Wi-Fi Direct clients to connect to this access point in "legacy mode". 
     */
    passphrase: undefined.PasswordCredential;

    /**
     * Gets or sets the Service Set Identifier (SSID, or "access point ID"). 
     */
    ssid: string
}


/**
 * Represents a property set, which is a set of PropertyValue objects with string keys. 
 */
declare class PropertySet {

    /**
     * Creates and initializes a new instance of the property set. 
     */
    constructor(): this;

    /**
     * Removes all items from the property set. 
     */
    clear(): void;

    /**
     * Returns an iterator to enumerate the items in the property set.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Gets an immutable view of the property set.
     * @return  The immutable view.
     */
    getView(): undefined.IMapView<string, any>;

    /**
     * Indicates whether the property set has an item with the specified key.
     * @param key The key.
     * @return  True if the property set has an item with the specified key; otherwise, false.
     */
    hasKey(key: string): boolean;

    /**
     * Adds an item to the property set.
     * @param key The key to insert.
     * @param value The value to insert.
     * @return  True if the method replaces a value that already exists for the key; false if this is a new key.
     */
    insert(key: string, value: any): boolean;

    /**
     * Retrieves the value for the specified key.
     * @param key The key.
     * @return  The value, if an item with the specified key exists; otherwise, null.
     */
    lookup(key: string): any;

    /**
     * Occurs when the observable map has changed. 
     */
    onmapchanged: undefined.MapChangedEventHandler<string, any>;
    addEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, any>): void;
    removeEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, any>): void;

    /**
     * Removes an item from the property set.
     * @param key The key.
     */
    remove(key: string): void;

    /**
     * Removes a specific item from the PropertySet .
     * @param key The key of the item to remove.
     * @return  true if the item was removed, otherwise false.
     */
    remove(key: string): boolean;

    /**
     * Gets the number of items contained in the property set. 
     */
    size: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * An associative collection, also known as a map or a dictionary. 
 */
declare class StringMap {

    /**
     * Creates and initializes a new instance of the StringMap. 
     */
    constructor(): this;

    /**
     * Removes all items from the map. 
     */
    clear(): void;

    /**
     * Returns an iterator containing the items in the collection.
     * @return  The items in the collection.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Returns an immutable view of the map.
     * @return  The view of the map.
     */
    getView(): undefined.IMapView<string, string>;

    /**
     * Determines whether the map contains the specified key.
     * @param key The key associated with the item to locate.
     * @return  True if the key is found; otherwise, false.
     */
    hasKey(key: string): boolean;

    /**
     * Inserts or replaces an item in the map.
     * @param key The key associated with the item to insert.
     * @param value The item to insert.
     * @return  True if an item with the specified key is an existing item that was replaced; otherwise, false.
     */
    insert(key: string, value: string): boolean;

    /**
     * Returns the item at the specified key in the map.
     * @param key The key associated with the item to locate.
     * @return  The item associated with the specified key.
     */
    lookup(key: string): string;

    /**
     * Occurs when the contents of the map change. 
     */
    onmapchanged: undefined.MapChangedEventHandler<string, string>;
    addEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, string>): void;
    removeEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, string>): void;

    /**
     * Removes an item from the map.
     * @param key The key associated with the item to remove.
     */
    remove(key: string): void;

    /**
     * Gets the number of items in the map. 
     */
    size: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Implements a map with keys of type String and values of type Object . This class prevents non-serializable types from being put into the map. 
 */
declare class ValueSet {

    /**
     * Creates and initializes a new instance of the property set. 
     */
    constructor(): this;

    /**
     * Removes all items from the value set. 
     */
    clear(): void;

    /**
     * Returns an iterator to enumerate the items in the value set.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the value set if the value set is empty.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Gets an immutable view of the value set.
     * @return  The immutable view.
     */
    getView(): undefined.IMapView<string, any>;

    /**
     * Indicates whether the value set has an item with the specified key.
     * @param key The key.
     * @return  True if the value set has an item with the specified key; otherwise, false.
     */
    hasKey(key: string): boolean;

    /**
     * Adds an item to the value set.
     * @param key The key to insert.
     * @param value The value to insert.
     * @return  True if the method replaces a value that already exists for the key; false if this is a new key.
     */
    insert(key: string, value: any): boolean;

    /**
     * Retrieves the value for the specified key.
     * @param key The key.
     * @return  The value, if an item with the specified key exists; otherwise, null.
     */
    lookup(key: string): any;

    /**
     * Occurs when the observable map has changed. 
     */
    onmapchanged: undefined.MapChangedEventHandler<string, any>;
    addEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, any>): void;
    removeEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, any>): void;

    /**
     * Removes a specific item from the ValueSet .
     * @param key The key of the item to remove.
     * @return  true if the item was removed, otherwise false.
     */
    remove(key: string): boolean;

    /**
     * Removes an item from the value set.
     * @param key The key.
     */
    remove(key: string): void;

    /**
     * Gets the number of items contained in the value set. 
     */
    size: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}

declare type Collections$IVectorView<T>= {
    indexOf(value: T, ...extra: any[]): {
        index: number,
        returnValue: boolean
    },
    indexOf(searchElement: T, fromIndex?: number): number
} & Array


declare type Collections$IVector<T>= {
    indexOf(value: T, ...extra: any[]): {
        index: number,
        returnValue: boolean
    },
    indexOf(searchElement: T, fromIndex?: number): number
} & Array



/**
 * Exposes an iterator that supports simple iteration over a collection of a specified type. 
 */
declare interface Collections$IIterable<T>{

    /**
     * Returns an iterator for the items in the collection.
     * @return  The iterator.
     */
    first(): undefined.IIterator<T >
}


/**
 * Represents an immutable view into a map. 
 */
declare type Collections$IMapView<K, V>= {

    /**
     * Determines whether the map view contains the specified key.
     * @param key The key to locate in the map view.
     * @return  True if the key is found; otherwise, false.
     */
    hasKey(key: K): boolean,

    /**
     * Returns the item at the specified key in the map view.
     * @param key The key to locate in the map view.
     * @return  The item associated with the specified key.
     */
    lookup(key: K): V,

    /**
     * Splits the map view into two views.
     */
    split(): {
        first: undefined.IMapView<K,
        V>,
        second: undefined.IMapView<K,
        V >
    },

    /**
     * Gets the number of elements in the map. 
     */
    size: number
}


/**
 * Represents a collection of key-value pairs, correlating several other collection interfaces. 
 */
declare type Collections$IPropertySet = {} & & &



    /**
     * Represents an associative collection, also known as a map or a dictionary. 
     */
    declare type Collections$IMap<K, V>= {

        /**
         * Removes all items from the map. 
         */
        clear(): void,

        /**
         * Returns an immutable view of the map.
         * @return  The view of the map.
         */
        getView(): undefined.IMapView<K,
        V>,

        /**
         * Determines whether the map contains the specified key.
         * @param key The key associated with the item to locate.
         * @return  True if the key is found; otherwise, false.
         */
        hasKey(key: K): boolean,

        /**
         * Inserts or replaces an item in the map.
         * @param key The key associated with the item to insert.
         * @param value The item to insert.
         * @return  True if an item with the specified key is an existing item that was replaced; otherwise, false.
         */
        insert(key: K, value: V): boolean,

        /**
         * Returns the item at the specified key in the map.
         * @param key The key associated with the item to locate.
         * @return  The item associated with the specified key.
         */
        lookup(key: K): V,

        /**
         * Removes an item from the map.
         * @param key The key associated with the item to remove.
         */
        remove(key: K): void,

        /**
         * Gets the number of items in the map. 
         */
        size: number
    }


/**
 * Supports simple iteration over a collection. 
 */
declare interface Collections$IIterator<T>{

    /**
     * Retrieves all items in the collection.
     */
    getMany(): {
        items: T,
        returnValue: number
    },

    /**
     * Advances the iterator to the next item in the collection.
     * @return  True if the iterator refers to a valid item in the collection; false if the iterator passes the end of the collection.
     */
    moveNext(): boolean,

    /**
     * Gets the current item in the collection. 
     */
    current: T,

    /**
     * Gets a value that indicates whether the iterator refers to a current item or is at the end of the collection. 
     */
    hasCurrent: boolean
}


/**
 * Represents a key-value pair. This is typically used as a constraint type when you need to encapsulate two type parameters into one to satisfy the constraints of another generic interface. 
 */
declare interface Collections$IKeyValuePair<K, V>{

    /**
     * Gets the key of the key-value pair. 
     */
    key: K,

    /**
     * Gets the value of the key-value pair. 
     */
    value: V
}


/**
 * Notifies listeners of dynamic changes to a map, such as when items are added or removed. 
 */
declare type Collections$IObservableMap<K, V>= {} & &



    /**
     * Represents the method that handles the changed event of an observable map. 
     */
    declare type Collections$MapChangedEventHandler<K, V>= (
        ev: undefined.IMapChangedEventArgs<K>& Windows$WinRTEvent<undefined.IObservableMap<K, V >> ) => void;


/**
 * Notifies listeners of changes to the vector. 
 */
declare type Collections$IObservableVector<T>= {} & &



    /**
     * Provides data for the changed event of a vector. 
     */
    declare interface Collections$IVectorChangedEventArgs {

        /**
         * Gets the type of change that occurred in the vector. 
         */
        collectionChange: undefined.CollectionChange,

            /**
             * Gets the position where the change occurred in the vector. 
             */
            index: number
    }


/**
 * Provides data for the changed event of a map collection. 
 */
declare interface Collections$IMapChangedEventArgs<K>{

    /**
     * Gets the type of change that occurred in the map. 
     */
    collectionChange: undefined.CollectionChange,

    /**
     * Gets the key of the item that changed. 
     */
    key: K
}


/**
 * Stores a DeferralCompletedHandler to be invoked upon completion of the deferral and manipulates the state of the deferral. 
 */
declare class Deferral {

    /**
     * Initializes a new Deferral object and specifies a DeferralCompletedHandler to be called upon completion of the deferral.
     * @param handler A DeferralCompletedHandler to be called upon completion of the deferral.
     */
    constructor(handler: undefined.DeferralCompletedHandler): this;

    /**
     * If the DeferralCompletedHandler has not yet been invoked, this will call it and drop the reference to the delegate. 
     */
    close(): void;

    /**
     * If the DeferralCompletedHandler has not yet been invoked, this will call it and drop the reference to the delegate. 
     */
    complete(): void
}


/**
 * Enables tracing control flow across asynchronous operations. 
 */
declare class AsyncCausalityTracer {

    /**
     * Raised when a client starts listening to the causality trace. 
     */
    ontracingstatuschanged: undefined.EventHandler<any>;
    addEventListener(type: "tracingstatuschanged", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "tracingstatuschanged", listener: undefined.EventHandler<any>): void;

    /**
     * Indicates that a previously created asynchronous operation has completed all of its asynchronous work.
     * @param traceLevel The trace level.
     * @param source The trace source.
     * @param platformId Identifier for the operation type.
     * @param operationId The identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
     * @param status The completion status of the asynchronous operation.
     */
    traceOperationCompletion(
        traceLevel: undefined.CausalityTraceLevel,
        source: undefined.CausalitySource,
        platformId: string,
        operationId: number,
        status: undefined.AsyncStatus): void;

    /**
     * Logs the creation of an asynchronous operation.
     * @param traceLevel The trace level.
     * @param source The trace source.
     * @param platformId Identifier for the operation type.
     * @param operationId An identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
     * @param operationName A human-readable description of the asynchronous work.
     * @param relatedContext Additional information related to this operation.
     */
    traceOperationCreation(
        traceLevel: undefined.CausalityTraceLevel,
        source: undefined.CausalitySource,
        platformId: string,
        operationId: number,
        operationName: string,
        relatedContext: number): void;

    /**
     * Logs the relation between the currently running synchronous work item and a specific asynchronous operation that it's related to.
     * @param traceLevel The trace level.
     * @param source The trace source.
     * @param platformId Identifier for the operation type.
     * @param operationId The identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
     * @param relation The relationship between the synchronous work item and asynchronous operation identified by operationId.
     */
    traceOperationRelation(
        traceLevel: undefined.CausalityTraceLevel,
        source: undefined.CausalitySource,
        platformId: string,
        operationId: number,
        relation: undefined.CausalityRelation): void;

    /**
     * Indicates that the most recently created synchronous work item running on the thread that the TraceSynchronousWorkCompletion method is called on has completed.
     * @param traceLevel The trace level.
     * @param source The trace source.
     * @param work Indicates the type of completion.
     */
    traceSynchronousWorkCompletion(
        traceLevel: undefined.CausalityTraceLevel,
        source: undefined.CausalitySource,
        work: undefined.CausalitySynchronousWork): void;

    /**
     * Indicates that the specified asynchronous operation is scheduling synchronous work on the thread that the TraceSynchronousWorkStart method is called on.
     * @param traceLevel The trace level.
     * @param source The trace source.
     * @param platformId Identifier for the operation type.
     * @param operationId The identifier for the asynchronous operation that's unique within the platform for the operation's lifetime.
     * @param work The relationship between the work item and the asynchronous operation.
     */
    traceSynchronousWorkStart(
        traceLevel: undefined.CausalityTraceLevel,
        source: undefined.CausalitySource,
        platformId: string,
        operationId: number,
        work: undefined.CausalitySynchronousWork): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides information about an error that occurred. 
 */
declare class ErrorDetails {

    /**
     * Asynchronously creates an ErrorDetails object based on an HRESULT error code.
     * @param errorCode The unique code representing the error.
     * @return  The newly created ErrorDetails object representing the error.
     */
    createFromHResultAsync(
        errorCode: number): undefined.IPromiseWithIAsyncOperation<undefined.ErrorDetails>;

    /**
     * Gets a short description of the error. 
     */
    description: string;

    /**
     * Gets the address to a help page about the error. 
     */
    helpUri: undefined.Uri;

    /**
     * Gets a detailed description of the error. 
     */
    longDescription: string
}


/**
 * Represents the destination of logged messages from LoggingChannel instances. 
 */
declare class FileLoggingSession {

    /**
     * Initializes a new instance of the FileLoggingSession class.
     * @param name The name of the logging session.
     */
    constructor(name: string): this;

    /**
     * Adds a logging channel to the current logging session. The logging channel only accepts events that have a logging level at or above the specified logging level.
     * @param loggingChannel The logging channel to add.
     * @param maxLevel The minimum logging level that an event must have to be accepted by the session.
     */
    addLoggingChannel(
        loggingChannel: undefined.ILoggingChannel,
        maxLevel: undefined.LoggingLevel): void;

    /**
     * Adds a logging channel to the current logging session.
     * @param loggingChannel The logging channel to add.
     */
    addLoggingChannel(loggingChannel: undefined.ILoggingChannel): void;

    /**
     * Ends the current logging session. 
     */
    close(): void;

    /**
     * Ends the current logging session and saves it to a file.
     * @return  When this method completes, it returns the new file as a StorageFile . Returns NULL if there are no events in the session or if logging has just rolled over into a new file that doesn't contain events yet.
     */
    closeAndSaveToFileAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Gets the name of the logging session. 
     */
    name: string;

    /**
     * Raised when a log file is saved. 
     */
    onlogfilegenerated: undefined.TypedEventHandler<undefined.IFileLoggingSession, undefined.LogFileGeneratedEventArgs>;
    addEventListener(
        type: "logfilegenerated",
        listener: undefined.TypedEventHandler<undefined.IFileLoggingSession, undefined.LogFileGeneratedEventArgs>): void;
    removeEventListener(
        type: "logfilegenerated",
        listener: undefined.TypedEventHandler<undefined.IFileLoggingSession, undefined.LogFileGeneratedEventArgs>): void;

    /**
     * Removes the specified logging channel from the current logging session.
     * @param loggingChannel The logging channel to remove.
     */
    removeLoggingChannel(loggingChannel: undefined.ILoggingChannel): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the LogFileGenerated event. 
 */
declare class LogFileGeneratedEventArgs {

    /**
     * Gets the log file. 
     */
    file: undefined.StorageFile
}


/**
 * Creates Event Tracing for Windows (ETW) events that mark the start and end of a group of related events. 
 */
declare class LoggingActivity {

    /**
     * Initializes a new instance of the LoggingActivity class for the specified LoggingChannel and LoggingLevel in Windows 8.1 compatibility mode.
     * @param activityName The name of the logging activity.
     * @param loggingChannel The logging channel.
     * @param level The logging level.
     */
    constructor(activityName: string, loggingChannel: undefined.ILoggingChannel, level: undefined.LoggingLevel): this;

    /**
     * Initializes a new instance of the LoggingActivity class for the specified LoggingChannel in Windows 8.1 compatibility mode.
     * @param activityName The name of the logging activity.
     * @param loggingChannel The logging channel.
     */
    constructor(activityName: string, loggingChannel: undefined.ILoggingChannel): this;

    /**
     * Returns the channel associated with this activity. 
     */
    channel: undefined.LoggingChannel;

    /**
     * Ends the current logging activity. 
     */
    close(): void;

    /**
     * Gets the identifier for the current logging activity. 
     */
    id: string;

    /**
     * Indicates whether at least one session is listening for events with the specified level and keywords from the channel associated with this activity.
     * @param level The event severity level.
     * @param keywords The keywords. Each bit of the keywords value represents an event category.
     * @return  Returns true if at least one session is listening for events with the specified level and keywords from the channel associated with this activity, and otherwise false.
     */
    isEnabled(level: undefined.LoggingLevel, keywords: number): boolean;

    /**
     * Indicates whether at least one session is listening for events from the channel associated with this activity.
     * @return  Returns true if at least one session is listening for events from the channel associated with this activity, and otherwise false.
     */
    isEnabled(): boolean;

    /**
     * Indicates whether at least one session is listening for events with the specified event severity level from the channel associated with this activity.
     * @param level The event severity level.
     * @return  Returns true if at least one session is listening for events with the specified level from the channel associated with this activity, and otherwise false.
     */
    isEnabled(level: undefined.LoggingLevel): boolean;

    /**
     * Logs an event with the specified name.
     * @param eventName The name for this event.
     */
    logEvent(eventName: string): void;

    /**
     * Logs an event with the specified name, fields, and level.
     * @param eventName The name for this event.
     * @param fields The fields for this event. May be null.
     * @param level The severity level for this event.
     */
    logEvent(
        eventName: string,
        fields: undefined.LoggingFields,
        level: undefined.LoggingLevel): void;

    /**
     * Logs an event with the specified name and fields.
     * @param eventName The name for this event.
     * @param fields The fields for this event. May be null.
     */
    logEvent(eventName: string, fields: undefined.LoggingFields): void;

    /**
     * Logs an event with the specified name, fields, level, and options.
     * @param eventName The name for this event.
     * @param fields The fields for this event. May be null.
     * @param level The severity level for this event.
     * @param options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
     */
    logEvent(
        eventName: string,
        fields: undefined.LoggingFields,
        level: undefined.LoggingLevel,
        options: undefined.LoggingOptions): void;

    /**
     * Gets the name of the current logging activity. 
     */
    name: string;

    /**
     * Writes an activity start event with the specified fields and level and creates a LoggingActivity object.
     * @param startEventName The name for the start event.
     * @param fields The fields for this event. May be null .
     * @param level The level of detail for this event.
     * @return  An object that represents the new activity.
     */
    startActivity(
        startEventName: string,
        fields: undefined.LoggingFields,
        level: undefined.LoggingLevel): undefined.LoggingActivity;

    /**
     * Writes an activity start event and creates a LoggingActivity object.
     * @param startEventName The name for the start event.
     * @return  An object the represents the new activity.
     */
    startActivity(startEventName: string): undefined.LoggingActivity;

    /**
     * Writes an activity start event with fields and creates a LoggingActivity object.
     * @param startEventName The name for the start event.
     * @param fields The fields for this event.
     * @return  An object that represents the new activity.
     */
    startActivity(
        startEventName: string,
        fields: undefined.LoggingFields): undefined.LoggingActivity;

    /**
     * Writes an activity start event with the specified fields, level, and options, and creates a LoggingActivity object.
     * @param startEventName The name for this event.
     * @param fields The fields for this event. May be null.
     * @param level The level of detail for this event.
     * @param options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
     * @return  An object that represents the new activity.
     */
    startActivity(
        startEventName: string,
        fields: undefined.LoggingFields,
        level: undefined.LoggingLevel,
        options: undefined.LoggingOptions): undefined.LoggingActivity;

    /**
     * Marks the activity as closed/disposed and generates a stop event with the specified event name, fields, and options.
     * @param stopEventName The name for the stop event.
     * @param fields The fields for this event. May be null.
     * @param options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
     */
    stopActivity(
        stopEventName: string,
        fields: undefined.LoggingFields,
        options: undefined.LoggingOptions): void;

    /**
     * Marks the activity as closed/disposed and generates a stop event with the specified event name.
     * @param stopEventName The name for the stop event.
     */
    stopActivity(stopEventName: string): void;

    /**
     * Marks the activity as closed/disposed and generates a stop event with the specified event name and fields.
     * @param stopEventName The name for this event.
     * @param fields The fields for this event. May be null.
     */
    stopActivity(stopEventName: string, fields: undefined.LoggingFields): void
}


/**
 * Represents a source of log messages. 
 */
declare class LoggingChannel {

    /**
     * This constructor creates a LoggingChannel in Windows 8.1 compatibility mode.
     * @param name The name of the logging channel.
     */
    constructor(name: string): this;

    /**
     * Initializes a new instance of the LoggingChannel class with the specified options.
     * @param name The name of the logging channel.
     * @param options The channel options. Pass null to specify the default options.
     */
    constructor(name: string, options: undefined.LoggingChannelOptions): this;

    /**
     * Initializes a new instance of the LoggingChannel class with the specified options and channel ID.
     * @param name The name of the logging channel.
     * @param options The channel options. Pass null to specify the default options.
     * @param id The channel identifier to use instead of the automatically generated identifier.
     */
    constructor(name: string, options: undefined.LoggingChannelOptions, id: string): this;

    /**
     * Ends logging on the current logging channel. 
     */
    close(): void;

    /**
     * Gets a value that indicates whether at least one session is logging events from this channel. 
     */
    enabled: boolean;

    /**
     * Returns the provider identifier for this channel. 
     */
    id: string;

    /**
     * Indicates whether at least one session is listening for events with the specified level and keywords from this channel.
     * @param level The event severity level.
     * @param keywords The keywords. Each bit of the keywords value represents an event category.
     * @return  Returns true if at least one session is listening for events with the specified level and keywords from the channel, and otherwise false.
     */
    isEnabled(level: undefined.LoggingLevel, keywords: number): boolean;

    /**
     * Indicates whether at least one session is listening for events from the channel.
     * @return  Returns true if at least one session is listening for events from the channel, and otherwise false.
     */
    isEnabled(): boolean;

    /**
     * Indicates whether at least one session is listening for events with the specified event severity level from the channel.
     * @param level The event severity level.
     * @return  Returns true if at least one session is listening for events with the specified level from the channel, and otherwise false.
     */
    isEnabled(level: undefined.LoggingLevel): boolean;

    /**
     * Gets the minimum level at which any session is listening to events from this channel. 
     */
    level: undefined.LoggingLevel;

    /**
     * Logs an event with the specified name.
     * @param eventName The name for this event.
     */
    logEvent(eventName: string): void;

    /**
     * Logs an event with the specified name, fields, and level.
     * @param eventName The name for this event.
     * @param fields The fields for this event. May be null.
     * @param level The level of detail for this event.
     */
    logEvent(
        eventName: string,
        fields: undefined.LoggingFields,
        level: undefined.LoggingLevel): void;

    /**
     * Logs an event with the specified name and fields.
     * @param eventName The name for this event.
     * @param fields The fields for this event. May be null.
     */
    logEvent(eventName: string, fields: undefined.LoggingFields): void;

    /**
     * Logs an event with the specified name, fields, level, and options.
     * @param eventName The name for this event.
     * @param fields The fields for this event. May be null.
     * @param level The level of detail for this event.
     * @param options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
     */
    logEvent(
        eventName: string,
        fields: undefined.LoggingFields,
        level: undefined.LoggingLevel,
        options: undefined.LoggingOptions): void;

    /**
     * Logs a message to the current LoggingChannel .
     * @param eventString The message to log.
     */
    logMessage(eventString: string): void;

    /**
     * Logs a message to the current LoggingChannel with the specified LoggingLevel .
     * @param eventString The message to log.
     * @param level The logging level.
     */
    logMessage(eventString: string, level: undefined.LoggingLevel): void;

    /**
     * Logs data to the current LoggingChannel with the specified LoggingLevel .
     * @param value1 The string to associate with value2.
     * @param value2 The value to associate with value1.
     * @param level The logging level.
     */
    logValuePair(value1: string, value2: number, level: undefined.LoggingLevel): void;

    /**
     * Logs data to the current LoggingChannel .
     * @param value1 The string to associate with value2.
     * @param value2 The value to associate with value1.
     */
    logValuePair(value1: string, value2: number): void;

    /**
     * Gets the name of the current LoggingChannel . 
     */
    name: string;

    /**
     * Raised when the logging channel is attached to a LoggingSession or other event tracing and debugging tools. 
     */
    onloggingenabled: undefined.TypedEventHandler<undefined.ILoggingChannel, any>;
    addEventListener(
        type: "loggingenabled",
        listener: undefined.TypedEventHandler<undefined.ILoggingChannel, any>): void;
    removeEventListener(
        type: "loggingenabled",
        listener: undefined.TypedEventHandler<undefined.ILoggingChannel, any>): void;

    /**
     * Writes an activity start event with the specified fields and level, and creates a LoggingActivity object.
     * @param startEventName The name for this event.
     * @param fields The fields for this event. May be null .
     * @param level The level of detail for this event.
     * @return  Returns an object that represents the new activity.
     */
    startActivity(
        startEventName: string,
        fields: undefined.LoggingFields,
        level: undefined.LoggingLevel): undefined.LoggingActivity;

    /**
     * Writes an activity start event and creates a LoggingActivity object.
     * @param startEventName The name for this event.
     * @return  Returns an object that represents the new activity.
     */
    startActivity(startEventName: string): undefined.LoggingActivity;

    /**
     * Writes an activity start event with the specified fields and creates a LoggingActivity object.
     * @param startEventName The name for this event.
     * @param fields The fields for this event.
     * @return  Returns an object that represents the new activity.
     */
    startActivity(
        startEventName: string,
        fields: undefined.LoggingFields): undefined.LoggingActivity;

    /**
     * Writes an activity start event with the specified fields, level, and options, and creates a LoggingActivity object.
     * @param startEventName The name for this event.
     * @param fields The fields for this event. May be null.
     * @param level The level of detail for this event.
     * @param options The options for this event. Pass null to use the default options. The options are for advanced scenarios. The default values are designed to work well for most events.
     * @return  Returns an object that represents the new activity.
     */
    startActivity(
        startEventName: string,
        fields: undefined.LoggingFields,
        level: undefined.LoggingLevel,
        options: undefined.LoggingOptions): undefined.LoggingActivity;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents advanced settings that you can use to configure a LoggingChannel object. 
 */
declare class LoggingChannelOptions {

    /**
     * Creates a LoggingChannelOptions object with all options set to default values. 
     */
    constructor(): this;

    /**
     * Creates a LoggingChannelOptions object with all properties set to default values except for the specified group.
     * @param group The group identifier.
     */
    constructor(group: string): this;

    /**
     * Gets or sets the channel group identifier. 
     */
    group: string
}


/**
 * Represents a sequence of event fields and provides methods for adding fields to the sequence. 
 */
declare class LoggingFields {

    /**
     * Initializes a new LoggingFields instance. 
     */
    constructor(): this;

    /**
     * Adds a boolean field with the specified field name, format, and tags.
     * @param name The name of the event field.
     * @param value The value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addBoolean(
        name: string,
        value: boolean,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a boolean field with the specified field name and format.
     * @param name The name of the event field.
     * @param value The value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addBoolean(name: string, value: boolean, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a boolean field with the specified field name.
     * @param name Name of the event field.
     * @param value Value of the event field.
     */
    addBoolean(name: string, value: boolean): void;

    /**
     * Adds a boolean array field with the specified field name.
     * @param name The name of the event field.
     * @param value The array values for the event field.
     */
    addBooleanArray(name: string, value: boolean[]): void;

    /**
     * Adds a boolean array field with the specified field name and format.
     * @param name The name of the event field.
     * @param value The array of values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addBooleanArray(name: string, value: boolean[], format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a boolean array field with the specified field name, format, and tag.
     * @param name The name of the event field.
     * @param value The array of values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addBooleanArray(
        name: string,
        value: boolean[],
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 16-bit character field with the specified field name.
     * @param name The name of the event field.
     * @param value The value of the event field.
     */
    addChar16(name: string, value: string): void;

    /**
     * Adds a 16-bit character field with the specified field name and format.
     * @param name The name of the event field.
     * @param value The value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addChar16(name: string, value: string, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a 16-bit character field with the specified field name, format, and tag.
     * @param name The name of the event field.
     * @param value The value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addChar16(
        name: string,
        value: string,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 16-bit character array field with the specified field name.
     * @param name The name of the event field.
     * @param value The array of values for the event field.
     */
    addChar16Array(name: string, value: string[]): void;

    /**
     * Adds a 16-bit character array field with the specified field name and format, and tags.
     * @param name The name of the event field.
     * @param value The array of values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addChar16Array(
        name: string,
        value: string[],
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 16-bit character array field with the specified field name and format.
     * @param name The name of the event field.
     * @param value The array of values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addChar16Array(name: string, value: string[], format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a DateTime field with the specified field name.
     * @param name The name of the event field.
     * @param value The value of the event field.
     */
    addDateTime(name: string, value: Date): void;

    /**
     * Adds a DateTime field with the specified field name, format, and tags.
     * @param name The name of the event field.
     * @param value The value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addDateTime(
        name: string,
        value: Date,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a DateTime field with the specified field name and format.
     * @param name The name of the event field.
     * @param value The value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addDateTime(name: string, value: Date, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a DateTime array field with the specified field name, format, and tags.
     * @param name The name of the event field.
     * @param value The array of values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addDateTimeArray(
        name: string,
        value: Date[],
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a DateTime array field with the specified field name and format.
     * @param name The name of the event field.
     * @param value The array of values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addDateTimeArray(name: string, value: Date[], format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a DateTime array field with the specified field name.
     * @param name The name of the event field.
     * @param value The array of values for the event field.
     */
    addDateTimeArray(name: string, value: Date[]): void;

    /**
     * Adds a Double field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value Value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addDouble(
        name: string,
        value: number,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a Double field with the specified field name and format.
     * @param name Name of the event field.
     * @param value Value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addDouble(name: string, value: number, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a Double field with the specified field name.
     * @param name Name of the event field.
     * @param value Value of the event field.
     */
    addDouble(name: string, value: number): void;

    /**
     * Adds a Double array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The array of values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addDoubleArray(
        name: string,
        value: Float64Array,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a Double array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The array of values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addDoubleArray(name: string, value: Float64Array, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a Double array field with the specified field name.
     * @param name Name of the event field.
     * @param value The array of values for the event field.
     */
    addDoubleArray(name: string, value: Float64Array): void;

    /**
     * Adds an empty field.
     * @param name Name of the event field.
     */
    addEmpty(name: string): void;

    /**
     * Adds an empty field.
     * @param name Name of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addEmpty(name: string, format: undefined.LoggingFieldFormat, tags: number): void;

    /**
     * Adds an empty field.
     * @param name Name of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addEmpty(name: string, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a GUID field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value Value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addGuid(
        name: string,
        value: string,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a GUID field with the specified field name and format.
     * @param name Name of the event field.
     * @param value Value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addGuid(name: string, value: string, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a GUID field with the specified field name.
     * @param name Name of the event field.
     * @param value Value of the event field.
     */
    addGuid(name: string, value: string): void;

    /**
     * Adds a GUID array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The array values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addGuidArray(
        name: string,
        value: string[],
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a GUID array field with the specified field name and format
     * @param name Name of the event field.
     * @param value The array values for the event field.
     * @param format The format of the event field.
     */
    addGuidArray(name: string, value: string[], format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a GUID array field with the specified field name.
     * @param name Name of the event field.
     * @param value The array values for the event field.
     */
    addGuidArray(name: string, value: string[]): void;

    /**
     * Adds a 16-bit integer field with the specified field name and format.
     * @param name Name of the event field.
     * @param value Value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addInt16(name: string, value: number, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a 16-bit integer field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value Value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addInt16(
        name: string,
        value: number,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 16-bit integer field with the specified field name.
     * @param name Name of the event field.
     * @param value Value of the event field.
     */
    addInt16(name: string, value: number): void;

    /**
     * Adds a 16-bit integer array field with the specified field name.
     * @param name Name of the event field.
     * @param value Value of the event field.
     */
    addInt16Array(name: string, value: Int16Array): void;

    /**
     * Adds a 16-bit integer array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value Value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addInt16Array(name: string, value: Int16Array, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a 16-bit integer array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value Value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addInt16Array(
        name: string,
        value: Int16Array,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 32-bit integer array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The array values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addInt32(
        name: string,
        value: number,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 32-bit integer array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value Value of the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addInt32(name: string, value: number, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a 32-bit integer array field with the specified field name.
     * @param name Name of the event field.
     * @param value Value of the event field.
     */
    addInt32(name: string, value: number): void;

    /**
     * Adds a 32-bit integer array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The array values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addInt32Array(name: string, value: Int32Array, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a 32-bit integer array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The array values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addInt32Array(
        name: string,
        value: Int32Array,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 32-bit integer array field with the specified field name.
     * @param name Name of the event field.
     * @param value The array values for the event field.
     */
    addInt32Array(name: string, value: Int32Array): void;

    /**
     * Adds a 64-bit integer array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The array values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addInt64(name: string, value: number, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a 64-bit integer field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addInt64(
        name: string,
        value: number,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 64-bit integer array field with the specified field name.
     * @param name Name of the event field.
     * @param value The array values for the event field.
     */
    addInt64(name: string, value: number): void;

    /**
     * Adds a 64-bit integer array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The array values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addInt64Array(
        name: string,
        value: number[],
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 64-bit integer array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The array values for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addInt64Array(name: string, value: number[], format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a 64-bit integer array field with the specified field name.
     * @param name Name of the event field.
     * @param value The array values for the event field.
     */
    addInt64Array(name: string, value: number[]): void;

    /**
     * Adds a Point field with the specified name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addPoint(name: string, value: undefined.Point): void;

    /**
     * Adds a Point field with the specified name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addPoint(
        name: string,
        value: undefined.Point,
        format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a Point field with the specified name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addPoint(
        name: string,
        value: undefined.Point,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a Point array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addPointArray(
        name: string,
        value: undefined.Point,
        format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a Point array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addPointArray(
        name: string,
        value: undefined.Point,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a Point array field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addPointArray(name: string, value: undefined.Point): void;

    /**
     * Adds a Rect field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addRect(
        name: string,
        value: undefined.Rect,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a Rect field with the specified field name, and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addRect(
        name: string,
        value: undefined.Rect,
        format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a Rect field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addRect(name: string, value: undefined.Rect): void;

    /**
     * Adds a Rect array field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addRectArray(name: string, value: undefined.Rect): void;

    /**
     * Adds a Rect array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The value for the event field.
     */
    addRectArray(
        name: string,
        value: undefined.Rect,
        format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a Rect array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addRectArray(
        name: string,
        value: undefined.Rect,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a Single field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addSingle(name: string, value: number, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a Single field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addSingle(
        name: string,
        value: number,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a Single field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addSingle(name: string, value: number): void;

    /**
     * Adds a Single array field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addSingleArray(name: string, value: Float32Array): void;

    /**
     * Adds a Single array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addSingleArray(name: string, value: Float32Array, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a Single array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addSingleArray(
        name: string,
        value: Float32Array,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a Size field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addSize(name: string, value: undefined.Size): void;

    /**
     * Adds a Size field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addSize(
        name: string,
        value: undefined.Size,
        format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a Size field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addSize(
        name: string,
        value: undefined.Size,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a Size array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addSizeArray(
        name: string,
        value: undefined.Size,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a Size array field with the specified field name.
     * @param name The name of the field.
     * @param value The value for the event field.
     */
    addSizeArray(name: string, value: undefined.Size): void;

    /**
     * Adds a Size array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addSizeArray(
        name: string,
        value: undefined.Size,
        format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a String field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addString(name: string, value: string): void;

    /**
     * Adds a String field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addString(
        name: string,
        value: string,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a String field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addString(name: string, value: string, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a String array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addStringArray(name: string, value: string[], format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a String array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addStringArray(
        name: string,
        value: string[],
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a String array field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addStringArray(name: string, value: string[]): void;

    /**
     * Adds a time span field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addTimeSpan(name: string, value: number, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a time span field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addTimeSpan(
        name: string,
        value: number,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a time span field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addTimeSpan(name: string, value: number): void;

    /**
     * Adds a time span array field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addTimeSpanArray(name: string, value: number[]): void;

    /**
     * Adds a time span array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addTimeSpanArray(name: string, value: number[], format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a time span array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addTimeSpanArray(
        name: string,
        value: number[],
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 16-bit unsigned integer field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addUInt16(
        name: string,
        value: number,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 16-bit unsigned integer field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addUInt16(name: string, value: number): void;

    /**
     * Adds a 16-bit unsigned integer field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addUInt16(name: string, value: number, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a16-bit unsigned integer field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
     */
    addUInt16Array(name: string, value: Uint16Array): void;

    /**
     * Adds a 16-bit unsigned integer array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addUInt16Array(
        name: string,
        value: Uint16Array,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 16-bit unsigned integer array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addUInt16Array(name: string, value: Uint16Array, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a 32-bit unsigned integer field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addUInt32(name: string, value: number): void;

    /**
     * Adds a 32-bit unsigned integer field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addUInt32(
        name: string,
        value: number,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 32-bit unsigned integer field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addUInt32(name: string, value: number, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a 32-bit unsigned integer array field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addUInt32Array(name: string, value: Uint32Array): void;

    /**
     * Adds a 32-bit unsigned integer array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addUInt32Array(
        name: string,
        value: Uint32Array,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 32-bit unsigned integer array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addUInt32Array(name: string, value: Uint32Array, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a 64-bit unsigned integer field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addUInt64(name: string, value: number, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds a 64-bit unsigned integer field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addUInt64(name: string, value: number): void;

    /**
     * Adds a 64-bit unsigned integer field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addUInt64(
        name: string,
        value: number,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 64-bit unsigned integer array field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addUInt64Array(name: string, value: number[]): void;

    /**
     * Adds a 64-bit unsigned integer array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addUInt64Array(
        name: string,
        value: number[],
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds a 64-bit unsigned integer array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addUInt64Array(name: string, value: number[], format: undefined.LoggingFieldFormat): void;

    /**
     * Adds an 8-bit unsigned integer field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field.
     */
    addUInt8(name: string, value: number): void;

    /**
     * Adds an 8-bit unsigned integer field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addUInt8(
        name: string,
        value: number,
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Adds an 8-bit unsigned integer field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addUInt8(name: string, value: number, format: undefined.LoggingFieldFormat): void;

    /**
     * Adds an 8-bit unsigned integer array field with the specified field name.
     * @param name Name of the event field.
     * @param value The value for the event field. The format for the array is binary.
     */
    addUInt8Array(name: string, value: number[]): void;

    /**
     * Adds an 8-bit unsigned integer array field with the specified field name and format.
     * @param name Name of the event field.
     * @param value The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     */
    addUInt8Array(name: string, value: number[], format: undefined.LoggingFieldFormat): void;

    /**
     * Adds an 8-bit unsigned integer array field with the specified field name, format, and tags.
     * @param name Name of the event field.
     * @param value The value for the event field. The default format for the array is binary. See the remarks section for other formats that may be specified.
     * @param format The format of the event field. Specifies an optional formatting hint that may be used by Event Tracing for Windows (ETW) tools.
     * @param tags The user-defined tag for the event field. Specifies up to twenty-eight bits of user-defined field processing metadata for use by a custom ETW processing tool. The top four bits are reserved and must be set to zero (0).
     */
    addUInt8Array(
        name: string,
        value: number[],
        format: undefined.LoggingFieldFormat,
        tags: number): void;

    /**
     * Begins a new structured field with the specified field name.
     * @param name Name of the structured field.
     */
    beginStruct(name: string): void;

    /**
     * Begins a new structured field with the specified field name and tags.
     * @param name Name of the structured field.
     * @param tags Specifies up to twenty-eight bits of user-defined field metadata. The top four bits are reserved and must be set to zero (0).
     */
    beginStruct(name: string, tags: number): void;

    /**
     * Removes all fields stored in the object and resets the object to its newly-constructed state. 
     */
    clear(): void;

    /**
     * Ends a structured field. 
     */
    endStruct(): void
}


/**
 * Represents advanced event settings. 
 */
declare class LoggingOptions {

    /**
     * Initializes a new LoggingOptions instance with default option values. 
     */
    constructor(): this;

    /**
     * Initializes a new LoggingOptions instance with the specified keyword value.
     * @param keywords The keyword value.
     */
    constructor(keywords: number): this;

    /**
     * Gets or sets the unique identifier associated with an activity. 
     */
    activityId: string;

    /**
     * Gets or sets the keyword value that represents the different categories that an event belongs to. 
     */
    keywords: number;

    /**
     * Gets or sets the operation code value for an event. 
     */
    opcode: undefined.LoggingOpcode;

    /**
     * Gets or sets a value that uniquely identifies the parent activity to which this activity is related. 
     */
    relatedActivityId: string;

    /**
     * Gets or sets the user-defined metadata value attached to an event. 
     */
    tags: number;

    /**
     * Gets or sets the user-defined value that identifies a larger unit of work within an application or component. 
     */
    task: number
}


/**
 * Represents the destination of logged messages from LoggingChannel instances. 
 */
declare class LoggingSession {

    /**
     * Initializes a new instance of the LoggingSession class.
     * @param name The name of the logging session.
     */
    constructor(name: string): this;

    /**
     * Adds a logging channel with the specified logging level to the current logging session.
     * @param loggingChannel The logging channel to add.
     * @param maxLevel The logging level for loggingChannel.
     */
    addLoggingChannel(
        loggingChannel: undefined.ILoggingChannel,
        maxLevel: undefined.LoggingLevel): void;

    /**
     * Adds a logging channel to the current logging session.
     * @param loggingChannel The logging channel to add.
     */
    addLoggingChannel(loggingChannel: undefined.ILoggingChannel): void;

    /**
     * Ends the current logging session. 
     */
    close(): void;

    /**
     * Gets the name of the logging session. 
     */
    name: string;

    /**
     * Removes the specified logging channel from the current logging session.
     * @param loggingChannel The logging channel to remove.
     */
    removeLoggingChannel(loggingChannel: undefined.ILoggingChannel): void;

    /**
     * Saves the current logging session to a file.
     * @param folder The folder that contains the log file.
     * @param fileName The name of the log file.
     * @return  When this method completes, it returns the new file as a StorageFile .
     */
    saveToFileAsync(
        folder: undefined.IStorageFolder,
        fileName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile >
}


/**
 * Represents diagnostic error reporting settings. 
 */
declare class RuntimeBrokerErrorSettings {

    /**
     * Creates and initializes a new instance of the RuntimeBrokerErrorSettings . 
     */
    constructor(): this;

    /**
     * Gets the type of error reporting for the error object.
     * @return  One of the enumeration values.
     */
    getErrorOptions(): undefined.ErrorOptions;

    /**
     * Sets the type of error reporting for the error object.
     * @param value One of the enumeration values.
     */
    setErrorOptions(value: undefined.ErrorOptions): void
}


/**
 * Provides data for the TracingStatusChanged event. 
 */
declare class TracingStatusChangedEventArgs {

    /**
     * Gets a value that indicates whether tracing is active. 
     */
    enabled: boolean;

    /**
     * Gets the trace level for the current tracing session. 
     */
    traceLevel: undefined.CausalityTraceLevel
}


/**
 * Represents a source of log messages. 
 */
declare type Diagnostics$ILoggingChannel = {

    /**
     * Logs a message to the current LoggingChannel .
     * @param eventString The message to log.
     */
    logMessage(eventString: string): void,

    /**
     * Logs a message to the current LoggingChannel with the specified LoggingLevel .
     * @param eventString The message to log.
     * @param level The logging level.
     */
    logMessage(eventString: string, level: undefined.LoggingLevel): void,

    /**
     * Logs data to the current LoggingChannel with the specified LoggingLevel .
     * @param value1 The string to associate with value2.
     * @param value2 The value to associate with value1.
     * @param level The logging level.
     */
    logValuePair(value1: string, value2: number, level: undefined.LoggingLevel): void,

    /**
     * Logs data to the current LoggingChannel .
     * @param value1 The string to associate with value2.
     * @param value2 The value to associate with value1.
     */
    logValuePair(value1: string, value2: number): void,

    /**
     * Gets a value that indicates whether messages are being logged on the current LoggingChannel . 
     */
    enabled: boolean,

    /**
     * Gets the level of detail for messages from the current LoggingChannel . 
     */
    level: undefined.LoggingLevel,

    /**
     * Gets the name of the current LoggingChannel . 
     */
    name: string
}


/**
 * Represents the destination of logged messages from LoggingChannel instances. 
 */
declare type Diagnostics$IFileLoggingSession = {

    /**
     * Adds a logging channel with the specified logging level to the current logging session.
     * @param loggingChannel The logging channel to add.
     * @param maxLevel The logging level for loggingChannel.
     */
    addLoggingChannel(
        loggingChannel: undefined.ILoggingChannel,
        maxLevel: undefined.LoggingLevel): void,

    /**
     * Adds a logging channel to the current logging session.
     * @param loggingChannel The logging channel to add.
     */
    addLoggingChannel(loggingChannel: undefined.ILoggingChannel): void,

    /**
     * Ends the current logging session and saves it to a file.
     * @return  When this method completes, it returns the new file as a StorageFile .
     */
    closeAndSaveToFileAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>,

    /**
     * Removes the specified logging channel from the current logging session.
     * @param loggingChannel The logging channel to remove.
     */
    removeLoggingChannel(loggingChannel: undefined.ILoggingChannel): void,

    /**
     * Gets the name of the logging session. 
     */
    name: string
}


/**
 * Represents a reference counted memory buffer. 
 */
declare class MemoryBuffer {

    /**
     * Initializes a new MemoryBuffer instance with the specified capacity.
     * @param capacity The desired size of the new memory buffer.
     */
    constructor(capacity: number): this;

    /**
     * Disconnects this MemoryBuffer object from the actual memory buffer. 
     */
    close(): void;

    /**
     * Returns a new managed object that implements the IMemoryBufferReference interface.
     * @return  A new managed object that implements the IMemoryBufferReference interface.
     */
    createReference(): undefined.IMemoryBufferReference
}


/**
 * Indicates that the class is an activatable runtime class. 
 */
declare class ActivatableAttribute {}


/**
 * Enables developers to expose a native Universal Windows Platform (UWP) object as a global parameter in the context of the top-level document inside of a WebView . For a UWP object to be projected, it must implement IAgileObject and be decorated with the AllowForWebAttribute attribute. 
 */
declare class AllowForWebAttribute {}


/**
 * Indicates that multiple instances of a custom attribute can be applied to a target. 
 */
declare class AllowMultipleAttribute {}

declare class ApiContractAttribute {}


/**
 * Enables you to detect whether a specified member, type, or API contract is present so that you can safely make API calls across a variety of devices. 
 */
declare class ApiInformation {

    /**
     * Returns true or false to indicate whether the API contract with the specified name and major version number is present.
     * @param contractName The name of the API contract.
     * @param majorVersion The major version number of the API contract.
     * @return  True if the specified API contract is present; otherwise, false.
     */
    isApiContractPresent(contractName: string, majorVersion: number): boolean;

    /**
     * Returns true or false to indicate whether the API contract with the specified name and major and minor version number is present.
     * @param contractName The name of the API contract.
     * @param majorVersion The major version number of the API contract.
     * @param minorVersion The minor version number of the API contract.
     * @return  True if the specified API contract is present; otherwise, false.
     */
    isApiContractPresent(contractName: string, majorVersion: number, minorVersion: number): boolean;

    /**
     * Returns true or false to indicate whether a specified named constant is present for a specified enumeration.
     * @param enumTypeName The namespace-qualified name of the type.
     * @param valueName The name of the constant.
     * @return  True if the specified constant is present; otherwise, false.
     */
    isEnumNamedValuePresent(enumTypeName: string, valueName: string): boolean;

    /**
     * Returns true or false to indicate whether a specified event is present for a specified type.
     * @param typeName The namespace-qualified name of the type.
     * @param eventName The name of the event.
     * @return  True if the specified event is present for the type; otherwise, false.
     */
    isEventPresent(typeName: string, eventName: string): boolean;

    /**
     * Returns true or false to indicate whether a specified method is present for a specified type.
     * @param typeName The namespace-qualified name of the type.
     * @param methodName The name of the method.
     * @return  True if the specified method is present for the type; otherwise, false.
     */
    isMethodPresent(typeName: string, methodName: string): boolean;

    /**
     * Returns true or false to indicate whether a specified method overload with the specified number of input parameters is present for a specified type.
     * @param typeName The namespace-qualified name of the type.
     * @param methodName The name of the method.
     * @param inputParameterCount The number of input parameters for the overload.
     * @return  True if the specified method is present for the type; otherwise, false.
     */
    isMethodPresent(typeName: string, methodName: string, inputParameterCount: number): boolean;

    /**
     * Returns true or false to indicate whether a specified property (writeable or read-only) is present for a specified type.
     * @param typeName The namespace-qualified name of the type.
     * @param propertyName The name of the property.
     * @return  True if the specified property is present for the type; otherwise, false.
     */
    isPropertyPresent(typeName: string, propertyName: string): boolean;

    /**
     * Returns true or false to indicate whether a specified read-only property is present for a specified type.
     * @param typeName The namespace-qualified name of the type.
     * @param propertyName The name of the property.
     * @return  True if the specified property is present for the type; otherwise, false.
     */
    isReadOnlyPropertyPresent(typeName: string, propertyName: string): boolean;

    /**
     * Returns true or false to indicate whether a specified type is present.
     * @param typeName The namespace-qualified name of the type.
     * @return  True if the specified type is present; otherwise, false.
     */
    isTypePresent(typeName: string): boolean;

    /**
     * Returns true or false to indicate whether a specified writeable property is present for a specified type.
     * @param typeName The namespace-qualified name of the type.
     * @param propertyName The name of the property.
     * @return  True if the specified property is present for the type; otherwise, false.
     */
    isWriteablePropertyPresent(typeName: string, propertyName: string): boolean
}


/**
 * Specifies the use of another attribute. 
 */
declare class AttributeUsageAttribute {}


/**
 * Indicates how a programming element is composed. 
 */
declare class ComposableAttribute {}

declare class ContractVersionAttribute {}


/**
 * Indicates the default interface for a runtime class. 
 */
declare class DefaultAttribute {}


/**
 * Indicates that a method is the default overload method. This attribute must be used with OverloadAttribute . 
 */
declare class DefaultOverloadAttribute {}


/**
 * Indicates that a type or member should be marked in metadata as deprecated. Compilers and other developer tools can read this attribute and provide info to the user about the deprecation type and possible alternates. 
 */
declare class DeprecatedAttribute {}


/**
 * Indicates that the type is supported in desktop apps and in Windows Store apps. 
 */
declare class DualApiPartitionAttribute {}


/**
 * Indicates that the specified type is exclusive to this type. 
 */
declare class ExclusiveToAttribute {}


/**
 * Indicates that a type or member should be marked in metadata as experimental, and consequently may not be present in the final, released version of an SDK or library. 
 */
declare class ExperimentalAttribute {}

declare class GCPressureAttribute {}


/**
 * Indicates the GUID for the interface or delegate. 
 */
declare class GuidAttribute {}


/**
 * Indicates that the type is an instance of a variant IInspectable. Applies to runtime classes, interfaces, and parameterized interfaces. 
 */
declare class HasVariantAttribute {}


/**
 * Indicates that a type or member should be marked in metadata as internal to the SDK or framework, and for consumption by system components only. 
 */
declare class InternalAttribute {}


/**
 * Indicates the number of array elements. 
 */
declare class LengthIsAttribute {}


/**
 * Indicates the marshaling behavior of a Windows Runtime component. 
 */
declare class MarshalingBehaviorAttribute {}


/**
 * Indicates that tools should create an entry for an interface when creating an application package. 
 */
declare class MetadataMarshalAttribute {}


/**
 * Indicates that a runtime class is compatible with Windows Store apps that are web browsers. 
 */
declare class MuseAttribute {}


/**
 * Identifies the method as an overload in a language that supports overloading. 
 */
declare class OverloadAttribute {}


/**
 * Indicates that the interface contains overridable methods. 
 */
declare class OverridableAttribute {}


/**
 * Declares the platform that a type should be supported in, when platform-specific metadata is produced. 
 */
declare class PlatformAttribute {}

declare class PreviousContractVersionAttribute {}


/**
 * Indicates that the interface contains protected methods. 
 */
declare class ProtectedAttribute {}


/**
 * Indicates the numeric range constraints for the value of a data field. 
 */
declare class RangeAttribute {}


/**
 * Indicates that an interface can be delivered using an asynchronous form of the Async pattern. 
 */
declare class RemoteAsyncAttribute {}


/**
 * Indicates an interface that contains only static methods. 
 */
declare class StaticAttribute {}


/**
 * Indicates the threading model of a Windows Runtime component. 
 */
declare class ThreadingAttribute {}


/**
 * Indicates that the item is an instance of a variant IInspectable. Applies to method parameters, properties, and return values of types. 
 */
declare class VariantAttribute {}


/**
 * Indicates the version of the type. 
 */
declare class VersionAttribute {}


/**
 * Identifies the type as one whose functionality is not projected into the specified target language. 
 */
declare class WebHostHiddenAttribute {}


/**
 * Describes a 44 floating point matrix. 
 */
declare interface Numerics$Matrix4x4 {

    /**
     * The row one and column one element of the matrix. 
     */
    m11: number,

        /**
         * The row one and column two element of the matrix. 
         */
        m12: number,

        /**
         * The row one and column three element of the matrix. 
         */
        m13: number,

        /**
         * The row one and column four element of the matrix. 
         */
        m14: number,

        /**
         * The row two and column one element of the matrix. 
         */
        m21: number,

        /**
         * The row two and column two element of the matrix. 
         */
        m22: number,

        /**
         * The row two and column three element of the matrix. 
         */
        m23: number,

        /**
         * The row two and column four element of the matrix. 
         */
        m24: number,

        /**
         * The row three and column one element of the matrix. 
         */
        m31: number,

        /**
         * The row three and column two element of the matrix. 
         */
        m32: number,

        /**
         * The row three and column three element of the matrix. 
         */
        m33: number,

        /**
         * The row three and column four element of the matrix. 
         */
        m34: number,

        /**
         * The row four and column one element of the matrix. 
         */
        m41: number,

        /**
         * The row four and column two element of the matrix. 
         */
        m42: number,

        /**
         * The row four and column three element of the matrix. 
         */
        m43: number,

        /**
         * The row four and column four element of the matrix. 
         */
        m44: number
}


/**
 * Describes a vector of three floating-point components. 
 */
declare interface Numerics$Vector3 {

    /**
     * The x component of the vector. 
     */
    x: number,

        /**
         * The y component of the vector. 
         */
        y: number,

        /**
         * The z component of the vector. 
         */
        z: number
}


/**
 * Describes a quaternion (an axis about which a rotation occurs and a rotation amount about that axis). 
 */
declare interface Numerics$Quaternion {

    /**
     * The w component that represents a rotation amount about the axis that is defined by the X, Y, and Z fields. 
     */
    w: number,

        /**
         * The x component of the vector that represents the axis about which a rotation occurs. 
         */
        x: number,

        /**
         * The y component of the vector that represents the axis about which a rotation occurs. 
         */
        y: number,

        /**
         * The z component of the vector that represents the axis about which a rotation occurs. 
         */
        z: number
}


/**
 * Describes a vector of two floating-point components. 
 */
declare interface Numerics$Vector2 {

    /**
     * The x component of the vector. 
     */
    x: number,

        /**
         * The y component of the vector. 
         */
        y: number
}


/**
 * Describes a 32 floating point matrix. 
 */
declare interface Numerics$Matrix3x2 {

    /**
     * The row one and column one element of the matrix. 
     */
    m11: number,

        /**
         * The row one and column two element of the matrix. 
         */
        m12: number,

        /**
         * The row two and column one element of the matrix. 
         */
        m21: number,

        /**
         * The row two and column two element of the matrix. 
         */
        m22: number,

        /**
         * The row three and column one element of the matrix. 
         */
        m31: number,

        /**
         * The row three and column two element of the matrix. 
         */
        m32: number
}


/**
 * Defines an object that represents a Uniform Resource Identifier (URI) value and parses it into components. The Uri object is used by many other Windows Runtime APIs that are not necessarily confined to web browser scenarios. 
 */
declare class Uri {

    /**
     * Converts a Uniform Resource Identifier (URI) string to its escaped representation.
     * @param toEscape The string to convert.
     * @return  The escaped representation of toEscape.
     */
    escapeComponent(toEscape: string): string;

    /**
     * Converts the specified string by replacing any escape sequences with their unescaped representation.
     * @param toUnescape The string to convert.
     * @return  The unescaped representation of stringToUnescape.
     */
    unescapeComponent(toUnescape: string): string;

    /**
     * Initializes a new Uri by combining a base Uniform Resource Identifier (URI) and a relative URI. Initializing the Uri also parses the combined string and populates the Uri properties that represent URI components.
     * @param baseUri The base URI.
     * @param relativeUri The relative URI.
     */
    constructor(baseUri: string, relativeUri: string): this;

    /**
     * Initializes a new Uri object from the specified Uniform Resource Identifier (URI) string. Initializing the Uri also parses the string and populates the Uri properties that represent URI components.
     * @param uri The string from which the new Uri object is created.
     */
    constructor(uri: string): this;

    /**
     * Gets a fully canonical RFC-compliant representation of the current URI. 
     */
    absoluteCanonicalUri: string;

    /**
     * Gets the entire, non-canonical URI (It is non-canonical because it might actually be an IRI, per the Windows.Foundation.Uri encoding behavior; see Remarks.). 
     */
    absoluteUri: string;

    /**
     * Adds the specified Uniform Resource Identifier (URI) to the current Uri .
     * @param relativeUri A relative URI specified as a string. This relative path is evaluated using the host/authority of the Uri instance where this method is called.
     * @return  The combined Uri value.
     */
    combineUri(relativeUri: string): undefined.Uri;

    /**
     * Gets the decoded unicode characters that make up the current URI. 
     */
    displayIri: string;

    /**
     * Gets a representation of the Uniform Resource Identifier (URI) that can be used for display purposes. 
     */
    displayUri: string;

    /**
     * Gets the domain name component, including top-level domain, from a Uniform Resource Identifier (URI). 
     */
    domain: string;

    /**
     * Determines whether the specified Uri object is equal to the current Uri object.
     * @param pUri The Uri object to be compared.
     * @return  true if the two Uri values are the same; otherwise, false.
     */
    equals(pUri: undefined.Uri): boolean;

    /**
     * Gets the file name extension of the resource that is referenced in the Uri . 
     */
    extension: string;

    /**
     * Gets the text following a fragment marker (#), including the fragment marker itself. 
     */
    fragment: string;

    /**
     * Gets the fully qualified domain name. 
     */
    host: string;

    /**
     * Gets the password component of the Uniform Resource Identifier (URI) as stored in this Uri instance. 
     */
    password: string;

    /**
     * Gets the path and resource name component of the Uniform Resource Identifier (URI) as stored in this Uri instance. 
     */
    path: string;

    /**
     * Gets the port number component of the Uniform Resource Identifier (URI) as stored in this Uri instance 
     */
    port: number;

    /**
     * Gets the query string component of the Uniform Resource Identifier (URI) as stored in this Uri instance. 
     */
    query: string;

    /**
     * Gets a parsed Uniform Resource Identifier (URI) query string. 
     */
    queryParsed: undefined.WwwFormUrlDecoder;

    /**
     * Gets the entire original Uniform Resource Identifier (URI) string as used to construct this Uri object, before parsing, and without any encoding applied. 
     */
    rawUri: string;

    /**
     * Gets the protocol scheme name component of the Uniform Resource Identifier (URI) as stored in this Uri instance 
     */
    schemeName: string;

    /**
     * Gets a value that indicates whether parsing determined that the Uniform Resource Identifier (URI) is not well-formed. 
     */
    suspicious: boolean;

    /**
     * Gets the user name component of the Uniform Resource Identifier (URI) as stored in this Uri instance. 
     */
    userName: string
}


/**
 * Parses a URL query string, and exposes the results as a read-only vector (list) of name-value pairs from the query string. 
 */
declare class WwwFormUrlDecoder mixins Array<undefined.IWwwFormUrlDecoderEntry>{

    /**
     * Creates and initializes a new instance of the WwwFormUrlDecoder class.
     * @param query The URL to parse.
     */
    constructor(query: string): this;

    /**
     * Gets an iterator that represents the first name-value pair in the current URL query string.
     * @return  The first name-value pair.
     */
    first(): undefined.IIterator<undefined.IWwwFormUrlDecoderEntry>;

    /**
     * Gets the name-value pair at the specified index in the current URL query string.
     * @param index The index of the name-value pair.
     * @return  The name-value pair at the position specified by index.
     */
    getAt(index: number): undefined.IWwwFormUrlDecoderEntry;

    /**
     * Gets the first name-value pair that has the specified name, as obtained from the constructing Uniform Resource Identifier (URI) query string.
     * @param name The name of the value to get.
     * @return  The first value in list order that corresponds with name.
     */
    getFirstValueByName(name: string): string;

    /**
     * Gets name-value pairs starting at the specified index in the current URL query string.
     * @param startIndex The index to start getting name-value pairs at.
     */
    getMany(
        startIndex: number): {
        items: undefined.IWwwFormUrlDecoderEntry,
        returnValue: number
    };

    /**
     * Gets a value indicating whether the specified IWwwFormUrlDecoderEntry is at the specified index in the current URL query string.
     * @param value The name-value pair to get the index of.
     */
    indexOf(
        value: undefined.IWwwFormUrlDecoderEntry): {
        index: number,
        returnValue: boolean
    };

    /**
     * Gets the number of the name-value pairs in the current URL query string. 
     */
    size: number;
    indexOf(
        value: undefined.IWwwFormUrlDecoderEntry,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.IWwwFormUrlDecoderEntry, fromIndex?: number): number
}


/**
 * Represents a name-value pair in a URL query string. Use the IWwwFormUrlDecoderEntry interface instead; see Remarks. 
 */
declare class WwwFormUrlDecoderEntry {

    /**
     * Represents the name of a parameter in a URL query string. Use the IWwwFormUrlDecoderEntry interface version ( IWwwFormUrlDecoderEntry.Name ) instead; see Remarks. 
     */
    name: string;

    /**
     * Represents a named value in a URL query string. Use the IWwwFormUrlDecoderEntry interface version ( IWwwFormUrlDecoderEntry.Value ) instead; see Remarks. 
     */
    value: string
}


/**
 * Represents a method that handles general events. 
 */
declare type Foundation$EventHandler<T>= (ev: T & Windows$WinRTEvent<any>) => void;


/**
 * Contains number values that represent the location and size of a rectangle. 
 */
declare interface Foundation$Rect {

    /**
     * The height of the rectangle, in pixels. 
     */
    height: number,

        /**
         * The width of the rectangle, in pixels. 
         */
        width: number,

        /**
         * The x-coordinate of the upper-left corner of the rectangle. 
         */
        x: number,

        /**
         * The y-coordinate of the upper-left corner of the rectangle. 
         */
        y: number
}


/**
 * Represents a method that handles general events. 
 */
declare type Foundation$TypedEventHandler<TSender, TResult>= (ev: TResult & Windows$WinRTEvent<TSender>) => void;


/**
 * Represents number values that specify a height and width. 
 */
declare interface Foundation$Size {

    /**
     * The height. 
     */
    height: number,

        /**
         * The width. 
         */
        width: number
}


/**
 * Represents an asynchronous operation, which returns a result upon completion. This is the return type for many Windows Runtime asynchronous methods that have results but don't report progress. 
 */
declare type Foundation$IAsyncOperation<TResult>= {

    /**
     * Returns the results of the operation.
     * @return  The results of the operation.
     */
    getResults(): TResult,

    /**
     * Gets or sets the method that handles the operation completed notification. 
     */
    completed: undefined.AsyncOperationCompletedHandler<TResult >
}


/**
 * Represents an asynchronous action. This is the return type for many Windows Runtime asynchronous methods that don't have a result object, and don't report ongoing progress. 
 */
declare type Foundation$IAsyncAction = {

    /**
     * Returns the results of the action. 
     */
    getResults(): void,

    /**
     * Gets or sets the method that handles the action completed notification. 
     */
    completed: undefined.AsyncActionCompletedHandler
}


/**
 * Represents an asynchronous operation that can report progress updates to callers. This is the return type for many Windows Runtime asynchronous methods that have results and also report progress. 
 */
declare type Foundation$IAsyncOperationWithProgress<TResult, TProgress>= {

    /**
     * Returns the results of the operation.
     * @return  The results of the operation.
     */
    getResults(): TResult,

    /**
     * Gets or sets the method that handles the operation completed notification. 
     */
    completed: undefined.AsyncOperationWithProgressCompletedHandler<TResult,
    TProgress>,

    /**
     * Gets or sets the method that handles progress notifications. 
     */
    progress: undefined.AsyncOperationProgressHandler<TResult,
    TProgress >
}


/**
 * Represents x- and y-coordinate values that define a point in a two-dimensional plane. 
 */
declare interface Foundation$Point {

    /**
     * The horizontal position of the point. 
     */
    x: number,

        /**
         * The vertical position of the point. 
         */
        y: number
}


/**
 * Represents a reference counted memory buffer. 
 */
declare type Foundation$IMemoryBuffer = {

    /**
     * Returns a new managed object that implements the IMemoryBufferReference interface.
     * @return  A new managed object that implements the IMemoryBufferReference interface.
     */
    createReference(): undefined.IMemoryBufferReference
}


/**
 * Represents a method that handles the completed event of an asynchronous action. 
 */
declare type Foundation$AsyncActionCompletedHandler = (asyncInfo: undefined.IAsyncAction, asyncStatus: undefined.AsyncStatus) => void;


/**
 * Represents a method that handles the completed event of an asynchronous operation. 
 */
declare type Foundation$AsyncOperationCompletedHandler<TResult>= (
    asyncInfo: undefined.IAsyncOperation<TResult>,
    asyncStatus: undefined.AsyncStatus) => void;


/**
 * Represents a method that handles the completed event of an asynchronous operation that provides progress updates. 
 */
declare type Foundation$AsyncOperationWithProgressCompletedHandler<TResult, TProgress>= (
    asyncInfo: undefined.IAsyncOperationWithProgress<TResult, TProgress>,
    asyncStatus: undefined.AsyncStatus) => void;


/**
 * Represents a method that handles progress update events of an asynchronous operation that provides progress updates. 
 */
declare type Foundation$AsyncOperationProgressHandler<TResult, TProgress>= (
    asyncInfo: undefined.IAsyncOperationWithProgress<TResult, TProgress>,
    progressInfo: TProgress) => void;


/**
 * Represents a method that handles the completed event of a deferred action. 
 */
declare type Foundation$DeferralCompletedHandler = () => void;


/**
 * Represents a reference to an IMemoryBuffer object. 
 */
declare type Foundation$IMemoryBufferReference = {

    /**
     * Gets the size of the memory buffer in bytes. 
     */
    capacity: number
}


/**
 * Represents a name-value pair in a URL query string. 
 */
declare interface Foundation$IWwwFormUrlDecoderEntry {

    /**
     * Represents the name of a parameter in a URL query string. 
     */
    name: string,

        /**
         * Represents a named value in a URL query string. 
         */
        value: string
}


/**
 * Represents an asynchronous action that can report progress updates to callers. This is the return type for all Windows Runtime asynchronous methods that don't have a result object, but do report progress to callback listeners. 
 */
declare type Foundation$IAsyncActionWithProgress<TProgress>= {

    /**
     * Returns the results of the action. 
     */
    getResults(): void,

    /**
     * Gets or sets the method that handles the action completed notification. 
     */
    completed: undefined.AsyncActionWithProgressCompletedHandler<TProgress>,

    /**
     * Gets or sets the callback method that receives progress notification. 
     */
    progress: undefined.AsyncActionProgressHandler<TProgress >
}


/**
 * Supports asynchronous actions and operations. IAsyncInfo is a base interface for IAsyncAction , IAsyncActionWithProgress<TProgress> , IAsyncOperation<TResult> and IAsyncOperationWithProgress<TResult,TProgress> , each of which support combinations of return type and progress for an asynchronous method. 
 */
declare interface Foundation$IAsyncInfo {

    /**
     * Cancels the asynchronous operation. 
     */
    cancel(): void,

        /**
         * Closes the asynchronous operation. 
         */
        close(): void,

        /**
         * Gets a string that describes an error condition of the asynchronous operation. 
         */
        errorCode: Windows$WinRTError,

        /**
         * Gets the handle of the asynchronous operation. 
         */
        id: number,

        /**
         * Gets a value that indicates the status of the asynchronous operation. 
         */
        status: undefined.AsyncStatus
}


/**
 * Defines a method to release allocated resources. 
 */
declare interface Foundation$IClosable {

    /**
     * Releases system resources that are exposed by a Windows Runtime object. 
     */
    close(): void
}


/**
 * Represents a method that handles the completed event of an asynchronous action that provides progress updates. 
 */
declare type Foundation$AsyncActionWithProgressCompletedHandler<TProgress>= (
    asyncInfo: undefined.IAsyncActionWithProgress<TProgress>,
    asyncStatus: undefined.AsyncStatus) => void;


/**
 * Represents a method that handles progress update events of an asynchronous action that provides progress updates. 
 */
declare type Foundation$AsyncActionProgressHandler<TProgress>= (
    asyncInfo: undefined.IAsyncActionWithProgress<TProgress>,
    progressInfo: TProgress) => void;


/**
 * Provides a way to represent the current object as a string. 
 */
declare interface Foundation$IStringable {

    /**
     * Gets a string that represents the current object.
     * @return  A string that represents the current object.
     */
    toString(): string
}


/**
 * Represents a game controller. 
 */
declare class Gamepad {

    /**
     * The list of all connected gamepads. 
     */
    gamepads: undefined.IVectorView<undefined.Gamepad>;

    /**
     * Signals when a new gamepad is connected. 
     */
    ongamepadadded: undefined.EventHandler<any>;
    addEventListener(type: "gamepadadded", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "gamepadadded", listener: undefined.EventHandler<any>): void;

    /**
     * Signals when a gamepad is disconnected. 
     */
    ongamepadremoved: undefined.EventHandler<any>;
    addEventListener(type: "gamepadremoved", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "gamepadremoved", listener: undefined.EventHandler<any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void;

    /**
     * Gets a snapshot of the gamepad state.
     * @return  Returns a GamepadReading containing the current state of the gamepad.
     */
    getCurrentReading(): undefined.GamepadReading;

    /**
     * The audio headset attached to the gamepad. 
     */
    headset: undefined.Headset;

    /**
     * Gets a value that indicates the wireless state of the gamepad. 
     */
    isWireless: boolean;

    /**
     * Signals when a headset is attached to the gamepad. 
     */
    onheadsetconnected: undefined.TypedEventHandler<undefined.IGameController, undefined.Headset>;
    addEventListener(
        type: "headsetconnected",
        listener: undefined.TypedEventHandler<undefined.IGameController, undefined.Headset>): void;
    removeEventListener(
        type: "headsetconnected",
        listener: undefined.TypedEventHandler<undefined.IGameController, undefined.Headset>): void;

    /**
     * Signals when a headset is disconnected from the gamepad. 
     */
    onheadsetdisconnected: undefined.TypedEventHandler<undefined.IGameController, undefined.Headset>;
    addEventListener(
        type: "headsetdisconnected",
        listener: undefined.TypedEventHandler<undefined.IGameController, undefined.Headset>): void;
    removeEventListener(
        type: "headsetdisconnected",
        listener: undefined.TypedEventHandler<undefined.IGameController, undefined.Headset>): void;

    /**
     * Signals when the user associated with the gamepad has changed. 
     */
    onuserchanged: undefined.TypedEventHandler<undefined.IGameController, undefined.UserChangedEventArgs>;
    addEventListener(
        type: "userchanged",
        listener: undefined.TypedEventHandler<undefined.IGameController, undefined.UserChangedEventArgs>): void;
    removeEventListener(
        type: "userchanged",
        listener: undefined.TypedEventHandler<undefined.IGameController, undefined.UserChangedEventArgs>): void;

    /**
     * The user associated with the gamepad. 
     */
    user: undefined.User;

    /**
     * Describes the gamepad motor speed. 
     */
    vibration: undefined.GamepadVibration;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains information about an audio headset attached to a gamepad. 
 */
declare class Headset {

    /**
     * The XAudio endpoint ID for the headset's audio capture device. 
     */
    captureDeviceId: string;

    /**
     * The XAudio enpoint ID for the headset's audio render device. 
     */
    renderDeviceId: string
}


/**
 * Represents the current state of the controller. 
 */
declare interface Input$GamepadReading {

    /**
     * The state of the controller buttons. 
     */
    buttons: undefined.GamepadButtons,

        /**
         * The position of the left thumbstick on the X-asxis. The value is between -1.0 and 1.0. 
         */
        leftThumbstickX: number,

        /**
         * The position of the left thumbstick on the Y-axis.The value is between -1.0 and 1.0. 
         */
        leftThumbstickY: number,

        /**
         * The position of the left trigger. The value is between 0.0 (not depressed) and 1.0 (fully depressed). 
         */
        leftTrigger: number,

        /**
         * The position of the right thumbstick on the X-axis.The value is between -1.0 and 1.0. 
         */
        rightThumbstickX: number,

        /**
         * The position of the right thumbstick on the Y-axis. The value is between -1.0 and 1.0. 
         */
        rightThumbstickY: number,

        /**
         * The position of the right trigger. The value is between 0.0 (not depressed) and 1.0 (fully depressed). 
         */
        rightTrigger: number,

        /**
         * Time when the state was retrieved from the controller. 
         */
        timestamp: number
}


/**
 * The core interface required to be implemented by all controller devices, regardless of their actual type (i.e. gamepads, steering wheels, flight sticks, etc). This interface exists mainly to support extensibility for game controllers, which allows OEMs to publish WinRT classes that provide rich access to their device's features, while integrating into the underlying game controller device enumeration framework. 
 */
declare interface Input$IGameController {

    /**
     * The audio headset attached to the controller. 
     */
    headset: undefined.Headset,

        /**
         * Gets a value that indicates the wireless state of the gamepad. 
         */
        isWireless: boolean,

        /**
         * The user associated with the controller. 
         */
        user: undefined.User
}


/**
 * Describes the speed of the gamepad's four available vibration motors. 
 */
declare interface Input$GamepadVibration {

    /**
     * The level of the left vibration motor. Valid values are between 0.0 and 1.0, where 0.0 signifies no motor use and 1.0 signifies max vibration. 
     */
    leftMotor: number,

        /**
         * The left trigger vibration level. Valid values are between 0.0 and 1.0, where 0.0 signifies no motor use and 1.0 signifies max vibration. 
         */
        leftTrigger: number,

        /**
         * The level of the right vibration motor. Valid values are between 0.0 and 1.0, where 0.0 signifies no motor use and 1.0 signifies max vibration. 
         */
        rightMotor: number,

        /**
         * The right trigger vibration level, Valid values are between 0.0 and 1.0, where 0.0 signifies no motor use and 1.0 signifies max vibration. 
         */
        rightTrigger: number
}

declare class GameList {
    addEventListener: any;
    findAllAsync: any;
    ongameadded: any;
    ongameremoved: any;
    ongameupdated: any;
    removeEventListener: any
}

declare
var candidate: any;

declare
var confirmedBySystem: any;

declare
var confirmedByUser: any;

declare class GameListEntry {
    category: any;
    displayInfo: any;
    launchAsync: any;
    properties: any;
    setCategoryAsync: any
}

declare class GameBar {
    addEventListener: any;
    isInputRedirected: any;
    onisinputredirectedchanged: any;
    onvisibilitychanged: any;
    removeEventListener: any;
    visible: any
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class GameSaveBlobGetResult {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    status: undefined.GameSaveErrorStatus;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    value: undefined.IMapView<string, undefined.IBuffer >
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class GameSaveBlobInfo {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    name: string;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    size: number
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class GameSaveBlobInfoGetResult {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    status: undefined.GameSaveErrorStatus;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    value: undefined.IVectorView<undefined.GameSaveBlobInfo >
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class GameSaveBlobInfoQuery {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param startIndex This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param maxNumberOfItems This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getBlobInfoAsync(
        startIndex: number,
        maxNumberOfItems: number): undefined.IPromiseWithIAsyncOperation<undefined.GameSaveBlobInfoGetResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getBlobInfoAsync(): undefined.IPromiseWithIAsyncOperation<undefined.GameSaveBlobInfoGetResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getItemCountAsync(): undefined.IPromiseWithIAsyncOperation<number >
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class GameSaveContainer {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param blobNamePrefix This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    createBlobInfoQuery(blobNamePrefix: string): undefined.GameSaveBlobInfoQuery;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param blobsToRead This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getAsync(
        blobsToRead: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.GameSaveBlobGetResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    name: string;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    provider: undefined.GameSaveProvider;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param blobsToRead This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    readAsync(
        blobsToRead: undefined.IMapView<string, undefined.IBuffer>): undefined.IPromiseWithIAsyncOperation<undefined.GameSaveOperationResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param blobsToWrite This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param blobsToDelete This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param displayName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    submitPropertySetUpdatesAsync(
        blobsToWrite: undefined.IPropertySet,
        blobsToDelete: undefined.IIterable<string>,
        displayName: string): undefined.IPromiseWithIAsyncOperation<undefined.GameSaveOperationResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param blobsToWrite This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param blobsToDelete This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param displayName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    submitUpdatesAsync(
        blobsToWrite: undefined.IMapView<string, undefined.IBuffer>,
        blobsToDelete: undefined.IIterable<string>,
        displayName: string): undefined.IPromiseWithIAsyncOperation<undefined.GameSaveOperationResult >
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class GameSaveContainerInfo {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    displayName: string;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    lastModifiedTime: Date;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    name: string;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    needsSync: boolean;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    totalSize: number
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class GameSaveContainerInfoGetResult {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    status: undefined.GameSaveErrorStatus;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    value: undefined.IVectorView<undefined.GameSaveContainerInfo >
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class GameSaveContainerInfoQuery {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param startIndex This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param maxNumberOfItems This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getContainerInfoAsync(
        startIndex: number,
        maxNumberOfItems: number): undefined.IPromiseWithIAsyncOperation<undefined.GameSaveContainerInfoGetResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getContainerInfoAsync(): undefined.IPromiseWithIAsyncOperation<undefined.GameSaveContainerInfoGetResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getItemCountAsync(): undefined.IPromiseWithIAsyncOperation<number >
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class GameSaveOperationResult {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    status: undefined.GameSaveErrorStatus
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class GameSaveProvider {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param user This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param serviceConfigId This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getForUserAsync(
        user: undefined.User,
        serviceConfigId: string): undefined.IPromiseWithIAsyncOperation<undefined.GameSaveProviderGetResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param user This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param serviceConfigId This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getSyncOnDemandForUserAsync(
        user: undefined.User,
        serviceConfigId: string): undefined.IPromiseWithIAsyncOperation<undefined.GameSaveProviderGetResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    containersChangedSinceLastSync: undefined.IVectorView<string>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param name This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    createContainer(name: string): undefined.GameSaveContainer;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param containerNamePrefix This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    createContainerInfoQuery(containerNamePrefix: string): undefined.GameSaveContainerInfoQuery;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    createContainerInfoQuery(): undefined.GameSaveContainerInfoQuery;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param name This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    deleteContainerAsync(
        name: string): undefined.IPromiseWithIAsyncOperation<undefined.GameSaveOperationResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getRemainingBytesInQuotaAsync(): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    user: undefined.User
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class GameSaveProviderGetResult {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    status: undefined.GameSaveErrorStatus;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    value: undefined.GameSaveProvider
}


/**
 * Specifies the language-related preferences that the app can use and maintain. 
 */
declare class ApplicationLanguages {

    /**
     * Gets the ranked list of current runtime language values preferred by the user. 
     */
    languages: undefined.IVectorView<string>;

    /**
     * Gets the app's declared list of supported languages. 
     */
    manifestLanguages: undefined.IVectorView<string>;

    /**
     * Gets or sets an override for the app's preferred language, expressed as a BCP-47 language tag. This setting is persisted. 
     */
    primaryLanguageOverride: string
}


/**
 * Manipulates the representation of a date and time within a given calendar and clock. 
 */
declare class Calendar {

    /**
     * Creates a Calendar object that is initialized with a language list, calendar, and clock.
     * @param languages The list of language identifiers, in priority order, representing the choice of languages. These are used for resolving patterns to strings. See Remarks.
     * @param calendar The calendar identifier to use.
     * @param clock The clock identifier to use.
     */
    constructor(languages: undefined.IIterable<string>, calendar: string, clock: string): this;

    /**
     * Creates a Calendar object that is initialized with a language list.
     * @param languages The list of language identifiers, in priority order, that represents the choice of languages. These are used for resolving patterns to strings. See Remarks.
     */
    constructor(languages: undefined.IIterable<string>): this;

    /**
     * Creates a Calendar object and initializes it to the current date and time. 
     */
    constructor(): this;

    /**
     * Creates a Calendar object that is initialized with a language list, calendar, clock, and time zone.
     * @param languages The list of language identifiers, in priority order, representing the choice of languages. These are used for resolving patterns to strings. See Remarks.
     * @param calendar The calendar identifier to use.
     * @param clock The clock identifier to use.
     * @param timeZoneId An identifier from the IANA Time Zone Database which identifies the time zone that should be used (for example, "Americas/Los_Angeles" for Pacific Time).
     */
    constructor(languages: undefined.IIterable<string>, calendar: string, clock: string, timeZoneId: string): this;

    /**
     * Increments or decrements the day.
     * @param days The number of days by which to increment the day (if the value is positive) or decrement the day (if the value is negative).
     */
    addDays(days: number): void;

    /**
     * Increments or decrements the era.
     * @param eras The number of eras by which to increment the era (if the value is positive) or decrement the era (if the value is negative).
     */
    addEras(eras: number): void;

    /**
     * Increments or decrements the hour.
     * @param hours The number of hours by which to increment the hour (if the value is positive) or decrement the hour (if the value is negative).
     */
    addHours(hours: number): void;

    /**
     * Increments or decrements the minute.
     * @param minutes The number of minutes by which to increment the minute (if the value is positive) or decrement the minute (if the value is negative).
     */
    addMinutes(minutes: number): void;

    /**
     * Increments or decrements the month.
     * @param months The number of months by which to increment the month (if the value is positive) or decrement the month (if the value is negative).
     */
    addMonths(months: number): void;

    /**
     * Increments or decrements the nanosecond.
     * @param nanoseconds The number of nanoseconds by which to increment the nanosecond (if the value is positive) or decrement the nanosecond (if the value is negative).
     */
    addNanoseconds(nanoseconds: number): void;

    /**
     * Increments or decrements the period.
     * @param periods The number of periods by which to increment the period (if the value is positive) or decrement the period (if the value is negative).
     */
    addPeriods(periods: number): void;

    /**
     * Increments or decrements the second.
     * @param seconds The number of seconds by which to increment the second (if the value is positive) or decrement the second (if the value is negative).
     */
    addSeconds(seconds: number): void;

    /**
     * Increments or decrements the day by the specified number of weeks.
     * @param weeks The number of weeks by which to increment the day (if the value is positive) or decrement the day (if the value is negative).
     */
    addWeeks(weeks: number): void;

    /**
     * Increments or decrements the year.
     * @param years The number of years by which to increment the year (if the value is positive) or decrement the year (if the value is negative).
     */
    addYears(years: number): void;

    /**
     * Sets a new calendar system to be used by this Calendar object.
     * @param value The calendar identifier to use.
     */
    changeCalendarSystem(value: string): void;

    /**
     * Sets a new clock to be used by this Calendar object.
     * @param value The clock identifier to use.
     */
    changeClock(value: string): void;

    /**
     * Sets a new time zone to be used by this Calendar object.
     * @param timeZoneId An identifier from the IANA Time Zone Database which identifies the time zone that should be used (for example, "Americas/Los_Angeles" for Pacific Time).
     */
    changeTimeZone(timeZoneId: string): void;

    /**
     * Creates a copy of the Calendar object.
     * @return  A copy of the Calendar .
     */
    clone(): undefined.Calendar;

    /**
     * Compares this calendar to another Calendar object and indicates whether the date and time of one is earlier, equal to, or later than that of the other.
     * @param other The Calendar object to compare to the current calendar.
     * @return  One of the following values:
     */
    compare(other: undefined.Calendar): number;

    /**
     * Compares this calendar to a DateTime object and indicates whether the date and time of one is earlier, equal to, or later than that of the other.
     * @param other The DateTime object to compare to the current calendar.
     * @return  One of the following values:
     */
    compareDateTime(other: Date): number;

    /**
     * Copies the values from another Calendar object into this Calendar.
     * @param other The Calendar object to be copied.
     */
    copyTo(other: undefined.Calendar): void;

    /**
     * Gets or sets the day. 
     */
    day: number;

    /**
     * Returns a string representation of the day, optionally zero-padded.
     * @param minDigits The minimum number of integer digits to be displayed. If the day does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the day 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
     * @return  A string representation of the day.
     */
    dayAsPaddedString(minDigits: number): string;

    /**
     * Returns a string that contains the numeric representation of the day.
     * @return  A string representation of the day.
     */
    dayAsString(): string;

    /**
     * Gets the day of the week. 
     */
    dayOfWeek: undefined.DayOfWeek;

    /**
     * Returns a string representation of the day of the week suitable for stand-alone display.
     * @param idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
     * @return  A string representation of the day of the week.
     */
    dayOfWeekAsSoloString(idealLength: number): string;

    /**
     * Returns a string representation of the day of the week suitable for stand-alone display.
     * @return  A string representation of the day of the week, using the most common abbreviation available.
     */
    dayOfWeekAsSoloString(): string;

    /**
     * Returns a string representation of the day of the week suitable for inclusion with other date components.
     * @param idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
     * @return  A string representation of the day of the week.
     */
    dayOfWeekAsString(idealLength: number): string;

    /**
     * Returns a string representation of the day of the week suitable for inclusion with other date components.
     * @return  A string representation of the day of the week, using the most common abbreviation available.
     */
    dayOfWeekAsString(): string;

    /**
     * Gets or sets the era. 
     */
    era: number;

    /**
     * Returns a string representation of the era. The string chosen is closest in length to the ideal length.
     * @param idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
     * @return  A string representation of the era.
     */
    eraAsString(idealLength: number): string;

    /**
     * Returns a string representation of the era.
     * @return  A string representation of the era, using the most common abbreviation available.
     */
    eraAsString(): string;

    /**
     * Gets the first Day of the current Month . 
     */
    firstDayInThisMonth: number;

    /**
     * Gets the first Era available in the calendar. 
     */
    firstEra: number;

    /**
     * Gets the first Hour of the current Period . 
     */
    firstHourInThisPeriod: number;

    /**
     * Gets the first Minute of the current Hour . 
     */
    firstMinuteInThisHour: number;

    /**
     * Gets the first Month of the current Year . 
     */
    firstMonthInThisYear: number;

    /**
     * Gets the first Period of the current Day . 
     */
    firstPeriodInThisDay: number;

    /**
     * Gets the first Second of the current Minute . 
     */
    firstSecondInThisMinute: number;

    /**
     * Gets the first Year of the current Era . 
     */
    firstYearInThisEra: number;

    /**
     * Gets the calendar system that is used by this Calendar object.
     * @return  The identifier of the calendar system.
     */
    getCalendarSystem(): string;

    /**
     * Gets the clock that is used by this Calendar object.
     * @return  The identifier of the clock.
     */
    getClock(): string;

    /**
     * Builds a date and time, given the components of this Calendar object.
     * @return  The DateTime representing the date and time of this Calendar .
     */
    getDateTime(): Date;

    /**
     * Gets the identifier that identifies the time zone that is used by this Calendar object.
     * @return  The identifier from the IANA Time Zone Database that identifies the time zone that is used by this Calendar object. (An example is "Americas/Los_Angeles" for Pacific Time.)
     */
    getTimeZone(): string;

    /**
     * Gets or sets the hour. 
     */
    hour: number;

    /**
     * Returns a string representation of the hour, optionally zero-padded.
     * @param minDigits The minimum number of integer digits to be displayed. If the hour does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the hour 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
     * @return  A string representation of the hour.
     */
    hourAsPaddedString(minDigits: number): string;

    /**
     * Returns a string that contains the numeric representation of the hour.
     * @return  A string representation of the hour.
     */
    hourAsString(): string;

    /**
     * Gets a Boolean indicating if Daylight Saving Time is in effect for the date of this Calendar object. 
     */
    isDaylightSavingTime: boolean;

    /**
     * Gets the priority list of language identifiers that is used when formatting components as strings. 
     */
    languages: undefined.IVectorView<string>;

    /**
     * Gets the last Day of the current Month . 
     */
    lastDayInThisMonth: number;

    /**
     * Gets the last Era available in the calendar. 
     */
    lastEra: number;

    /**
     * Gets the last Hour of the current Period . 
     */
    lastHourInThisPeriod: number;

    /**
     * Gets the last Minute of the current Hour . 
     */
    lastMinuteInThisHour: number;

    /**
     * Gets the last Month of the current Year . 
     */
    lastMonthInThisYear: number;

    /**
     * Gets the last Period of the current Day . 
     */
    lastPeriodInThisDay: number;

    /**
     * Gets the last Second of the current Minute . 
     */
    lastSecondInThisMinute: number;

    /**
     * Gets the last Year of the current Era . 
     */
    lastYearInThisEra: number;

    /**
     * Gets or sets the minute. 
     */
    minute: number;

    /**
     * Returns a string representation of the minute, optionally zero-padded.
     * @param minDigits The minimum number of integer digits to be displayed. If the minute does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the minute 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
     * @return  A string representation of the minute.
     */
    minuteAsPaddedString(minDigits: number): string;

    /**
     * Returns a string that contains the numeric representation of the minute.
     * @return  A string representation of the minute.
     */
    minuteAsString(): string;

    /**
     * Gets or sets the month. 
     */
    month: number;

    /**
     * Returns a string that contains the numeric representation of the month.
     * @return  A string representation of the month.
     */
    monthAsNumericString(): string;

    /**
     * Returns a string representation of the month, optionally zero-padded.
     * @param minDigits The minimum number of integer digits to be displayed. If the month does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the month 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
     * @return  A string representation of the month.
     */
    monthAsPaddedNumericString(minDigits: number): string;

    /**
     * Returns a string representation of the month suitable for stand-alone display.
     * @param idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
     * @return  A string representation of the month.
     */
    monthAsSoloString(idealLength: number): string;

    /**
     * Returns a string representation of the month suitable for stand-alone display.
     * @return  A string representation of the month, using the most common abbreviation available.
     */
    monthAsSoloString(): string;

    /**
     * Returns a string representation of the month suitable for inclusion with other date components.
     * @param idealLength A positive integer specifying the ideal length, in characters, for the returned string, or 0 specifying the most common abbreviation available.
     * @return  A string representation of the month.
     */
    monthAsString(idealLength: number): string;

    /**
     * Returns a string representation of the month suitable for inclusion with other date components.
     * @return  A string representation of the month, using the most common abbreviation available.
     */
    monthAsString(): string;

    /**
     * Gets or sets the nanosecond. 
     */
    nanosecond: number;

    /**
     * Returns a string representation of the nanosecond, optionally zero-padded.
     * @param minDigits The minimum number of integer digits to be displayed. If the nanosecond does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the nanosecond 42, a parameter of 1 or 2 returns 42, and a parameter of 3 returns 042.
     * @return  A string representation of the nanosecond.
     */
    nanosecondAsPaddedString(minDigits: number): string;

    /**
     * Returns a string that contains the numeric representation of the nanosecond.
     * @return  A string representation of the nanosecond.
     */
    nanosecondAsString(): string;

    /**
     * Gets the number of days in the current month of this Calendar object. 
     */
    numberOfDaysInThisMonth: number;

    /**
     * Gets the number of eras in this Calendar object. 
     */
    numberOfEras: number;

    /**
     * Gets the number of hours in the current day period of this Calendar object. 
     */
    numberOfHoursInThisPeriod: number;

    /**
     * Gets the number of Minute s in the current Hour . 
     */
    numberOfMinutesInThisHour: number;

    /**
     * Gets the number of months in the current year of this Calendar object. 
     */
    numberOfMonthsInThisYear: number;

    /**
     * Gets the number of periods in the current day of this Calendar object. 
     */
    numberOfPeriodsInThisDay: number;

    /**
     * Gets the number of Second s in the current Minute . 
     */
    numberOfSecondsInThisMinute: number;

    /**
     * Gets the number of years in the current era of this Calendar object. 
     */
    numberOfYearsInThisEra: number;

    /**
     * Gets or sets the numbering system that is used when formatting components as strings. 
     */
    numeralSystem: string;

    /**
     * Gets or sets the period of the current day. 
     */
    period: number;

    /**
     * Returns a string representation of the day period, such as AM or PM, that uses the most common abbreviation available.
     * @return  A string representation of the day period.
     */
    periodAsString(): string;

    /**
     * Returns a string representation of the day period, such as AM or PM.
     * @param idealLength A positive integer that specifies the ideal length, in characters, for the returned string; or a zero that specifies the most common abbreviation available.
     * @return  A string representation for the day period.
     */
    periodAsString(idealLength: number): string;

    /**
     * Gets the language that was most recently used to perform calendar formatting or operations. 
     */
    resolvedLanguage: string;

    /**
     * Gets or sets the second. 
     */
    second: number;

    /**
     * Returns a string representation of the second, optionally zero-padded.
     * @param minDigits The minimum number of integer digits to be displayed. If the second does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the second 3, a parameter of 1 returns 3, and a parameter of 2 returns 03.
     * @return  A string representation of the second.
     */
    secondAsPaddedString(minDigits: number): string;

    /**
     * Returns a string that contains the numeric representation of the second.
     * @return  A string representation of the second.
     */
    secondAsString(): string;

    /**
     * Sets all the date and time fields to the date and time represented by the DateTime parameter.
     * @param value The DateTime that is used to set all of the date and time fields.
     */
    setDateTime(value: Date): void;

    /**
     * Sets the components of this Calendar object to the latest date and time that are supported. 
     */
    setToMax(): void;

    /**
     * Sets the components of this Calendar object to the earliest date and time that are supported. 
     */
    setToMin(): void;

    /**
     * Sets the components of this Calendar object to the current date and time. 
     */
    setToNow(): void;

    /**
     * Returns the full time zone name applicable at the instant of time that this Calendar object represents.
     * @return  The full time zone name. This usually differs depending on whether the time zone is observing Daylight Saving Time or not. It also may differ due to historical changes. (An example is "Americas/Los_Angeles" for Pacific Time.)
     */
    timeZoneAsString(): string;

    /**
     * Returns the abbreviated time zone name applicable at the instant of time that this Calendar object represents.
     * @param idealLength The desired length of the abbreviation to be returned. Use 0 to request the abbreviation in most common use.
     * @return  The time zone abbreviation that is closest in length to idealLength. If there is a tie, the shorter abbreviation is returned. If idealLength is 0, the abbreviation in most common use is returned. (An example is "Americas/Los_Angeles" for Pacific Time.)
     */
    timeZoneAsString(idealLength: number): string;

    /**
     * Gets or sets the year. 
     */
    year: number;

    /**
     * Returns a string representation of the year, optionally zero-padded.
     * @param minDigits The minimum number of integer digits to be displayed. If the year does not have enough integer digits, it will be padded with zeros to the correct amount. For example, for the year 42, a parameter of 1 or 2 returns 42, and a parameter of 3 returns 042.
     * @return  A string representation of the year.
     */
    yearAsPaddedString(minDigits: number): string;

    /**
     * Returns a string representation of the year without any initial zero padding.
     * @return  A string representation of the year.
     */
    yearAsString(): string;

    /**
     * Returns a string representation of the year, optionally truncated.
     * @param remainingDigits A positive integer that represents the number of least significant digits that should be included. For example, for the year 1234, a parameter of 2 returns 34, and a parameter of 4 or larger returns 1234.
     * @return  A string representation of the year.
     */
    yearAsTruncatedString(remainingDigits: number): string
}


/**
 * Contains the calendar identifiers for the supported calendars, as static properties. 
 */
declare class CalendarIdentifiers {

    /**
     * Gets the identifier for the Gregorian calendar. 
     */
    gregorian: string;

    /**
     * Gets the identifier for the Hebrew calendar. 
     */
    hebrew: string;

    /**
     * Gets the identifier for the Hijri calendar. 
     */
    hijri: string;

    /**
     * Gets the identifier for the Japanese calendar. 
     */
    japanese: string;

    /**
     * Gets the identifier for the Julian calendar. 
     */
    julian: string;

    /**
     * Gets the identifier for the Korean calendar. 
     */
    korean: string;

    /**
     * Gets the identifier for the Persian calendar. 
     */
    persian: string;

    /**
     * Gets the identifier for the Taiwan calendar. 
     */
    taiwan: string;

    /**
     * Gets the identifier for the Thai calendar. 
     */
    thai: string;

    /**
     * Gets the identifier for the Um Al-Qura calendar. 
     */
    umAlQura: string
}


/**
 * Contains the clock identifiers for the supported clocks, as static properties. 
 */
declare class ClockIdentifiers {

    /**
     * Gets the identifier for a 12-hour clock. 
     */
    twelveHour: string;

    /**
     * Gets the identifier for a 24-hour clock. 
     */
    twentyFourHour: string
}


/**
 * A container for character group information. Characters are grouped in an index that enables an application to determine where the grouping boundaries are. 
 */
declare class CharacterGrouping {

    /**
     * Gets the first item that appears in the grouping under this index. 
     */
    first: string;

    /**
     * Gets the label that is associated with this index. 
     */
    label: string
}


/**
 * Contains the set of character groups and the functionality to get the label for any given string. 
 */
declare class CharacterGroupings mixins Array<undefined.CharacterGrouping>{

    /**
     * Create a CharacterGroupings object for the default collation. 
     */
    constructor(): this;

    /**
     * Returns an iterator to enumerate the items in the set of character groups.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the set of character groups if the set is empty.
     */
    first(): undefined.IIterator<undefined.CharacterGrouping>;

    /**
     * Returns the CharacterGrouping at the specified index in the set of character groups.
     * @param index The zero-based index of the CharacterGrouping in the set to return.
     * @return  The CharacterGrouping at the specified index.
     */
    getAt(index: number): undefined.CharacterGrouping;

    /**
     * Returns the CharacterGrouping objects that start at the specified index in the set of character groups.
     * @param startIndex The zero-based index of the start of the CharacterGrouping objects in the set to return.
     */
    getMany(
        startIndex: number): {
        items: undefined.CharacterGrouping,
        returnValue: number
    };

    /**
     * Returns the index of a specified CharacterGrouping object in the set of character groups.
     * @param value The CharacterGrouping object to find in the set.
     */
    indexOf(value: undefined.CharacterGrouping): {
        index: number,
        returnValue: boolean
    };

    /**
     * Gets the label under which the provided text falls.
     * @param text The string for which to get the label.
     * @return  The first character grouping label that applies to the given text.
     */
    lookup(text: string): string;

    /**
     * Gets the number of CharacterGrouping objects in the set of character groups. 
     */
    size: number;
    indexOf(
        value: undefined.CharacterGrouping,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.CharacterGrouping, fromIndex?: number): number
}


/**
 * Contains the currency identifiers for the supported currencies, as static properties. 
 */
declare class CurrencyIdentifiers {

    /**
     * Gets the currency identifier for the United Arab Emirates Dirham. 
     */
    aed: string;

    /**
     * Gets the currency identifier for the Afghan Afghani. 
     */
    afn: string;

    /**
     * Gets the currency identifier for the Albanian Lek. 
     */
    all: string;

    /**
     * Gets the currency identifier for the Armenian Dram. 
     */
    amd: string;

    /**
     * Gets the currency identifier for the Netherlands Antilles Guilder. 
     */
    ang: string;

    /**
     * Gets the currency identifier for the Angolan Kwanza. 
     */
    aoa: string;

    /**
     * Gets the currency identifier for the Argentine Peso. 
     */
    ars: string;

    /**
     * Gets the currency identifier for the Australian Dollar. 
     */
    aud: string;

    /**
     * Gets the currency identifier for the Aruban Florin. 
     */
    awg: string;

    /**
     * Gets the currency identifier for the Azerbaijani Manat. 
     */
    azn: string;

    /**
     * Gets the currency identifier for the Bosnia and Herzegovina Convertible Mark. 
     */
    bam: string;

    /**
     * Gets the currency identifier for the Barbados Dollar. 
     */
    bbd: string;

    /**
     * Gets the currency identifier for the Bangladeshi Taka. 
     */
    bdt: string;

    /**
     * Gets the currency identifier for the Bulgarian Lev. 
     */
    bgn: string;

    /**
     * Gets the currency identifier for the Bahraini Dinar. 
     */
    bhd: string;

    /**
     * Gets the currency identifier for the Burundian Franc. 
     */
    bif: string;

    /**
     * Gets the currency identifier for the Bermuda Dollar. 
     */
    bmd: string;

    /**
     * Gets the currency identifier for the Brunei Dollar. 
     */
    bnd: string;

    /**
     * Gets the currency identifier for the Bolivian Boliviano. 
     */
    bob: string;

    /**
     * Gets the currency identifier for the Brazilian Real. 
     */
    brl: string;

    /**
     * Gets the currency identifier for the Bahamian Dollar. 
     */
    bsd: string;

    /**
     * Gets the currency identifier for the Bhutanese Ngultrum. 
     */
    btn: string;

    /**
     * Gets the currency identifier for the Botswana Pula. 
     */
    bwp: string;

    /**
     * Gets the currency identifier for the Belarusian Ruble. 
     */
    byr: string;

    /**
     * Gets the currency identifier for the Belize Dollar. 
     */
    bzd: string;

    /**
     * Gets the currency identifier for the Canadian Dollar. 
     */
    cad: string;

    /**
     * Gets the currency identifier for the Congolese Franc. 
     */
    cdf: string;

    /**
     * Gets the currency identifier for the Swiss Franc. 
     */
    chf: string;

    /**
     * Gets the currency identifier for the Chilean Peso. 
     */
    clp: string;

    /**
     * Gets the currency identifier for the Chinese Yuan. 
     */
    cny: string;

    /**
     * Gets the currency identifier for the Colombian Peso. 
     */
    cop: string;

    /**
     * Gets the currency identifier for the Costa Rican Colon. 
     */
    crc: string;

    /**
     * Gets the currency identifier for the Cuban Peso. 
     */
    cup: string;

    /**
     * Gets the currency identifier for the Cabo Verde Escudo. 
     */
    cve: string;

    /**
     * Gets the currency identifier for the Czech Koruna. 
     */
    czk: string;

    /**
     * Gets the currency identifier for the Djiboutian Franc. 
     */
    djf: string;

    /**
     * Gets the currency identifier for the Danish Krone. 
     */
    dkk: string;

    /**
     * Gets the currency identifier for the Dominican Peso. 
     */
    dop: string;

    /**
     * Gets the currency identifier for the Algerian Dinar. 
     */
    dzd: string;

    /**
     * Gets the currency identifier for the Egyptian Pound. 
     */
    egp: string;

    /**
     * Gets the currency identifier for the Eritrean Nakfa. 
     */
    ern: string;

    /**
     * Gets the currency identifier for the Ethiopian Birr. 
     */
    etb: string;

    /**
     * Gets the currency identifier for the Euro. 
     */
    eur: string;

    /**
     * Gets the currency identifier for the Fiji Dollar. 
     */
    fjd: string;

    /**
     * Gets the currency identifier for the Falkland Islands Pound. 
     */
    fkp: string;

    /**
     * Gets the currency identifier for the Pound Sterling. 
     */
    gbp: string;

    /**
     * Gets the currency identifier for the Georgian Lari. 
     */
    gel: string;

    /**
     * Gets the currency identifier for the Ghanaian Cedi. 
     */
    ghs: string;

    /**
     * Gets the currency identifier for the Gibraltar Pound. 
     */
    gip: string;

    /**
     * Gets the currency identifier for the Gambian Dalasi. 
     */
    gmd: string;

    /**
     * Gets the currency identifier for the Guinean Franc. 
     */
    gnf: string;

    /**
     * Gets the currency identifier for the Guatemalan Quetzal. 
     */
    gtq: string;

    /**
     * Gets the currency identifier for the Guyanese Dollar. 
     */
    gyd: string;

    /**
     * Gets the currency identifier for the Hong Kong Dollar. 
     */
    hkd: string;

    /**
     * Gets the currency identifier for the Honduran Lempira. 
     */
    hnl: string;

    /**
     * Gets the currency identifier for the Croatian Kuna. 
     */
    hrk: string;

    /**
     * Gets the currency identifier for the Haitian Gourde. 
     */
    htg: string;

    /**
     * Gets the currency identifier for the Hungarian Forint. 
     */
    huf: string;

    /**
     * Gets the currency identifier for the Indonesian Rupiah. 
     */
    idr: string;

    /**
     * Gets the currency identifier for the Israeli New Shekel. 
     */
    ils: string;

    /**
     * Gets the currency identifier for the Indian Rupee. 
     */
    inr: string;

    /**
     * Gets the currency identifier for the Iraqi Dinar. 
     */
    iqd: string;

    /**
     * Gets the currency identifier for the Iranian Rial. 
     */
    irr: string;

    /**
     * Gets the currency identifier for the Icelandic Krona. 
     */
    isk: string;

    /**
     * Gets the currency identifier for the Jamaican Dollar. 
     */
    jmd: string;

    /**
     * Gets the currency identifier for the Jordanian Dinar. 
     */
    jod: string;

    /**
     * Gets the currency identifier for the Japanese Yen. 
     */
    jpy: string;

    /**
     * Gets the currency identifier for the Kenyan Shilling. 
     */
    kes: string;

    /**
     * Gets the currency identifier for the Kyrgyzstani Som. 
     */
    kgs: string;

    /**
     * Gets the currency identifier for the Cambodian Riel. 
     */
    khr: string;

    /**
     * Gets the currency identifier for the Comorian Franc. 
     */
    kmf: string;

    /**
     * Gets the currency identifier for the North Korean Won. 
     */
    kpw: string;

    /**
     * Gets the currency identifier for the Korean Won. 
     */
    krw: string;

    /**
     * Gets the currency identifier for the Kuwaiti Dinar. 
     */
    kwd: string;

    /**
     * Gets the currency identifier for the Cayman Islands Dollar. 
     */
    kyd: string;

    /**
     * Gets the currency identifier for the Kazakhstani Tenge. 
     */
    kzt: string;

    /**
     * Gets the currency identifier for the Lao Kip. 
     */
    lak: string;

    /**
     * Gets the currency identifier for the Lebanese Pound. 
     */
    lbp: string;

    /**
     * Gets the currency identifier for the Sri Lankan Rupee. 
     */
    lkr: string;

    /**
     * Gets the currency identifier for the Liberian Dollar. 
     */
    lrd: string;

    /**
     * Gets the currency identifier for the Lesotho Loti. 
     */
    lsl: string;

    /**
     * Gets the currency identifier for the Lithuanian Litas. 
     */
    ltl: string;

    /**
     * Gets the currency identifier for the Latvian Lats. 
     */
    lvl: string;

    /**
     * Gets the currency identifier for the Libyan Dinar. 
     */
    lyd: string;

    /**
     * Gets the currency identifier for the Moroccan Dirham. 
     */
    mad: string;

    /**
     * Gets the currency identifier for the Moldovan Leu. 
     */
    mdl: string;

    /**
     * Gets the currency identifier for the Malagasy Ariary. 
     */
    mga: string;

    /**
     * Gets the currency identifier for the Macedonia (FYROM) Denar. 
     */
    mkd: string;

    /**
     * Gets the currency identifier for the Myanmar Kyat. 
     */
    mmk: string;

    /**
     * Gets the currency identifier for the Mongolian Tugrik. 
     */
    mnt: string;

    /**
     * Gets the currency identifier for the Macao SAR Pataca. 
     */
    mop: string;

    /**
     * Gets the currency identifier for the Mauritania Ouguiya. 
     */
    mro: string;

    /**
     * Gets the currency identifier for the Mauritian Rupee. 
     */
    mur: string;

    /**
     * Gets the currency identifier for the Maldives Rufiyaa. 
     */
    mvr: string;

    /**
     * Gets the currency identifier for the Malawian Kwacha. 
     */
    mwk: string;

    /**
     * Gets the currency identifier for the Mexican Peso. 
     */
    mxn: string;

    /**
     * Gets the currency identifier for the Malaysian Ringgit. 
     */
    myr: string;

    /**
     * Gets the currency identifier for the New Mozambican Metical. 
     */
    mzn: string;

    /**
     * Gets the currency identifier for the Namibian Dollar. 
     */
    nad: string;

    /**
     * Gets the currency identifier for the Nigerian Naira. 
     */
    ngn: string;

    /**
     * Gets the currency identifier for the Nicaraguan Cordoba Oro. 
     */
    nio: string;

    /**
     * Gets the currency identifier for the Norwegian Krone. 
     */
    nok: string;

    /**
     * Gets the currency identifier for the Nepalese Rupee. 
     */
    npr: string;

    /**
     * Gets the currency identifier for the New Zealand Dollar. 
     */
    nzd: string;

    /**
     * Gets the currency identifier for the Omani Rial. 
     */
    omr: string;

    /**
     * Gets the currency identifier for the Panamanian Balboa. 
     */
    pab: string;

    /**
     * Gets the currency identifier for the Peruvian Nuevo Sol. 
     */
    pen: string;

    /**
     * Gets the currency identifier for the Papua New Guinea Kina. 
     */
    pgk: string;

    /**
     * Gets the currency identifier for the Philippine Peso. 
     */
    php: string;

    /**
     * Gets the currency identifier for the Pakistan Rupee. 
     */
    pkr: string;

    /**
     * Gets the currency identifier for the Polish Zloty. 
     */
    pln: string;

    /**
     * Gets the currency identifier for the Paraguay Guarani. 
     */
    pyg: string;

    /**
     * Gets the currency identifier for the Qatari Riyal. 
     */
    qar: string;

    /**
     * Gets the currency identifier for the Romanian Leu. 
     */
    ron: string;

    /**
     * Gets the currency identifier for the Serbian Dinar. 
     */
    rsd: string;

    /**
     * Gets the currency identifier for the Russian Ruble. 
     */
    rub: string;

    /**
     * Gets the currency identifier for the Rwandan Franc. 
     */
    rwf: string;

    /**
     * Gets the currency identifier for the Saudi Arabian Riyal. 
     */
    sar: string;

    /**
     * Gets the currency identifier for the Solomon Islands Dollar. 
     */
    sbd: string;

    /**
     * Gets the currency identifier for the Seychelles Rupee. 
     */
    scr: string;

    /**
     * Gets the currency identifier for the Sudanese Pound. 
     */
    sdg: string;

    /**
     * Gets the currency identifier for the Swedish Krona. 
     */
    sek: string;

    /**
     * Gets the currency identifier for the Singapore Dollar. 
     */
    sgd: string;

    /**
     * Gets the currency identifier for the Saint Helena Pound. 
     */
    shp: string;

    /**
     * Gets the currency identifier for the Sierra Leone Leone. 
     */
    sll: string;

    /**
     * Gets the currency identifier for the Somali Shilling. 
     */
    sos: string;

    /**
     * Gets the currency identifier for the Suriname Dollar. 
     */
    srd: string;

    /**
     * Gets the currency identifier for the Sao Tome Dobra. 
     */
    std: string;

    /**
     * Gets the currency identifier for the Syrian Pound. 
     */
    syp: string;

    /**
     * Gets the currency identifier for the Swazi Lilangeni. 
     */
    szl: string;

    /**
     * Gets the currency identifier for the Thai Baht. 
     */
    thb: string;

    /**
     * Gets the currency identifier for the Tajikistani Somoni. 
     */
    tjs: string;

    /**
     * Gets the currency identifier for the Turkmenistan Manat. 
     */
    tmt: string;

    /**
     * Gets the currency identifier for the Tunisian Dinar. 
     */
    tnd: string;

    /**
     * Gets the currency identifier for the Tongan Pa'Anga. 
     */
    top: string;

    /**
     * Gets the currency identifier for the Turkish Lira. 
     */
    try: string;

    /**
     * Gets the currency identifier for the Trinidad and Tobago Dollar. 
     */
    ttd: string;

    /**
     * Gets the currency identifier for the New Taiwan Dollar. 
     */
    twd: string;

    /**
     * Gets the currency identifier for the Tanzanian Shilling. 
     */
    tzs: string;

    /**
     * Gets the currency identifier for the Ukrainian Hryvnia. 
     */
    uah: string;

    /**
     * Gets the currency identifier for the Uganda Shilling. 
     */
    ugx: string;

    /**
     * Gets the currency identifier for the United States Dollar. 
     */
    usd: string;

    /**
     * Gets the currency identifier for the Uruguayan Peso. 
     */
    uyu: string;

    /**
     * Gets the currency identifier for the Uzbekistani Som. 
     */
    uzs: string;

    /**
     * Gets the currency identifier for the Venezuelan Bolivar Fuerte. 
     */
    vef: string;

    /**
     * Gets the currency identifier for the Viet Nam Dong. 
     */
    vnd: string;

    /**
     * Gets the currency identifier for the Vanuatu Vatu. 
     */
    vuv: string;

    /**
     * Gets the currency identifier for the Samoa Tala. 
     */
    wst: string;

    /**
     * Gets the currency identifier for the Central African CFA. 
     */
    xaf: string;

    /**
     * Gets the currency identifier for the East Caribbean Dollar. 
     */
    xcd: string;

    /**
     * Gets the currency identifier for the West African CFA. 
     */
    xof: string;

    /**
     * Gets the currency identifier for the French Pacific Franc. 
     */
    xpf: string;

    /**
     * Gets the currency identifier that represents no currency. 
     */
    xxx: string;

    /**
     * Gets the currency identifier for the Yemeni Rial. 
     */
    yer: string;

    /**
     * Gets the currency identifier for the South African Rand. 
     */
    zar: string;

    /**
     * Gets the currency identifier for the Zambian Kwacha. 
     */
    zmw: string;

    /**
     * Gets the currency identifier for the Zimbabwean Dollar. 
     */
    zwl: string
}


/**
 * Formats dates and times. 
 */
declare class DateTimeFormatter {

    /**
     * Gets the DateTimeFormatter object that formats dates according to the user's choice of long date pattern. 
     */
    longDate: undefined.DateTimeFormatter;

    /**
     * Gets the DateTimeFormatter object that formats times according to the user's choice of long time pattern. 
     */
    longTime: undefined.DateTimeFormatter;

    /**
     * Gets the DateTimeFormatter object that formats dates according to the user's choice of short date pattern. 
     */
    shortDate: undefined.DateTimeFormatter;

    /**
     * Gets the DateTimeFormatter object that formats times according to the user's choice of short time pattern. 
     */
    shortTime: undefined.DateTimeFormatter;

    /**
     * Creates a DateTimeFormatter object that is initialized with hour, minute, and second formats.
     * @param hourFormat The desired hour format to include in the template.
     * @param minuteFormat The desired minute format to include in the template.
     * @param secondFormat The desired second format to include in the template.
     */
    constructor(hourFormat: undefined.HourFormat, minuteFormat: undefined.MinuteFormat, secondFormat: undefined.SecondFormat): this;

    /**
     * Creates a DateTimeFormatter object that is initialized by a format template string.
     * @param formatTemplate A format template string that specifies the requested components. The order of the components is irrelevant. This can also be a format pattern. See the remarks for the DateTimeFormatter class for a list of valid format templates and format patterns.
     */
    constructor(formatTemplate: string): this;

    /**
     * Creates a DateTimeFormatter object with all formats and identifiers specified.
     * @param yearFormat The desired year format to include in the template.
     * @param monthFormat The desired month format to include in the template.
     * @param dayFormat The desired day format to include in the template.
     * @param dayOfWeekFormat The desired day of week format to include in the template.
     * @param hourFormat The desired hour format to include in the template.
     * @param minuteFormat The desired minute format to include in the template.
     * @param secondFormat The desired second format to include in the template.
     * @param languages The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern, and for formatting. See Remarks.
     * @param geographicRegion The identifier for the geographic region. This identifier is used for resolving the template to a pattern.
     * @param calendar The calendar identifier to use.
     * @param clock The clock identifier to use.
     */
    constructor(yearFormat: undefined.YearFormat, monthFormat: undefined.MonthFormat, dayFormat: undefined.DayFormat, dayOfWeekFormat: undefined.DayOfWeekFormat, hourFormat: undefined.HourFormat, minuteFormat: undefined.MinuteFormat, secondFormat: undefined.SecondFormat, languages: undefined.IIterable<string>, geographicRegion: string, calendar: string, clock: string): this;

    /**
     * Creates a DateTimeFormatter object that is initialized by a format template string, language list, geographic region, calendar, and clock.
     * @param formatTemplate A format template string that specifies the requested components. The order of the components is irrelevant. This can also be a format pattern. See the remarks for the DateTimeFormatter class for a list of valid format templates and format patterns.
     * @param languages The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern, and for formatting. See Remarks.
     * @param geographicRegion The identifier for the geographic region. This identifier is used for resolving the template to a pattern.
     * @param calendar The calendar identifier to use.
     * @param clock The clock identifier to use.
     */
    constructor(formatTemplate: string, languages: undefined.IIterable<string>, geographicRegion: string, calendar: string, clock: string): this;

    /**
     * Creates a DateTimeFormatter object that is initialized with year, month, day, and day of week formats.
     * @param yearFormat The desired year format to include in the template.
     * @param monthFormat The desired month format to include in the template.
     * @param dayFormat The desired day format to include in the template.
     * @param dayOfWeekFormat The desired day of week format to include in the template.
     */
    constructor(yearFormat: undefined.YearFormat, monthFormat: undefined.MonthFormat, dayFormat: undefined.DayFormat, dayOfWeekFormat: undefined.DayOfWeekFormat): this;

    /**
     * Creates a DateTimeFormatter object that is initialized with year, month, day, day of week, hour, minute, and second formats, and a language list.
     * @param yearFormat The year format to include in the template.
     * @param monthFormat The month format to include in the template.
     * @param dayFormat The day format to include in the template.
     * @param dayOfWeekFormat The day of week format to include in the template.
     * @param hourFormat The hour format to include in the template.
     * @param minuteFormat The minute format to include in the template.
     * @param secondFormat The second format to include in the template.
     * @param languages The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern and for formatting. See Remarks.
     */
    constructor(yearFormat: undefined.YearFormat, monthFormat: undefined.MonthFormat, dayFormat: undefined.DayFormat, dayOfWeekFormat: undefined.DayOfWeekFormat, hourFormat: undefined.HourFormat, minuteFormat: undefined.MinuteFormat, secondFormat: undefined.SecondFormat, languages: undefined.IIterable<string>): this;

    /**
     * Creates a DateTimeFormatter object that is initialized by a format template string and language list.
     * @param formatTemplate A format template string that specifies the requested components. The order of the components is irrelevant. This can also be a format pattern. See the remarks for the DateTimeFormatter class for a list of valid format templates and format patterns.
     * @param languages The list of language identifiers, in priority order, that represent the choice of languages. These identifiers are used for resolving the template to a pattern and for formatting. See Remarks.
     */
    constructor(formatTemplate: string, languages: undefined.IIterable<string>): this;

    /**
     * Gets the calendar that is used when formatting dates. 
     */
    calendar: string;

    /**
     * Gets the clock that is used when formatting times. 
     */
    clock: string;

    /**
     * Returns a string representation of the provided date and time.
     * @param value The date and time to be formatted.
     * @return  A string that represents the date and time.
     */
    format(value: Date): string;

    /**
     * Returns a string that represents the given date and time in the given time zone, conforming to the template the formatter is currently using.
     * @param datetime The date and time to be formatted.
     * @param timeZoneId An identifier from the IANA Time Zone Database which identifies the time zone that should be used (for example, "Americas/Los_Angeles" for Pacific Time).
     * @return  A string that represents the date, time, and time zone.
     */
    format(datetime: Date, timeZoneId: string): string;

    /**
     * Gets or sets the region that is used when formatting dates and times. 
     */
    geographicRegion: string;

    /**
     * Gets the DayFormat in the template. 
     */
    includeDay: undefined.DayFormat;

    /**
     * Gets the DayOfWeekFormat in the template. 
     */
    includeDayOfWeek: undefined.DayOfWeekFormat;

    /**
     * Gets the HourFormat in the template. 
     */
    includeHour: undefined.HourFormat;

    /**
     * Gets the MinuteFormat in the template. 
     */
    includeMinute: undefined.MinuteFormat;

    /**
     * Gets the MonthFormat in the template. 
     */
    includeMonth: undefined.MonthFormat;

    /**
     * Gets the SecondFormat in the template. 
     */
    includeSecond: undefined.SecondFormat;

    /**
     * Gets the YearFormat in the template. 
     */
    includeYear: undefined.YearFormat;

    /**
     * Gets the priority list of language identifiers that is used when formatting dates and times. 
     */
    languages: undefined.IVectorView<string>;

    /**
     * Gets or sets the numbering system that is used to format dates and times. 
     */
    numeralSystem: string;

    /**
     * Gets the patterns corresponding to this template that are used when formatting dates and times. 
     */
    patterns: undefined.IVectorView<string>;

    /**
     * Gets the geographic region that was most recently used to format dates and times. 
     */
    resolvedGeographicRegion: string;

    /**
     * Gets the language that was most recently used to format dates and times. 
     */
    resolvedLanguage: string;

    /**
     * Gets a string representation of this format template. 
     */
    template: string
}


/**
 * Provides data related to a particular font recommendation for a given language. 
 */
declare class LanguageFont {

    /**
     * Gets the family name of the font. 
     */
    fontFamily: string;

    /**
     * Gets the FontStretch property of the font. 
     */
    fontStretch: undefined.FontStretch;

    /**
     * Gets the FontStyle property of the font. 
     */
    fontStyle: undefined.FontStyle;

    /**
     * Gets the weight of the font ( FontWeight ). 
     */
    fontWeight: undefined.FontWeight;

    /**
     * Gets a recommended font size scaling factor for the font. 
     */
    scaleFactor: number
}


/**
 * Supplies a set of font recommendations for a given language or script for various usage cases. 
 */
declare class LanguageFontGroup {

    /**
     * Creates a LanguageFontGroup object for a given language or script.
     * @param languageTag A BCP-47 language tag, or an ISO 15924 script identifier.
     */
    constructor(languageTag: string): this;

    /**
     * Gets a font that is recommended as an additional option for use in documents beyond the recommendations provided by DocumentHeadingFont , ModernDocumentFont and TraditionalDocumentFont . 
     */
    documentAlternate1Font: undefined.LanguageFont;

    /**
     * Gets a font that is recommended as an additional option for use in documents beyond the recommendations provided by DocumentHeadingFont , ModernDocumentFont and TraditionalDocumentFont . 
     */
    documentAlternate2Font: undefined.LanguageFont;

    /**
     * Gets a font that is recommended for use in document headings. 
     */
    documentHeadingFont: undefined.LanguageFont;

    /**
     * Gets a font that is recommended for displaying fixed-width characters. 
     */
    fixedWidthTextFont: undefined.LanguageFont;

    /**
     * Gets a font that is recommended for typical document body text following modern style conventions. 
     */
    modernDocumentFont: undefined.LanguageFont;

    /**
     * Gets a font that is recommended for typical document body text following traditional style conventions. 
     */
    traditionalDocumentFont: undefined.LanguageFont;

    /**
     * Gets a font that is recommended for special UI elements, such as captions, that are displayed at sizes smaller than typical UI body text. 
     */
    uiCaptionFont: undefined.LanguageFont;

    /**
     * Gets a font that is recommended for special UI elements, such as headings, that are displayed at sizes somewhat larger than typical UI body text. 
     */
    uiHeadingFont: undefined.LanguageFont;

    /**
     * Gets a font that is recommended for special UI elements, such as headings in notifications or other app messages, that are displayed at UI body text size or only slightly larger yet need to be differentiated from UI body text. 
     */
    uiNotificationHeadingFont: undefined.LanguageFont;

    /**
     * Gets a font that is recommended for typical UI body text. 
     */
    uiTextFont: undefined.LanguageFont;

    /**
     * Gets a font that is recommended for special UI elements set at sizes much larger than typical UI body text. 
     */
    uiTitleFont: undefined.LanguageFont
}


/**
 * Describes a region. This is usually a country, but may be a macroregion. 
 */
declare class GeographicRegion {

    /**
     * Determines whether a geographic region identifier is supported.
     * @param geographicRegionCode One of the ISO 3166-1 two-letter or three-letter codes that identify the country, or one of the three-digit UN-M49 codes that identify the geographical region.
     * @return  True if the ID is known; otherwise, false. If this method returns true, an app can safely construct a region by using this region identifier. If it returns false, attempting to construct a region for the given code will throw an exception.
     */
    isSupported(geographicRegionCode: string): boolean;

    /**
     * Creates a GeographicRegion object that defaults to the user's home region. 
     */
    constructor(): this;

    /**
     * Creates a GeographicRegion object.
     * @param geographicRegionCode One of the ISO 3166-1 two-letter or three-letter codes that identify the country, or one of the three-digit UN-M49 codes that identify the geographical region.
     */
    constructor(geographicRegionCode: string): this;

    /**
     * Gets the string that contains the best available identifier that represents the region. 
     */
    code: string;

    /**
     * Gets the three-digit identifier for this region, as a string. 
     */
    codeThreeDigit: string;

    /**
     * Gets the three-letter identifier for this region. 
     */
    codeThreeLetter: string;

    /**
     * Gets the two-letter identifier for this region. 
     */
    codeTwoLetter: string;

    /**
     * Gets the set of currencies in use in this region. 
     */
    currenciesInUse: undefined.IVectorView<string>;

    /**
     * Gets a localized string that is suitable for display to the user for identifying the region. 
     */
    displayName: string;

    /**
     * Gets the name of the region in the primary language spoken in this region. 
     */
    nativeName: string
}


/**
 * Represents a single Japanese word (a "reading") that has been extracted from a Japanese string by JapanesePhoneticAnalyzer . 
 */
declare class JapanesePhoneme {

    /**
     * Gets the text to display for this Japanese word. 
     */
    displayText: string;

    /**
     * Gets a Boolean that indicates if this Japanese word is the start of a phrase. 
     */
    isPhraseStart: boolean;

    /**
     * Gets the "reading" (the pronunciation of DisplayText ) for this Japanese word. 
     */
    yomiText: string
}


/**
 * Reads a Japanese string that is a combination of Kanji characters and Hiragana characters, and returns a collection of proper readings from the string with word breaks. 
 */
declare class JapanesePhoneticAnalyzer {

    /**
     * Reads a Japanese string that is a combination of Kanji characters and Hiragana characters, and returns a collection of proper readings from the string with word breaks. Optionally uses the "Mono Ruby" strategy in breaking multi-Kanji words into multiple Kanji words.
     * @param input A Japanese string that is a combination of Kanji characters and Hiragana characters.
     * @param monoRuby Specifies the use of the word-breaking strategy "Mono Ruby".
     * @return  A collection of JapanesePhoneme objects that represent proper readings from the string with word breaks.
     */
    getWords(
        input: string,
        monoRuby: boolean): undefined.IVectorView<undefined.JapanesePhoneme>;

    /**
     * Reads a Japanese string that is a combination of Kanji characters and Hiragana characters, and returns a collection of proper readings from the string with word breaks.
     * @param input A Japanese string that is a combination of Kanji characters and Hiragana characters.
     * @return  A collection of JapanesePhoneme objects that represent proper readings from the string with word breaks.
     */
    getWords(input: string): undefined.IVectorView<undefined.JapanesePhoneme >
}


/**
 * A class that provides information related to BCP-47 language tags such as the language name and the script. 
 */
declare class Language {

    /**
     * Gets the BCP-47 language tag for the currently enabled keyboard layout or Input Method Editor (IME). 
     */
    currentInputMethodLanguageTag: string;

    /**
     * Determines whether a BCP-47 language tag is well-formed.
     * @param languageTag A BCP-47 language tag.
     * @return  True if the language tag is well-formed as defined by BCP-47, except when the language tag can never be valid according to BCP-47. Otherwise it returns false. If this method returns true, an application can safely construct a language by using this tag. If it returns false, attempting to construct a language for the given tag will throw an exception.
     */
    isWellFormed(languageTag: string): boolean;

    /**
     * Tries to set the normalized BCP-47 language tag of this language.
     * @param languageTag The normalized BCP-47 language tag.
     * @return  true if the value is successfully set, otherwise false.
     */
    trySetInputMethodLanguageTag(languageTag: string): boolean;

    /**
     * Creates a Language object.
     * @param languageTag A BCP-47 language tag. See Remarks.
     */
    constructor(languageTag: string): this;

    /**
     * Gets a localized string that is suitable for display to the user for identifying the language. 
     */
    displayName: string;

    /**
     * Retrieves a vector of extension subtags in the current language for the given extension identified by singleton.
     * @param singleton A single-character subtag for the LanguageTag of the current language. See BCP-47 language tags, Extensions and the Extensions Registry.
     * @return  The list of extension subtags identified by singleton.
     */
    getExtensionSubtags(singleton: string): undefined.IVectorView<string>;

    /**
     * Gets the normalized BCP-47 language tag for this language. 
     */
    languageTag: string;

    /**
     * Gets the name of the language in the language itself. 
     */
    nativeName: string;

    /**
     * Gets the four-letter ISO 15924 script code of the language. 
     */
    script: string
}


/**
 * Formats and parses currencies. 
 */
declare class CurrencyFormatter {

    /**
     * Creates a CurrencyFormatter object initialized with a currency identifier, language list, and geographic region.
     * @param currencyCode The currency identifier to use when formatting and parsing currency values.
     * @param languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
     * @param geographicRegion The identifier for the geographic region.
     */
    constructor(currencyCode: string, languages: undefined.IIterable<string>, geographicRegion: string): this;

    /**
     * Creates a CurrencyFormatter object that is initialized with a currency identifier.
     * @param currencyCode The currency identifier to use when formatting and parsing currency values.
     */
    constructor(currencyCode: string): this;

    /**
     * Prepares the CurrencyFormatter object to format currency values with a specified rounding algorithm.
     * @param roundingAlgorithm The desired rounding algorithm for the currency. This must be one of the members of RoundingAlgorithm , excluding None.
     */
    applyRoundingForCurrency(roundingAlgorithm: undefined.RoundingAlgorithm): void;

    /**
     * Gets the identifier for the currency to be used for formatting and parsing currency values. 
     */
    currency: string;

    /**
     * Returns a string representation of a UInt64 currency value.
     * @param value The UInt64 currency value to be formatted.
     * @return  A string that represents the value.
     */
    format(value: number): string;

    /**
     * Returns a string representation of a Double currency value.
     * @param value The Double currency value to be formatted.
     * @return  A string that represents the value.
     */
    format(value: number): string;

    /**
     * Returns a string representation of an Int64 currency value.
     * @param value The Int64 currency value to be formatted.
     * @return  A string that represents the value.
     */
    format(value: number): string;

    /**
     * Returns a string representation of a Double currency value.
     * @param value The Double currency value to be formatted.
     * @return  A string that represents the value.
     */
    formatDouble(value: number): string;

    /**
     * Returns a string representation of an Int64 currency value.
     * @param value The Int64 currency value to be formatted.
     * @return  A string that represents the value.
     */
    formatInt(value: number): string;

    /**
     * Returns a string representation of a UInt64 currency value.
     * @param value The UInt64 currency value to be formatted.
     * @return  The UInt64 currency value to be formatted.
     */
    formatUInt(value: number): string;

    /**
     * Gets or sets the minimum number of digits to display for the fraction part of the currency value. 
     */
    fractionDigits: number;

    /**
     * Gets the region that is used when formatting and parsing currency values. 
     */
    geographicRegion: string;

    /**
     * Gets or sets the minimum number of digits to display for the integer part of the currency value. 
     */
    integerDigits: number;

    /**
     * Gets or sets whether the decimal point of the currency value should always be displayed. 
     */
    isDecimalPointAlwaysDisplayed: boolean;

    /**
     * Gets or sets whether the integer part of the currency value should be grouped. 
     */
    isGrouped: boolean;

    /**
     * Gets or sets whether -0 is formatted using the conventions for negative numbers or for positive numbers. (In the Latin numeral system, the choice is "-0" or "0".) 
     */
    isZeroSigned: boolean;

    /**
     * Gets the priority list of language identifiers that is used when formatting and parsing currency values. 
     */
    languages: undefined.IVectorView<string>;

    /**
     * Gets or sets whether the currency is formatted with the currency symbol or currency code. 
     */
    mode: undefined.CurrencyFormatterMode;

    /**
     * Gets or sets the current rounding strategy to be used when formatting currency amounts. 
     */
    numberRounder: undefined.INumberRounder;

    /**
     * Gets or sets the numbering system that is used to format and parse currency values. 
     */
    numeralSystem: string;

    /**
     * Attempts to parse a string representation of a Double currency value.
     * @param text The text to be parsed.
     * @return  If successful, a Double that corresponds to the string representation, and otherwise null.
     */
    parseDouble(text: string): number;

    /**
     * Attempts to parse a string representation of an integer currency value.
     * @param text The text to be parsed.
     * @return  If successful, an Int64 that corresponds to the string representation, and otherwise null.
     */
    parseInt(text: string): number;

    /**
     * Attempts to parse a string representation of an unsigned integer currency value.
     * @param text The text to be parsed.
     * @return  If successful, a UInt64 that corresponds to the string representation, and otherwise null.
     */
    parseUInt(text: string): number;

    /**
     * Gets the geographic region that was most recently used to format or parse currency values. 
     */
    resolvedGeographicRegion: string;

    /**
     * Gets the language that was most recently used to format or parse currency values. 
     */
    resolvedLanguage: string;

    /**
     * Gets or sets the current padding to significant digits when a currency amount is formatted. 
     */
    significantDigits: number
}


/**
 * Formats and parses decimal numbers. 
 */
declare class DecimalFormatter {

    /**
     * Creates a DecimalFormatter object and initializes it to default values. 
     */
    constructor(): this;

    /**
     * Creates a DecimalFormatter object initialized by a language list and a geographic region.
     * @param languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
     * @param geographicRegion The identifier for the geographic region.
     */
    constructor(languages: undefined.IIterable<string>, geographicRegion: string): this;

    /**
     * Returns a string representation of a Double number.
     * @param value The Double value to be formatted.
     * @return  A string that represents the number.
     */
    format(value: number): string;

    /**
     * Returns a string representation of an Int64 number.
     * @param value The Int64 value to be formatted.
     * @return  A string that represents the number.
     */
    format(value: number): string;

    /**
     * Returns a string representation of a UInt64 number.
     * @param value The UInt64 value to be formatted.
     * @return  A string that represents the number.
     */
    format(value: number): string;

    /**
     * Returns a string representation of a Double number.
     * @param value The Double value to be formatted.
     * @return  A string that represents the number.
     */
    formatDouble(value: number): string;

    /**
     * Returns a string representation of an Int64 number.
     * @param value The Int64 value to be formatted.
     * @return  A string that represents the number.
     */
    formatInt(value: number): string;

    /**
     * Returns a string representation of a UInt64 number.
     * @param value The UInt64 value to be formatted.
     * @return  A string that represents the number.
     */
    formatUInt(value: number): string;

    /**
     * Gets or sets the minimum number of digits to display for the fraction part of the number. 
     */
    fractionDigits: number;

    /**
     * Gets the region that is used when formatting and parsing decimal numbers. 
     */
    geographicRegion: string;

    /**
     * Gets or sets the minimum number of digits to display for the integer part of the number. 
     */
    integerDigits: number;

    /**
     * Gets or sets whether the decimal point of the number should always be displayed. 
     */
    isDecimalPointAlwaysDisplayed: boolean;

    /**
     * Gets or sets whether the integer part of the number should be grouped. 
     */
    isGrouped: boolean;

    /**
     * Gets or sets whether -0 is formatted as "-0" or "0". 
     */
    isZeroSigned: boolean;

    /**
     * Gets the priority list of language identifiers that is used when formatting and parsing decimal numbers. 
     */
    languages: undefined.IVectorView<string>;

    /**
     * Gets or sets the current rounding strategy to be used when formatting numbers. 
     */
    numberRounder: undefined.INumberRounder;

    /**
     * Gets or sets the numbering system that is used to format and parse decimal numbers. 
     */
    numeralSystem: string;

    /**
     * Attempts to parse a string representation of a Double number.
     * @param text The text to be parsed.
     * @return  If successful, a Double that corresponds to the string representation, and otherwise null.
     */
    parseDouble(text: string): number;

    /**
     * Attempts to parse a string representation of an integer.
     * @param text The text to be parsed.
     * @return  If successful, an Int64 that corresponds to the string representation, and otherwise null.
     */
    parseInt(text: string): number;

    /**
     * Attempts to parse a string representation of an unsigned integer.
     * @param text The text to be parsed.
     * @return  If successful, a UInt64 that corresponds to the string representation, and otherwise null.
     */
    parseUInt(text: string): number;

    /**
     * Gets the geographic region that was most recently used to format or parse decimal values. 
     */
    resolvedGeographicRegion: string;

    /**
     * Gets the language that was most recently used to format or parse decimal values. 
     */
    resolvedLanguage: string;

    /**
     * Gets or sets the current padding to significant digits when a decimal number is formatted. 
     */
    significantDigits: number
}


/**
 * Rounds numbers to a specified increment. 
 */
declare class IncrementNumberRounder {

    /**
     * Creates an IncrementNumberRounder object. 
     */
    constructor(): this;

    /**
     * Gets or sets the increment this IncrementNumberRounder object uses for rounding. 
     */
    increment: number;

    /**
     * Rounds a Double number to the specified increment.
     * @param value The Double value to be rounded.
     * @return  The rounded number. This result is a double precision floating point number, which is not necessarily an integer.
     */
    roundDouble(value: number): number;

    /**
     * Rounds an Int32 number to the specified increment.
     * @param value The Int32 value to be rounded.
     * @return  The rounded 32 bit integer.
     */
    roundInt32(value: number): number;

    /**
     * Rounds an Int64 number to the specified increment.
     * @param value The Int64 value to be rounded.
     * @return  The rounded 64 bit integer.
     */
    roundInt64(value: number): number;

    /**
     * Rounds a Single number to the specified increment.
     * @param value The Single value to be rounded.
     * @return  The rounded number. This result is a single precision floating point number, which is not necessarily an integer.
     */
    roundSingle(value: number): number;

    /**
     * Rounds a UInt32 number to the specified increment.
     * @param value The UInt32 value to be rounded.
     * @return  The rounded unsigned 32 bit integer.
     */
    roundUInt32(value: number): number;

    /**
     * Rounds a UInt64 number to the specified increment.
     * @param value The UInt64 value to be rounded.
     * @return  The rounded unsigned 64 bit integer.
     */
    roundUInt64(value: number): number;

    /**
     * Gets or sets the rounding strategy value for this IncrementNumberRounder object. 
     */
    roundingAlgorithm: undefined.RoundingAlgorithm
}


/**
 * Translates digits of the Latin numerical system into digits of another numerical system. 
 */
declare class NumeralSystemTranslator {

    /**
     * Creates a NumeralSystemTranslator object initialized by a language list.
     * @param languages A list of BCP-47 language tags, in priority order, representing the choice of languages. They must all be well-formed according to Windows.Globalization.Language.isWellFormed .
     */
    constructor(languages: undefined.IIterable<string>): this;

    /**
     * Creates a NumeralSystemTranslator object initialized by the list of current runtime language values preferred by the user. 
     */
    constructor(): this;

    /**
     * Gets the BCP-47 language tag(s) used to initialize this NumeralSystemTranslator object. 
     */
    languages: undefined.IVectorView<string>;

    /**
     * Gets or sets the numeral system that Latin digits will be converted to on calls to TranslateNumerals . 
     */
    numeralSystem: string;

    /**
     * Gets the language used to determine the numeral system when this object was initialized. 
     */
    resolvedLanguage: string;

    /**
     * Converts a string of characters containing Latin digits to a string containing the corresponding digits of NumeralSystem .
     * @param value A string of characters containing Latin digits to be converted.
     * @return  A string containing the converted digits. This string may be a different length than value.
     */
    translateNumerals(value: string): string
}


/**
 * Formats and parses percentages. 
 */
declare class PercentFormatter {

    /**
     * Creates a PercentFormatter object and initializes it to default values. 
     */
    constructor(): this;

    /**
     * Creates a PercentFormatter object initialized by a language list and a geographic region.
     * @param languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
     * @param geographicRegion The identifier for the geographic region.
     */
    constructor(languages: undefined.IIterable<string>, geographicRegion: string): this;

    /**
     * Returns a string representation of a UInt64 percentage.
     * @param value The UInt64 value to be formatted.
     * @return  A string that represents the percentage.
     */
    format(value: number): string;

    /**
     * Returns a string representation of an Int64 percentage.
     * @param value The Int64 value to be formatted.
     * @return  A string that represents the percentage.
     */
    format(value: number): string;

    /**
     * Returns a string representation of a Double percentage.
     * @param value The Double value to be formatted.
     * @return  A string that represents the percentage.
     */
    format(value: number): string;

    /**
     * Returns a string representation of a Double percentage.
     * @param value The Double value to be formatted.
     * @return  A string that represents the percentage.
     */
    formatDouble(value: number): string;

    /**
     * Returns a string representation of an Int64 percentage.
     * @param value The Int64 value to be formatted.
     * @return  A string that represents the percentage.
     */
    formatInt(value: number): string;

    /**
     * Returns a string representation of a UInt64 percentage.
     * @param value The UInt64 value to be formatted.
     * @return  A string that represents the percentage.
     */
    formatUInt(value: number): string;

    /**
     * Gets or sets the minimum number of digits to display for the fraction part of the percentage. 
     */
    fractionDigits: number;

    /**
     * Gets the region that is used when formatting and parsing percentages. 
     */
    geographicRegion: string;

    /**
     * Gets or sets the minimum number of digits to display for the integer part of the percentage. 
     */
    integerDigits: number;

    /**
     * Gets or sets whether the decimal point of the percentage should always be displayed. 
     */
    isDecimalPointAlwaysDisplayed: boolean;

    /**
     * Gets or sets whether the integer part of the percentage should be grouped. 
     */
    isGrouped: boolean;

    /**
     * Gets or sets whether -0 is formatted as "-0" or "0". 
     */
    isZeroSigned: boolean;

    /**
     * Gets the priority list of language identifiers that is used when formatting and parsing percentages. 
     */
    languages: undefined.IVectorView<string>;

    /**
     * Gets or sets the current rounding strategy to be used when formatting percents. 
     */
    numberRounder: undefined.INumberRounder;

    /**
     * Gets or sets the numbering system that is used to format and parse percentages. 
     */
    numeralSystem: string;

    /**
     * Attempts to parse a string representation of a Double percentage.
     * @param text The text to be parsed.
     * @return  If successful, a Double that corresponds to the string representation, and otherwise null.
     */
    parseDouble(text: string): number;

    /**
     * Attempts to parse a string representation of an integer percentage.
     * @param text The text to be parsed.
     * @return  If successful, an Int64 that corresponds to the string representation, and otherwise null.
     */
    parseInt(text: string): number;

    /**
     * Attempts to parse a string representation of an unsigned integer percentage.
     * @param text The text to be parsed.
     * @return  If successful, a UInt64 that corresponds to the string representation, and otherwise null.
     */
    parseUInt(text: string): number;

    /**
     * Gets the geographic region that was most recently used to format or parse percent values. 
     */
    resolvedGeographicRegion: string;

    /**
     * Gets the language that was most recently used to format or parse percent values. 
     */
    resolvedLanguage: string;

    /**
     * Gets or sets the current padding to significant digits when a percent is formatted. 
     */
    significantDigits: number
}


/**
 * Formats and parses permillages. 
 */
declare class PermilleFormatter {

    /**
     * Creates a PermilleFormatter object and initializes it to default values. 
     */
    constructor(): this;

    /**
     * Creates a PermilleFormatter object initialized by a language list and a geographic region.
     * @param languages The list of language identifiers, in priority order, representing the choice of languages. See Remarks.
     * @param geographicRegion The identifier for the geographic region.
     */
    constructor(languages: undefined.IIterable<string>, geographicRegion: string): this;

    /**
     * Returns a string representation of a UInt64 permillage.
     * @param value The UInt64 value to be formatted.
     * @return  A string that represents the permillage.
     */
    format(value: number): string;

    /**
     * Returns a string representation of an Int64 permillage.
     * @param value The Int64 value to be formatted.
     * @return  A string that represents the permillage.
     */
    format(value: number): string;

    /**
     * Returns a string representation of a Double permillage.
     * @param value The Double value to be formatted.
     * @return  A string that represents the permillage.
     */
    format(value: number): string;

    /**
     * Returns a string representation of a Double permillage.
     * @param value The Double value to be formatted.
     * @return  A string that represents the permillage.
     */
    formatDouble(value: number): string;

    /**
     * Returns a string representation of an Int64 permillage.
     * @param value The Int64 value to be formatted.
     * @return  A string that represents the permillage.
     */
    formatInt(value: number): string;

    /**
     * Returns a string representation of a UInt64 permillage.
     * @param value The UInt64 value to be formatted.
     * @return  A string that represents the permillage.
     */
    formatUInt(value: number): string;

    /**
     * Gets or sets the minimum number of digits to display for the fraction part of the permillage. 
     */
    fractionDigits: number;

    /**
     * Gets the region that is used when formatting and parsing permille values. 
     */
    geographicRegion: string;

    /**
     * Gets or sets the minimum number of digits to display for the integer part of the permillage. 
     */
    integerDigits: number;

    /**
     * Gets or sets whether the decimal point of the permillage should always be displayed. 
     */
    isDecimalPointAlwaysDisplayed: boolean;

    /**
     * Gets or sets whether the integer part of the permillage should be grouped. 
     */
    isGrouped: boolean;

    /**
     * Gets or sets whether -0 is formatted as "-0" or "0". 
     */
    isZeroSigned: boolean;

    /**
     * Gets the priority list of language identifiers that is used when formatting and parsing permille values. 
     */
    languages: undefined.IVectorView<string>;

    /**
     * Gets or sets the current rounding strategy to be used when formatting permilles. 
     */
    numberRounder: undefined.INumberRounder;

    /**
     * Gets or sets the numbering system that is used to format and parse permille values. 
     */
    numeralSystem: string;

    /**
     * Attempts to parse a string representation of a Double permillage.
     * @param text The text to be parsed.
     * @return  If successful, a Double that corresponds to the string representation, and otherwise null.
     */
    parseDouble(text: string): number;

    /**
     * Attempts to parse a string representation of an integer permillage.
     * @param text The text to be parsed.
     * @return  If successful, an Int64 that corresponds to the string representation, and otherwise null.
     */
    parseInt(text: string): number;

    /**
     * Attempts to parse a string representation of an unsigned integer permillage.
     * @param text The text to be parsed.
     * @return  If successful, a UInt64 that corresponds to the string representation, and otherwise null.
     */
    parseUInt(text: string): number;

    /**
     * Gets the geographic region that was most recently used to format or parse permille values. 
     */
    resolvedGeographicRegion: string;

    /**
     * Gets the language that was most recently used to format or parse permille values. 
     */
    resolvedLanguage: string;

    /**
     * Gets or sets the current padding to significant digits when a permille is formatted. 
     */
    significantDigits: number
}


/**
 * Rounds numbers to a specified number of significant digits. 
 */
declare class SignificantDigitsNumberRounder {

    /**
     * Creates a SignificantDigitsNumberRounder object. 
     */
    constructor(): this;

    /**
     * Rounds a Double number to the specified number of significant digits.
     * @param value The Double value to be rounded.
     * @return  The rounded number. This result is a double precision floating point number, which is not necessarily an integer.
     */
    roundDouble(value: number): number;

    /**
     * Rounds an Int32 number to the specified number of significant digits.
     * @param value The Int32 value to be rounded.
     * @return  The rounded 32 bit integer.
     */
    roundInt32(value: number): number;

    /**
     * Rounds an Int64 number to the specified number of significant digits.
     * @param value The Int64 value to be rounded.
     * @return  The rounded 64 bit integer.
     */
    roundInt64(value: number): number;

    /**
     * Rounds a Single number to the specified number of significant digits.
     * @param value The Single value to be rounded.
     * @return  The rounded number. This result is a single precision floating point number, which is not necessarily an integer.
     */
    roundSingle(value: number): number;

    /**
     * Rounds a UInt32 number to the specified number of significant digits.
     * @param value The UInt32 value to be rounded.
     * @return  The rounded unsigned 32 bit integer.
     */
    roundUInt32(value: number): number;

    /**
     * Rounds a UInt64 number to the specified number of significant digits.
     * @param value The UInt64 value to be rounded.
     * @return  The rounded unsigned 64 bit integer.
     */
    roundUInt64(value: number): number;

    /**
     * Gets or sets the rounding strategy value for this SignificantDigitsNumberRounder object. 
     */
    roundingAlgorithm: undefined.RoundingAlgorithm;

    /**
     * Gets or sets the number of significant digits this SignificantDigitsNumberRounder object uses for rounding. 
     */
    significantDigits: number
}


/**
 * An interface that returns rounded results for provided numbers of several data types. 
 */
declare interface NumberFormatting$INumberRounder {

    /**
     * Rounds a Double number.
     * @param value The Double value to be rounded.
     * @return  The rounded number. This result is a double precision floating point number, which is not necessarily an integer.
     */
    roundDouble(value: number): number,

        /**
         * Rounds an Int32 number.
         * @param value The Int32 value to be rounded.
         * @return  The rounded 32 bit integer.
         */
        roundInt32(value: number): number,

        /**
         * Rounds an Int64 number.
         * @param value The Int64 value to be rounded.
         * @return  The rounded 64 bit integer.
         */
        roundInt64(value: number): number,

        /**
         * Rounds a Single number.
         * @param value The Single value to be rounded.
         * @return  The rounded number. This result is a single precision floating point number, which is not necessarily an integer.
         */
        roundSingle(value: number): number,

        /**
         * Rounds a UInt32 number.
         * @param value The UInt32 value to be rounded.
         * @return  The rounded unsigned 32 bit integer.
         */
        roundUInt32(value: number): number,

        /**
         * Rounds a UInt64 number.
         * @param value The UInt64 value to be rounded.
         * @return  The rounded unsigned 64 bit integer.
         */
        roundUInt64(value: number): number
}


/**
 * Contains the numeral system identifiers for the supported numeral systems, as static properties. 
 */
declare class NumeralSystemIdentifiers {

    /**
     * Gets the identifier for the Arabic-Indic decimal numeral system. 
     */
    arab: string;

    /**
     * Gets the identifier for the Extended Arabic-Indic decimal numeral system. 
     */
    arabExt: string;

    /**
     * Gets the identifier for the Balinese decimal numeral system. 
     */
    bali: string;

    /**
     * Gets the identifier for the Bangla decimal numeral system. 
     */
    beng: string;

    /**
     * Gets the identifier for the Brahmi decimal numeral system. 
     */
    brah: string;

    /**
     * Gets the identifier for the Cham decimal numeral system. 
     */
    cham: string;

    /**
     * Gets the identifier for the Devanagari decimal numeral system. 
     */
    deva: string;

    /**
     * Gets the identifier for the Latin decimal numeral system using full-width characters. 
     */
    fullWide: string;

    /**
     * Gets the identifier for the Gujarati decimal numeral system. 
     */
    gujr: string;

    /**
     * Gets the identifier for the Gurmukhi decimal numeral system. 
     */
    guru: string;

    /**
     * Gets the identifier for the Han decimal numeral system. 
     */
    haniDec: string;

    /**
     * Gets the identifier for the Javanese decimal numeral system. 
     */
    java: string;

    /**
     * Gets the identifier for the Kayah Li decimal numeral system. 
     */
    kali: string;

    /**
     * Gets the identifier for the Khmer decimal numeral system. 
     */
    khmr: string;

    /**
     * Gets the identifier for the Kannada decimal numeral system. 
     */
    knda: string;

    /**
     * Gets the identifier for the Tai Tham Hora decimal numeral system. 
     */
    lana: string;

    /**
     * Gets the identifier for the Tai Tham Tham decimal numeral system. 
     */
    lanaTham: string;

    /**
     * Gets the identifier for the Laoo decimal numeral system. 
     */
    laoo: string;

    /**
     * Gets the identifier for the Latin decimal numeral system. 
     */
    latn: string;

    /**
     * Gets the identifier for the Lepcha decimal numeral system. 
     */
    lepc: string;

    /**
     * Gets the identifier for the Limbu decimal numeral system. 
     */
    limb: string;

    /**
     * Gets the identifier for the decimal numeral system using MathBold characters. 
     */
    mathBold: string;

    /**
     * Gets the identifier for the decimal numeral system using MathDbl characters. 
     */
    mathDbl: string;

    /**
     * Gets the identifier for the decimal numeral system using MathMono characters. 
     */
    mathMono: string;

    /**
     * Gets the identifier for the decimal numeral system using MathSanb characters. 
     */
    mathSanb: string;

    /**
     * Gets the identifier for the decimal numeral system using MathSans characters. 
     */
    mathSans: string;

    /**
     * Gets the identifier for the Malayalam decimal numeral system. 
     */
    mlym: string;

    /**
     * Gets the identifier for the Mongolian decimal numeral system. 
     */
    mong: string;

    /**
     * Gets the identifier for the Meetei Mayek decimal numeral system. 
     */
    mtei: string;

    /**
     * Gets the identifier for the Myanmar decimal numeral system. 
     */
    mymr: string;

    /**
     * Gets the identifier for the Myanmar Shan decimal numeral system. 
     */
    mymrShan: string;

    /**
     * Gets the identifier for the Nko decimal numeral system. 
     */
    nkoo: string;

    /**
     * Gets the identifier for the Ol Chiki decimal numeral system. 
     */
    olck: string;

    /**
     * Gets the identifier for the Odia decimal numeral system. 
     */
    orya: string;

    /**
     * Gets the identifier for the Osmanya decimal numeral system. 
     */
    osma: string;

    /**
     * Gets the identifier for the Saurashtra decimal numeral system. 
     */
    saur: string;

    /**
     * Gets the identifier for the Sundanese decimal numeral system. 
     */
    sund: string;

    /**
     * Gets the identifier for the New Tai Lue decimal numeral system. 
     */
    talu: string;

    /**
     * Gets the identifier for the Tamil decimal numeral system. 
     */
    tamlDec: string;

    /**
     * Gets the identifier for the Telugu decimal numeral system. 
     */
    telu: string;

    /**
     * Gets the identifier for the Thai decimal numeral system. 
     */
    thai: string;

    /**
     * Gets the identifier for the Tibetan decimal numeral system. 
     */
    tibt: string;

    /**
     * Gets the identifier for the Vai decimal numeral system. 
     */
    vaii: string;

    /**
     * Gets the identifier for the decimal numeral system using ZmthBold (Mathematical notation) characters. 
     */
    zmthBold: string;

    /**
     * Gets the identifier for the decimal numeral system using ZmthDbl (Mathematical notation) characters. 
     */
    zmthDbl: string;

    /**
     * Gets the identifier for the decimal numeral system using ZmthMono (Mathematical notation) characters. 
     */
    zmthMono: string;

    /**
     * Gets the identifier for the decimal numeral system using ZmthSanb (Mathematical notation) characters. 
     */
    zmthSanb: string;

    /**
     * Gets the identifier for the decimal numeral system using ZmthSans (Mathematical notation) characters. 
     */
    zmthSans: string
}


/**
 * This represents an IDXGISurface and can be used to interop between Windows Runtime components that need to exchange IDXGISurface references. 
 */
declare type Direct3D11$IDirect3DSurface = {

    /**
     * Gets a Direct3DSurfaceDescription describing the surface. 
     */
    description: undefined.Direct3DSurfaceDescription
}


/**
 * A Windows Runtime projection of the DXGI_SURFACE_DESC structure. Describes a IDirect3DSurface . 
 */
declare interface Direct3D11$Direct3DSurfaceDescription {

    /**
     * Pixel format of the surface. 
     */
    format: undefined.DirectXPixelFormat,

        /**
         * Height of the surface. 
         */
        height: number,

        /**
         * Multi-sampling parameters for the surface. 
         */
        multisampleDescription: undefined.Direct3DMultisampleDescription,

        /**
         * Width of the surface. 
         */
        width: number
}


/**
 * A Windows Runtime projection of the DXGI_SAMPLE_DESC structure. Describes multi-sampling parameters for a IDirect3DSurface . 
 */
declare interface Direct3D11$Direct3DMultisampleDescription {

    /**
     * The number of multisamples per pixel. 
     */
    count: number,

        /**
         * The image quality level. The higher the quality, the lower the performance. 
         */
        quality: number
}


/**
 * Monitors and controls physical display information. The class provides events to allow clients to monitor for changes in the display. 
 */
declare class DisplayInformation {

    /**
     * Gets and sets the preferred orientation of the app. 
     */
    autoRotationPreferences: undefined.DisplayOrientations;

    /**
     * Gets the current physical display information.
     * @return  A DisplayInformation object that contains the current physical display information.
     */
    getForCurrentView(): undefined.DisplayInformation;

    /**
     * Occurs when the display requires redrawing. 
     */
    ondisplaycontentsinvalidated: undefined.TypedEventHandler<undefined.DisplayInformation, any>;
    addEventListener(
        type: "displaycontentsinvalidated",
        listener: undefined.TypedEventHandler<undefined.DisplayInformation, any>): void;
    removeEventListener(
        type: "displaycontentsinvalidated",
        listener: undefined.TypedEventHandler<undefined.DisplayInformation, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void;

    /**
     * Gets the current orientation of a rectangular monitor. 
     */
    currentOrientation: undefined.DisplayOrientations;

    /**
     * Diagonal size of the display in inches. 
     */
    diagonalSizeInInches: number;

    /**
     * Asynchronously gets the default International Color Consortium (ICC) color profile that is associated with the physical display.
     * @return  Object that manages the asynchronous retrieval of the color profile.
     */
    getColorProfileAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStream>;

    /**
     * Gets the pixels per logical inch of the current environment. 
     */
    logicalDpi: number;

    /**
     * Gets the native orientation of the display monitor, which is typically the orientation where the buttons on the device match the orientation of the monitor. 
     */
    nativeOrientation: undefined.DisplayOrientations;

    /**
     * Occurs when the physical display's color profile changes. 
     */
    oncolorprofilechanged: undefined.TypedEventHandler<undefined.DisplayInformation, any>;
    addEventListener(
        type: "colorprofilechanged",
        listener: undefined.TypedEventHandler<undefined.DisplayInformation, any>): void;
    removeEventListener(
        type: "colorprofilechanged",
        listener: undefined.TypedEventHandler<undefined.DisplayInformation, any>): void;

    /**
     * Occurs when the LogicalDpi property changes because the pixels per inch (PPI) of the display changes. 
     */
    ondpichanged: undefined.TypedEventHandler<undefined.DisplayInformation, any>;
    addEventListener(
        type: "dpichanged",
        listener: undefined.TypedEventHandler<undefined.DisplayInformation, any>): void;
    removeEventListener(
        type: "dpichanged",
        listener: undefined.TypedEventHandler<undefined.DisplayInformation, any>): void;

    /**
     * Occurs when either the CurrentOrientation or NativeOrientation property changes because of a mode change or a monitor change. 
     */
    onorientationchanged: undefined.TypedEventHandler<undefined.DisplayInformation, any>;
    addEventListener(
        type: "orientationchanged",
        listener: undefined.TypedEventHandler<undefined.DisplayInformation, any>): void;
    removeEventListener(
        type: "orientationchanged",
        listener: undefined.TypedEventHandler<undefined.DisplayInformation, any>): void;

    /**
     * Occurs when the StereoEnabled property changes because support for stereoscopic 3D changes. 
     */
    onstereoenabledchanged: undefined.TypedEventHandler<undefined.DisplayInformation, any>;
    addEventListener(
        type: "stereoenabledchanged",
        listener: undefined.TypedEventHandler<undefined.DisplayInformation, any>): void;
    removeEventListener(
        type: "stereoenabledchanged",
        listener: undefined.TypedEventHandler<undefined.DisplayInformation, any>): void;

    /**
     * Gets the raw dots per inch (DPI) along the x axis of the display monitor. 
     */
    rawDpiX: number;

    /**
     * Gets the raw dots per inch (DPI) along the y axis of the display monitor. 
     */
    rawDpiY: number;

    /**
     * Gets a value representing the number of raw (physical) pixels for each view (layout) pixel. 
     */
    rawPixelsPerViewPixel: number;

    /**
     * Gets the scale factor of the immersive environment. 
     */
    resolutionScale: undefined.ResolutionScale;

    /**
     * Gets a value that indicates whether the device supports stereoscopic 3D. 
     */
    stereoEnabled: boolean;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides various properties that are related to the physical display. 
 */
declare class DisplayProperties {

    /**
     * Gets and sets the preferred orientation of the app. 
     */
    autoRotationPreferences: undefined.DisplayOrientations;

    /**
     * Gets the current orientation of a rectangular monitor. 
     */
    currentOrientation: undefined.DisplayOrientations;

    /**
     * Asynchronously gets the default International Color Consortium (ICC) color profile that is associated with the physical display.
     * @return  Object that manages the asynchronous retrieval of the color profile.
     */
    getColorProfileAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStream>;

    /**
     * Gets the pixels per logical inch of the current environment. 
     */
    logicalDpi: number;

    /**
     * Gets the native orientation of the display monitor, which is typically the orientation where the buttons on the device match the orientation of the monitor. 
     */
    nativeOrientation: undefined.DisplayOrientations;

    /**
     * Occurs when the physical display's color profile changes. 
     */
    oncolorprofilechanged: undefined.DisplayPropertiesEventHandler;
    addEventListener(
        type: "colorprofilechanged",
        listener: undefined.DisplayPropertiesEventHandler): void;
    removeEventListener(
        type: "colorprofilechanged",
        listener: undefined.DisplayPropertiesEventHandler): void;

    /**
     * Occurs when the display requires redrawing. 
     */
    ondisplaycontentsinvalidated: undefined.DisplayPropertiesEventHandler;
    addEventListener(
        type: "displaycontentsinvalidated",
        listener: undefined.DisplayPropertiesEventHandler): void;
    removeEventListener(
        type: "displaycontentsinvalidated",
        listener: undefined.DisplayPropertiesEventHandler): void;

    /**
     * Occurs when the LogicalDpi property changes because the pixels per inch (PPI) of the display changes. 
     */
    onlogicaldpichanged: undefined.DisplayPropertiesEventHandler;
    addEventListener(
        type: "logicaldpichanged",
        listener: undefined.DisplayPropertiesEventHandler): void;
    removeEventListener(
        type: "logicaldpichanged",
        listener: undefined.DisplayPropertiesEventHandler): void;

    /**
     * Occurs when either the CurrentOrientation or NativeOrientation property changes because of a mode change or a monitor change. 
     */
    onorientationchanged: undefined.DisplayPropertiesEventHandler;
    addEventListener(
        type: "orientationchanged",
        listener: undefined.DisplayPropertiesEventHandler): void;
    removeEventListener(
        type: "orientationchanged",
        listener: undefined.DisplayPropertiesEventHandler): void;

    /**
     * Occurs when the StereoEnabled property changes because support for stereoscopic 3D changes. 
     */
    onstereoenabledchanged: undefined.DisplayPropertiesEventHandler;
    addEventListener(
        type: "stereoenabledchanged",
        listener: undefined.DisplayPropertiesEventHandler): void;
    removeEventListener(
        type: "stereoenabledchanged",
        listener: undefined.DisplayPropertiesEventHandler): void;

    /**
     * Gets the scale factor of the immersive environment. 
     */
    resolutionScale: undefined.ResolutionScale;

    /**
     * Gets a value that indicates whether the device supports stereoscopic 3D. 
     */
    stereoEnabled: boolean;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a method that handles display property events. 
 */
declare type Display$DisplayPropertiesEventHandler = (ev: Windows$WinRTEvent<any>) => void;



declare class HolographicCamera {
    id: any;
    isStereo: any;
    renderTargetSize: any;
    setFarPlaneDistance: any;
    setNearPlaneDistance: any;
    viewportScaleFactor: any
}

declare class HolographicCameraPose {
    farPlaneDistance: any;
    holographicCamera: any;
    nearPlaneDistance: any;
    projectionTransform: any;
    tryGetCullingFrustum: any;
    tryGetViewTransform: any;
    tryGetVisibleFrustum: any;
    viewport: any
}

declare class HolographicCameraRenderingParameters {
    direct3D11BackBuffer: any;
    direct3D11Device: any;
    setFocusPoint: any
}

declare class HolographicFrame {
    addedCameras: any;
    currentPrediction: any;
    duration: any;
    getRenderingParameters: any;
    presentUsingCurrentPrediction: any;
    removedCameras: any;
    updateCurrentPrediction: any;
    waitForFrameToFinish: any
}

declare class HolographicFramePrediction {
    cameraPoses: any;
    timestamp: any
}

declare
var success: any;

declare
var deviceRemoved: any;

declare
var waitForFrameToFinish: any;

declare
var doNotWaitForFrameToFinish: any;

declare class HolographicSpace {
    createForCoreWindow: any;
    addEventListener: any;
    createNextFrame: any;
    oncameraadded: any;
    oncameraremoved: any;
    primaryAdapterId: any;
    removeEventListener: any;
    setDirect3D11Device: any
}

declare class HolographicSpaceCameraAddedEventArgs {
    camera: any;
    getDeferral: any
}

declare class HolographicSpaceCameraRemovedEventArgs {
    camera: any
}


/**
 * Represents the pixel data buffer of a bitmap. 
 */
declare class BitmapBuffer {

    /**
     * Disposes of the object and associated resources. 
     */
    close(): void;

    /**
     * Creates a reference to the underlying memory buffer.
     * @return  A reference to the underlying memory buffer.
     */
    createReference(): undefined.IMemoryBufferReference;

    /**
     * Gets the number of bit planes in the bitmap buffer.
     * @return  The number of bit planes in the bitmap buffer.
     */
    getPlaneCount(): number;

    /**
     * Gets a BitmapPlaneDescription object that describes the size, offset, and stride of the bitmap data in the bit plane with the specified index.
     * @param index The index of the bit plane for which the description is retrieved.
     * @return  The bit plane description.
     */
    getPlaneDescription(index: number): undefined.BitmapPlaneDescription
}


/**
 * Provides access to information about a decoder or encoder. 
 */
declare class BitmapCodecInformation {

    /**
     * The unique identifier of the decoder or encoder. Methods like BitmapDecoder::CreateAsync and BitmapEncoder::CreateAsync use the codec identifier to determine which codec to create. 
     */
    codecId: string;

    /**
     * A collection of all the file extensions supported by the decoder or encoder. 
     */
    fileExtensions: undefined.IVectorView<string>;

    /**
     * The friendly name of the decoder or encoder. 
     */
    friendlyName: string;

    /**
     * A collection of all the MIME/content types supported by the decoder or encoder. MIME type is synonymous with content type . 
     */
    mimeTypes: undefined.IVectorView<string >
}


/**
 * Provides read access to bitmap container data as well as data from the first frame. 
 */
declare class BitmapDecoder {

    /**
     * The unique identifier of the BMP decoder. 
     */
    bmpDecoderId: string;

    /**
     * Asynchronously creates a new BitmapDecoder and initializes it using a stream.
     * @param stream The stream containing the image file to be decoded.
     * @return  An object that manages the asynchronous creation of a new BitmapDecoder .
     */
    createAsync(
        stream: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncOperation<undefined.BitmapDecoder>;

    /**
     * Asynchronously creates a new BitmapDecoder using a specific bitmap codec and initializes it using a stream.
     * @param decoderId The unique identifier of the specified bitmap codec.
     * @param stream The stream containing the image file to be decoded.
     * @return  An object that manages the asynchronous creation of a new BitmapDecoder .
     */
    createAsync(
        decoderId: string,
        stream: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncOperation<undefined.BitmapDecoder>;

    /**
     * The bitmap decoders installed on the system and information about them.
     * @return  A list of BitmapCodecInformation objects containing information about each decoder.
     */
    getDecoderInformationEnumerator(): undefined.IVectorView<undefined.BitmapCodecInformation>;

    /**
     * The unique identifier of the GIF decoder. 
     */
    gifDecoderId: string;

    /**
     * The unique identifier of the ICO decoder. 
     */
    icoDecoderId: string;

    /**
     * The unique identifier of the JPEG decoder. 
     */
    jpegDecoderId: string;

    /**
     * The unique identifier of the JPEG-XR decoder. 
     */
    jpegXRDecoderId: string;

    /**
     * The unique identifier of the PNG decoder. 
     */
    pngDecoderId: string;

    /**
     * The unique identifier of the TIFF decoder. 
     */
    tiffDecoderId: string;

    /**
     * The default alpha mode of the first frame. 
     */
    bitmapAlphaMode: undefined.BitmapAlphaMode;

    /**
     * Provides access to the container bitmap properties. 
     */
    bitmapContainerProperties: undefined.BitmapPropertiesView;

    /**
     * The pixel format that best fits the first frame. 
     */
    bitmapPixelFormat: undefined.BitmapPixelFormat;

    /**
     * A read-only view of the metadata within the first frame. 
     */
    bitmapProperties: undefined.BitmapPropertiesView;

    /**
     * Information about the bitmap decoder. 
     */
    decoderInformation: undefined.BitmapCodecInformation;

    /**
     * The horizontal resolution of the first frame in dots per inch. 
     */
    dpiX: number;

    /**
     * The vertical resolution of the first frame in dots per inch. 
     */
    dpiY: number;

    /**
     * The number of frames within the image file. 
     */
    frameCount: number;

    /**
     * Asynchronously retrieves a frame from the image file.
     * @param frameIndex The zero-based index of the frame to be retrieved.
     * @return  Object that manages the asynchronous retrieval of the frame.
     */
    getFrameAsync(
        frameIndex: number): undefined.IPromiseWithIAsyncOperation<undefined.BitmapFrame>;

    /**
     * Asynchronously requests the pixel data for the frame.
     * @return  Object that manages the asynchronous retrieval of the pixel data.
     */
    getPixelDataAsync(): undefined.IPromiseWithIAsyncOperation<undefined.PixelDataProvider>;

    /**
     * Asynchronously requests the pixel data for the frame using the specified parameters.
     * @param pixelFormat The specified pixel format.
     * @param alphaMode The specified alpha mode.
     * @param transform The set of transformations to be applied to the frame.
     * @param exifOrientationMode Indicates whether the EXIF orientation flag should be ignored or respected.
     * @param colorManagementMode Indicates whether the pixel data should be color managed to the sRGB color space.
     * @return  Object that manages the asynchronous retrieval of the pixel data.
     */
    getPixelDataAsync(
        pixelFormat: undefined.BitmapPixelFormat,
        alphaMode: undefined.BitmapAlphaMode,
        transform: undefined.BitmapTransform,
        exifOrientationMode: undefined.ExifOrientationMode,
        colorManagementMode: undefined.ColorManagementMode): undefined.IPromiseWithIAsyncOperation<undefined.PixelDataProvider>;

    /**
     * Asynchronously returns a stream containing the preview image.
     * @return  Object that manages the asynchronous retrieval of the bitmap preview data.
     */
    getPreviewAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ImageStream>;

    /**
     * Asynchronously gets a SoftwareBitmap representation of the decoded bitmap.
     * @return  An asynchronous operation that returns a SoftwareBitmap on successful completion.
     */
    getSoftwareBitmapAsync(): undefined.IPromiseWithIAsyncOperation<undefined.SoftwareBitmap>;

    /**
     * Asynchronously gets a SoftwareBitmap representation of the decoded bitmap.
     * @param pixelFormat The pixel format of the software bitmap.
     * @param alphaMode The alpha mode of the software bitmap.
     * @param transform The transform of the software bitmap.
     * @param exifOrientationMode The EXIF orientation mode of the software bitmap.
     * @param colorManagementMode The color management mode of the software bitmap.
     * @return  An asynchronous operation that returns a SoftwareBitmap on successful completion.
     */
    getSoftwareBitmapAsync(
        pixelFormat: undefined.BitmapPixelFormat,
        alphaMode: undefined.BitmapAlphaMode,
        transform: undefined.BitmapTransform,
        exifOrientationMode: undefined.ExifOrientationMode,
        colorManagementMode: undefined.ColorManagementMode): undefined.IPromiseWithIAsyncOperation<undefined.SoftwareBitmap>;

    /**
     * Asynchronously gets a SoftwareBitmap representation of the decoded bitmap.
     * @param pixelFormat The pixel format of the software bitmap.
     * @param alphaMode The alpha mode of the software bitmap.
     * @return  An asynchronous operation that returns a SoftwareBitmap on successful completion.
     */
    getSoftwareBitmapAsync(
        pixelFormat: undefined.BitmapPixelFormat,
        alphaMode: undefined.BitmapAlphaMode): undefined.IPromiseWithIAsyncOperation<undefined.SoftwareBitmap>;

    /**
     * Asynchronously returns a stream containing the thumbnail image.
     * @return  Object that manages the asynchronous retrieval of the thumbnail stream.
     */
    getThumbnailAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ImageStream>;

    /**
     * The height of the first frame in pixels, after any EXIF orientation has been applied to the bitmap. 
     */
    orientedPixelHeight: number;

    /**
     * The width of the first frame in pixels, after any EXIF orientation has been applied to the bitmap. 
     */
    orientedPixelWidth: number;

    /**
     * The height of the first frame in pixels. 
     */
    pixelHeight: number;

    /**
     * The width of the first frame in pixels. 
     */
    pixelWidth: number
}


/**
 * Contains methods to create, edit and save images. 
 */
declare class BitmapEncoder {

    /**
     * The unique identifier of the built-in BMP encoder. 
     */
    bmpEncoderId: string;

    /**
     * Asynchronously creates a new BitmapEncoder for the specified codec with the specified encoding options and initializes it on a stream.
     * @param encoderId The unique identifier of the specified encoder.
     * @param stream A stream representing where the image file is to be written.
     * @param encodingOptions A collection of key-value pairs containing one or more codec-specific encoding options and the desired values.
     * @return  An object that manages the asynchronous creation of a new BitmapEncoder .
     */
    createAsync(
        encoderId: string,
        stream: undefined.IRandomAccessStream,
        encodingOptions: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncOperation<undefined.BitmapEncoder>;

    /**
     * Asynchronously creates a new BitmapEncoder .
     * @param encoderId The unique identifier of the specified encoder.
     * @param stream The output stream.
     * @return  An object that manages the asynchronous creation of a new BitmapEncoder .
     */
    createAsync(
        encoderId: string,
        stream: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncOperation<undefined.BitmapEncoder>;

    /**
     * Asynchronously creates a new BitmapEncoder for in-place property and metadata editing. The new encoder can only edit bitmap properties in-place and will fail for any other uses.
     * @param bitmapDecoder A BitmapDecoder containing the image data to be edited. This parameter must be created on a stream with an access mode of ReadWrite .
     * @return  An object that manages the asynchronous initialization of a new BitmapEncoder using data from an existing BitmapDecoder .
     */
    createForInPlacePropertyEncodingAsync(
        bitmapDecoder: undefined.BitmapDecoder): undefined.IPromiseWithIAsyncOperation<undefined.BitmapEncoder>;

    /**
     * Asynchronously creates a new BitmapEncoder and initializes it using data from an existing BitmapDecoder .
     * @param stream The output stream.
     * @param bitmapDecoder A BitmapDecoder containing the image data to be copied.
     * @return  An object that manages the asynchronous creation of a new BitmapEncoder using data from an existing BitmapDecoder .
     */
    createForTranscodingAsync(
        stream: undefined.IRandomAccessStream,
        bitmapDecoder: undefined.BitmapDecoder): undefined.IPromiseWithIAsyncOperation<undefined.BitmapEncoder>;

    /**
     * A list of the bitmap encoders installed on the system and information about them.
     * @return  A list of BitmapCodecInformation objects containing information about each encoder.
     */
    getEncoderInformationEnumerator(): undefined.IVectorView<undefined.BitmapCodecInformation>;

    /**
     * The unique identifier of the built-in GIF encoder. 
     */
    gifEncoderId: string;

    /**
     * The unique identifier of the built-in JPEG encoder. 
     */
    jpegEncoderId: string;

    /**
     * The unique identifier of the built-in JPEG-XR encoder. 
     */
    jpegXREncoderId: string;

    /**
     * The unique identifier of the built-in PNG encoder. 
     */
    pngEncoderId: string;

    /**
     * The unique identifier of the built-in TIFF encoder. 
     */
    tiffEncoderId: string;

    /**
     * The metadata for the container. 
     */
    bitmapContainerProperties: undefined.BitmapProperties;

    /**
     * The metadata for the selected frame. 
     */
    bitmapProperties: undefined.BitmapProperties;

    /**
     * A BitmapTransform object that is used to specify how the frame bitmap is to be transformed. 
     */
    bitmapTransform: undefined.BitmapTransform;

    /**
     * Information about the bitmap encoder. 
     */
    encoderInformation: undefined.BitmapCodecInformation;

    /**
     * Asynchronously commits and flushes all of the image data.
     * @return  An object that manages the asynchronous flush operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * The height, in pixels, of any generated thumbnail. 
     */
    generatedThumbnailHeight: number;

    /**
     * The width, in pixels, of any generated thumbnail. 
     */
    generatedThumbnailWidth: number;

    /**
     * Asynchronously commits the current frame data and appends a new empty frame, with the specified encoding options, to be edited.
     * @param encodingOptions The specified encoding options. A collection of key-value pairs containing one or more codec-specific encoding options and the desired values.
     * @return  An object that manages the asynchronous operation of committing the current frame data and appending a new empty frame to be edited.
     */
    goToNextFrameAsync(
        encodingOptions: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously commits the current frame data and appends a new empty frame to be edited.
     * @return  An object that manages the asynchronous operation of committing the current frame data and appending a new empty frame to be edited.
     */
    goToNextFrameAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Indicates whether or not a new thumbnail is automatically generated. 
     */
    isThumbnailGenerated: boolean;

    /**
     * Sets pixel data on the frame.
     * @param pixelFormat The pixel format of the pixel data.
     * @param alphaMode The alpha mode of the pixel data.
     * @param width The width, in pixels, of the pixel data.
     * @param height The height, in pixels, of the pixel data.
     * @param dpiX The horizontal resolution, in dots per inch, of the pixel data.
     * @param dpiY The vertical resolution, in dots per inch, of the pixel data.
     * @param pixels The pixel data.
     */
    setPixelData(
        pixelFormat: undefined.BitmapPixelFormat,
        alphaMode: undefined.BitmapAlphaMode,
        width: number,
        height: number,
        dpiX: number,
        dpiY: number,
        pixels: number[]): void;

    /**
     * Sets the image data of the current frame using the specified SoftwareBitmap .
     * @param bitmap The software bitmap containing the image data.
     */
    setSoftwareBitmap(bitmap: undefined.SoftwareBitmap): void
}


/**
 * Provides read access to data within a single frame. 
 */
declare class BitmapFrame {

    /**
     * The default alpha mode of the frame. 
     */
    bitmapAlphaMode: undefined.BitmapAlphaMode;

    /**
     * The pixel format that best fits the frame. 
     */
    bitmapPixelFormat: undefined.BitmapPixelFormat;

    /**
     * A read-only view of the metadata within the frame. 
     */
    bitmapProperties: undefined.BitmapPropertiesView;

    /**
     * The horizontal resolution of the frame in dots per inch. 
     */
    dpiX: number;

    /**
     * The vertical resolution of the frame in dots per inch. 
     */
    dpiY: number;

    /**
     * Asynchronously requests the pixel data for the frame. The resulting pixel data array will use the bitmap pixel format and alpha mode specified in the BitmapPixelFormat and BitmapAlphaMode properties. It will also have color management and EXIF orientation applied (see the Remarks section for more information).
     * @return  Object that manages the asynchronous retrieval of the pixel data.
     */
    getPixelDataAsync(): undefined.IPromiseWithIAsyncOperation<undefined.PixelDataProvider>;

    /**
     * Asynchronously requests the pixel data for the frame using the specified parameters.
     * @param pixelFormat The specified pixel format.
     * @param alphaMode The specified alpha mode.
     * @param transform The set of transformations to be applied to the frame.
     * @param exifOrientationMode Indicates whether the EXIF orientation flag should be ignored or respected.
     * @param colorManagementMode Indicates whether the pixel data should be color managed to the sRGB color space.
     * @return  Object that manages the asynchronous retrieval of the pixel data.
     */
    getPixelDataAsync(
        pixelFormat: undefined.BitmapPixelFormat,
        alphaMode: undefined.BitmapAlphaMode,
        transform: undefined.BitmapTransform,
        exifOrientationMode: undefined.ExifOrientationMode,
        colorManagementMode: undefined.ColorManagementMode): undefined.IPromiseWithIAsyncOperation<undefined.PixelDataProvider>;

    /**
     * Asynchronously gets a SoftwareBitmap representation of the bitmap frame.
     * @return  An asynchronous operation that returns a SoftwareBitmap on successful completion.
     */
    getSoftwareBitmapAsync(): undefined.IPromiseWithIAsyncOperation<undefined.SoftwareBitmap>;

    /**
     * Asynchronously gets a SoftwareBitmap representation of the bitmap frame.
     * @param pixelFormat The pixel format of the software bitmap.
     * @param alphaMode The alpha mode of the software bitmap.
     * @param transform The transform of the software bitmap.
     * @param exifOrientationMode The EXIF orientation mode of the software bitmap.
     * @param colorManagementMode The color management mode of the software bitmap.
     * @return  An asynchronous operation that returns a SoftwareBitmap on successful completion.
     */
    getSoftwareBitmapAsync(
        pixelFormat: undefined.BitmapPixelFormat,
        alphaMode: undefined.BitmapAlphaMode,
        transform: undefined.BitmapTransform,
        exifOrientationMode: undefined.ExifOrientationMode,
        colorManagementMode: undefined.ColorManagementMode): undefined.IPromiseWithIAsyncOperation<undefined.SoftwareBitmap>;

    /**
     * Asynchronously gets a SoftwareBitmap representation of the bitmap frame.
     * @param pixelFormat The pixel format of the software bitmap.
     * @param alphaMode The alpha mode of the software bitmap.
     * @return  An asynchronous operation that returns a SoftwareBitmap on successful completion.
     */
    getSoftwareBitmapAsync(
        pixelFormat: undefined.BitmapPixelFormat,
        alphaMode: undefined.BitmapAlphaMode): undefined.IPromiseWithIAsyncOperation<undefined.SoftwareBitmap>;

    /**
     * Asynchronously returns a stream containing the thumbnail image.
     * @return  Object that manages the asynchronous retrieval of the thumbnail data.
     */
    getThumbnailAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ImageStream>;

    /**
     * The height of the frame in pixels, after any EXIF orientation has been applied to the bitmap. 
     */
    orientedPixelHeight: number;

    /**
     * The width of the frame in pixels, after any EXIF orientation has been applied to the bitmap. 
     */
    orientedPixelWidth: number;

    /**
     * The height of the frame in pixels. 
     */
    pixelHeight: number;

    /**
     * The width of the frame in pixels. 
     */
    pixelWidth: number
}


/**
 * Provides read and write access to image properties and metadata. 
 */
declare class BitmapProperties {

    /**
     * Asynchronously retrieves one or more bitmap properties.
     * @param propertiesToRetrieve A collection of strings containing the specified property keys.
     * @return  Object that manages the asynchronous retrieval of the bitmap properties.
     */
    getPropertiesAsync(
        propertiesToRetrieve: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.BitmapPropertySet>;

    /**
     * Asynchronously sets one or more bitmap properties.
     * @param propertiesToSet A collection of key-value pairs representing the bitmap properties to be set. Each key is a string containing the Windows property or metadata query, and the corresponding value is a BitmapTypedValue with the data and the correct PropertyType .
     * @return  Object that manages the setting of the bitmap properties asynchronously.
     */
    setPropertiesAsync(
        propertiesToSet: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncAction
}


/**
 * Provides read access to image properties and metadata. A particular instance of BitmapPropertiesView may represent the entire contents of the frame metadata, or any nested metadata block within the frame. 
 */
declare class BitmapPropertiesView {

    /**
     * Asynchronously retrieves one or more bitmap properties.
     * @param propertiesToRetrieve A collection of strings representing the property keys or queries that are being requested. Valid strings include Windows properties and Windows Imaging Component metadata queries.
     * @return  Object that manages the asynchronous retrieval of the bitmap properties.
     */
    getPropertiesAsync(
        propertiesToRetrieve: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.BitmapPropertySet >
}


/**
 * Represents a property set of BitmapTypedValue objects. 
 */
declare class BitmapPropertySet {

    /**
     * Creates and initializes a new instance of the bitmap property set. 
     */
    constructor(): this;

    /**
     * Removes all items from the property set. 
     */
    clear(): void;

    /**
     * Returns an iterator to enumerate the items in the property set.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Gets an immutable view of the property set.
     * @return  The immutable view.
     */
    getView(): undefined.IMapView<string, undefined.BitmapTypedValue>;

    /**
     * Indicates whether the property set has an item with the specified key.
     * @param key The key.
     * @return  True if the property set has an item with the specified key; otherwise, false.
     */
    hasKey(key: string): boolean;

    /**
     * Adds an item to the property set.
     * @param key The key to insert.
     * @param value The value to insert.
     * @return  True if the method replaces a value that already exists for the key; false if this is a new key.
     */
    insert(key: string, value: undefined.BitmapTypedValue): boolean;

    /**
     * Retrieves the value for the specified key.
     * @param key The key.
     * @return  The value, if an item with the specified key exists; otherwise, null.
     */
    lookup(key: string): undefined.BitmapTypedValue;

    /**
     * Removes an item from the property set.
     * @param key The key.
     */
    remove(key: string): void;

    /**
     * Removes a specific item from the BitmapPropertySet .
     * @param key The key of the item to remove.
     * @return  true if the item was removed, otherwise false.
     */
    remove(key: string): boolean;

    /**
     * Gets the number of items contained in the property set. 
     */
    size: number
}


/**
 * Contains transformations that can be applied to pixel data. 
 */
declare class BitmapTransform {

    /**
     * Creates a new BitmapTransform object. 
     */
    constructor(): this;

    /**
     * Specifies the bounding rectangle that is used to crop the bitmap. This rectangle is defined in the coordinate space after scale, rotation, and flip are applied. 
     */
    bounds: undefined.BitmapBounds;

    /**
     * Specifies the flip operation that is used to transform the bitmap. 
     */
    flip: undefined.BitmapFlip;

    /**
     * Specifies the interpolation mode that is used to scale the bitmap. 
     */
    interpolationMode: undefined.BitmapInterpolationMode;

    /**
     * Specifies the rotation operation that is used to transform the bitmap. 
     */
    rotation: undefined.BitmapRotation;

    /**
     * Specifies the height, in pixels, of the bitmap after it is scaled. This is defined in the coordinate space of the source image, before rotation and flip are applied. 
     */
    scaledHeight: number;

    /**
     * Specifies the width, in pixels, of the bitmap after it is scaled. This is defined in the coordinate space of the source image, before rotation and flip are applied. 
     */
    scaledWidth: number
}


/**
 * A value along with an enumeration specifying its data type. 
 */
declare class BitmapTypedValue {

    /**
     * Creates a new BitmapTypedValue object.
     * @param value The value to store.
     * @param type The type of the value parameter.
     */
    constructor(value: any, type: undefined.PropertyType): this;

    /**
     * Gets the PropertyType of the stored value. 
     */
    type: undefined.PropertyType;

    /**
     * Gets the stored value. 
     */
    value: any
}


/**
 * An implementation of IRandomAccessStreamWithContent type used in the Imaging namespace. 
 */
declare class ImageStream {

    /**
     * Indicates if you can read the stream. 
     */
    canRead: boolean;

    /**
     * Indicates if you can write to the stream. 
     */
    canWrite: boolean;

    /**
     * Returns the file stream for the ImageStream .
     * @return  The file stream for the image.
     */
    cloneStream(): undefined.IRandomAccessStream;

    /**
     * Closes the ImageStream . 
     */
    close(): void;

    /**
     * Returns the data format of the stream. 
     */
    contentType: string;

    /**
     * Asynchronously commits the current frame data and flushes all of the data on the image stream.
     * @return  An object that manages the asynchronous flush operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Returns an input stream at a specified location in a stream.
     * @param position The location in the stream at which to begin.
     * @return  The input stream.
     */
    getInputStreamAt(position: number): undefined.IInputStream;

    /**
     * Returns an output stream at a specified location in a stream.
     * @param position The location in the output stream at which to begin.
     * @return  The output stream.
     */
    getOutputStreamAt(position: number): undefined.IOutputStream;

    /**
     * Gets the byte offset of the stream. 
     */
    position: number;

    /**
     * Reads data asynchronously from a sequential stream.
     * @param buffer The buffer into which the asynchronous read operation stores the data.
     * @param count The size of the buffer.
     * @param options The options for the stream to be read.
     * @return  The byte reader operation.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Sets the position of the stream to the specified value.
     * @param position The new position of the stream.
     */
    seek(position: number): void;

    /**
     * Gets or sets the size of the random access stream. 
     */
    size: number;

    /**
     * Writes data asynchronously in a sequential stream.
     * @param buffer The buffer into which the asynchronous writer operation writes.
     * @return  The byte writer operation.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides access to the pixel data from a bitmap frame. 
 */
declare class PixelDataProvider {

    /**
     * Returns the internally-stored pixel data.
     * @return  The pixel data.
     */
    detachPixelData(): number[]
}


/**
 * Represents an uncompressed bitmap. 
 */
declare class SoftwareBitmap {

    /**
     * Converts an existing SoftwareBitmap to a SoftwareBitmap with a different pixel format or alpha mode.
     * @param source The software bitmap to convert.
     * @param format The pixel format of the new software bitmap.
     * @param alpha The alpha mode of the new software bitmap.
     * @return  The converted software bitmap.
     */
    convert(
        source: undefined.SoftwareBitmap,
        format: undefined.BitmapPixelFormat,
        alpha: undefined.BitmapAlphaMode): undefined.SoftwareBitmap;

    /**
     * Converts an existing SoftwareBitmap to a SoftwareBitmap with a different pixel format.
     * @param source The software bitmap to convert.
     * @param format The pixel format of the new software bitmap.
     * @return  The converted software bitmap.
     */
    convert(
        source: undefined.SoftwareBitmap,
        format: undefined.BitmapPixelFormat): undefined.SoftwareBitmap;

    /**
     * Creates a copy of the provided SoftwareBitmap object.
     * @param source The software bitmap to copy.
     * @return  The newly created copy of the software bitmap.
     */
    copy(source: undefined.SoftwareBitmap): undefined.SoftwareBitmap;

    /**
     * Creates a new SoftwareBitmap by performing a deep copy of the provided buffer. Modifications to the data in the new SoftwareBitmap will not effect the buffer from which it was created.
     * @param source The source buffer from which the copy will be created.
     * @param format The pixel format of the software bitmap.
     * @param width The width of the software bitmap, in pixels.
     * @param height The height of the software bitmap, in pixels.
     * @return  The new software bitmap.
     */
    createCopyFromBuffer(
        source: undefined.IBuffer,
        format: undefined.BitmapPixelFormat,
        width: number,
        height: number): undefined.SoftwareBitmap;

    /**
     * Creates a new SoftwareBitmap by performing a deep copy of the provided buffer. Modifications to the data in the new SoftwareBitmap will not effect the buffer from which it was created.
     * @param source The source buffer from which the copy will be created.
     * @param format The pixel format of the software bitmap.
     * @param width The width of the software bitmap, in pixels.
     * @param height The height of the software bitmap, in pixels.
     * @param alpha The alpha mode of the software bitmap.
     * @return  The new software bitmap.
     */
    createCopyFromBuffer(
        source: undefined.IBuffer,
        format: undefined.BitmapPixelFormat,
        width: number,
        height: number,
        alpha: undefined.BitmapAlphaMode): undefined.SoftwareBitmap;

    /**
     * Asynchronously creates a new SoftwareBitmap by performing a deep copy of the provided IDirect3DSurface . Modifications to the data in the new SoftwareBitmap will not effect the surface from which it was created.
     * @param surface The source surface from which the copy will be created.
     * @return  An asynchronous operation that returns a SoftwareBitmap on successful completion.
     */
    createCopyFromSurfaceAsync(
        surface: undefined.IDirect3DSurface): undefined.IPromiseWithIAsyncOperation<undefined.SoftwareBitmap>;

    /**
     * Asynchronously creates a new SoftwareBitmap by performing a deep copy of the provided IDirect3DSurface . Modifications to the data in the new SoftwareBitmap will not effect the surface from which it was created.
     * @param surface The source surface from which the copy will be created.
     * @param alpha The alpha mode of the software bitmap.
     * @return  An asynchronous operation that returns a SoftwareBitmap on successful completion.
     */
    createCopyFromSurfaceAsync(
        surface: undefined.IDirect3DSurface,
        alpha: undefined.BitmapAlphaMode): undefined.IPromiseWithIAsyncOperation<undefined.SoftwareBitmap>;

    /**
     * Initializes a new instance of the SoftwareBitmap class.
     * @param format The pixel format of the new software bitmap.
     * @param width The width of the new software bitmap, in pixels.
     * @param height The height of the new software bitmap, in pixels.
     * @param alpha The alpha mode of the new software bitmap.
     */
    constructor(format: undefined.BitmapPixelFormat, width: number, height: number, alpha: undefined.BitmapAlphaMode): this;

    /**
     * Initializes a new instance of the SoftwareBitmap class.
     * @param format The pixel format of the new software bitmap.
     * @param width The width of the new software bitmap, in pixels.
     * @param height The height of the new software bitmap, in pixels.
     */
    constructor(format: undefined.BitmapPixelFormat, width: number, height: number): this;

    /**
     * Gets the alpha mode of the software bitmap. 
     */
    bitmapAlphaMode: undefined.BitmapAlphaMode;

    /**
     * Gets the pixel format of the software bitmap. 
     */
    bitmapPixelFormat: undefined.BitmapPixelFormat;

    /**
     * Disposes of the object and associated resources. 
     */
    close(): void;

    /**
     * Copies the pixel data from an IBuffer into the SoftwareBitmap .
     * @param buffer The buffer containing the pixel data to be copied.
     */
    copyFromBuffer(buffer: undefined.IBuffer): void;

    /**
     * Copies the current SoftwareBitmap into the provided SoftwareBitmap object.
     * @param bitmap The target software bitmap into which the data will be copied.
     */
    copyTo(bitmap: undefined.SoftwareBitmap): void;

    /**
     * Copies the software bitmap pixel data into the specified IBuffer .
     * @param buffer The target buffer to which the pixel data will be copied.
     */
    copyToBuffer(buffer: undefined.IBuffer): void;

    /**
     * Gets or sets the dots per inch of the software bitmap in the X direction. 
     */
    dpiX: number;

    /**
     * Gets or sets the dots per inch of the software bitmap in the Y direction. 
     */
    dpiY: number;

    /**
     * Gets a read-only representation of the SoftwareBitmap object.
     * @return  A read-only representation of the SoftwareBitmap object.
     */
    getReadOnlyView(): undefined.SoftwareBitmap;

    /**
     * Gets a value indicating whether the software bitmap can be modified. 
     */
    isReadOnly: boolean;

    /**
     * Gets a BitmapBuffer object that allows you to operate directly on the software bitmap's pixel data.
     * @param mode A value indicating the access mode of the returned buffer.
     * @return  The buffer containing pixel data.
     */
    lockBuffer(mode: undefined.BitmapBufferAccessMode): undefined.BitmapBuffer;

    /**
     * Gets the height of the software bitmap, in pixels. 
     */
    pixelHeight: number;

    /**
     * Gets the width of the software bitmap, in pixels. 
     */
    pixelWidth: number
}


/**
 * Defines the format of a bitmap plane. 
 */
declare interface Imaging$BitmapPlaneDescription {

    /**
     * The height of the plane, in pixels. 
     */
    height: number,

        /**
         * The start index of the pixel data within the plane. 
         */
        startIndex: number,

        /**
         * The stride of the bitmap data. 
         */
        stride: number,

        /**
         * The width of the plane, in pixels. 
         */
        width: number
}


/**
 * Specifies a bounding rectangle. 
 */
declare interface Imaging$BitmapBounds {

    /**
     * The Height, in pixels, of the bounding box 
     */
    height: number,

        /**
         * The Width, in pixels, of the bounding box. 
         */
        width: number,

        /**
         * The X coordinate, in pixels, of the top left corner of the bounding box. 
         */
        x: number,

        /**
         * The Y coordinate, in pixels, of the top left corner of the bounding box. 
         */
        y: number
}


/**
 * Represents the size of a bitmap, in pixels. 
 */
declare interface Imaging$BitmapSize {

    /**
     * The height of a bitmap, in pixels. 
     */
    height: number,

        /**
         * The width of a bitmap, in pixels. 
         */
        width: number
}

declare
var D: void;


/**
 * Represents the list of print binding options. 
 */
declare class PrintBindingOptionDetails {

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets the list of items for the print binding options. 
     */
    items: undefined.IVectorView<any>;

    /**
     * Gets the ID of the print binding option. 
     */
    optionId: string;

    /**
     * Gets the option type of the print binding option. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state of the print binding option. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the print binding option.
     * @param value Value for the print binding option.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the enumerated value of the print binding option. 
     */
    value: any
}


/**
 * Represents the list of print collation options. 
 */
declare class PrintCollationOptionDetails {

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets the list of items for the print collation option. 
     */
    items: undefined.IVectorView<any>;

    /**
     * Gets the ID of the print collation option. 
     */
    optionId: string;

    /**
     * Gets the option type for the print collation option. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state of the print collation option. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the print collation option.
     * @param value Value for the print collation option.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the enumerated value of the print collation option. 
     */
    value: any
}


/**
 * Represents the list of print color mode options. 
 */
declare class PrintColorModeOptionDetails {

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets the list of items for the print color mode option. 
     */
    items: undefined.IVectorView<any>;

    /**
     * Gets the ID for the print color mode option. 
     */
    optionId: string;

    /**
     * Gets the option type for the print color mode option. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state of the print color mode option. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the print color mode option.
     * @param value Value for the print color mode option.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the enumerated value of the print color mode option. 
     */
    value: any
}


/**
 * Represents the option for the number of printed copies. 
 */
declare class PrintCopiesOptionDetails {

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets the value for the maximum number of printed copies allowed. 
     */
    maxValue: number;

    /**
     * Gets the value for the minimum number of printed copies allowed. 
     */
    minValue: number;

    /**
     * Gets the ID for the option for the number of printed copies. 
     */
    optionId: string;

    /**
     * Gets the option type for the option for the number of printed copies. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state of the option for the number of printed copies. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the print copies option.
     * @param value Value for the print copies option.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the number of copies for a print task. 
     */
    value: any
}


/**
 * Allows apps to add a collection of enumerable options to the app print experience. 
 */
declare class PrintCustomItemDetails {

    /**
     * Gets or sets the display name of the custom print task option item. 
     */
    itemDisplayName: string;

    /**
     * Gets the ID of the custom print task option item. 
     */
    itemId: string
}


/**
 * Represents a list of the custom print task option items. 
 */
declare class PrintCustomItemListOptionDetails {

    /**
     * Sets the ID or display name of an item in the list of custom print task options.
     * @param itemId The ID of the option item.
     * @param displayName The display name of the option item.
     */
    addItem(itemId: string, displayName: string): void;

    /**
     * Gets or sets the display name of an item in the list of custom print task options. 
     */
    displayName: string;

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets an item from the list of custom print tasks. 
     */
    items: undefined.IVectorView<any>;

    /**
     * Gets the ID of a custom print task option. 
     */
    optionId: string;

    /**
     * Gets the option type for a custom print task option. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state of the list of custom print task option items. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the item ID or the display name of the custom item.
     * @param value Value for the item ID or the display name of the custom item.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the value of the list of custom print tasks. 
     */
    value: any
}


/**
 * Represents a custom print task option. 
 */
declare class PrintCustomTextOptionDetails {

    /**
     * Gets or sets the display name of the custom print task option. 
     */
    displayName: string;

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets or sets the maximum number of characters for the display name of the custom print task option. 
     */
    maxCharacters: number;

    /**
     * Gets the ID of the custom print task option. 
     */
    optionId: string;

    /**
     * Gets the option type for the custom print task option. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state of a custom print task option. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the custom print task.
     * @param value Value for the custom print task.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the value of a custom print task option. 
     */
    value: any
}


/**
 * Represents the list of print duplex options. 
 */
declare class PrintDuplexOptionDetails {

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets the list of print duplex options. 
     */
    items: undefined.IVectorView<any>;

    /**
     * Gets the ID of the print duplex option. 
     */
    optionId: string;

    /**
     * Gets the option type of the print duplex option. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state of the print duplex options. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the duplex option.
     * @param value Value for the duplex option.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the enumerated vlaue of the print duplex option. 
     */
    value: any
}


/**
 * Represents the list of punch hole options. 
 */
declare class PrintHolePunchOptionDetails {

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets the list of items for the hole punch option. 
     */
    items: undefined.IVectorView<any>;

    /**
     * Gets the ID for the hole punch option. 
     */
    optionId: string;

    /**
     * Gets the option type for the hole punch option. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state of the hole punch option. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the hole punch option.
     * @param value Value for the hole punch option.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the enumerated value of the hole punch option. 
     */
    value: any
}


/**
 * Represents the list of media size options. 
 */
declare class PrintMediaSizeOptionDetails {

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets the list of print media size option items. 
     */
    items: undefined.IVectorView<any>;

    /**
     * Gets the ID for the print media size option. 
     */
    optionId: string;

    /**
     * Gets the option type for the option for the number of printed copies. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state of the option for the number of printed copies. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the media size option.
     * @param value Value for the media size option.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the number of copies for a print task. 
     */
    value: any
}


/**
 * Represents the list of print media type options. 
 */
declare class PrintMediaTypeOptionDetails {

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets the list of items for the print media type options. 
     */
    items: undefined.IVectorView<any>;

    /**
     * Gets the ID for the print media type option. 
     */
    optionId: string;

    /**
     * Gets the option type for the print media type option. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state for the print media type option. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the media type option.
     * @param value Value for the media type option.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the enumerated value of the print media type option. 
     */
    value: any
}


/**
 * Represents the list of print orientation options. 
 */
declare class PrintOrientationOptionDetails {

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets the list of items for the print media type options. 
     */
    items: undefined.IVectorView<any>;

    /**
     * Gets the ID for the print orientation option. 
     */
    optionId: string;

    /**
     * Gets the option type for the print media type option. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state for the print media type option. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the print orientation option.
     * @param value Value for the print orientation option.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the enumerated value of the print media type option. 
     */
    value: any
}


/**
 * Represents the list of print quality options. 
 */
declare class PrintQualityOptionDetails {

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets the list of items for the print quality options. 
     */
    items: undefined.IVectorView<any>;

    /**
     * Gets the ID for the print quality option. 
     */
    optionId: string;

    /**
     * Gets the option type for the print quality option. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state of the print quality option. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the print quality option.
     * @param value Value for the print quality option.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the enumerated value of the print quality option. 
     */
    value: any
}


/**
 * Represents a list of the stapling options. 
 */
declare class PrintStapleOptionDetails {

    /**
     * Gets or sets the string for an error condition. 
     */
    errorText: string;

    /**
     * Gets the list of items for the stapling options. 
     */
    items: undefined.IVectorView<any>;

    /**
     * Gets the ID for the stapling option. 
     */
    optionId: string;

    /**
     * Gets the option type for the stapling option. 
     */
    optionType: undefined.PrintOptionType;

    /**
     * Gets or sets the state of the stapling option. 
     */
    state: undefined.PrintOptionStates;

    /**
     * Sets the value for the staple opiton.
     * @param value Value for the staple opiton.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean;

    /**
     * Gets or sets the enumerated value of the stapling option. 
     */
    value: any
}


/**
 * Called when a print task option has changed. 
 */
declare class PrintTaskOptionChangedEventArgs {

    /**
     * Gets the ID of the print task option that changed. 
     */
    optionId: any
}


/**
 * A collection of events, methods and properties for advanced print tasks. 
 */
declare class PrintTaskOptionDetails {

    /**
     * Used to retrieve the available options for a print task.
     * @param printTaskOptions Pointer to a PrintTaskOptions object.
     * @return  Pointer to a PrintTaskOptionDetails object.
     */
    getFromPrintTaskOptions(printTaskOptions: undefined.PrintTaskOptions): undefined.PrintTaskOptionDetails;

    /**
     * Creates a custom list of items that allow the user to choose the page format.
     * @param optionId The ID for the custom item.
     * @param displayName The display name for the custom item.
     * @return  The list of custom items.
     */
    createItemListOption(
        optionId: string,
        displayName: string): undefined.PrintCustomItemListOptionDetails;

    /**
     * Creates a CustomPrintTaskOptionText object to handle the display name and other parameters of the advanced print task option item.
     * @param optionId The ID of the print task option.
     * @param displayName The display name of the print task option.
     * @return  The CustomPrintTaskOptionText object.
     */
    createTextOption(optionId: string, displayName: string): undefined.PrintCustomTextOptionDetails;

    /**
     * Gets the list of print task options that are currently displayed. 
     */
    displayedOptions: undefined.IVector<string>;

    /**
     * Returns a PrintPageDescription object for the referenced page number.
     * @param jobPageNumber The page number.
     * @return  The PrintPageDescription object.
     */
    getPageDescription(jobPageNumber: number): undefined.PrintPageDescription;

    /**
     * Raised when the print system begins a validation pass on the current state of the print ticket. 
     */
    onbeginvalidation: undefined.TypedEventHandler<undefined.PrintTaskOptionDetails, any>;
    addEventListener(
        type: "beginvalidation",
        listener: undefined.TypedEventHandler<undefined.PrintTaskOptionDetails, any>): void;
    removeEventListener(
        type: "beginvalidation",
        listener: undefined.TypedEventHandler<undefined.PrintTaskOptionDetails, any>): void;

    /**
     * Raised when any one of the advanced print task options is changed. 
     */
    onoptionchanged: undefined.TypedEventHandler<undefined.PrintTaskOptionDetails, undefined.PrintTaskOptionChangedEventArgs>;
    addEventListener(
        type: "optionchanged",
        listener: undefined.TypedEventHandler<undefined.PrintTaskOptionDetails, undefined.PrintTaskOptionChangedEventArgs>): void;
    removeEventListener(
        type: "optionchanged",
        listener: undefined.TypedEventHandler<undefined.PrintTaskOptionDetails, undefined.PrintTaskOptionChangedEventArgs>): void;

    /**
     * Gets the list of options for the advanced print task. 
     */
    options: undefined.IMapView<string, undefined.IPrintOptionDetails>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the base class for the PrintTaskOptionXxx objects. 
 */
declare interface OptionDetails$IPrintOptionDetails {

    /**
     * Sets the value for the print task option.
     * @param value Value for the print task option.
     * @return  Boolean value that indicates TRUE for a successful Get or Set, and FALSE for a failed Get or Set.
     */
    trySetValue(value: any): boolean,

        /**
         * Gets or sets the string for an error condition. 
         */
        errorText: string,

        /**
         * Gets the ID for a print task option. 
         */
        optionId: string,

        /**
         * Gets the option type for a print task option. 
         */
        optionType: undefined.PrintOptionType,

        /**
         * Gets or sets the state of a print task option. 
         */
        state: undefined.PrintOptionStates,

        /**
         * Gets the enumerated value of a print task option. 
         */
        value: any
}


/**
 * Informs Windows that an application wishes to participate in printing. The PrintManager class is also used for programmatically initiating printing. 
 */
declare class PrintManager {

    /**
     * Retrieves the PrintManager object associated with the current window.
     * @return  The PrintManager object.
     */
    getForCurrentView(): undefined.PrintManager;

    /**
     * Programmatically initiates the user interface for printing content.
     * @return  A Boolean value to indicate a TRUE for success or a FALSE for a failure.
     */
    showPrintUIAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Raised when a request to print has occurred. This event may be triggered by user action or via programmatic invocation of printing via the ShowPrintUIAsync method. 
     */
    onprinttaskrequested: undefined.TypedEventHandler<undefined.PrintManager, undefined.PrintTaskRequestedEventArgs>;
    addEventListener(
        type: "printtaskrequested",
        listener: undefined.TypedEventHandler<undefined.PrintManager, undefined.PrintTaskRequestedEventArgs>): void;
    removeEventListener(
        type: "printtaskrequested",
        listener: undefined.TypedEventHandler<undefined.PrintManager, undefined.PrintTaskRequestedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a printing operation including the content to be printed, as well as providing access to information describing how the content is to be printed. 
 */
declare class PrintTask {

    /**
     * Gets or sets a value that indicates whether the PrintTask supports 3D manufacturing devices, like a 3D printer. 
     */
    is3DManufacturingTargetEnabled: boolean;

    /**
     * Gets or sets a value indicating whether the PrintTask supports printer targets. 
     */
    isPrinterTargetEnabled: boolean;

    /**
     * Raised when the print task is completed. 
     */
    oncompleted: undefined.TypedEventHandler<undefined.PrintTask, undefined.PrintTaskCompletedEventArgs>;
    addEventListener(
        type: "completed",
        listener: undefined.TypedEventHandler<undefined.PrintTask, undefined.PrintTaskCompletedEventArgs>): void;
    removeEventListener(
        type: "completed",
        listener: undefined.TypedEventHandler<undefined.PrintTask, undefined.PrintTaskCompletedEventArgs>): void;

    /**
     * Raised when the print system initializes print preview mode. 
     */
    onpreviewing: undefined.TypedEventHandler<undefined.PrintTask, any>;
    addEventListener(
        type: "previewing",
        listener: undefined.TypedEventHandler<undefined.PrintTask, any>): void;
    removeEventListener(
        type: "previewing",
        listener: undefined.TypedEventHandler<undefined.PrintTask, any>): void;

    /**
     * Raised to provide progress information about how much of the printed content has been submitted to the print subsystem for printing. 
     */
    onprogressing: undefined.TypedEventHandler<undefined.PrintTask, undefined.PrintTaskProgressingEventArgs>;
    addEventListener(
        type: "progressing",
        listener: undefined.TypedEventHandler<undefined.PrintTask, undefined.PrintTaskProgressingEventArgs>): void;
    removeEventListener(
        type: "progressing",
        listener: undefined.TypedEventHandler<undefined.PrintTask, undefined.PrintTaskProgressingEventArgs>): void;

    /**
     * Raised when a print task begins submitting content to the print subsystem to be printed. 
     */
    onsubmitting: undefined.TypedEventHandler<undefined.PrintTask, any>;
    addEventListener(
        type: "submitting",
        listener: undefined.TypedEventHandler<undefined.PrintTask, any>): void;
    removeEventListener(
        type: "submitting",
        listener: undefined.TypedEventHandler<undefined.PrintTask, any>): void;

    /**
     * Retrieves the PrintTaskOptions for the print task that defines how the content is to be formatted for printing. 
     */
    options: undefined.PrintTaskOptions;

    /**
     * Retrieves a set of properties associated with the PrintTask . 
     */
    properties: undefined.DataPackagePropertySet;

    /**
     * Returns a pointer to the app-provided object that represents the content to be printed. This object must support the IPrintDocumentSource interface. 
     */
    source: undefined.IPrintDocumentSource;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Reports the completion of the print task. 
 */
declare class PrintTaskCompletedEventArgs {

    /**
     * Gets the completion status of the print task. 
     */
    completion: undefined.PrintTaskCompletion
}


/**
 * Represents a collection of methods and properties for managing the options which define how the content is to be printed. 
 */
declare class PrintTaskOptions {

    /**
     * Gets or sets the binding option for the print task. 
     */
    binding: undefined.PrintBinding;

    /**
     * Gets or sets the collation option of the print tasks. 
     */
    collation: undefined.PrintCollation;

    /**
     * Gets or sets the color mode option of the print task. 
     */
    colorMode: undefined.PrintColorMode;

    /**
     * Gets the list of options displayed for the print experience. 
     */
    displayedOptions: undefined.IVector<string>;

    /**
     * Gets or sets the duplex option of the print task. 
     */
    duplex: undefined.PrintDuplex;

    /**
     * Retrieves the physical dimensions of the printed page.
     * @param jobPageNumber The page number.
     * @return  The page description data.
     */
    getPageDescription(jobPageNumber: number): undefined.PrintPageDescription;

    /**
     * Gets or sets the hole punch option of the print task. 
     */
    holePunch: undefined.PrintHolePunch;

    /**
     * Gets the maximum number of copies supported for the print task. 
     */
    maxCopies: number;

    /**
     * Gets or sets the media size option of the print task. 
     */
    mediaSize: undefined.PrintMediaSize;

    /**
     * Gets or sets the media type option for the print task. 
     */
    mediaType: undefined.PrintMediaType;

    /**
     * Gets the minimum number of copies allowed for the print task. 
     */
    minCopies: number;

    /**
     * Gets or sets the value for the number of copies for the print task. 
     */
    numberOfCopies: number;

    /**
     * Gets or sets the orientation option for the print task. 
     */
    orientation: undefined.PrintOrientation;

    /**
     * Gets or sets the print quality option for the print task. 
     */
    printQuality: undefined.PrintQuality;

    /**
     * Gets or sets the staple option for the print task. 
     */
    staple: undefined.PrintStaple
}


/**
 * Contains the event arguments for the PrintTask.Progressing event. This event is raised during the submitting phase of the PrintTask . 
 */
declare class PrintTaskProgressingEventArgs {

    /**
     * Gets the page count for a print task. 
     */
    documentPageCount: number
}


/**
 * Contains the request from the system to create a print task. This object is available from the PrintTaskRequestedEventArgs object passed to the PrintTaskRequested event. 
 */
declare class PrintTaskRequest {

    /**
     * Creates a new PrintTask which indicates that the app has content to be printed.
     * @param title Title for the print task.
     * @param handler Pointer to a PrintTaskSourceRequestedHandler delegate for the print task.
     * @return  Pointer to the print task that was created.
     */
    createPrintTask(
        title: string,
        handler: undefined.PrintTaskSourceRequestedHandler): undefined.PrintTask;

    /**
     * Gets a DateTime value that indicates how long an app has to respond to the PrintTaskRequested event. If the system has not received a response from the PrintTaskRequested event handler by the time the deadline is reached, then the print task is ignored. 
     */
    deadline: Date;

    /**
     * Retrieves the deferral object associated with the PrintTaskRequest . The deferral object is used to handle asynchronous calls in the PrintTaskRequested event handler.
     * @return  The PrintTaskRequestedDeferral for a print task.
     */
    getDeferral(): undefined.PrintTaskRequestedDeferral
}


/**
 * Used to defer the request for a print task. 
 */
declare class PrintTaskRequestedDeferral {

    /**
     * Indicates when the deferral for the print task request is over. 
     */
    complete(): void
}


/**
 * Event arguments associated with the PrintTaskRequest . 
 */
declare class PrintTaskRequestedEventArgs {

    /**
     * Gets the PrintTaskRequest object for a print task. 
     */
    request: undefined.PrintTaskRequest
}


/**
 * Arguments associated with the PrintTaskSourceRequestedHandler delegate. Provides a method for handing the content to be printed to the Print Task. 
 */
declare class PrintTaskSourceRequestedArgs {

    /**
     * Gets the DateTime object that indicates the deadline for a print task source request. 
     */
    deadline: Date;

    /**
     * Gets a PrintTaskSourceRequestedDeferral object that provides access to a Complete method. This method indicates then the deferral is over.
     * @return  Provides access to a Complete method.
     */
    getDeferral(): undefined.PrintTaskSourceRequestedDeferral;

    /**
     * Informs the print task of the content to be printed.
     * @param source A pointer to the IPrintDocumentSource interface.
     */
    setSource(source: undefined.IPrintDocumentSource): void
}


/**
 * Used to defer the request for a print task source. 
 */
declare class PrintTaskSourceRequestedDeferral {

    /**
     * Indicates when the deferral for a print task source request is over. 
     */
    complete(): void
}


/**
 * Provides access to the canonical names for the options represented by the PrintTaskOptions class. You can use the StandardPrintTaskOptions class to identify print options displayed in the user experience or to retrieve specific options using the PrintTaskOptionDetails class. 
 */
declare class StandardPrintTaskOptions {

    /**
     * Gets the canonical name for the binding option of the print task. 
     */
    binding: string;

    /**
     * Gets the canonical name for collation option of the print task. 
     */
    collation: string;

    /**
     * Gets the canonical name for color mode option of the print task. 
     */
    colorMode: string;

    /**
     * Gets the canonical name for the copies option of the print task. 
     */
    copies: string;

    /**
     * Gets the canonical name for the duplex option of the print task. 
     */
    duplex: string;

    /**
     * Gets the canonical name for the hole punch option of the print task. 
     */
    holePunch: string;

    /**
     * Gets the canonical name for the input bin option of the print task. 
     */
    inputBin: string;

    /**
     * Gets the canonical name for the media size option of the print task. 
     */
    mediaSize: string;

    /**
     * Gets the canonical name for the media type option of the print task. 
     */
    mediaType: string;

    /**
     * Gets the canonical name for the NUp option of the print task. 
     */
    nup: string;

    /**
     * Gets the canonical name for the orientation option of the print task. 
     */
    orientation: string;

    /**
     * Gets the canonical name for the print quality option of the print task. 
     */
    printQuality: string;

    /**
     * Gets the canonical name for the staple option of the print task. 
     */
    staple: string
}


/**
 * Represents the data that describes a document page. 
 */
declare interface Printing$PrintPageDescription {

    /**
     * The resolution in dots per inch (DPI) for the X dimension of the page. 
     */
    dpiX: number,

        /**
         * The resolution in dots per inch (DPI) for the Y dimension of the page. 
         */
        dpiY: number,

        /**
         * The Rect within the page size on which content may actually be printed. Content outside of the ImageableRect, whether less or greater than the page size, will be cropped by the print target. The ImageableRect is specified in device independent pixels (DIPs). 
         */
        imageableRect: undefined.Rect,

        /**
         * The page size in device independent pixels (DIPs). 
         */
        pageSize: undefined.Size
}


/**
 * Initialized when a print task is initialized for the print system. 
 */
declare interface Printing$IPrintDocumentSource {}


/**
 * Occurs when a print task requests the document to print. The supplied print document must implement the IPrintDocumentSource interface. 
 */
declare type Printing$PrintTaskSourceRequestedHandler = (args: undefined.PrintTaskSourceRequestedArgs) => void;


/**
 * Creates the 3D printing experience. 
 */
declare class Print3DManager {

    /**
     * Gets a 3D print manager.
     * @return  The 3D print manager.
     */
    getForCurrentView(): undefined.Print3DManager;

    /**
     * Programmatically initiates the 3D printing user interface.
     * @return  true if the operation completes successfully; otherwise, false.
     */
    showPrintUIAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Occurs when a new 3D print job has been created. 
     */
    ontaskrequested: undefined.TypedEventHandler<undefined.Print3DManager, undefined.Print3DTaskRequestedEventArgs>;
    addEventListener(
        type: "taskrequested",
        listener: undefined.TypedEventHandler<undefined.Print3DManager, undefined.Print3DTaskRequestedEventArgs>): void;
    removeEventListener(
        type: "taskrequested",
        listener: undefined.TypedEventHandler<undefined.Print3DManager, undefined.Print3DTaskRequestedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a 3D print job. 
 */
declare class Print3DTask {

    /**
     * Occurs when the print request has been sent to the 3D printer and the 3D print job has been created. 
     */
    oncompleted: undefined.TypedEventHandler<undefined.Print3DTask, undefined.Print3DTaskCompletedEventArgs>;
    addEventListener(
        type: "completed",
        listener: undefined.TypedEventHandler<undefined.Print3DTask, undefined.Print3DTaskCompletedEventArgs>): void;
    removeEventListener(
        type: "completed",
        listener: undefined.TypedEventHandler<undefined.Print3DTask, undefined.Print3DTaskCompletedEventArgs>): void;

    /**
     * Occurs when the workflow modifies the 3D print package. 
     */
    onsourcechanged: undefined.TypedEventHandler<undefined.Print3DTask, undefined.Print3DTaskSourceChangedEventArgs>;
    addEventListener(
        type: "sourcechanged",
        listener: undefined.TypedEventHandler<undefined.Print3DTask, undefined.Print3DTaskSourceChangedEventArgs>): void;
    removeEventListener(
        type: "sourcechanged",
        listener: undefined.TypedEventHandler<undefined.Print3DTask, undefined.Print3DTaskSourceChangedEventArgs>): void;

    /**
     * Occurs when the 3D print package has been submitted to the 3D printer. 
     */
    onsubmitting: undefined.TypedEventHandler<undefined.Print3DTask, any>;
    addEventListener(
        type: "submitting",
        listener: undefined.TypedEventHandler<undefined.Print3DTask, any>): void;
    removeEventListener(
        type: "submitting",
        listener: undefined.TypedEventHandler<undefined.Print3DTask, any>): void;

    /**
     * Gets the 3D print package to be printed. 
     */
    source: undefined.Printing3D3MFPackage;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the Completed event of the 3D print request. 
 */
declare class Print3DTaskCompletedEventArgs {

    /**
     * Gets the status of the 3D print request. 
     */
    completion: undefined.Print3DTaskCompletion;

    /**
     * Gets the type of error encountered during the 3D print request. 
     */
    extendedStatus: undefined.Print3DTaskDetail
}


/**
 * Represents a 3D print job request. 
 */
declare class Print3DTaskRequest {

    /**
     * Creates a 3D print job.
     * @param title The name of the print job.
     * @param printerId The identifier of the 3D printer.
     * @param handler The callback for the source of the print job request.
     * @return  The 3D print job.
     */
    createTask(
        title: string,
        printerId: string,
        handler: undefined.Print3DTaskSourceRequestedHandler): undefined.Print3DTask
}


/**
 * Provides data for the TaskRequested event. 
 */
declare class Print3DTaskRequestedEventArgs {

    /**
     * Gets the 3D print job request associated with the Print3DManager . 
     */
    request: undefined.Print3DTaskRequest
}


/**
 * Provides data for the SourceChanged event. 
 */
declare class Print3DTaskSourceChangedEventArgs {

    /**
     * Gets the updated 3D print package from the workflow. 
     */
    source: undefined.Printing3D3MFPackage
}


/**
 * Provides data for the Print3DTaskSourceRequestedHandler delegate. 
 */
declare class Print3DTaskSourceRequestedArgs {

    /**
     * Specifies the 3D Manufacturing Format (3MF) package to use in the print job.
     * @param source The 3D Manufacturing Format (3MF) package to use in the print job.
     */
    setSource(source: undefined.Printing3D3MFPackage): void
}


/**
 * Represents a 3D Manufacturing Format (3MF) package. 
 */
declare class Printing3D3MFPackage {

    /**
     * Creates a Printing3D3MFPackage object from a 3D Manufacturing Format (3MF) file stream.
     * @param value A 3MF file stream.
     * @return  A Printing3D3MFPackage created from the specified 3MF package stream.
     */
    loadAsync(
        value: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncOperation<undefined.Printing3D3MFPackage>;

    /**
     * Creates a Printing3D3MFPackage object. 
     */
    constructor(): this;

    /**
     * Creates a Printing3DModel object from a 3D Manufacturing Format (3MF) file stream.
     * @param value A 3MF file stream.
     * @return  A Printing3DModel object created from the specified 3MF object stream.
     */
    loadModelFromPackageAsync(
        value: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncOperation<undefined.Printing3DModel>;

    /**
     * Gets or sets an XML stream to the 3D model in the 3D Manufacturing Format (3MF) package. 
     */
    modelPart: undefined.IRandomAccessStream;

    /**
     * Gets or sets a stream to the print ticket in the 3D Manufacturing Format (3MF) package. 
     */
    printTicket: undefined.IRandomAccessStream;

    /**
     * Saves the Printing3D3MFPackage object to a 3D Manufacturing Format (3MF) file stream.
     * @return  A stream to the 3MF file where the package is to be saved.
     */
    saveAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStream>;

    /**
     * Saves the specified 3D model to the 3D Manufacturing Format (3MF) package.
     * @param value The 3D model to be saved to the 3MF package.
     * @return  The results of the operation.
     */
    saveModelToPackageAsync(value: undefined.Printing3DModel): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets the textures in the 3D Manufacturing Format (3MF) package. 
     */
    textures: undefined.IVector<undefined.Printing3DTextureResource>;

    /**
     * Gets or sets a thumbnail image that represents the contents of the 3D Manufacturing Format (3MF) package. 
     */
    thumbnail: undefined.Printing3DTextureResource
}


/**
 * Represents the base material used for manufacturing certain objects in the 3D model. 
 */
declare class Printing3DBaseMaterial {

    /**
     * Gets the name the acrylonitrile butadiene styrene (ABS) thermoplastic used in the base material. 
     */
    abs: string;

    /**
     * Gets the name the polylactic acid (PLA) thermoplastic used in the base material. 
     */
    pla: string;

    /**
     * Creates an instance of the Printing3DBaseMaterial class. 
     */
    constructor(): this;

    /**
     * Gets or sets the color of the base material. 
     */
    color: undefined.Printing3DColorMaterial;

    /**
     * Gets or sets the name of the base material. 
     */
    name: string
}


/**
 * Represents a group of base materials used in the 3D model. 
 */
declare class Printing3DBaseMaterialGroup {

    /**
     * Creates an instance of the Printing3DBaseMaterialGroup class.
     * @param MaterialGroupId The identifier for the group of base materials used in the 3D model; a value greater than zero.
     */
    constructor(MaterialGroupId: number): this;

    /**
     * Gets a group of base materials used in the 3D model. 
     */
    bases: undefined.IVector<undefined.Printing3DBaseMaterial>;

    /**
     * Gets the identifier (ID) of the base material group. 
     */
    materialGroupId: number
}


/**
 * Represents a color material used in the 3D model. 
 */
declare class Printing3DColorMaterial {

    /**
     * Creates an instance of the Printing3DColorMaterial class. 
     */
    constructor(): this;

    /**
     * Gets or sets the color of the material. 
     */
    color: undefined.Color;

    /**
     * Gets or sets the color value of the material. 
     */
    value: number
}


/**
 * Represents a group of color materials used in the 3D model. 
 */
declare class Printing3DColorMaterialGroup {

    /**
     * Creates an instance of the Printing3DColorMaterialGroup class.
     * @param MaterialGroupId The identifier for the group of color materials used in the 3D model; a value greater than zero.
     */
    constructor(MaterialGroupId: number): this;

    /**
     * Gets a group of color materials used in the 3D model. 
     */
    colors: undefined.IVector<undefined.Printing3DColorMaterial>;

    /**
     * Gets the identifier (ID) for the color material group. 
     */
    materialGroupId: number
}


/**
 * Represents a 3D Manufacturing Format (3MF) component. Acts as a container of other components. 
 */
declare class Printing3DComponent {

    /**
     * Creates an instance of the Printing3DComponent class. 
     */
    constructor(): this;

    /**
     * Gets the other components contained within the component. 
     */
    components: undefined.IVector<undefined.Printing3DComponentWithMatrix>;

    /**
     * Gets or sets the 3D mesh of the component. 
     */
    mesh: undefined.Printing3DMesh;

    /**
     * Gets or sets the name of the 3D Manufacturing Format (3MF) component. 
     */
    name: string;

    /**
     * Gets or sets the part number of the 3D Manufacturing Format (3MF) component. 
     */
    partNumber: string;

    /**
     * Gets or sets the thumbnail image of the 3D Manufacturing Format (3MF) component. 
     */
    thumbnail: undefined.Printing3DTextureResource;

    /**
     * Gets or sets the type of the 3D Manufacturing Format (3MF) component. 
     */
    type: undefined.Printing3DObjectType
}


/**
 * Represents a 3D Manufacturing Format (3MF) component that's applied to the object definition with a matrix transform. 
 */
declare class Printing3DComponentWithMatrix {

    /**
     * Creates an instance of the Printing3DComponentWithMatrix class. 
     */
    constructor(): this;

    /**
     * Gets or sets the 3D Manufacturing Format (3MF) primitive component that's applied to the object definition with a matrix transform. 
     */
    component: undefined.Printing3DComponent;

    /**
     * Gets or sets the matrix transform that's applied to the 3D Manufacturing Format (3MF) primitive component. 
     */
    matrix: undefined.Matrix4x4
}


/**
 * Represents a composite material that's defined by a mixture of base materials. 
 */
declare class Printing3DCompositeMaterial {

    /**
     * Creates an instance of the Printing3DCompositeMaterial class. 
     */
    constructor(): this;

    /**
     * Gets the mixture of base materials used in the composite material. Each mixture is defined by listing the proportion of the overall mixture for each base material (values between 0 and 1). 
     */
    values: undefined.IVector<number >
}


/**
 * Represents a group of composite materials. 
 */
declare class Printing3DCompositeMaterialGroup {

    /**
     * Creates an instance of the Printing3DCompositeMaterialGroup class.
     * @param MaterialGroupId The identifier (ID) of the composite material group; a value greater than zero.
     */
    constructor(MaterialGroupId: number): this;

    /**
     * Gets an list of mixtures that define individual composite materials. Each mixture is defined by listing the proportion of the overall mixture for each base material (values between 0 and 1), where the proportion values are specified in the same order as the base materials in MaterialIndices . 
     */
    composites: undefined.IVector<undefined.Printing3DCompositeMaterial>;

    /**
     * Gets the identifier (ID) of the base material group that defines the materials used in the composite material group. 
     */
    materialGroupId: number;

    /**
     * Gets an ordered list of base materials that are used to make the composite materials in the group. The order of base materials is maintained in the mixture values defined by Composites . 
     */
    materialIndices: undefined.IVector<number >
}


/**
 * Represents all material resources in the 3D model. 
 */
declare class Printing3DMaterial {

    /**
     * Creates an instance of the Printing3DMaterial class. 
     */
    constructor(): this;

    /**
     * Gets all base material groups used in the 3D model. 
     */
    baseGroups: undefined.IVector<undefined.Printing3DBaseMaterialGroup>;

    /**
     * Gets all color material groups used in the 3D model. 
     */
    colorGroups: undefined.IVector<undefined.Printing3DColorMaterialGroup>;

    /**
     * Gets all composite material groups used in the 3D model. 
     */
    compositeGroups: undefined.IVector<undefined.Printing3DCompositeMaterialGroup>;

    /**
     * Gets all multi-property groups used in the 3D model. 
     */
    multiplePropertyGroups: undefined.IVector<undefined.Printing3DMultiplePropertyMaterialGroup>;

    /**
     * Gets all 2D texture material groups used in the 3D model. 
     */
    texture2CoordGroups: undefined.IVector<undefined.Printing3DTexture2CoordMaterialGroup >
}


/**
 * Represents a mesh in the 3D model. 
 */
declare class Printing3DMesh {

    /**
     * Creates an instance of the Printing3DMesh class. 
     */
    constructor(): this;

    /**
     * Gets a set of mesh buffer descriptions. 
     */
    bufferDescriptionSet: undefined.IPropertySet;

    /**
     * Gets a set of mesh buffers. 
     */
    bufferSet: undefined.IPropertySet;

    /**
     * Creates the buffer for triangle indices.
     * @param value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
     */
    createTriangleIndices(value: number): void;

    /**
     * Creates the buffer for triangle material indices.
     * @param value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
     */
    createTriangleMaterialIndices(value: number): void;

    /**
     * Creates the buffer for vertex normals.
     * @param value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
     */
    createVertexNormals(value: number): void;

    /**
     * Creates the buffer for vertex positions.
     * @param value The capacity of the buffer, the maximum number of bytes that the IBuffer can hold.
     */
    createVertexPositions(value: number): void;

    /**
     * Gets the buffer for triangle indices.
     * @return  The buffer for triangle indices.
     */
    getTriangleIndices(): undefined.IBuffer;

    /**
     * Gets the buffer for triangle material indices.
     * @return  The buffer for triangle material indices.
     */
    getTriangleMaterialIndices(): undefined.IBuffer;

    /**
     * Gets the buffer for vertex normals.
     * @return  The buffer for vertex normals.
     */
    getVertexNormals(): undefined.IBuffer;

    /**
     * Gets the buffer for vertex positions.
     * @return  The buffer for vertex positions.
     */
    getVertexPositions(): undefined.IBuffer;

    /**
     * Gets or sets the number of triangle indices. 
     */
    indexCount: number;

    /**
     * Gets or sets the buffer description for triangle indices. 
     */
    triangleIndicesDescription: undefined.Printing3DBufferDescription;

    /**
     * Gets or sets the buffer description for triangle material indices. 
     */
    triangleMaterialIndicesDescription: undefined.Printing3DBufferDescription;

    /**
     * Verifies the mesh has manifold edges and normal triangles.
     * @param value Specifies how the mesh is verified.
     * @return  The results of the verification, of type Printing3DMeshVerificationResult .
     */
    verifyAsync(
        value: undefined.Printing3DMeshVerificationMode): undefined.IPromiseWithIAsyncOperation<undefined.Printing3DMeshVerificationResult>;

    /**
     * Gets or sets the number of triangle vertices. 
     */
    vertexCount: number;

    /**
     * Gets or sets the buffer description for vertex normals. 
     */
    vertexNormalsDescription: undefined.Printing3DBufferDescription;

    /**
     * Gets or sets the buffer description for vertex positions. 
     */
    vertexPositionsDescription: undefined.Printing3DBufferDescription
}


/**
 * Provides data for the VerifyAsync method. 
 */
declare class Printing3DMeshVerificationResult {

    /**
     * Gets a value that indicates if the mesh is valid. 
     */
    isValid: boolean;

    /**
     * Gets the triangles with non-manifold edges, if applicable. 
     */
    nonmanifoldTriangles: undefined.IVectorView<number>;

    /**
     * Gets the reverse normal triangles, if applicable. 
     */
    reversedNormalTriangles: undefined.IVectorView<number >
}


/**
 * Represents the 3D model in a 3D Manufacturing Format (3MF) package. 
 */
declare class Printing3DModel {

    /**
     * Creates an instance of the Printing3DModel class. 
     */
    constructor(): this;

    /**
     * Gets or sets the root 3D Manufacturing Format (3MF) component. It represents the build plate on a 3D printer and defines what will be printed. 
     */
    build: undefined.Printing3DComponent;

    /**
     * Gets a copy of the current 3D model.
     * @return  A copy of the current 3D model.
     */
    clone(): undefined.Printing3DModel;

    /**
     * Gets all 3D Manufacturing Format (3MF) components used in the 3D model. 
     */
    components: undefined.IVector<undefined.Printing3DComponent>;

    /**
     * Gets or sets the root material container for the 3D model. 
     */
    material: undefined.Printing3DMaterial;

    /**
     * Gets all meshes used in the 3D model. 
     */
    meshes: undefined.IVector<undefined.Printing3DMesh>;

    /**
     * Gets the metadata for the 3D Manufacturing Format (3MF) package. 
     */
    metadata: undefined.IMap<string, string>;

    /**
     * Repairs the 3D model.
     * @return  Results of the operation.
     */
    repairAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets a list of the extensions required by the 3D Manufacturing Format (3MF) package. 
     */
    requiredExtensions: undefined.IVector<string>;

    /**
     * Gets all textures used in the 3D model. 
     */
    textures: undefined.IVector<undefined.Printing3DModelTexture>;

    /**
     * Gets or sets the units of measure used in the 3D model. 
     */
    unit: undefined.Printing3DModelUnit;

    /**
     * Gets or sets the version of the 3D Manufacturing Format (3MF) package. 
     */
    version: string
}


/**
 * Represents a texture used in the 3D model. 
 */
declare class Printing3DModelTexture {

    /**
     * Creates an instance of the Printing3DModelTexture class. 
     */
    constructor(): this;

    /**
     * Gets or sets the texture resource used by the texture. 
     */
    textureResource: undefined.Printing3DTextureResource;

    /**
     * Get or sets a value that indicates how tiling should occur in the U axis in order to fill the overall requested area. 
     */
    tileStyleU: undefined.Printing3DTextureEdgeBehavior;

    /**
     * Gets or sets a value that indicates how tiling should occur in the V axis in order to fill the overall requested area. 
     */
    tileStyleV: undefined.Printing3DTextureEdgeBehavior
}


/**
 * Represents a combination of properties and/or materials from the material groups specified in ( MaterialGroupIndices ). 
 */
declare class Printing3DMultiplePropertyMaterial {

    /**
     * Creates an instance of the Printing3DMultiplePropertyMaterial class. 
     */
    constructor(): this;

    /**
     * Gets the indices of the properties and/or materials combined in the multi-property material. Each combination is defined by listing the index of an item from one material group with the index of an item from a secondary material group. The index values are specified in the same order as the material groups listed in MaterialGroupIndices . 
     */
    materialIndices: undefined.IVector<number >
}


/**
 * Represents a multi-property material group. 
 */
declare class Printing3DMultiplePropertyMaterialGroup {

    /**
     * Creates a new instance of the Printing3DMultiplePropertyMaterialGroup class.
     * @param MaterialGroupId The identifier (ID) of the multi-property material group; a value greater than zero.
     */
    constructor(MaterialGroupId: number): this;

    /**
     * Gets the identifier (ID) of the multi-property material group. 
     */
    materialGroupId: number;

    /**
     * Gets an ordered list of material groups ( MaterialGroupId values) that are used to define property-material combinations in the multi-property group. The order of material groups is maintained in the combinations defined by MultipleProperties . 
     */
    materialGroupIndices: undefined.IVector<number>;

    /**
     * Gets a list of property-material combinations. Each combination is defined by listing the index of an item from one material group with the index of an item from a secondary material group. The index values are specified in the same order as the material groups listed in MaterialGroupIndices . 
     */
    multipleProperties: undefined.IVector<undefined.Printing3DMultiplePropertyMaterial >
}


/**
 * Represents a 2D texture material used in the 3D model. 
 */
declare class Printing3DTexture2CoordMaterial {

    /**
     * Creates an instance of the Printing3DTexture2CoordMaterial class. 
     */
    constructor(): this;

    /**
     * Gets or sets the texture used in the 2D texture material. 
     */
    texture: undefined.Printing3DModelTexture;

    /**
     * Gets or sets the U-coordinate within the texture, horizontally right from the origin in the upper left of the texture. 
     */
    u: number;

    /**
     * Gets or sets the V-coordinate within the texture, vertically down from the origin in the upper left of the texture. 
     */
    v: number
}


/**
 * Represents a group of 2D texture materials used in the 3D model. 
 */
declare class Printing3DTexture2CoordMaterialGroup {

    /**
     * Creates a instance of the Printing3DTexture2CoordMaterialGroup class.
     * @param MaterialGroupId The identifier for a group of 2D texture materials used in the 3D model; a value greater than zero.
     */
    constructor(MaterialGroupId: number): this;

    /**
     * Gets the identifier (ID) of the 2D texture material group. 
     */
    materialGroupId: number;

    /**
     * Gets or sets the texture of the material group. 
     */
    texture: undefined.Printing3DModelTexture;

    /**
     * Gets a group of 2D texture materials used in the 3D model. 
     */
    texture2Coords: undefined.IVector<undefined.Printing3DTexture2CoordMaterial >
}


/**
 * Specifies the texture resource used in a 2D texture material. 
 */
declare class Printing3DTextureResource {

    /**
     * Creates an instance of the Printing3DTextureResource class. 
     */
    constructor(): this;

    /**
     * Gets or sets the name of the texture resource. 
     */
    name: string;

    /**
     * Gets or sets the image stream of the texture resource. 
     */
    textureData: undefined.IRandomAccessStreamWithContentType
}


/**
 * Represents the method that handles requests for 3D print packages. 
 */
declare type Printing3D$Print3DTaskSourceRequestedHandler = (args: undefined.Print3DTaskSourceRequestedArgs) => void;


/**
 * Specifies how to parse data in the buffer. 
 */
declare interface Printing3D$Printing3DBufferDescription {

    /**
     * Specifies the format used by the buffer. 
     */
    format: undefined.Printing3DBufferFormat,

        /**
         * Specifies how far to move the pointer forward to find the next unit of data. 
         */
        stride: number
}


/**
 * Enables you to access and manage the app data store for a package family. 
 */
declare class ApplicationDataManager {

    /**
     * Provides access to the app data store for the specified package family.
     * @param packageFamilyName The package family name.
     * @return  The app data store.
     */
    createForPackageFamily(packageFamilyName: string): undefined.ApplicationData
}


/**
 * Provides the result of a deployment request. 
 */
declare class DeploymentResult {

    /**
     * Gets the activity identifier used to look up an event in Windows Event Viewer. Gets the activity identifier used to look up an event. All events of a deployment operation are logged with the same activityId. 
     */
    activityId: string;

    /**
     * Gets extended error text for the error if the deployment operation is not successful. 
     */
    errorText: string;

    /**
     * The extended error code can be used to distinguish a specific error condition which needs to be handled differently from the general error indicated by the return code. The extended error code may provide a more specific reason for the failure that caused the general error. Also, it usually corresponds directly to the specific message in the ErrorText . 
     */
    extendedErrorCode: Windows$WinRTError
}


/**
 * Provides information about the users of an installed package. 
 */
declare class PackageUserInformation {

    /**
     * Gets the install state of the package for the user. 
     */
    installState: undefined.PackageInstallState;

    /**
     * Gets the security identifier (SID) of the package user. 
     */
    userSecurityId: string
}


/**
 * Represents a package storage volume. 
 */
declare class PackageVolume {

    /**
     * Initializes a new instance of the PackageVolume class. 
     */
    constructor(): this;

    /**
     * Gets a collection of info about all installed instances of the specified package for all registered users.
     * @param packageFullName The full name of the package.
     * @return  A collection of info about all installed instances of the specified package for all registered users.
     */
    findPackage(packageFullName: string): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about the installed instances of the specified package for the specified user or users.
     * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
     * @param packageFullName The full name of the package.
     * @return  A collection of info about all installed instances of the specified package for the specified user or users.
     */
    findPackageForUser(
        userSecurityId: string,
        packageFullName: string): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of all packages for all registered users.
     * @return  A collection of info about the specified packages.
     */
    findPackages(): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of the specified package from the specified publisher for all registered users.
     * @param packageName The full name of the package.
     * @param packagePublisher The publisher of the package.
     * @return  A collection of info about the specified packages.
     */
    findPackages(
        packageName: string,
        packagePublisher: string): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of the specified package for all registered users.
     * @param packageFamilyName The package family name of the package.
     * @return  A collection of info about the specified packages.
     */
    findPackages(packageFamilyName: string): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of the specified package for the specified user or users.
     * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
     * @param packageFamilyName The package family name.
     * @return  A collection of info about the specified packages.
     */
    findPackagesForUser(
        userSecurityId: string,
        packageFamilyName: string): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of the specified package from the specified publisher for the specified user or users.
     * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
     * @param packageName The full name of the package.
     * @param packagePublisher The publisher of the package.
     * @return  A collection of info about the specified packages.
     */
    findPackagesForUser(
        userSecurityId: string,
        packageName: string,
        packagePublisher: string): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of all packages for the specified user or users.
     * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
     * @return  A collection of info about the specified packages.
     */
    findPackagesForUser(userSecurityId: string): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of all packages for the specified user or users and with the specified package types.
     * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
     * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
     * @return  A collection of info about the specified packages.
     */
    findPackagesForUserWithPackageTypes(
        userSecurityId: string,
        packageTypes: undefined.PackageTypes): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of the specified package for the specified user or users and with the specified package types.
     * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
     * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
     * @param packageName The full name of the package.
     * @param packagePublisher The publisher of the package.
     * @return  A collection of info about the specified packages.
     */
    findPackagesForUserWithPackageTypes(
        userSecurityId: string,
        packageTypes: undefined.PackageTypes,
        packageName: string,
        packagePublisher: string): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of the specified package for the specified user or users and with the specified package types.
     * @param userSecurityId The security identifier (SID) of the user or users. An empty string denotes the current user. The Everyone SID (S-1-1-0) denotes all users. Any SID other than that of the current user requires administrative privileges.
     * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
     * @param packageFamilyName The package family name.
     * @return  A collection of info about the specified packages.
     */
    findPackagesForUserWithPackageTypes(
        userSecurityId: string,
        packageTypes: undefined.PackageTypes,
        packageFamilyName: string): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of the specified package with the specified package types for all registered users.
     * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
     * @param packageFamilyName The package family name.
     * @return  A collection of info about the specified packages.
     */
    findPackagesWithPackageTypes(
        packageTypes: undefined.PackageTypes,
        packageFamilyName: string): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of all packages with the specified package types for all registered users.
     * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
     * @return  A collection of info about the specified packages.
     */
    findPackagesWithPackageTypes(packageTypes: undefined.PackageTypes): undefined.IVector<undefined.Package>;

    /**
     * Gets a collection of info about all installed instances of the specified package from the specified publisher with the specified package types for all registered users.
     * @param packageTypes A bitwise combination of the enumeration values that specifies the types of packages to return.
     * @param packageName The full name of the package.
     * @param packagePublisher The publisher of the package.
     * @return  A collection of info about the specified packages.
     */
    findPackagesWithPackageTypes(
        packageTypes: undefined.PackageTypes,
        packageName: string,
        packagePublisher: string): undefined.IVector<undefined.Package>;

    /**
     * Describes whether a volume is in an offline state. 
     */
    isOffline: boolean;

    /**
     * Describes whether a volume is an internal system volume mapped to the %SYSTEMDRIVER% environment variable. 
     */
    isSystemVolume: boolean;

    /**
     * Gets the path of the last known volume mount point. 
     */
    mountPoint: string;

    /**
     * Gets the media ID of the volume. 
     */
    name: string;

    /**
     * Gets the absolute path for the package store on the volume. 
     */
    packageStorePath: string;

    /**
     * Gets a value that specifies whether the volume supports the creation of hard links in its file system. 
     */
    supportsHardLinks: boolean
}

declare class ClassicAppManager {
    findInstalledApp: any
}

declare class InstalledClassicAppInfo {
    displayName: any;
    displayVersion: any
}

declare class CurrentAppOrchestration {
    getForCurrentView: any;
    startSingleAppMode: any
}

declare class SingleAppModeContext {
    close: any
}


/**
 * MDM (Mobile Device Management) policy. 
 */
declare class MdmPolicy {

    /**
     * Returns true if a browser is allowed.
     * @return  true if a browser is allowed.
     */
    isBrowserAllowed(): boolean;

    /**
     * Returns true if a camera is allowed.
     * @return  true if a camera is allowed.
     */
    isCameraAllowed(): boolean;

    /**
     * Returns true if a Microsoft Account is allowed.
     * @return  true if a Microsoft Account is allowed.
     */
    isMicrosoftAccountAllowed(): boolean;

    /**
     * Returns true if a Store is allowed.
     * @return  true if a Store is allowed.
     */
    isStoreAllowed(): boolean
}


/**
 * Enables Windows Store apps to access select enterprise settings that are managed through group policy or other management services. 
 */
declare class WorkplaceSettings {

    /**
     * Gets a value that indicates whether an enterprise ID can be used instead of a Microsoft account. 
     */
    isMicrosoftAccountOptional: boolean
}


/**
 * Represents an audio device input node. 
 */
declare class AudioDeviceInputNode {

    /**
     * Adds an outgoing connection with gain to the audio device input node.
     * @param destination The destination node for the connection.
     * @param gain A value indicating the gain associated with the connection.
     */
    addOutgoingConnection(destination: undefined.IAudioNode, gain: number): void;

    /**
     * Adds an outgoing connection to the audio device input node.
     * @param destination The destination node for the connection.
     */
    addOutgoingConnection(destination: undefined.IAudioNode): void;

    /**
     * Closes the audio device input node. 
     */
    close(): void;

    /**
     * Gets or sets a value indicating if the audio device input node consumes input. 
     */
    consumeInput: boolean;

    /**
     * Gets information about the audio device. 
     */
    device: undefined.DeviceInformation;

    /**
     * Disables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to disable.
     */
    disableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the list of effect definitions for the audio device input node. 
     */
    effectDefinitions: undefined.IVector<undefined.IAudioEffectDefinition>;

    /**
     * Enables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to enable.
     */
    enableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the encoding properties for the audio device input node. 
     */
    encodingProperties: undefined.AudioEncodingProperties;

    /**
     * Gets the list of outgoing connections from the audio device input node to other nodes in the audio graph. 
     */
    outgoingConnections: undefined.IVectorView<undefined.AudioGraphConnection>;

    /**
     * Gets or sets the outgoing gain for the audio device input node. 
     */
    outgoingGain: number;

    /**
     * Removes the outgoing connection for the audio device input node.
     * @param destination The destination for the outgoing connection.
     */
    removeOutgoingConnection(destination: undefined.IAudioNode): void;

    /**
     * Resets the audio device input node. 
     */
    reset(): void;

    /**
     * Starts the audio device input node. 
     */
    start(): void;

    /**
     * Stops the audio device input node. 
     */
    stop(): void
}


/**
 * Represents an audio device output node. 
 */
declare class AudioDeviceOutputNode {

    /**
     * Closes the audio device output node. 
     */
    close(): void;

    /**
     * Gets or sets a value indicating if the audio device output node consumes input. 
     */
    consumeInput: boolean;

    /**
     * Gets information about the audio device. 
     */
    device: undefined.DeviceInformation;

    /**
     * Disables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to disable.
     */
    disableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the list of effect definitions for the audio device output node. 
     */
    effectDefinitions: undefined.IVector<undefined.IAudioEffectDefinition>;

    /**
     * Enables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to enable.
     */
    enableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the encoding properties for the audio device output node. 
     */
    encodingProperties: undefined.AudioEncodingProperties;

    /**
     * Gets or sets the outgoing gain for the audio device output node. 
     */
    outgoingGain: number;

    /**
     * Resets the audio device output node. 
     */
    reset(): void;

    /**
     * Starts the audio device output node. 
     */
    start(): void;

    /**
     * Stops the audio device output node. 
     */
    stop(): void
}


/**
 * Represents an audio file input node. 
 */
declare class AudioFileInputNode {

    /**
     * Adds an outgoing connection with gain to the audio file input node.
     * @param destination The destination node for the connection.
     * @param gain A value indicating the gain associated with the connection.
     */
    addOutgoingConnection(destination: undefined.IAudioNode, gain: number): void;

    /**
     * Adds an outgoing connection to the audio file input node.
     * @param destination The destination node for the connection.
     */
    addOutgoingConnection(destination: undefined.IAudioNode): void;

    /**
     * Closes the audio file input node. 
     */
    close(): void;

    /**
     * Gets or sets a value indicating if the audio file input node consumes input. 
     */
    consumeInput: boolean;

    /**
     * Disables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to disable.
     */
    disableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the duration for the audio input file. 
     */
    duration: number;

    /**
     * Gets the list of effect definitions for the audio file input node. 
     */
    effectDefinitions: undefined.IVector<undefined.IAudioEffectDefinition>;

    /**
     * Enables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to enable.
     */
    enableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the encoding properties for the audio file input node. 
     */
    encodingProperties: undefined.AudioEncodingProperties;

    /**
     * Gets or sets the end time for the audio file input node. 
     */
    endTime: number;

    /**
     * Gets or sets the loop count of the audio file input node. 
     */
    loopCount: number;

    /**
     * Notifies of completion of the file associated with the audio file input node. 
     */
    onfilecompleted: undefined.TypedEventHandler<undefined.AudioFileInputNode, any>;
    addEventListener(
        type: "filecompleted",
        listener: undefined.TypedEventHandler<undefined.AudioFileInputNode, any>): void;
    removeEventListener(
        type: "filecompleted",
        listener: undefined.TypedEventHandler<undefined.AudioFileInputNode, any>): void;

    /**
     * Gets the list of outgoing connections from the audio file input node to other nodes in the audio graph. 
     */
    outgoingConnections: undefined.IVectorView<undefined.AudioGraphConnection>;

    /**
     * Gets or sets the outgoing gain for the audio file input node. 
     */
    outgoingGain: number;

    /**
     * Gets or sets the playback speed factor for the audio file input node. 
     */
    playbackSpeedFactor: number;

    /**
     * Gets the position of the audio file input node. 
     */
    position: number;

    /**
     * Removes the outgoing connection for the audio file input node.
     * @param destination The destination for the outgoing connection.
     */
    removeOutgoingConnection(destination: undefined.IAudioNode): void;

    /**
     * Resets the audio file input node. 
     */
    reset(): void;

    /**
     * Moves the playback position of the node to the specified time within the audio input file.
     * @param position A value indicating the position to which the node should seek.
     */
    seek(position: number): void;

    /**
     * Gets the source audio file for the audio file input node. 
     */
    sourceFile: undefined.StorageFile;

    /**
     * Starts the audio file input node. 
     */
    start(): void;

    /**
     * Gets or sets the start time for the audio file input node. 
     */
    startTime: number;

    /**
     * Stops the audio file input node. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an audio file output node. 
 */
declare class AudioFileOutputNode {

    /**
     * Closes the audio file output node. 
     */
    close(): void;

    /**
     * Gets or sets a value indicating if the audio file output node consumes input. 
     */
    consumeInput: boolean;

    /**
     * Disables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to disable.
     */
    disableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the list of effect definitions for the audio file output node. 
     */
    effectDefinitions: undefined.IVector<undefined.IAudioEffectDefinition>;

    /**
     * Enables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to enable.
     */
    enableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the encoding properties for the audio file output node. 
     */
    encodingProperties: undefined.AudioEncodingProperties;

    /**
     * Gets the file associated with the audio file output node. 
     */
    file: undefined.IStorageFile;

    /**
     * Gets the file encoding profile supported by the audio file output node. 
     */
    fileEncodingProfile: undefined.MediaEncodingProfile;

    /**
     * Finalizes the asynchronous operation of the audio file output node.
     * @return  When this operation completes, a TranscodeFailureReason value is returned.
     */
    finalizeAsync(): undefined.IPromiseWithIAsyncOperation<undefined.TranscodeFailureReason>;

    /**
     * Gets or sets the outgoing gain for the audio file output node. 
     */
    outgoingGain: number;

    /**
     * Resets the audio file output node. 
     */
    reset(): void;

    /**
     * Starts the audio file output node. 
     */
    start(): void;

    /**
     * Stops the audio file output node. 
     */
    stop(): void
}


/**
 * Represents arguments for an AudioFrameCompleted event. 
 */
declare class AudioFrameCompletedEventArgs {

    /**
     * Gets the audio frame that was just completed by the AudioFrameInputNode . A frame is completed when all of the audio in the frame has been consumed by the audio graph. 
     */
    frame: undefined.AudioFrame
}


/**
 * Represents an audio frame input node. 
 */
declare class AudioFrameInputNode {

    /**
     * Adds an audio frame to the audio frame input node.
     * @param frame An AudioFrame object representing the frame.
     */
    addFrame(frame: undefined.AudioFrame): void;

    /**
     * Adds an outgoing connection with gain to the audio frame input node.
     * @param destination The destination node for the connection.
     * @param gain A value indicating the gain associated with the connection.
     */
    addOutgoingConnection(destination: undefined.IAudioNode, gain: number): void;

    /**
     * Adds an outgoing connection to the audio frame input node.
     * @param destination The destination node for the connection.
     */
    addOutgoingConnection(destination: undefined.IAudioNode): void;

    /**
     * Closes the audio frame input node. 
     */
    close(): void;

    /**
     * Gets or sets a value indicating if the audio frame input node consumes input. 
     */
    consumeInput: boolean;

    /**
     * Disables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to disable.
     */
    disableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Removes queued frames from the audio frame input node. 
     */
    discardQueuedFrames(): void;

    /**
     * Gets the list of effect definitions for the audio frame input node. 
     */
    effectDefinitions: undefined.IVector<undefined.IAudioEffectDefinition>;

    /**
     * Enables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to enable.
     */
    enableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the encoding properties for the audio frame input node. 
     */
    encodingProperties: undefined.AudioEncodingProperties;

    /**
     * Notifies of a completed audio frame that has been submitted to the graph with a call to AddFrame . 
     */
    onaudioframecompleted: undefined.TypedEventHandler<undefined.AudioFrameInputNode, undefined.AudioFrameCompletedEventArgs>;
    addEventListener(
        type: "audioframecompleted",
        listener: undefined.TypedEventHandler<undefined.AudioFrameInputNode, undefined.AudioFrameCompletedEventArgs>): void;
    removeEventListener(
        type: "audioframecompleted",
        listener: undefined.TypedEventHandler<undefined.AudioFrameInputNode, undefined.AudioFrameCompletedEventArgs>): void;

    /**
     * Raised when the audio graph is ready to begin processing a new quantum of data. 
     */
    onquantumstarted: undefined.TypedEventHandler<undefined.AudioFrameInputNode, undefined.FrameInputNodeQuantumStartedEventArgs>;
    addEventListener(
        type: "quantumstarted",
        listener: undefined.TypedEventHandler<undefined.AudioFrameInputNode, undefined.FrameInputNodeQuantumStartedEventArgs>): void;
    removeEventListener(
        type: "quantumstarted",
        listener: undefined.TypedEventHandler<undefined.AudioFrameInputNode, undefined.FrameInputNodeQuantumStartedEventArgs>): void;

    /**
     * Gets the list of outgoing connections from the audio frame input node to other nodes in the audio graph. 
     */
    outgoingConnections: undefined.IVectorView<undefined.AudioGraphConnection>;

    /**
     * Gets or sets the outgoing gain for the audio frame input node. 
     */
    outgoingGain: number;

    /**
     * Gets or sets the playback speed factor for the audio frame input node. 
     */
    playbackSpeedFactor: number;

    /**
     * Gets the queued sample count for the audio frame input node. 
     */
    queuedSampleCount: number;

    /**
     * Removes an outgoing connection from the audio frame input node.
     * @param destination The destination for the outgoing connection.
     */
    removeOutgoingConnection(destination: undefined.IAudioNode): void;

    /**
     * Resets the audio frame input node. 
     */
    reset(): void;

    /**
     * Starts the audio frame input node. 
     */
    start(): void;

    /**
     * Stops the audio frame input node. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an audio frame output node. 
 */
declare class AudioFrameOutputNode {

    /**
     * Closes the audio frame output node. 
     */
    close(): void;

    /**
     * Gets or sets a value indicating if the audio frame output node consumes input. 
     */
    consumeInput: boolean;

    /**
     * Disables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to disable.
     */
    disableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the list of effect definitions for the audio frame output node. 
     */
    effectDefinitions: undefined.IVector<undefined.IAudioEffectDefinition>;

    /**
     * Enables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to enable.
     */
    enableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the encoding properties for the audio frame output node. 
     */
    encodingProperties: undefined.AudioEncodingProperties;

    /**
     * Gets an audio frame containing all of the data accumulated by this node since the previous call to GetFrame. If GetFrame has not yet been called, the audio frame will contain all of the data accumulated since the node was created.
     * @return  An AudioFrame object representing the frame.
     */
    getFrame(): undefined.AudioFrame;

    /**
     * Gets or sets the outgoing gain for the audio frame output node. 
     */
    outgoingGain: number;

    /**
     * Resets the audio frame output node. 
     */
    reset(): void;

    /**
     * Starts the audio frame output node. 
     */
    start(): void;

    /**
     * Stops the audio frame output node. 
     */
    stop(): void
}


/**
 * Represents an audio graph of connected input, output, and submix nodes that manipulate and route audio. 
 */
declare class AudioGraph {

    /**
     * Creates an audio graph with specific settings.
     * @param settings An AudioGraphSettings object representing the source audio file.
     * @return  When this operation completes, a CreateAudioGraphResult object is returned.
     */
    createAsync(
        settings: undefined.AudioGraphSettings): undefined.IPromiseWithIAsyncOperation<undefined.CreateAudioGraphResult>;

    /**
     * Closes the audio graph. 
     */
    close(): void;

    /**
     * Gets the completed quantum count for the audio graph. 
     */
    completedQuantumCount: number;

    /**
     * Creates a device input node for the indicated media and audio encoding properties.
     * @param category An enumeration value indicating the media category.
     * @param encodingProperties An object representing the audio encoding properties for the device input node.
     * @return  An asynchronous operation that returns a CreateAudioDeviceInputNodeResult on completion. This object exposes a Status property, that indicates either that the operation was successful or the reason why the operation failed. The DeviceInputNode property provides a reference to the created input node on success.
     */
    createDeviceInputNodeAsync(
        category: undefined.MediaCategory,
        encodingProperties: undefined.AudioEncodingProperties): undefined.IPromiseWithIAsyncOperation<undefined.CreateAudioDeviceInputNodeResult>;

    /**
     * Creates a device input node for the indicated media.
     * @param category An enumeration value indicating the media category.
     * @return  An asynchronous operation that returns a CreateAudioDeviceInputNodeResult on completion. This object exposes a Status property, that indicates either that the operation was successful or the reason why the operation failed. The DeviceInputNode property provides a reference to the created input node on success.
     */
    createDeviceInputNodeAsync(
        category: undefined.MediaCategory): undefined.IPromiseWithIAsyncOperation<undefined.CreateAudioDeviceInputNodeResult>;

    /**
     * Creates a device input node for the indicated media, audio encoding properties, and device information.
     * @param category An enumeration value indicating the media category.
     * @param encodingProperties An object representing the audio encoding properties for the device input node.
     * @param device An object representing the device associated with the device input node.
     * @return  An asynchronous operation that returns a CreateAudioDeviceInputNodeResult on completion. This object exposes a Status property, that indicates either that the operation was successful or the reason why the operation failed. The DeviceInputNode property provides a reference to the created input node on success.
     */
    createDeviceInputNodeAsync(
        category: undefined.MediaCategory,
        encodingProperties: undefined.AudioEncodingProperties,
        device: undefined.DeviceInformation): undefined.IPromiseWithIAsyncOperation<undefined.CreateAudioDeviceInputNodeResult>;

    /**
     * Creates a new device output node for the audio graph.
     * @return  An asynchronous operation that returns a CreateAudioDeviceOutputNodeResult on completion. This object exposes a Status property, that indicates either that the operation was successful or the reason why the operation failed. The DeviceOutputNode property provides a reference to the created output node on success.
     */
    createDeviceOutputNodeAsync(): undefined.IPromiseWithIAsyncOperation<undefined.CreateAudioDeviceOutputNodeResult>;

    /**
     * Creates a file input node for the audio graph.
     * @param file A IStorageFile object representing the file associated with the file input node.
     * @return  When this operation completes, a CreateAudioFileInputNodeResult object is returned.
     */
    createFileInputNodeAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.CreateAudioFileInputNodeResult>;

    /**
     * Creates a file output node for the indicated file.
     * @param file A StorageFile object representing the file.
     * @return  When this operation completes, a CreateAudioFileOutputNodeResult object is returned.
     */
    createFileOutputNodeAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.CreateAudioFileOutputNodeResult>;

    /**
     * Creates a file output node for the indicated file and media encoding profile.
     * @param file A StorageFile object representing the file.
     * @param fileEncodingProfile An objecting representing the media encoding profile.
     * @return  When this operation completes, a CreateAudioFileOutputNodeResult object is returned.
     */
    createFileOutputNodeAsync(
        file: undefined.IStorageFile,
        fileEncodingProfile: undefined.MediaEncodingProfile): undefined.IPromiseWithIAsyncOperation<undefined.CreateAudioFileOutputNodeResult>;

    /**
     * Creates an audio frame input node from encoding properties.
     * @param encodingProperties An object representing encoding properties.
     * @return  An audio frame input node.
     */
    createFrameInputNode(
        encodingProperties: undefined.AudioEncodingProperties): undefined.AudioFrameInputNode;

    /**
     * Creates a simple audio frame input node for the audio graph.
     * @return  An audio frame input node.
     */
    createFrameInputNode(): undefined.AudioFrameInputNode;

    /**
     * Creates a frame output node from encoding properties.
     * @param encodingProperties An object representing audio encoding properties.
     * @return  An audio frame output node.
     */
    createFrameOutputNode(
        encodingProperties: undefined.AudioEncodingProperties): undefined.AudioFrameOutputNode;

    /**
     * Creates a simple frame output node for the audio graph.
     * @return  An audio frame output node.
     */
    createFrameOutputNode(): undefined.AudioFrameOutputNode;

    /**
     * Creates an audio graph submix node that mixes the output of one or more nodes into single output that can be connected to output nodes or other submix nodes.
     * @return  An audio submix node.
     */
    createSubmixNode(): undefined.AudioSubmixNode;

    /**
     * Creates an audio graph submix node that mixes the output of one or more nodes into single output that can be connected to output nodes or other submix nodes.
     * @param encodingProperties An object representing audio encoding properties.
     * @return  An audio submix node.
     */
    createSubmixNode(
        encodingProperties: undefined.AudioEncodingProperties): undefined.AudioSubmixNode;

    /**
     * Gets the encoding properties for the audio graph. 
     */
    encodingProperties: undefined.AudioEncodingProperties;

    /**
     * Gets the latency in samples that the audio graph supports. 
     */
    latencyInSamples: number;

    /**
     * Notifies that the audio graph has processed the specified quantum. 
     */
    onquantumprocessed: undefined.TypedEventHandler<undefined.AudioGraph, any>;
    addEventListener(
        type: "quantumprocessed",
        listener: undefined.TypedEventHandler<undefined.AudioGraph, any>): void;
    removeEventListener(
        type: "quantumprocessed",
        listener: undefined.TypedEventHandler<undefined.AudioGraph, any>): void;

    /**
     * Notifies that the audio graph has started processing a new quantum. 
     */
    onquantumstarted: undefined.TypedEventHandler<undefined.AudioGraph, any>;
    addEventListener(
        type: "quantumstarted",
        listener: undefined.TypedEventHandler<undefined.AudioGraph, any>): void;
    removeEventListener(
        type: "quantumstarted",
        listener: undefined.TypedEventHandler<undefined.AudioGraph, any>): void;

    /**
     * Notifies of an unrecoverable audio error in audio graph operation. 
     */
    onunrecoverableerroroccurred: undefined.TypedEventHandler<undefined.AudioGraph, undefined.AudioGraphUnrecoverableErrorOccurredEventArgs>;
    addEventListener(
        type: "unrecoverableerroroccurred",
        listener: undefined.TypedEventHandler<undefined.AudioGraph, undefined.AudioGraphUnrecoverableErrorOccurredEventArgs>): void;
    removeEventListener(
        type: "unrecoverableerroroccurred",
        listener: undefined.TypedEventHandler<undefined.AudioGraph, undefined.AudioGraphUnrecoverableErrorOccurredEventArgs>): void;

    /**
     * Gets the primary render device for the audio graph. 
     */
    primaryRenderDevice: undefined.DeviceInformation;

    /**
     * Gets a value that indicates the audio processing mode for the audio graph. 
     */
    renderDeviceAudioProcessing: undefined.AudioProcessing;

    /**
     * Resets all nodes in the audio graph. 
     */
    resetAllNodes(): void;

    /**
     * Gets the number of samples per quantum at which the audio graph is currently operating. 
     */
    samplesPerQuantum: number;

    /**
     * Starts the audio graph. 
     */
    start(): void;

    /**
     * Stops the audio graph. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a connection within an audio graph. 
 */
declare class AudioGraphConnection {

    /**
     * Gets the destination node for the connection. 
     */
    destination: undefined.IAudioNode;

    /**
     * Gets the gain associated with the audio graph connection. 
     */
    gain: number
}


/**
 * Represents initialization settings for an audio graph. Set the properties of this object to your desired values and then call AudioGraph::CreateAsync to create a new audio graph instance with the specified settings. 
 */
declare class AudioGraphSettings {

    /**
     * Initializes a new instance of the AudioGraphSettings class with initial settings values optimized for the specified AudioRenderCategory .
     * @param audioRenderCategory The AudioRenderCategory that determines the initial settings values.
     */
    constructor(audioRenderCategory: undefined.AudioRenderCategory): this;

    /**
     * Gets or sets a value that indicates the audio render category setting for the audio graph. 
     */
    audioRenderCategory: undefined.AudioRenderCategory;

    /**
     * Gets or sets a value that indicates the desired audio processing mode setting for the audio graph. 
     */
    desiredRenderDeviceAudioProcessing: undefined.AudioProcessing;

    /**
     * Gets or sets the desired number of samples per quantum defined for the audio graph. 
     */
    desiredSamplesPerQuantum: number;

    /**
     * Gets or sets the audio encoding properties setting for the audio graph. 
     */
    encodingProperties: undefined.AudioEncodingProperties;

    /**
     * Gets or sets an object that represents the primary render device for the audio graph. 
     */
    primaryRenderDevice: undefined.DeviceInformation;

    /**
     * Gets or sets the quantum size selection mode for the audio graph. 
     */
    quantumSizeSelectionMode: undefined.QuantumSizeSelectionMode
}


/**
 * Represents arguments for an UnrecoverableErrorOccurred event. 
 */
declare class AudioGraphUnrecoverableErrorOccurredEventArgs {

    /**
     * Gets the error associated with the event. 
     */
    error: undefined.AudioGraphUnrecoverableError
}


/**
 * Represents an audio submix node that mixes the output of one or more nodes into single output that can be connected to output nodes or other submix nodes. 
 */
declare class AudioSubmixNode {

    /**
     * Adds an outgoing connection with gain to the audio submix node.
     * @param destination The destination node for the connection.
     * @param gain A value indicating the gain associated with the connection.
     */
    addOutgoingConnection(destination: undefined.IAudioNode, gain: number): void;

    /**
     * Adds an outgoing connection to the audio submix node.
     * @param destination The destination node for the connection.
     */
    addOutgoingConnection(destination: undefined.IAudioNode): void;

    /**
     * Closes the audio submix node. 
     */
    close(): void;

    /**
     * Gets or sets a value indicating if the audio submix node consumes input. 
     */
    consumeInput: boolean;

    /**
     * Disables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to disable.
     */
    disableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the list of effect definitions for the audio submix node. 
     */
    effectDefinitions: undefined.IVector<undefined.IAudioEffectDefinition>;

    /**
     * Enables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to enable.
     */
    enableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void;

    /**
     * Gets the encoding properties for the audio device submix node. 
     */
    encodingProperties: undefined.AudioEncodingProperties;

    /**
     * Gets outgoing connections from the audio submix node to other nodes in the audio graph. 
     */
    outgoingConnections: undefined.IVectorView<undefined.AudioGraphConnection>;

    /**
     * Gets or sets the outgoing gain for the audio submix node. 
     */
    outgoingGain: number;

    /**
     * Removes an outgoing connection from the audio submix node.
     * @param destination The destination for the outgoing connection.
     */
    removeOutgoingConnection(destination: undefined.IAudioNode): void;

    /**
     * Resets the audio submix node. 
     */
    reset(): void;

    /**
     * Starts the audio submix node. 
     */
    start(): void;

    /**
     * Stops the audio submix node. 
     */
    stop(): void
}


/**
 * Represents the result of creating an audio device input node. 
 */
declare class CreateAudioDeviceInputNodeResult {

    /**
     * Gets the audio device input node. 
     */
    deviceInputNode: undefined.AudioDeviceInputNode;

    /**
     * Gets the status of audio device input node creation. 
     */
    status: undefined.AudioDeviceNodeCreationStatus
}


/**
 * Represents the result of creating an audio device output node. 
 */
declare class CreateAudioDeviceOutputNodeResult {

    /**
     * Gets the audio device output node. 
     */
    deviceOutputNode: undefined.AudioDeviceOutputNode;

    /**
     * Gets the status of audio device output node creation. 
     */
    status: undefined.AudioDeviceNodeCreationStatus
}


/**
 * Represents the result of creating an audio file input node. 
 */
declare class CreateAudioFileInputNodeResult {

    /**
     * Gets the audio file input node. 
     */
    fileInputNode: undefined.AudioFileInputNode;

    /**
     * Gets the status of audio file input node creation. 
     */
    status: undefined.AudioFileNodeCreationStatus
}


/**
 * Represents the result of creating an audio file output node. 
 */
declare class CreateAudioFileOutputNodeResult {

    /**
     * Gets the audio file output node. 
     */
    fileOutputNode: undefined.AudioFileOutputNode;

    /**
     * Gets the status of audio file output node creation. 
     */
    status: undefined.AudioFileNodeCreationStatus
}


/**
 * Represents the result of creating an audio graph. 
 */
declare class CreateAudioGraphResult {

    /**
     * Gets the audio graph object. 
     */
    graph: undefined.AudioGraph;

    /**
     * Gets the status of audio graph creation. 
     */
    status: undefined.AudioGraphCreationStatus
}


/**
 * Represents an echo effect definition supported by the audio graph. 
 */
declare class EchoEffectDefinition {

    /**
     * Creates an EchoEffectDefinition object.
     * @param audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
     */
    constructor(audioGraph: undefined.AudioGraph): this;

    /**
     * Gets the activatable class ID for the echo effect definition object. 
     */
    activatableClassId: string;

    /**
     * Gets or sets the delay supported by the echo effect definition. 
     */
    delay: number;

    /**
     * Gets or sets the feedback included in the echo effect definition. 
     */
    feedback: number;

    /**
     * Gets or sets the properties supported by the echo effect definition. 
     */
    properties: undefined.IPropertySet;

    /**
     * Gets or sets the wet-dry audio voice mix for the echo effect definition. 
     */
    wetDryMix: number
}


/**
 * Represents an equalizer band for the equalizer effect. 
 */
declare class EqualizerBand {

    /**
     * Gets or sets the bandwidth for the equalizer band. 
     */
    bandwidth: number;

    /**
     * Gets or sets the frequency center for the equalizer band. 
     */
    frequencyCenter: number;

    /**
     * Gets or sets the gain for the equalizer band. 
     */
    gain: number
}


/**
 * Represents an equalizer effect definition supported by the audio graph. 
 */
declare class EqualizerEffectDefinition {

    /**
     * Initializes a new instance of the EqualizerEffectDefinition class.
     * @param audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
     */
    constructor(audioGraph: undefined.AudioGraph): this;

    /**
     * Gets the activatable class ID for the equalizer effect definition object. 
     */
    activatableClassId: string;

    /**
     * Gets the bands included in the equalizer effect definition. 
     */
    bands: undefined.IVectorView<undefined.EqualizerBand>;

    /**
     * Gets the properties supported by the equalizer effect definition. 
     */
    properties: undefined.IPropertySet
}


/**
 * Provides data for the AudioFrameInputNode::QuantumStarted event. This event is raised when the audio graph containing the audio frame input node is ready to begin processing a new quantum of data. 
 */
declare class FrameInputNodeQuantumStartedEventArgs {

    /**
     * Gets the number of samples that the audio graph requires to fill the quantum with data. 
     */
    requiredSamples: number
}


/**
 * Represents a limiter effect definition supported by the audio graph. 
 */
declare class LimiterEffectDefinition {

    /**
     * Initializes a new instance of the LimiterEffectDefinition class.
     * @param audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
     */
    constructor(audioGraph: undefined.AudioGraph): this;

    /**
     * Gets the activatable class ID for the limiter effect definition object. 
     */
    activatableClassId: string;

    /**
     * Gets or sets the loudness included in the limiter effect definition. 
     */
    loudness: number;

    /**
     * Gets the properties supported by the limiter effect definition. 
     */
    properties: undefined.IPropertySet;

    /**
     * Gets or sets the release included in the limiter effect definition. 
     */
    release: number
}


/**
 * Represents a reverberation effect definition supported by the audio graph. 
 */
declare class ReverbEffectDefinition {

    /**
     * Initializes a new instance of the ReverbffectDefinition class.
     * @param audioGraph The AudioGraph with which the effect will be used. Using effects outside of the audio graph it was created with is not supported.
     */
    constructor(audioGraph: undefined.AudioGraph): this;

    /**
     * Gets the activatable class ID for the reverberation effect definition object. 
     */
    activatableClassId: string;

    /**
     * Gets or sets the decay time supported by the reverberation effect definition. 
     */
    decayTime: number;

    /**
     * Gets or sets the density included in the reverberation effect definition. 
     */
    density: number;

    /**
     * Gets or sets a value indicating if the reverberation effect disables late fields. 
     */
    disableLateField: boolean;

    /**
     * Gets or sets the early diffusion value for the reverberation effect definition. 
     */
    earlyDiffusion: number;

    /**
     * Gets or sets the high equalization cutoff included in the reverberation effect definition. 
     */
    highEQCutoff: number;

    /**
     * Gets or sets the high equalization gain included in the reverberation effect definition. 
     */
    highEQGain: number;

    /**
     * Gets or sets the late diffusion included in the reverberation effect definition. 
     */
    lateDiffusion: number;

    /**
     * Gets or sets the low equalization cutoff included in the reverberation effect definition. 
     */
    lowEQCutoff: number;

    /**
     * Gets or sets the low equalization gain included in the reverberation effect definition. 
     */
    lowEQGain: number;

    /**
     * Gets or sets the position left included in the reverberation effect definition. 
     */
    positionLeft: number;

    /**
     * Gets or sets the matrix position left included in the reverberation effect definition. 
     */
    positionMatrixLeft: number;

    /**
     * Gets or sets the matrix position right included in the reverberation effect definition. 
     */
    positionMatrixRight: number;

    /**
     * Gets or sets the position right included in the reverberation effect definition. 
     */
    positionRight: number;

    /**
     * Gets the properties supported by the reverberation effect definition. 
     */
    properties: undefined.IPropertySet;

    /**
     * Gets or sets the rear delay included in the reverberation effect definition. 
     */
    rearDelay: number;

    /**
     * Gets or sets the reflections delay included in the reverberation effect definition. 
     */
    reflectionsDelay: number;

    /**
     * Gets or sets the reflections gain included in the reverberation effect definition. 
     */
    reflectionsGain: number;

    /**
     * Gets or sets the reverberation delay included in the reverberation effect definition. 
     */
    reverbDelay: number;

    /**
     * Gets or sets the reverberation gain included in the reverberation effect definition. 
     */
    reverbGain: number;

    /**
     * Gets or sets the room filter frequency included in the reverberation effect definition. 
     */
    roomFilterFreq: number;

    /**
     * Gets or sets the room filter high frequency included in the reverberation effect definition. 
     */
    roomFilterHF: number;

    /**
     * Gets or sets the main room filter included in the reverberation effect definition. 
     */
    roomFilterMain: number;

    /**
     * Gets or sets the room size included in the reverberation effect definition. 
     */
    roomSize: number;

    /**
     * Gets or sets the wet-dry audio voice mix for the reverberation effect definition. 
     */
    wetDryMix: number
}

declare
var rame: any;

declare
var rocessing: any;

declare
var uffer: any;

declare
var ufferAccessMode: any;


/**
 * Defines an audio node. 
 */
declare type Audio$IAudioNode = {

    /**
     * Disables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to disable.
     */
    disableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void,

    /**
     * Enables all effects in the EffectDefinitions list with the specified effect definition.
     * @param definition The effect definition of the effects to enable.
     */
    enableEffectsByDefinition(definition: undefined.IAudioEffectDefinition): void,

    /**
     * Resets the audio node. 
     */
    reset(): void,

    /**
     * Starts the audio node. 
     */
    start(): void,

    /**
     * Stops the audio node. 
     */
    stop(): void,

    /**
     * Gets or sets a value indicating if the audio node consumes input. 
     */
    consumeInput: boolean,

    /**
     * Gets the list of effect definitions for the audio node. 
     */
    effectDefinitions: undefined.IVector<undefined.IAudioEffectDefinition>,

    /**
     * Gets the encoding properties for the audio node. 
     */
    encodingProperties: undefined.AudioEncodingProperties,

    /**
     * Gets or sets the outgoing gain for the audio node. 
     */
    outgoingGain: number
}


/**
 * Represents a buffer containing audio data. 
 */
declare class AudioBuffer {

    /**
     * Gets the maximum number of bytes that the buffer can hold. 
     */
    capacity: number;

    /**
     * Disposes of the object and associated resources. 
     */
    close(): void;

    /**
     * Returns an IMemoryBufferReference representation of the audio buffer.
     * @return  The IMemoryBufferReference representation of the audio buffer.
     */
    createReference(): undefined.IMemoryBufferReference;

    /**
     * Gets or sets the number of bytes currently in use in the buffer. 
     */
    length: number
}


/**
 * Represents a single frame of audio data. 
 */
declare class AudioFrame {

    /**
     * Initializes a new instance of the AudioFrame class.
     * @param capacity The maximum number of bytes that the buffer can hold.
     */
    constructor(capacity: number): this;

    /**
     * Disposes of the object and associated resources. 
     */
    close(): void;

    /**
     * Gets or sets the duration of the audio frame. 
     */
    duration: number;

    /**
     * Gets the extended property set which enables getting and setting properties on the AudioFrame . 
     */
    extendedProperties: undefined.IPropertySet;

    /**
     * Gets or sets a value that indicates whether an audio frame is the first frame after a gap in the stream. 
     */
    isDiscontinuous: boolean;

    /**
     * Gets a value indicating whether the audio frame is read-only. 
     */
    isReadOnly: boolean;

    /**
     * Gets a AudioBuffer object that allows you to operate directly on the software bitmap's pixel data.
     * @param mode A value indicating the access mode of the returned audio buffer.
     * @return  The buffer containing pixel data.
     */
    lockBuffer(mode: undefined.AudioBufferAccessMode): undefined.AudioBuffer;

    /**
     * Gets or sets the relative time of the frame within the audio stream. 
     */
    relativeTime: number;

    /**
     * Gets or sets a timestamp that is relative to the system and is correlatable across multiple media sources on the same device. 
     */
    systemRelativeTime: number;

    /**
     * Gets a string indicating the type of audio data the audio frame contains. 
     */
    type: string
}


/**
 * Provides data for the AutoRepeatModeChangeRequested event. 
 */
declare class AutoRepeatModeChangeRequestedEventArgs {

    /**
     * Gets a value indicating the requested auto-repeat mode. 
     */
    requestedAutoRepeatMode: undefined.MediaPlaybackAutoRepeatMode
}


/**
 * Represents a photo captured using system-provided computational photography techniques provided by the AdvancedPhotoCapture class. 
 */
declare class AdvancedCapturedPhoto {

    /**
     * Gets the app-defined context object associated with the advanced photo capture operation, if one was provided in the call to AdvancedPhotoCapture::CaptureAsync(Object) . 
     */
    context: any;

    /**
     * Gets the captured frame containing the result of the advanced photo capture. 
     */
    frame: undefined.CapturedFrame;

    /**
     * Gets a value indicating the advanced capture mode with which the photo was captured. 
     */
    mode: undefined.AdvancedPhotoMode
}


/**
 * Provides methods for capturing photos using system-provided computational photography techniques. 
 */
declare class AdvancedPhotoCapture {

    /**
     * Asynchronously performs an advanced photo capture.
     * @return  An asynchronous operation that returns an AdvancedCapturedPhoto upon successful completion.
     */
    captureAsync(): undefined.IPromiseWithIAsyncOperation<undefined.AdvancedCapturedPhoto>;

    /**
     * Asynchronously performs an advanced photo capture passing the provided app-defined context object to the result of the operation.
     * @param context An app-defined context object that passes context information to the result of the operation.
     * @return  An asynchronous operation that returns an AdvancedCapturedPhoto upon successful completion.
     */
    captureAsync(
        context: any): undefined.IPromiseWithIAsyncOperation<undefined.AdvancedCapturedPhoto>;

    /**
     * Asynchronously releases the AdvancedPhotoCapture object and resources used by the advanced photo capture operation.
     * @return  An asynchronous action.
     */
    finishAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Occurs when all of the frames required for the advanced photo capture have been captured. 
     */
    onallphotoscaptured: undefined.TypedEventHandler<undefined.AdvancedPhotoCapture, any>;
    addEventListener(
        type: "allphotoscaptured",
        listener: undefined.TypedEventHandler<undefined.AdvancedPhotoCapture, any>): void;
    removeEventListener(
        type: "allphotoscaptured",
        listener: undefined.TypedEventHandler<undefined.AdvancedPhotoCapture, any>): void;

    /**
     * Raised when a reference photo for the advanced photo operation has been captured, on devices that support this feature. 
     */
    onoptionalreferencephotocaptured: undefined.TypedEventHandler<undefined.AdvancedPhotoCapture, undefined.OptionalReferencePhotoCapturedEventArgs>;
    addEventListener(
        type: "optionalreferencephotocaptured",
        listener: undefined.TypedEventHandler<undefined.AdvancedPhotoCapture, undefined.OptionalReferencePhotoCapturedEventArgs>): void;
    removeEventListener(
        type: "optionalreferencephotocaptured",
        listener: undefined.TypedEventHandler<undefined.AdvancedPhotoCapture, undefined.OptionalReferencePhotoCapturedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}

declare class AppCapture {
    getForCurrentView: any;
    addEventListener: any;
    isCapturingAudio: any;
    isCapturingVideo: any;
    oncapturingchanged: any;
    removeEventListener: any
}


/**
 * Defines alternate shortcut keys for app capture. 
 */
declare class AppCaptureAlternateShortcutKeys {

    /**
     * Gets or sets the save historical video shortcut key. 
     */
    saveHistoricalVideoKey: undefined.VirtualKey;

    /**
     * Gets or sets the save historical video shortcut key modifiers. 
     */
    saveHistoricalVideoKeyModifiers: undefined.VirtualKeyModifiers;

    /**
     * Gets or sets the take screenshot shortcut key. 
     */
    takeScreenshotKey: undefined.VirtualKey;

    /**
     * Gets or sets the take screenshot shortcut key modifiers. 
     */
    takeScreenshotKeyModifiers: undefined.VirtualKeyModifiers;

    /**
     * Gets or sets the toggle game bar shortcut key. 
     */
    toggleGameBarKey: undefined.VirtualKey;

    /**
     * Gets or sets the toggle game bar shortcut key modifiers. 
     */
    toggleGameBarKeyModifiers: undefined.VirtualKeyModifiers;
    toggleMicrophoneCaptureKey: any;
    toggleMicrophoneCaptureKeyModifiers: any;

    /**
     * Gets or sets the toggle recording indicator shortcut key. 
     */
    toggleRecordingIndicatorKey: undefined.VirtualKey;

    /**
     * Gets or sets the toggle recording indicator shortcut key modifiers. 
     */
    toggleRecordingIndicatorKeyModifiers: undefined.VirtualKeyModifiers;

    /**
     * Gets or sets the toggle recording shortcut key. 
     */
    toggleRecordingKey: undefined.VirtualKey;

    /**
     * Gets or sets the toggle recording shortcut key modifiers. 
     */
    toggleRecordingKeyModifiers: undefined.VirtualKeyModifiers
}


/**
 * Provides access to app capture settings. 
 */
declare class AppCaptureManager {

    /**
     * Applies app capture settings.
     * @param appCaptureSettings The settings to apply.
     */
    applySettings(appCaptureSettings: undefined.AppCaptureSettings): void;

    /**
     * Gets the current app capture settings.
     * @return  The current app capture settings.
     */
    getCurrentSettings(): undefined.AppCaptureSettings
}


/**
 * Represents app capture settings. 
 */
declare class AppCaptureSettings {

    /**
     * Gets the alternate shortcut key settings. 
     */
    alternateShortcutKeys: undefined.AppCaptureAlternateShortcutKeys;

    /**
     * Gets or sets the app capture destination folder. 
     */
    appCaptureDestinationFolder: undefined.StorageFolder;

    /**
     * Gets or sets the audio encoding bitrate. 
     */
    audioEncodingBitrate: number;

    /**
     * Gets or sets the custom video encoding bitrate. 
     */
    customVideoEncodingBitrate: number;

    /**
     * Gets or sets the custom video encoding height. 
     */
    customVideoEncodingHeight: number;

    /**
     * Gets the custom video encoding width. 
     */
    customVideoEncodingWidth: number;

    /**
     * Gets a value indicating if the device has a hardware encoder. 
     */
    hasHardwareEncoder: boolean;

    /**
     * Gets or sets the historical buffer length. 
     */
    historicalBufferLength: number;

    /**
     * Gets or sets the units of the historical buffer length. 
     */
    historicalBufferLengthUnit: undefined.AppCaptureHistoricalBufferLengthUnit;

    /**
     * Gets or sets a value indicating if app capture is enabled. 
     */
    isAppCaptureEnabled: boolean;

    /**
     * Gets or sets a value indicating whether audio capture is enabled. 
     */
    isAudioCaptureEnabled: boolean;

    /**
     * Gets a value indicating if app capture is CPU-constrained. 
     */
    isCpuConstrained: boolean;

    /**
     * Gets a value indicating if app capture is disabled by policy. 
     */
    isDisabledByPolicy: boolean;

    /**
     * Gets a value indicating if app capture is GPU-constrained. 
     */
    isGpuConstrained: boolean;

    /**
     * Gets or sets a value indicating if historical capture is enabled. 
     */
    isHistoricalCaptureEnabled: boolean;

    /**
     * Gets or sets a value indicating whether historical capture is allowed while the device is on battery power. 
     */
    isHistoricalCaptureOnBatteryAllowed: boolean;

    /**
     * Gets or sets a value indicating whether historical capture is allowed on wireless displays. 
     */
    isHistoricalCaptureOnWirelessDisplayAllowed: boolean;

    /**
     * Gets a value indicating whether the device is memory-constrained. 
     */
    isMemoryConstrained: boolean;
    isMicrophoneCaptureEnabled: any;

    /**
     * Gets or sets the maximum recording length. 
     */
    maximumRecordLength: number;

    /**
     * Gets or sets the screenshot destination folder. 
     */
    screenshotDestinationFolder: undefined.StorageFolder;

    /**
     * Gets or sets the video encoding bitrate. 
     */
    videoEncodingBitrateMode: undefined.AppCaptureVideoEncodingBitrateMode;

    /**
     * Gets or sets the video encoding resolution mode. 
     */
    videoEncodingResolutionMode: undefined.AppCaptureVideoEncodingResolutionMode
}


/**
 * Provides a full window UI for capturing audio, video, and photos from a camera. As well as controls for trimming video, time delayed capture, and camera settings. 
 */
declare class CameraCaptureUI {

    /**
     * Create a new CameraCaptureUI object. 
     */
    constructor(): this;

    /**
     * Launches the CameraCaptureUI user interface.
     * @param mode Specifies whether the user interface that will be shown allows the user to capture a photo, capture a video, or capture both photos and videos.
     * @return  When this operation completes, a StorageFile object is returned.
     */
    captureFileAsync(
        mode: undefined.CameraCaptureUIMode): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Provides settings for capturing photos. The settings include aspect ratio, image size, format, resolution, and whether or not cropping is allowed by the user interface (UI). 
     */
    photoSettings: undefined.CameraCaptureUIPhotoCaptureSettings;

    /**
     * Provides settings for capturing videos. The settings include format, maximum resolution, maximum duration, and whether or not to allow trimming. 
     */
    videoSettings: undefined.CameraCaptureUIVideoCaptureSettings
}


/**
 * Provides settings for capturing photos. The settings include aspect ratio, image size, format, resolution, and whether or not cropping is allowed by the user interface (UI). 
 */
declare class CameraCaptureUIPhotoCaptureSettings {

    /**
     * Determines whether photo cropping will be enabled in the user interface for capture a photo. 
     */
    allowCropping: boolean;

    /**
     * The aspect ratio of the captured photo. 
     */
    croppedAspectRatio: undefined.Size;

    /**
     * The exact size in pixels of the captured photo. 
     */
    croppedSizeInPixels: undefined.Size;

    /**
     * Determines the format that captured photos will be stored in. 
     */
    format: undefined.CameraCaptureUIPhotoFormat;

    /**
     * Determines the maximum resolution the user will be able to select. 
     */
    maxResolution: undefined.CameraCaptureUIMaxPhotoResolution
}


/**
 * Provides settings for capturing videos. The settings include format, maximum resolution, maximum duration, and whether or not to allow trimming. 
 */
declare class CameraCaptureUIVideoCaptureSettings {

    /**
     * Determines whether or not the video trimming user interface will be enabled. 
     */
    allowTrimming: boolean;

    /**
     * Determines the format for storing captured videos. 
     */
    format: undefined.CameraCaptureUIVideoFormat;

    /**
     * Determines the maximum duration of a video. 
     */
    maxDurationInSeconds: number;

    /**
     * Determines the maximum resolution that the user can select. 
     */
    maxResolution: undefined.CameraCaptureUIMaxVideoResolution
}


/**
 * Provides a method for displaying a UI, by which the UI contains options for the capture of photos, audio recordings and videos. 
 */
declare class CameraOptionsUI {

    /**
     * Displays a UI that contains options for the capture of photos, audio recordings and videos.
     * @param mediaCapture The MediaCapture object that provides methods for the capture of photos, audio recordings and videos.
     */
    show(mediaCapture: undefined.MediaCapture): void
}


/**
 * Represents a captured video frame. 
 */
declare class CapturedFrame {

    /**
     * Gets a value that indicates if the captured frame can be read from. 
     */
    canRead: boolean;

    /**
     * Gets a value that indicates if the captured frame can be written to. 
     */
    canWrite: boolean;

    /**
     * Creates a copy of the stream.
     * @return  The clone of the strem.
     */
    cloneStream(): undefined.IRandomAccessStream;

    /**
     * Closes the captured framed object. 
     */
    close(): void;

    /**
     * Gets the content type of the captured frame. 
     */
    contentType: string;

    /**
     * Asynchronously commits and flushes all of the data of the CapturedFrame .
     * @return  When this method completes, a boolean value is returned which specifies true if the operation completed successfully; otherwise, false.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets the input stream at the specified position.
     * @param position The position in the input stream.
     * @return  The input stream.
     */
    getInputStreamAt(position: number): undefined.IInputStream;

    /**
     * Gets the output stream at the specified position.
     * @param position The position in the output stream.
     * @return  The output stream.
     */
    getOutputStreamAt(position: number): undefined.IOutputStream;

    /**
     * Gets the height of the captured frame 
     */
    height: number;

    /**
     * Gets the position of the captured frame. 
     */
    position: number;

    /**
     * Returns an asynchronous byte reader object.
     * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
     * @param count The number of bytes to read that is less than or equal to the Capacity value.
     * @param options Specifies the type of the asynchronous read operation.
     * @return  The asynchronous operation.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Seeks the stream to the specified position.
     * @param position The position in the stream to seek too.
     */
    seek(position: number): void;

    /**
     * Gets the size of the captured frame in bytes. 
     */
    size: number;

    /**
     * Gets a SoftwareBitmap object representing the captured frame. 
     */
    softwareBitmap: undefined.SoftwareBitmap;

    /**
     * Gets the width of the captured frame. 
     */
    width: number;

    /**
     * Asynchronously writes the specified data to the stream.
     * @param buffer The data to write to the stream.
     * @return  Represents an asynchronous operation that returns a result and reports progress.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides information about the capture device settings that were used for a frame in a variable photo sequence. 
 */
declare class CapturedFrameControlValues {

    /**
     * Gets the exposure time used for a frame in a variable photo sequence. 
     */
    exposure: number;

    /**
     * Gets the exposure compensation value used for a frame in a variable photo sequence. 
     */
    exposureCompensation: number;

    /**
     * Gets the flash power used for a frame in a variable photo sequence. 
     */
    flashPowerPercent: number;

    /**
     * Gets a value indicating if the flash was used for a frame in a variable photo sequence. 
     */
    flashed: boolean;

    /**
     * Gets the focus lens position used for a frame in a variable photo sequence. 
     */
    focus: number;

    /**
     * Gets the focus state for a frame in a variable photo sequence. 
     */
    focusState: undefined.MediaCaptureFocusState;

    /**
     * Gets the ISO analog gain used for a frame in a variable photo sequence. 
     */
    isoAnalogGain: number;

    /**
     * Gets the ISO digital gain used for a frame in a variable photo sequence. 
     */
    isoDigitalGain: number;

    /**
     * Gets the ISO speed used for a frame in a variable photo sequence. 
     */
    isoSpeed: number;

    /**
     * Gets the scene mode used for a frame in a variable photo sequence. 
     */
    sceneMode: undefined.CaptureSceneMode;

    /**
     * Gets the sensor frame rate used for a frame in a variable photo sequence. 
     */
    sensorFrameRate: undefined.MediaRatio;

    /**
     * Gets the white balance setting used for a frame in a variable photo sequence. 
     */
    whiteBalance: number;

    /**
     * Gets the white balance gain used for a frame in a variable photo sequence. 
     */
    whiteBalanceGain: undefined.WhiteBalanceGain;

    /**
     * Gets the zoom factor used for a frame in a variable photo sequence. 
     */
    zoomFactor: number
}


/**
 * Represents a photo taken from a capture device such as a webcam attached. 
 */
declare class CapturedPhoto {

    /**
     * Gets the photo data, represented as CapturedFrame object, associated with the CapturedPhoto object. 
     */
    frame: undefined.CapturedFrame;

    /**
     * Represents a thumbnail image of the capture photo. 
     */
    thumbnail: undefined.CapturedFrame
}


/**
 * Provides data for the PhotoCaptured event. 
 */
declare class VariablePhotoCapturedEventArgs {

    /**
     * Gets the time offset of the capture of the associated frame in a variable photo sequence. 
     */
    captureTimeOffset: number;

    /**
     * Gets a CapturedFrameControlValues object that indicates the capture settings used for the associated frame in a variable photo sequence. 
     */
    capturedFrameControlValues: undefined.CapturedFrameControlValues;

    /**
     * Gets a CapturedFrame object representing a captured frame of a variable photo sequence. 
     */
    frame: undefined.CapturedFrame;

    /**
     * Gets an index value that indicates which element of the DesiredFrameControllers vector was used to specify the requested control values for the associated frame of a variable photo sequence. 
     */
    usedFrameControllerIndex: number
}


/**
 * Provides methods and events that enable the capture of variable photo sequences. 
 */
declare class VariablePhotoSequenceCapture {

    /**
     * Asynchronously releases the VariablePhotoSequenceCapture object and resources used by the capture operation.
     * @return  An asynchronous action.
     */
    finishAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Occurs when a frame of a variable photo sequence is captured. 
     */
    onphotocaptured: undefined.TypedEventHandler<undefined.VariablePhotoSequenceCapture, undefined.VariablePhotoCapturedEventArgs>;
    addEventListener(
        type: "photocaptured",
        listener: undefined.TypedEventHandler<undefined.VariablePhotoSequenceCapture, undefined.VariablePhotoCapturedEventArgs>): void;
    removeEventListener(
        type: "photocaptured",
        listener: undefined.TypedEventHandler<undefined.VariablePhotoSequenceCapture, undefined.VariablePhotoCapturedEventArgs>): void;

    /**
     * Occurs when the VariablePhotoSequenceCapture object stops capturing frames for a variable photo sequence. 
     */
    onstopped: undefined.TypedEventHandler<undefined.VariablePhotoSequenceCapture, any>;
    addEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.VariablePhotoSequenceCapture, any>): void;
    removeEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.VariablePhotoSequenceCapture, any>): void;

    /**
     * Starts the capturing of variable photo sequence frames.
     * @return  An asynchronous action.
     */
    startAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Stops the capturing of variable photo sequence frames.
     * @return  An asynchronous action.
     */
    stopAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Updates the frame control values of the variable photo sequence.
     * @return  An asynchronous action.
     */
    updateSettingsAsync(): undefined.IPromiseWithIAsyncAction;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides methods for taking a low lag media recording. 
 */
declare class LowLagMediaRecording {

    /**
     * Asynchronously releases the LowLagMediaRecording object and resources used by the media recording operation.
     * @return  Object that is used to control the asynchronous operation.
     */
    finishAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Pauses an ongoing low lag media record operation
     * @param behavior A value indicating whether the media capture hardware resources should be preserved or released while recording is paused.
     * @return  An asynchronous action.
     */
    pauseAsync(
        behavior: undefined.MediaCapturePauseBehavior): undefined.IPromiseWithIAsyncAction;

    /**
     * Resumes a paused low lag recording operation.
     * @return  An asynchronous action.
     */
    resumeAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously starts the low lag media recording.
     * @return  Object that is used to control the asynchronous operation.
     */
    startAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously stops the low lag media recording.
     * @return  Object that is used to control the asynchronous operation.
     */
    stopAsync(): undefined.IPromiseWithIAsyncAction
}


/**
 * Provides methods for taking a low shutter lag photo. 
 */
declare class LowLagPhotoCapture {

    /**
     * Asynchronously captures a low shutter lag photo.
     * @return  When this method completes, a CapturedPhoto object is returned which contains the captured photo.
     */
    captureAsync(): undefined.IPromiseWithIAsyncOperation<undefined.CapturedPhoto>;

    /**
     * Asynchronously releases the LowLagPhotoCapture object and resources used by the capture photo operation.
     * @return  Object that is used to control the asynchronous operation.
     */
    finishAsync(): undefined.IPromiseWithIAsyncAction
}


/**
 * Provides methods for taking a rapid sequence of low shutter lag photos. 
 */
declare class LowLagPhotoSequenceCapture {

    /**
     * Asynchronously releases the LowLagPhotoSequenceCapture object and resources used by the photo sequence capture operation.
     * @return  Object that is used to control the asynchronous operation.
     */
    finishAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Occurs when a photo has been captured. 
     */
    onphotocaptured: undefined.TypedEventHandler<undefined.LowLagPhotoSequenceCapture, undefined.PhotoCapturedEventArgs>;
    addEventListener(
        type: "photocaptured",
        listener: undefined.TypedEventHandler<undefined.LowLagPhotoSequenceCapture, undefined.PhotoCapturedEventArgs>): void;
    removeEventListener(
        type: "photocaptured",
        listener: undefined.TypedEventHandler<undefined.LowLagPhotoSequenceCapture, undefined.PhotoCapturedEventArgs>): void;

    /**
     * Asynchronously starts capturing photos.
     * @return  Object that is used to control the asynchronous operation.
     */
    startAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously stops capturing photos.
     * @return  Object that is used to control the asynchronous operation.
     */
    stopAsync(): undefined.IPromiseWithIAsyncAction;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides functionality for capturing photos, audio, and videos from a capture device, such as a webcam. 
 */
declare class MediaCapture {

    /**
     * Retrieves the list of all video profiles supported by the specified video capture device.
     * @param videoDeviceId The identifier of the video device for which supported video profiles are queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
     * @return  The list of video profiles supported by the specified video capture device.
     */
    findAllVideoProfiles(
        videoDeviceId: string): undefined.IVectorView<undefined.MediaCaptureVideoProfile>;

    /**
     * Retrieves the list of video profiles supported by the specified video capture device that can be used while another profile is used on a different capture device.
     * @param videoDeviceId The identifier of the video device for which supported video profiles are queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
     * @return  The list of video profiles supported by the specified video capture device that support concurrency.
     */
    findConcurrentProfiles(
        videoDeviceId: string): undefined.IVectorView<undefined.MediaCaptureVideoProfile>;

    /**
     * Retrieves the list of all video profiles supported by the specified video capture device that match the specified KnownVideoProfile value.
     * @param videoDeviceId The identifier of the video device for which supported video profiles are queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
     * @param name A value specifying one of the profile names known by the system.
     * @return  The list of video profiles supported by the specified video capture device that match the specified known profile name.
     */
    findKnownVideoProfiles(
        videoDeviceId: string,
        name: undefined.KnownVideoProfile): undefined.IVectorView<undefined.MediaCaptureVideoProfile>;

    /**
     * Gets a boolean value indicating whether video profiles are supported by the specified video capture device.
     * @param videoDeviceId The identifier of the video device for which supported video profile support is queried. For information on getting the video device ID, see DeviceInformation::FindAllAsync .
     * @return  True if video profiles are supported; otherwise, false.
     */
    isVideoProfileSupported(videoDeviceId: string): boolean;

    /**
     * Creates a new instance of the MediaCapture object. 
     */
    constructor(): this;

    /**
     * Adds an audio effect to the capture pipeline.
     * @param definition The object containing the definition of the effect to be added.
     * @return  An asynchronous operation that returns an IMediaExtension upon successful completion.
     */
    addAudioEffectAsync(
        definition: undefined.IAudioEffectDefinition): undefined.IPromiseWithIAsyncOperation<undefined.IMediaExtension>;

    /**
     * Adds an audio or video effect.
     * @param mediaStreamType Specifies the streams to which the effect will be applied.
     * @param effectActivationID The class identifier of the activatable runtime class that implements the effect. The runtime class must implement the IMediaExtension interface.
     * @param effectSettings Configuration parameters for the effect.
     * @return  Returns an IAsyncAction object that is used to control the asynchronous operation.
     */
    addEffectAsync(
        mediaStreamType: undefined.MediaStreamType,
        effectActivationID: string,
        effectSettings: undefined.IPropertySet): undefined.IPromiseWithIAsyncAction;

    /**
     * Adds a video effect to the capture pipeline.
     * @param definition The object containing the definition of the effect to be added.
     * @param mediaStreamType Specifies the streams to which the effect will be applied.
     * @return  An asynchronous operation that returns an IMediaExtension upon successful completion.
     */
    addVideoEffectAsync(
        definition: undefined.IVideoEffectDefinition,
        mediaStreamType: undefined.MediaStreamType): undefined.IPromiseWithIAsyncOperation<undefined.IMediaExtension>;

    /**
     * Gets an object that controls settings for the microphone. 
     */
    audioDeviceController: undefined.AudioDeviceController;

    /**
     * Gets the current stream state of the camera stream. 
     */
    cameraStreamState: undefined.CameraStreamState;

    /**
     * Captures a photo to a storage file.
     * @param type The encoding properties for the output image.
     * @param file The storage file where the image is saved.
     * @return  Returns an IAsyncAction object that is used to control the asynchronous operation.
     */
    capturePhotoToStorageFileAsync(
        type: undefined.ImageEncodingProperties,
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncAction;

    /**
     * Captures a photo to a random-access stream.
     * @param type The encoding properties for the output image.
     * @param stream The stream where the image data is written.
     * @return  Returns an IAsyncAction object that is used to control the asynchronous operation.
     */
    capturePhotoToStreamAsync(
        type: undefined.ImageEncodingProperties,
        stream: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncAction;

    /**
     * Removes all audio and video effects from a stream.
     * @param mediaStreamType The stream from which to remove the effects.
     * @return  Returns a IAsyncAction object that is used to control the asynchronous operation.
     */
    clearEffectsAsync(mediaStreamType: undefined.MediaStreamType): undefined.IPromiseWithIAsyncAction;

    /**
     * Closes the media capture object. 
     */
    close(): void;

    /**
     * Gets the value of an encoding property.
     * @param mediaStreamType Specifies the stream to query for the encoding property.
     * @param propertyId The encoding property to retrieve.
     * @return  Returns the value of the encoding property.
     */
    getEncoderProperty(mediaStreamType: undefined.MediaStreamType, propertyId: string): any;

    /**
     * Gets a preview frame from the capture device.
     * @return  An asynchronous operation that returns a VideoFrame on successful completion.
     */
    getPreviewFrameAsync(): undefined.IPromiseWithIAsyncOperation<undefined.VideoFrame>;

    /**
     * Gets a preview frame from the capture device, copied into the provided destination VideoFrame and converted into the destination frame's format.
     * @param destination The video frame into which the preview frame will be copied.
     * @return  An asynchronous operation that returns a VideoFrame on successful completion.
     */
    getPreviewFrameAsync(
        destination: undefined.VideoFrame): undefined.IPromiseWithIAsyncOperation<undefined.VideoFrame>;

    /**
     * Queries whether the video stream is mirrored horizontally.
     * @return  True if mirroring is enabled; false otherwise.
     */
    getPreviewMirroring(): boolean;

    /**
     * Gets the rotation of the video preview stream.
     * @return  The amount by which the video preview stream is rotated.
     */
    getPreviewRotation(): undefined.VideoRotation;

    /**
     * Gets the rotation of the recorded video.
     * @return  The amount by which the recorded video is rotated.
     */
    getRecordRotation(): undefined.VideoRotation;

    /**
     * Initializes the MediaCapture object, using default settings.
     * @return  Returns a IAsyncAction object that is used to control the asynchronous operation.
     */
    initializeAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Initializes the MediaCapture object.
     * @param mediaCaptureInitializationSettings The initialization settings.
     * @return  Returns a IAsyncAction object that is used to control the asynchronous operation.
     */
    initializeAsync(
        mediaCaptureInitializationSettings: undefined.MediaCaptureInitializationSettings): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the configuration settings for the MediaCapture object. 
     */
    mediaCaptureSettings: undefined.MediaCaptureSettings;

    /**
     * Occurs when the state of the camera stream changes. 
     */
    oncamerastreamstatechanged: undefined.TypedEventHandler<undefined.MediaCapture, any>;
    addEventListener(
        type: "camerastreamstatechanged",
        listener: undefined.TypedEventHandler<undefined.MediaCapture, any>): void;
    removeEventListener(
        type: "camerastreamstatechanged",
        listener: undefined.TypedEventHandler<undefined.MediaCapture, any>): void;

    /**
     * Raised when an error occurs during media capture. 
     */
    onfailed: undefined.MediaCaptureFailedEventHandler;
    addEventListener(type: "failed", listener: undefined.MediaCaptureFailedEventHandler): void;
    removeEventListener(type: "failed", listener: undefined.MediaCaptureFailedEventHandler): void;

    /**
     * Occurs when the capture device changes focus. 
     */
    onfocuschanged: undefined.TypedEventHandler<undefined.MediaCapture, undefined.MediaCaptureFocusChangedEventArgs>;
    addEventListener(
        type: "focuschanged",
        listener: undefined.TypedEventHandler<undefined.MediaCapture, undefined.MediaCaptureFocusChangedEventArgs>): void;
    removeEventListener(
        type: "focuschanged",
        listener: undefined.TypedEventHandler<undefined.MediaCapture, undefined.MediaCaptureFocusChangedEventArgs>): void;

    /**
     * Occurs when a photo confirmation frame is captured. 
     */
    onphotoconfirmationcaptured: undefined.TypedEventHandler<undefined.MediaCapture, undefined.PhotoConfirmationCapturedEventArgs>;
    addEventListener(
        type: "photoconfirmationcaptured",
        listener: undefined.TypedEventHandler<undefined.MediaCapture, undefined.PhotoConfirmationCapturedEventArgs>): void;
    removeEventListener(
        type: "photoconfirmationcaptured",
        listener: undefined.TypedEventHandler<undefined.MediaCapture, undefined.PhotoConfirmationCapturedEventArgs>): void;

    /**
     * Occurs when the record limit is exceeded. 
     */
    onrecordlimitationexceeded: undefined.RecordLimitationExceededEventHandler;
    addEventListener(
        type: "recordlimitationexceeded",
        listener: undefined.RecordLimitationExceededEventHandler): void;
    removeEventListener(
        type: "recordlimitationexceeded",
        listener: undefined.RecordLimitationExceededEventHandler): void;

    /**
     * Occurs when the thermal status of the capture device changes. 
     */
    onthermalstatuschanged: undefined.TypedEventHandler<undefined.MediaCapture, any>;
    addEventListener(
        type: "thermalstatuschanged",
        listener: undefined.TypedEventHandler<undefined.MediaCapture, any>): void;
    removeEventListener(
        type: "thermalstatuschanged",
        listener: undefined.TypedEventHandler<undefined.MediaCapture, any>): void;

    /**
     * Pauses an ongoing record operation.
     * @param behavior A value indicating whether the media capture hardware resources should be preserved or released while recording is paused.
     * @return  An asynchronous action.
     */
    pauseRecordAsync(
        behavior: undefined.MediaCapturePauseBehavior): undefined.IPromiseWithIAsyncAction;

    /**
     * Initializes the advanced photo capture and provides the AdvancedPhotoCapture object used to manage the recording.
     * @param encodingProperties The encoding properties used for the resulting image.
     * @return  An asynchronous operation that returns an AdvancedPhotoCapture object on successful completion.
     */
    prepareAdvancedPhotoCaptureAsync(
        encodingProperties: undefined.ImageEncodingProperties): undefined.IPromiseWithIAsyncOperation<undefined.AdvancedPhotoCapture>;

    /**
     * Initializes the low shutter lag photo capture and provides the LowLagPhotoCapture object used to manage the recording.
     * @param type The encoding profile used for the image.
     * @return  When this method completes, a LowLagPhotoCapture object is returned which can be used to start the photo capture.
     */
    prepareLowLagPhotoCaptureAsync(
        type: undefined.ImageEncodingProperties): undefined.IPromiseWithIAsyncOperation<undefined.LowLagPhotoCapture>;

    /**
     * Initializes the low shutter lag photo sequence capture and provides the LowLagPhotoSequenceCapture object used to manage the recording.
     * @param type The encoding profile used for the image.
     * @return  When this method completes, a LowLagPhotoSequenceCapture object is returned which can be used to start the photo sequence capture.
     */
    prepareLowLagPhotoSequenceCaptureAsync(
        type: undefined.ImageEncodingProperties): undefined.IPromiseWithIAsyncOperation<undefined.LowLagPhotoSequenceCapture>;

    /**
     * Initializes the low lag recording using the specified custom sink to store the recording. This method provides the LowLagMediaRecording object used to managed the capture.
     * @param encodingProfile The encoding profile to use for the recording.
     * @param customMediaSink The media extension for the custom media sink.
     * @return  When this method completes, a LowLagMediaRecording object is returned which can be used to start the photo capture.
     */
    prepareLowLagRecordToCustomSinkAsync(
        encodingProfile: undefined.MediaEncodingProfile,
        customMediaSink: undefined.IMediaExtension): undefined.IPromiseWithIAsyncOperation<undefined.LowLagMediaRecording>;

    /**
     * Initializes the low lag recording using the specified custom sink to store the recording. This method provides the LowLagMediaRecording object used to managed the recording.
     * @param encodingProfile The encoding profile to use for the recording.
     * @param customSinkActivationId The activatable class ID of the media extension for the custom media sink.
     * @param customSinkSettings Contains properties of the media extension.
     * @return  When this method completes, a LowLagMediaRecording object is returned which can be used to start the photo capture.
     */
    prepareLowLagRecordToCustomSinkAsync(
        encodingProfile: undefined.MediaEncodingProfile,
        customSinkActivationId: string,
        customSinkSettings: undefined.IPropertySet): undefined.IPromiseWithIAsyncOperation<undefined.LowLagMediaRecording>;

    /**
     * Initializes the low lag recording using the specified file to store the recording. This method provides the LowLagMediaRecording object used to managed the recording.
     * @param encodingProfile The encoding profile for the recording.
     * @param file The storage file where the image is saved.
     * @return  When this method completes, a LowLagMediaRecording object is returned which can be used to start the photo capture.
     */
    prepareLowLagRecordToStorageFileAsync(
        encodingProfile: undefined.MediaEncodingProfile,
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.LowLagMediaRecording>;

    /**
     * Initializes the low lag recording using the specified random-access stream to store the recording. This method provides the LowLagMediaRecording object used to managed the recording.
     * @param encodingProfile The encoding profile for the recording.
     * @param stream The stream where the image data is written.
     * @return  When this method completes, a LowLagMediaRecording object is returned which can be used to start the photo capture.
     */
    prepareLowLagRecordToStreamAsync(
        encodingProfile: undefined.MediaEncodingProfile,
        stream: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncOperation<undefined.LowLagMediaRecording>;

    /**
     * Initializes the variable photo sequence capture and provides the VariablePhotoSequenceCapture object used to manage the recording.
     * @param type The encoding profile used for the image.
     * @return  When this method completes, a VariablePhotoSequenceCapture object is returned which can be used to start the photo sequence capture.
     */
    prepareVariablePhotoSequenceCaptureAsync(
        type: undefined.ImageEncodingProperties): undefined.IPromiseWithIAsyncOperation<undefined.VariablePhotoSequenceCapture>;

    /**
     * Resumes a paused recording operation.
     * @return  An asynchronous operation.
     */
    resumeRecordAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Sets an encoding property.
     * @param mediaStreamType The type of media data the stream represents, such as video or audio.
     * @param propertyId The encoding property to set.
     * @param propertyValue The new value of the encoding property.
     */
    setEncoderProperty(
        mediaStreamType: undefined.MediaStreamType,
        propertyId: string,
        propertyValue: any): void;

    /**
     * Asynchronously sets the media encoding properties.
     * @param mediaStreamType The type of media data the stream represents, such as video or audio.
     * @param mediaEncodingProperties The properties for the media encoding.
     * @param encoderProperties The properties for the encoder.
     * @return  Object that is used to control the asynchronous operation.
     */
    setEncodingPropertiesAsync(
        mediaStreamType: undefined.MediaStreamType,
        mediaEncodingProperties: undefined.IMediaEncodingProperties,
        encoderProperties: undefined.MediaPropertySet): undefined.IPromiseWithIAsyncAction;

    /**
     * Enables or disables horizontal mirroring of the video preview stream. This is not the preferred method for mirroring. See the Remarks section below for details.
     * @param value True to enable mirroring; false to disable mirroring.
     */
    setPreviewMirroring(value: boolean): void;

    /**
     * Rotates the video preview stream.
     * @param value The amount by which to rotate the video.
     */
    setPreviewRotation(value: undefined.VideoRotation): void;

    /**
     * Rotates the recorded video.
     * @param value The amount by which to rotate the video.
     */
    setRecordRotation(value: undefined.VideoRotation): void;

    /**
     * Start recording to a custom media sink using the specified encoding profile and sink settings.
     * @param encodingProfile The encoding profile to use for the recording.
     * @param customSinkActivationId The activatable class ID of the media extension for the custom media sink.
     * @param customSinkSettings Contains properties of the media extension.
     * @return  Anobject that is used to control the asynchronous operation.
     */
    startRecordToCustomSinkAsync(
        encodingProfile: undefined.MediaEncodingProfile,
        customSinkActivationId: string,
        customSinkSettings: undefined.IPropertySet): undefined.IPromiseWithIAsyncAction;

    /**
     * Start recording to a custom media sink using the specified encoding profile.
     * @param encodingProfile The encoding profile to use for the recording.
     * @param customMediaSink The media extension for the custom media sink.
     * @return  An object that is used to control the asynchronous operation.
     */
    startRecordToCustomSinkAsync(
        encodingProfile: undefined.MediaEncodingProfile,
        customMediaSink: undefined.IMediaExtension): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts recording asynchronously to a storage file.
     * @param encodingProfile The encoding profile for the recording.
     * @param file The storage file where the image is saved.
     * @return  Returns a IAsyncAction object that is used to control the asynchronous operation.
     */
    startRecordToStorageFileAsync(
        encodingProfile: undefined.MediaEncodingProfile,
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts recording to a random-access stream.
     * @param encodingProfile The encoding profile for the recording.
     * @param stream The stream where the image data is written.
     * @return  Returns a IAsyncAction object that is used to control the asynchronous operation.
     */
    startRecordToStreamAsync(
        encodingProfile: undefined.MediaEncodingProfile,
        stream: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncAction;

    /**
     * Stops recording.
     * @return  Returns a IAsyncAction object that is used to control the asynchronous operation.
     */
    stopRecordAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets a value that indicates the current thermal status of the capture device. 
     */
    thermalStatus: undefined.MediaCaptureThermalStatus;

    /**
     * Gets an object that controls settings for the video camera. 
     */
    videoDeviceController: undefined.VideoDeviceController;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the MediaCapture.Failed event. 
 */
declare class MediaCaptureFailedEventArgs {

    /**
     * The error code of the error that caused the event. 
     */
    code: number;

    /**
     * A message string for the error. 
     */
    message: string
}


/**
 * Provides data for the FocusChanged event. 
 */
declare class MediaCaptureFocusChangedEventArgs {

    /**
     * Gets the current focus state of the capture device. 
     */
    focusState: undefined.MediaCaptureFocusState
}


/**
 * Contains initialization settings for the MediaCapture object which are passed to the MediaCapture.InitializeAsync method. 
 */
declare class MediaCaptureInitializationSettings {

    /**
     * Creates a new instance of the MediaCaptureInitializationSettings object. 
     */
    constructor(): this;

    /**
     * Gets the DeviceInformation.Id of the microphone. 
     */
    audioDeviceId: string;

    /**
     * Gets or sets a value that specifies the audio processing mode. 
     */
    audioProcessing: undefined.AudioProcessing;

    /**
     * Gets or sets the audio source for the capture operation. 
     */
    audioSource: undefined.IMediaSource;

    /**
     * Gets or set the media category. 
     */
    mediaCategory: undefined.MediaCategory;

    /**
     * Gets or sets the stream that is used for photo capture. 
     */
    photoCaptureSource: undefined.PhotoCaptureSource;

    /**
     * Gets or sets the media description for photo capture. 
     */
    photoMediaDescription: undefined.MediaCaptureVideoProfileMediaDescription;

    /**
     * Gets or sets the media description for preview video. 
     */
    previewMediaDescription: undefined.MediaCaptureVideoProfileMediaDescription;

    /**
     * Gets or sets the media description for video recording. 
     */
    recordMediaDescription: undefined.MediaCaptureVideoProfileMediaDescription;

    /**
     * Gets or sets the streaming mode. 
     */
    streamingCaptureMode: undefined.StreamingCaptureMode;

    /**
     * Gets the DeviceInformation.Id of the video camera. 
     */
    videoDeviceId: string;

    /**
     * Gets or sets the video profile which provides hints to the driver to allow it to optimize for different capture scenarios. 
     */
    videoProfile: undefined.MediaCaptureVideoProfile;

    /**
     * Gets or sets the video source for the capture operation. 
     */
    videoSource: undefined.IMediaSource
}


/**
 * Contains read-only configuration settings for the MediaCapture object. 
 */
declare class MediaCaptureSettings {

    /**
     * Gets the DeviceInformation.Id of the microphone. 
     */
    audioDeviceId: string;

    /**
     * Gets the audio processing mode. 
     */
    audioProcessing: undefined.AudioProcessing;

    /**
     * Gets a value that indicates if the operating system will make a sound when the capture device takes a picture. 
     */
    cameraSoundRequiredForRegion: boolean;

    /**
     * Gets a value that indicates if the capture device supports recording video and taking a photo sequence at the same time. 
     */
    concurrentRecordAndPhotoSequenceSupported: boolean;

    /**
     * Gets a value that indicates if the capture device supports recording video and taking a photo at the same time. 
     */
    concurrentRecordAndPhotoSupported: boolean;

    /**
     * Gets the horizontal 35mm equivalent focal length of the camera lens on the capture device. 
     */
    horizontal35mmEquivalentFocalLength: number;

    /**
     * Gets the media category of the media. 
     */
    mediaCategory: undefined.MediaCategory;

    /**
     * Gets the stream that is used for photo capture. 
     */
    photoCaptureSource: undefined.PhotoCaptureSource;

    /**
     * Gets the pitch offset of the camera in degrees. 
     */
    pitchOffsetDegrees: number;

    /**
     * Gets the streaming mode. 
     */
    streamingCaptureMode: undefined.StreamingCaptureMode;

    /**
     * Gets the vertical 35mm equivalent focal length of the camera lens on the capture device. 
     */
    vertical35mmEquivalentFocalLength: number;

    /**
     * Gets a value that indicates which video streams are independent of each other. 
     */
    videoDeviceCharacteristic: undefined.VideoDeviceCharacteristic;

    /**
     * Gets the DeviceInformation.Id of the video camera. 
     */
    videoDeviceId: string
}


/**
 * Represents a video profile that indicates a configuration supported by the video capture device. 
 */
declare class MediaCaptureVideoProfile {

    /**
     * Gets the list of MediaCaptureVideoProfile objects that can be used concurrently with this video profile.
     * @return  The list of MediaCaptureVideoProfile objects that can be used concurrently with this video profile.
     */
    getConcurrency(): undefined.IVectorView<undefined.MediaCaptureVideoProfile>;

    /**
     * Gets the unique identifier of the video profile. 
     */
    id: string;

    /**
     * Gets a list of MediaCaptureVideoProfileMediaDescription objects that represent supported video device settings for photo capture. 
     */
    supportedPhotoMediaDescription: undefined.IVectorView<undefined.MediaCaptureVideoProfileMediaDescription>;

    /**
     * Gets a list of MediaCaptureVideoProfileMediaDescription objects that represent supported video device settings for video preview. 
     */
    supportedPreviewMediaDescription: undefined.IVectorView<undefined.MediaCaptureVideoProfileMediaDescription>;

    /**
     * Gets a list of MediaCaptureVideoProfileMediaDescription objects that represent supported video device settings for video recording. 
     */
    supportedRecordMediaDescription: undefined.IVectorView<undefined.MediaCaptureVideoProfileMediaDescription>;

    /**
     * Gets the device ID of the video device associated with the video profile. 
     */
    videoDeviceId: string
}


/**
 * Represents a description of media that is supported by a video profile. 
 */
declare class MediaCaptureVideoProfileMediaDescription {

    /**
     * Gets the frame rate of the media description. 
     */
    frameRate: number;

    /**
     * Gets the height of the media description. 
     */
    height: number;

    /**
     * Gets a value indicating if the media description includes HDR video support. 
     */
    isHdrVideoSupported: boolean;

    /**
     * Gets a value indicating if the media description includes variable photo sequence support. 
     */
    isVariablePhotoSequenceSupported: boolean;

    /**
     * Gets the height of the media description. 
     */
    width: number
}


/**
 * Provides data for the AdvancedPhotoCapture::OptionalReferencePhotoCaptured event. 
 */
declare class OptionalReferencePhotoCapturedEventArgs {

    /**
     * Gets the app-defined context object associated with the advanced photo capture operation, if one was provided in the call to AdvancedPhotoCapture::CaptureAsync(Object) . 
     */
    context: any;

    /**
     * Gets the captured frame containing the reference photo from the advanced photo capture. 
     */
    frame: undefined.CapturedFrame
}


/**
 * Provides data for the photo sequence PhotoCaptured event. 
 */
declare class PhotoCapturedEventArgs {

    /**
     * Gets a value that indicates time offset in the photo sequence. 
     */
    captureTimeOffset: number;

    /**
     * Gets the captured image associated with the event. 
     */
    frame: undefined.CapturedFrame;

    /**
     * Gets a thumbnail version of the captured image associated with the event. 
     */
    thumbnail: undefined.CapturedFrame
}


/**
 * Provides data for the PhotoConfirmationCaptured event. 
 */
declare class PhotoConfirmationCapturedEventArgs {

    /**
     * Gets the time offset from when capture began to the capture of the frame associated with the event. 
     */
    captureTimeOffset: number;

    /**
     * Gets the captured frame. 
     */
    frame: undefined.CapturedFrame
}


/**
 * Represents a set of input and output VideoEncodingProperties for a video stream 
 */
declare class VideoStreamConfiguration {

    /**
     * Gets a VideoEncodingProperties object representing an video stream input configuration. 
     */
    inputProperties: undefined.VideoEncodingProperties;

    /**
     * Gets a VideoEncodingProperties object representing an video stream output configuration. 
     */
    outputProperties: undefined.VideoEncodingProperties
}


/**
 * Represents the red, green, and blue values of a white balance gain setting. 
 */
declare interface Capture$WhiteBalanceGain {

    /**
     * The blue value of a white balance gain setting. 
     */
    b: number,

        /**
         * The green value of a white balance gain setting. 
         */
        g: number,

        /**
         * The red value of a white balance gain setting. 
         */
        r: number
}


/**
 * Represents the method that will handle the MediaCapture.Failed event. 
 */
declare type Capture$MediaCaptureFailedEventHandler = (
    ev: undefined.MediaCaptureFailedEventArgs & Windows$WinRTEvent<undefined.MediaCapture>) => void;


/**
 * Represents the method that will handle RecordLimitationExceeded and related events. 
 */
declare type Capture$RecordLimitationExceededEventHandler = (ev: Windows$WinRTEvent<undefined.MediaCapture>) => void;


/**
 * Represents the actual connection with a casting device. 
 */
declare class CastingConnection {

    /**
     * Closes the casting connection. 
     */
    close(): void;

    /**
     * Gets the casting device with which a connection has been made. 
     */
    device: undefined.CastingDevice;

    /**
     * Terminates a casting connection. The content that was rendering remotely returns to the local element that you retrieved the casting source from.
     * @return  The status of the termination.
     */
    disconnectAsync(): undefined.IPromiseWithIAsyncOperation<undefined.CastingConnectionErrorStatus>;

    /**
     * Indicates an error occurred while attempting to make a casting connection. 
     */
    onerroroccurred: undefined.TypedEventHandler<undefined.CastingConnection, undefined.CastingConnectionErrorOccurredEventArgs>;
    addEventListener(
        type: "erroroccurred",
        listener: undefined.TypedEventHandler<undefined.CastingConnection, undefined.CastingConnectionErrorOccurredEventArgs>): void;
    removeEventListener(
        type: "erroroccurred",
        listener: undefined.TypedEventHandler<undefined.CastingConnection, undefined.CastingConnectionErrorOccurredEventArgs>): void;

    /**
     * Indicates a change in the State property. 
     */
    onstatechanged: undefined.TypedEventHandler<undefined.CastingConnection, any>;
    addEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.CastingConnection, any>): void;
    removeEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.CastingConnection, any>): void;

    /**
     * Starts the process of casting to a casting device. When called, this method pairs the c sting device, if necessary, and verifies access to the casting device with the user. If the user denies the app access to the device, casting fails. Otherwise, a connection is established, and content is sent to the device. During this time, the connection state changes to connecting, then to connected. If a casting source is set, the state changes to rendering once playback begins.
     * @param value The content to be casted.
     * @return  The status of the casting connection request.
     */
    requestStartCastingAsync(
        value: undefined.CastingSource): undefined.IPromiseWithIAsyncOperation<undefined.CastingConnectionErrorStatus>;

    /**
     * Gets and sets the content source that is being casted through the connection to the casting device. The content can be set and changed at any time and doing so does not disconnect the connection. 
     */
    source: undefined.CastingSource;

    /**
     * Gets the current state of the connection. 
     */
    state: undefined.CastingConnectionState;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents arguments for the ErrorOccurred event from the CastingConnection 
 */
declare class CastingConnectionErrorOccurredEventArgs {

    /**
     * Gets the particular error that triggered the casting error event, ErrorOccurred . 
     */
    errorStatus: undefined.CastingConnectionErrorStatus;

    /**
     * Gets human-readable message to accompany the error status code, ErrorStatus . 
     */
    message: string
}


/**
 * Represents a physical device that is capable of supporting casting connections and rendering media content sent to it. 
 */
declare class CastingDevice {

    /**
     * Indicates whether the given device (a DeviceInformation object) supports casting.
     * @param device The device you want to know about.
     * @return  True if the device supports casting; false otherwise.
     */
    deviceInfoSupportsCastingAsync(
        device: undefined.DeviceInformation): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets a CastingDevice object for a given a device ID (acquired from a query using the Windows.Devices.Enumeration APIs).
     * @param value The device ID.
     * @return  The object representing the casting device.
     */
    fromIdAsync(value: string): undefined.IPromiseWithIAsyncOperation<undefined.CastingDevice>;

    /**
     * Gets an AQS filter string to be used with the Windows.Devices.Enumeration APIs for a given CastingPlaybackTypes .
     * @param type The casting playback type.
     * @return  The AQS filter string.
     */
    getDeviceSelector(type: undefined.CastingPlaybackTypes): string;

    /**
     * Gets an AQS filter string to be used with the Windows.Devices.Enumeration APIs for a given CastingSource .
     * @param castingSource The casting source.
     * @return  The AQS filter string.
     */
    getDeviceSelectorFromCastingSourceAsync(
        castingSource: undefined.CastingSource): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Creates a new CastingConnection object. This method does not establish a connection to the casting device.
     * @return  The object that represents the casting connection.
     */
    createCastingConnection(): undefined.CastingConnection;

    /**
     * A human-readable name for the device, retrieved from the device itself. 
     */
    friendlyName: string;

    /**
     * Gets the media types supported by the device. containing
     * @return  The media types, CastingPlaybackTypes , supported by the device.
     */
    getSupportedCastingPlaybackTypesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.CastingPlaybackTypes>;

    /**
     * An icon representing the device. 
     */
    icon: undefined.IRandomAccessStreamWithContentType;

    /**
     * The device ID. This is the same ID used with Windows.Devices.Enumeration APIs. 
     */
    id: string
}


/**
 * Represents a device picker that contains a list of casting devices for the user to choose from. 
 */
declare class CastingDevicePicker {

    /**
     * Creates a CastingDevicePicker object. 
     */
    constructor(): this;

    /**
     * Gets the colors of the picker UI. 
     */
    appearance: undefined.DevicePickerAppearance;

    /**
     * Gets the filter information for which devices to show in the picker. 
     */
    filter: undefined.CastingDevicePickerFilter;

    /**
     * Hides the device picker UI. 
     */
    hide(): void;

    /**
     * Indicates that the user has dismissed the picker UI. 
     */
    oncastingdevicepickerdismissed: undefined.TypedEventHandler<undefined.CastingDevicePicker, any>;
    addEventListener(
        type: "castingdevicepickerdismissed",
        listener: undefined.TypedEventHandler<undefined.CastingDevicePicker, any>): void;
    removeEventListener(
        type: "castingdevicepickerdismissed",
        listener: undefined.TypedEventHandler<undefined.CastingDevicePicker, any>): void;

    /**
     * Indicates that the user has selected a device from the picker. 
     */
    oncastingdeviceselected: undefined.TypedEventHandler<undefined.CastingDevicePicker, undefined.CastingDeviceSelectedEventArgs>;
    addEventListener(
        type: "castingdeviceselected",
        listener: undefined.TypedEventHandler<undefined.CastingDevicePicker, undefined.CastingDeviceSelectedEventArgs>): void;
    removeEventListener(
        type: "castingdeviceselected",
        listener: undefined.TypedEventHandler<undefined.CastingDevicePicker, undefined.CastingDeviceSelectedEventArgs>): void;

    /**
     * Shows the casting device picker UI, which flies out from the specified edge of the provided rectangle.
     * @param selection The rectangle from which the picker should fly out.
     * @param preferredPlacement The edge of the rectangle from which the picker should fly out.
     */
    show(selection: undefined.Rect, preferredPlacement: undefined.Placement): void;

    /**
     * Shows the casting device picker UI, which flies out from an edge of the provided rectangle.
     * @param selection The rectangle from which the picker UI should fly out.
     */
    show(selection: undefined.Rect): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the filter used to determine which devices to show in a casting device picker UI. The filter parameters are OR-ed together to build the resulting filter. In other words, if SupportsAudio and SupportsVideo are both true, the picker will display Audio-only devices, video-only devices, and audio/video devices. 
 */
declare class CastingDevicePickerFilter {

    /**
     * Gets the casting sources supported. 
     */
    supportedCastingSources: undefined.IVector<undefined.CastingSource>;

    /**
     * Gets and sets whether the devices in the device picker should support audio playback. 
     */
    supportsAudio: boolean;

    /**
     * Gets and sets whether the devices in the device picker should support rending still images. 
     */
    supportsPictures: boolean;

    /**
     * Gets and sets whether the devices in the device picker should support video playback. 
     */
    supportsVideo: boolean
}


/**
 * Represents the event arguments for the CastingDeviceSelected event on the CastingDevicePicker object. 
 */
declare class CastingDeviceSelectedEventArgs {

    /**
     * Represents the CastingDevice that has been selected by the user in a casting device picker. 
     */
    selectedCastingDevice: undefined.CastingDevice
}


/**
 * Represents the media content that can be sent to another device. 
 */
declare class CastingSource {

    /**
     * Gets or sets an alternative URI for the content for use with DLNA ByRef. 
     */
    preferredSourceUri: undefined.Uri
}


/**
 * Exposes properties for retrieving the closed caption formatting settings that the user can set through the system's closed captioning settings page. 
 */
declare class ClosedCaptionProperties {

    /**
     * Gets the background color of lines of closed caption text. 
     */
    backgroundColor: undefined.ClosedCaptionColor;

    /**
     * Gets the background opacity of lines of closed caption text. 
     */
    backgroundOpacity: undefined.ClosedCaptionOpacity;

    /**
     * Gets the computed background color of lines of closed caption text. 
     */
    computedBackgroundColor: undefined.Color;

    /**
     * Gets the computed font color for closed caption text. 
     */
    computedFontColor: undefined.Color;

    /**
     * Gets the computed region color for closed caption text. 
     */
    computedRegionColor: undefined.Color;

    /**
     * Gets the font color for closed caption text. 
     */
    fontColor: undefined.ClosedCaptionColor;

    /**
     * Gets the font effect for closed caption text. 
     */
    fontEffect: undefined.ClosedCaptionEdgeEffect;

    /**
     * Gets the font opacity for closed caption text. 
     */
    fontOpacity: undefined.ClosedCaptionOpacity;

    /**
     * Gets the font size for closed caption text. 
     */
    fontSize: undefined.ClosedCaptionSize;

    /**
     * Gets the font style for closed caption text. 
     */
    fontStyle: undefined.ClosedCaptionStyle;

    /**
     * Gets the region color for closed caption text. 
     */
    regionColor: undefined.ClosedCaptionColor;

    /**
     * Gets the region opacity for closed caption text. 
     */
    regionOpacity: undefined.ClosedCaptionOpacity
}


/**
 * Contains information used to filter an app's content catalog. 
 */
declare class ContentRestrictionsBrowsePolicy {

    /**
     * Gets the region of the user's content restrictions. 
     */
    geographicRegion: string;

    /**
     * Gets the maximum allowed age rating level to show in a content catalog. No content rated above this level should be displayed. For example, if the MaxBrowsableAgeRating is 13, MPAA:R rated movies should not be displayed. 
     */
    maxBrowsableAgeRating: number;

    /**
     * Gets the maximum allowed rating level for content consumption. 
     */
    preferredAgeRating: number
}


/**
 * Contains information about a piece of content. An app creates a RatedContentDescription object, for each piece of content to be used in the GetRestrictionLevelAsync and RequestContentAccessAsync methods. 
 */
declare class RatedContentDescription {

    /**
     * Initializes a new instance of the RatedContentDescription class.
     * @param id The ID of the content, as specified by the app developer.
     * @param title The title of the content.
     * @param category Specifies the type of a piece of content, defined by RatedContentCategory .
     */
    constructor(id: string, title: string, category: undefined.RatedContentCategory): this;

    /**
     * Specifies the type of a piece of content, defined by RatedContentCategory . 
     */
    category: undefined.RatedContentCategory;

    /**
     * The unique content ID of a piece of content, in the app's content catalog. 
     */
    id: string;

    /**
     * The thumbnail image associated with the content. 
     */
    image: undefined.IRandomAccessStreamReference;

    /**
     * Provides all existing third-party and Windows Store age ratings for a piece of content. 
     */
    ratings: undefined.IVector<string>;

    /**
     * The display title of a piece of content. 
     */
    title: string
}


/**
 * Contains all behavior and functionality related to a user's Family Safety content settings. 
 */
declare class RatedContentRestrictions {

    /**
     * Initializes a new instance of the RatedContentRestrictions class. 
     */
    constructor(): this;

    /**
     * Initializes a new instance of the RatedContentRestrictions class, with the specified age rating the app uses, to restrict content usage.
     * @param maxAgeRating The max age rating.
     */
    constructor(maxAgeRating: number): this;

    /**
     * Gets information that is used filter an app's content catalog.
     * @return  Returns a ContentRestrictionsBrowsePolicy object.
     */
    getBrowsePolicyAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ContentRestrictionsBrowsePolicy>;

    /**
     * Gets the policy that applies to a piece of content, for content browsing and consumption.
     * @param RatedContentDescription The rated content info.
     * @return  This method returns these values:
     */
    getRestrictionLevelAsync(
        RatedContentDescription: undefined.RatedContentDescription): undefined.IPromiseWithIAsyncOperation<undefined.ContentAccessRestrictionLevel>;

    /**
     * An event handler to notify apps when there are changes to the user's content settings. 
     */
    onrestrictionschanged: undefined.EventHandler<any>;
    addEventListener(type: "restrictionschanged", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "restrictionschanged", listener: undefined.EventHandler<any>): void;

    /**
     * Determines whether the user is allowed to consume a piece of content.
     * @param RatedContentDescription The rated content info.
     * @return  Returns true, if the user can consume the content. Otherwise, returns false.
     */
    requestContentAccessAsync(
        RatedContentDescription: undefined.RatedContentDescription): undefined.IPromiseWithIAsyncOperation<boolean>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Defines an audio media stream. 
 */
declare class AudioStreamDescriptor {

    /**
     * Creates an instance of AudioStreamDescriptor class using the specified AudioEncodingProperties .
     * @param encodingProperties The encoding properties for the audio stream.
     */
    constructor(encodingProperties: undefined.AudioEncodingProperties): this;

    /**
     * The encoding properties of the stream. 
     */
    encodingProperties: undefined.AudioEncodingProperties;

    /**
     * Specifies whether the stream is currently in use by the MediaStreamSource . 
     */
    isSelected: boolean;

    /**
     * Gets or sets the RFC-1766 language code for the stream. 
     */
    language: string;

    /**
     * Gets or sets the name of the stream. 
     */
    name: string
}


/**
 * Represents an audio track. 
 */
declare class AudioTrack {

    /**
     * Gets or sets the identifier for the audio track. 
     */
    id: string;

    /**
     * Gets or sets the label for the audio track. 
     */
    label: string;

    /**
     * Gets or sets a string indicating the language of the audio track. 
     */
    language: string;

    /**
     * Gets a value indicating the type of data the track contains. For AudioTrack objects, this value is always MediaTrackKind::Audio . 
     */
    trackKind: undefined.MediaTrackKind
}


/**
 * Represents a data cue that can be included in a TimedMetadataTrack . 
 */
declare class DataCue {

    /**
     * Initializes a new instance of the DataCue class. 
     */
    constructor(): this;

    /**
     * Gets the data associated with the cue. 
     */
    data: undefined.IBuffer;

    /**
     * Gets or sets the duration of the cue. 
     */
    duration: number;

    /**
     * Gets the identifier for the timed metadata track. 
     */
    id: string;

    /**
     * Gets the start time of the cue. 
     */
    startTime: number
}


/**
 * Provides data for the FaceDetected event. 
 */
declare class FaceDetectedEventArgs {

    /**
     * Gets the FaceDetectionEffectFrame associated with a FaceDetected event. 
     */
    resultFrame: undefined.FaceDetectionEffectFrame
}


/**
 * Represents an effect that attempts to detect faces in a video stream. 
 */
declare class FaceDetectionEffect {

    /**
     * Gets or sets the time span for which face detection should be performed. 
     */
    desiredDetectionInterval: number;

    /**
     * Gets or sets a value indicating whether face detection is enabled. 
     */
    enabled: boolean;

    /**
     * Occurs when a face is detected. 
     */
    onfacedetected: undefined.TypedEventHandler<undefined.FaceDetectionEffect, undefined.FaceDetectedEventArgs>;
    addEventListener(
        type: "facedetected",
        listener: undefined.TypedEventHandler<undefined.FaceDetectionEffect, undefined.FaceDetectedEventArgs>): void;
    removeEventListener(
        type: "facedetected",
        listener: undefined.TypedEventHandler<undefined.FaceDetectionEffect, undefined.FaceDetectedEventArgs>): void;

    /**
     * Sets properties on the IMediaExtension .
     * @param configuration The property set.
     */
    setProperties(configuration: undefined.IPropertySet): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the definition of a face detection video effect. 
 */
declare class FaceDetectionEffectDefinition {

    /**
     * Initializes a new instance of the FaceDetectionEffectDefinition class. 
     */
    constructor(): this;

    /**
     * Gets a string containing the activatable class ID of the face detection effect definition. 
     */
    activatableClassId: string;

    /**
     * Gets or sets a value that prioritizes the speed of face detection and the quality of detection results. 
     */
    detectionMode: undefined.FaceDetectionMode;

    /**
     * Gets the set of properties for configuring the FaceDetectionEffectDefinition object. 
     */
    properties: undefined.IPropertySet;

    /**
     * Gets or sets a value indicating whether synchronous face detection is enabled. 
     */
    synchronousDetectionEnabled: boolean
}


/**
 * Represents a video frame that includes a list of faces detected by the FaceDetectionEffect . 
 */
declare class FaceDetectionEffectFrame {

    /**
     * Disposes of the object and associated resources. 
     */
    close(): void;

    /**
     * Gets the list of objects representing the faces detected in the frame. 
     */
    detectedFaces: undefined.IVectorView<undefined.DetectedFace>;

    /**
     * Gets or sets the duration of the face detection effect frame. 
     */
    duration: number;

    /**
     * Gets the extended property set which enables getting and setting properties on the media frame. 
     */
    extendedProperties: undefined.IPropertySet;

    /**
     * Gets or sets a value that indicates whether a video frame is the first frame after a gap in the stream. 
     */
    isDiscontinuous: boolean;

    /**
     * Gets a value indicating whether the frame is read-only. 
     */
    isReadOnly: boolean;

    /**
     * Gets or sets the relative time of the frame within the video stream. 
     */
    relativeTime: number;

    /**
     * Gets or sets a timestamp that is relative to the system and is correlatable across multiple media sources on the same device. 
     */
    systemRelativeTime: number;

    /**
     * Gets a string indicating the type of data the frame contains. 
     */
    type: string
}


/**
 * Provides the ability to enable and disable High Dynamic Range (HDR) analysis for the SceneAnalysisEffect . 
 */
declare class HighDynamicRangeControl {

    /**
     * Gets or sets a value that specifies whether High Dynamic Range (HDR) analysis is enabled for the SceneAnalysisEffect . 
     */
    enabled: boolean
}


/**
 * Provides the results of a High Dynamic Range (HDR) analysis operation from the SceneAnalysisEffect . 
 */
declare class HighDynamicRangeOutput {

    /**
     * Gets a value indicating the certainty of the results of the HDR analysis. 
     */
    certainty: number;

    /**
     * Gets a set of FrameController objects representing the suggested frame controllers settings for capturing a variable photo sequence with the High Dynamic Range (HDR) technique. 
     */
    frameControllers: undefined.IVectorView<undefined.FrameController >
}

declare class MediaBinder {

    /**
     * Initializes a new instance of the MediaBinder class. 
     */
    constructor(): this;

    /**
     * Occurs when a media player is ready for the media content to be bound to a MediaSource . Use the handler for this to set the media content for the source by calling SetStream , SetStreamReference , or SetUri . 
     */
    onbinding: undefined.TypedEventHandler<Core$MediaBinder, Core$MediaBindingEventArgs>;
    addEventListener(
        type: "binding",
        listener: undefined.TypedEventHandler<Core$MediaBinder, Core$MediaBindingEventArgs>): void;
    removeEventListener(
        type: "binding",
        listener: undefined.TypedEventHandler<Core$MediaBinder, Core$MediaBindingEventArgs>): void;

    /**
     * Gets the MediaSource object associated with the MediaBinder . 
     */
    source: undefined.MediaSource;

    /**
     * Gets or sets an app-specified string that is used to identify the media content that the app should bind when the Binding event is raised. 
     */
    token: string;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}

declare class MediaBindingEventArgs {

    /**
     * Informs the system that the app might continue to perform work after the Binding event handler returns.
     * @return  The requested deferral.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Gets the MediaBinder associated with the binding event. 
     */
    mediaBinder: undefined.MediaBinder;

    /**
     * Occurs when the binding operation is cancelled. 
     */
    oncanceled: undefined.TypedEventHandler<Core$MediaBindingEventArgs, any>;
    addEventListener(
        type: "canceled",
        listener: undefined.TypedEventHandler<Core$MediaBindingEventArgs, any>): void;
    removeEventListener(
        type: "canceled",
        listener: undefined.TypedEventHandler<Core$MediaBindingEventArgs, any>): void;

    /**
     * Sets the media content to be bound to the MediaSource .
     * @param stream A stream containing the media content.
     * @param contentType A string specifying the content type of the media content.
     */
    setStream(stream: undefined.IRandomAccessStream, contentType: string): void;

    /**
     * Sets the media content to be bound to the MediaSource .
     * @param stream A stream reference containing the media content to be bound.
     * @param contentType A string specifying the content type of the media content.
     */
    setStreamReference(stream: undefined.IRandomAccessStreamReference, contentType: string): void;

    /**
     * Sets the URI of the media content to be bound to the MediaSource .
     * @param uri The URI of the media content to be bound.
     */
    setUri(uri: undefined.Uri): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the TimedMetadataTrack::CueEntered and TimedMetadataTrack::CueExited events. 
 */
declare class MediaCueEventArgs {

    /**
     * Gets the cue that triggered the event. 
     */
    cue: undefined.IMediaCue
}


/**
 * Represents a media source. Provides a common way to reference media from different sources and exposes a common model for accessing media data regardless of the underlying media format. 
 */
declare class MediaSource {

    /**
     * Creates an instance of MediaSource from the provided AdaptiveMediaSource .
     * @param mediaSource The AdaptiveMediaSource from which the MediaSource is created.
     * @return  The new media source.
     */
    createFromAdaptiveMediaSource(mediaSource: undefined.AdaptiveMediaSource): undefined.MediaSource;

    /**
     * Creates an instance of MediaSource from the provided IMediaSource .
     * @param mediaSource The IMediaSource from which the MediaSource is created.
     * @return  The new media source.
     */
    createFromIMediaSource(mediaSource: undefined.IMediaSource): undefined.MediaSource;

    /**
     * Creates an instance of MediaSource from the provided MediaBinder .
     * @param binder The MediaBinder with which the MediaSource is associated.
     * @return  The new media source.
     */
    createFromMediaBinder(binder: undefined.MediaBinder): undefined.MediaSource;

    /**
     * Creates an instance of MediaSource from the provided MediaStreamSource .
     * @param mediaSource The MediaStreamSource from which the MediaSource is created.
     * @return  The new media source.
     */
    createFromMediaStreamSource(mediaSource: undefined.MediaStreamSource): undefined.MediaSource;

    /**
     * Creates an instance of MediaSource from the provided MseStreamSource .
     * @param mediaSource The MediaStreamSource from which the MediaSource is created.
     * @return  The new media source.
     */
    createFromMseStreamSource(mediaSource: undefined.MseStreamSource): undefined.MediaSource;

    /**
     * Creates an instance of MediaSource from the provided IStorageFile .
     * @param file The IStorageFile from which the MediaSource is created.
     * @return  The new media source.
     */
    createFromStorageFile(file: undefined.IStorageFile): undefined.MediaSource;

    /**
     * Creates an instance of MediaSource from the provided IRandomAccessStream .
     * @param stream The stream from which the MediaSource is created.
     * @param contentType The MIME type of the contents of the stream.
     * @return  The new media source.
     */
    createFromStream(
        stream: undefined.IRandomAccessStream,
        contentType: string): undefined.MediaSource;

    /**
     * Creates an instance of MediaSource from the provided IRandomAccessStreamReference .
     * @param stream The stream reference from which the MediaSource is created.
     * @param contentType The MIME type of the contents of the stream.
     * @return  The new media source.
     */
    createFromStreamReference(
        stream: undefined.IRandomAccessStreamReference,
        contentType: string): undefined.MediaSource;

    /**
     * Creates an instance of MediaSource from the provided Uri .
     * @param uri The URI from which the MediaSource is created.
     * @return  The new media source.
     */
    createFromUri(uri: undefined.Uri): undefined.MediaSource;

    /**
     * Closes the MediaSource . 
     */
    close(): void;

    /**
     * Gets a set of properties that can be used to associate app-specific data with a MediaSource . 
     */
    customProperties: undefined.ValueSet;

    /**
     * Gets the duration of the content in the MediaSource . 
     */
    duration: number;

    /**
     * A collection of external timed metadata tracks associated with the MediaSource . 
     */
    externalTimedMetadataTracks: undefined.IObservableVector<undefined.TimedMetadataTrack>;

    /**
     * A collection of external timed text sources associated with the MediaSource . 
     */
    externalTimedTextSources: undefined.IObservableVector<undefined.TimedTextSource>;

    /**
     * Gets a value indicating whether the media source is currently open. 
     */
    isOpen: boolean;

    /**
     * Occurs when a MediaSource open operation completes. 
     */
    onopenoperationcompleted: undefined.TypedEventHandler<undefined.MediaSource, undefined.MediaSourceOpenOperationCompletedEventArgs>;
    addEventListener(
        type: "openoperationcompleted",
        listener: undefined.TypedEventHandler<undefined.MediaSource, undefined.MediaSourceOpenOperationCompletedEventArgs>): void;
    removeEventListener(
        type: "openoperationcompleted",
        listener: undefined.TypedEventHandler<undefined.MediaSource, undefined.MediaSourceOpenOperationCompletedEventArgs>): void;

    /**
     * Occurs when the current state of the MediaSource changes. 
     */
    onstatechanged: undefined.TypedEventHandler<undefined.MediaSource, Core$MediaSourceStateChangedEventArgs>;
    addEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.MediaSource, Core$MediaSourceStateChangedEventArgs>): void;
    removeEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.MediaSource, Core$MediaSourceStateChangedEventArgs>): void;

    /**
     * Resets the internal state of the MediaSource . 
     */
    reset(): void;

    /**
     * Gets the current state of the MediaSource . 
     */
    state: undefined.MediaSourceState;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an error that occurred with a MediaSource . 
 */
declare class MediaSourceError {

    /**
     * Gets the extended error code for the MediaSourceError . 
     */
    extendedError: Windows$WinRTError
}


/**
 * Provides data for the MediaSource::MediaSourceOpenOperationCompleted event. 
 */
declare class MediaSourceOpenOperationCompletedEventArgs {

    /**
     * Represents the error that occurred while asynchronously opening the MediaSource . 
     */
    error: undefined.MediaSourceError
}

declare class MediaSourceStateChangedEventArgs {

    /**
     * Gets the new current state of the MediaSource . 
     */
    newState: undefined.MediaSourceState;

    /**
     * Gets the previous state of the MediaSource before the state changed. 
     */
    oldState: undefined.MediaSourceState
}


/**
 * Represents a media sample used by the MediaStreamSource . 
 */
declare class MediaStreamSample {

    /**
     * Creates a MediaStreamSample from an IBuffer .
     * @param buffer The buffer that contains the media data used to create the MediaStreamSample .
     * @param timestamp The presentation time of this sample.
     * @return  The sample created from the data in buffer.
     */
    createFromBuffer(buffer: undefined.IBuffer, timestamp: number): undefined.MediaStreamSample;

    /**
     * Asynchronously creates a MediaStreamSample from an IInputStream .
     * @param stream The stream that contains the media data used to create the MediaStreamSample .
     * @param count The length of the data in the sample. This is the number of bytes that will be read from stream.
     * @param timestamp The presentation time of this MediaStreamSample .
     * @return  When this method completes, it returns the new file as a MediaStreamSample .
     */
    createFromStreamAsync(
        stream: undefined.IInputStream,
        count: number,
        timestamp: number): undefined.IPromiseWithIAsyncOperation<undefined.MediaStreamSample>;

    /**
     * Gets the buffer which encapsulates the MediaStreamSample data. 
     */
    buffer: undefined.Buffer;

    /**
     * Gets and sets the decode timestamp for this MediaStreamSample . 
     */
    decodeTimestamp: number;

    /**
     * Gets or sets a value to indicate that the previous MediaStreamSample in the sequence is missing. 
     */
    discontinuous: boolean;

    /**
     * Gets the duration of the sample. 
     */
    duration: number;

    /**
     * Gets the extended property set which enables getting and setting properties on the MediaStreamSample . 
     */
    extendedProperties: undefined.MediaStreamSamplePropertySet;

    /**
     * Gets or sets a value that indicates the MediaStreamSample contains a keyframe. 
     */
    keyFrame: boolean;

    /**
     * Occurs when the MediaStreamSample has been processed by the media pipeline. 
     */
    onprocessed: undefined.TypedEventHandler<undefined.MediaStreamSample, any>;
    addEventListener(
        type: "processed",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSample, any>): void;
    removeEventListener(
        type: "processed",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSample, any>): void;

    /**
     * Gets a MediaStreamSampleProtectionProperties object, which is used for getting and setting properties that are specific to the Digital Rights Management (DRM) protection of the MediaStreamSample . 
     */
    protection: undefined.MediaStreamSampleProtectionProperties;

    /**
     * Gets the time at which a sample should be rendered. This is also referred to as the presentation time. 
     */
    timestamp: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains properties for the MediaStreamSample . 
 */
declare class MediaStreamSamplePropertySet {

    /**
     * Removes all items from the property set. 
     */
    clear(): void;

    /**
     * Returns an iterator to enumerate the items in the property set.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Gets an immutable view of the property set.
     * @return  The immutable view.
     */
    getView(): undefined.IMapView<string, any>;

    /**
     * Indicates if the specified key exists in the property set.
     * @param key The key to check.
     * @return  true if the key exists; otherwise, false.
     */
    hasKey(key: string): boolean;

    /**
     * Adds the specified key and value to the property set.
     * @param key The key to add.
     * @param value The value of the key.
     * @return  True if the method replaces a value that already exists for the key; false if this is a new key.
     */
    insert(key: string, value: any): boolean;

    /**
     * Retrieves the value for the specified key.
     * @param key The key to retrieve the value for.
     * @return  The value, if an item with the specified key exists; otherwise, null.
     */
    lookup(key: string): any;

    /**
     * Removes an item from the property set.
     * @param key The key to remove.
     */
    remove(key: string): void;

    /**
     * Gets the number of items contained in the property set. 
     */
    size: number
}


/**
 * Represents a collection properties that are specific to the Digital Rights Management (DRM) protection of the MediaStreamSample . 
 */
declare class MediaStreamSampleProtectionProperties {

    /**
     * Gets the Digital Rights Management (DRM) initialization vector from the MediaStreamSample .
     * @return  The initialization vector.
     */
    getInitializationVector(): number[];

    /**
     * Gets the Digital Rights Management (DRM) key identifier from the MediaStreamSample .
     * @return  Receives the key identifier used to decrypt the data.
     */
    getKeyIdentifier(): number[];

    /**
     * Gets the Digital Rights Management (DRM) sub-sample mapping from the MediaStreamSample .
     * @return  Receives the sub-sample mapping.
     */
    getSubSampleMapping(): number[];

    /**
     * Sets the Digital Rights Management (DRM) initialization vector for the MediaStreamSample .
     * @param value The value to set the DRM initialization vector to.
     */
    setInitializationVector(value: number[]): void;

    /**
     * Sets the Digital Rights Management (DRM) key identifier for the MediaStreamSample .
     * @param value The value to set the DRM key identifier to.
     */
    setKeyIdentifier(value: number[]): void;

    /**
     * Sets the Digital Rights Management (DRM) sub-sample mapping for the MediaStreamSample .
     * @param value The value to set the DRM sub-sample mapping to.
     */
    setSubSampleMapping(value: number[]): void
}


/**
 * Represents a media source that delivers media samples directly to the media pipeline. 
 */
declare class MediaStreamSource {

    /**
     * Creates an instance of MediaStreamSource from the specified IMediaStreamDescriptor .
     * @param descriptor The AudioStreamDescriptor or VideoStreamDescriptor to create the MediaStreamSource from.
     */
    constructor(descriptor: undefined.IMediaStreamDescriptor): this;

    /**
     * Creates an instance of MediaStreamSource from two IMediaStreamDescriptor objects.
     * @param descriptor The first AudioStreamDescriptor or VideoStreamDescriptor to create the MediaStreamSource from.
     * @param descriptor2 The second AudioStreamDescriptor or VideoStreamDescriptor to create the MediaStreamSource from.
     */
    constructor(descriptor: undefined.IMediaStreamDescriptor, descriptor2: undefined.IMediaStreamDescriptor): this;

    /**
     * Adds a Digital Rights Management (DRM) protection key which is used by the MediaProtectionManager to encrypt and decrypt the specified stream.
     * @param streamDescriptor The stream the key is used to encrypt and decrypt.
     * @param keyIdentifier The key used to encrypt and decrypt the stream.
     * @param licenseData The DRM licence for the media.
     */
    addProtectionKey(
        streamDescriptor: undefined.IMediaStreamDescriptor,
        keyIdentifier: number[],
        licenseData: number[]): void;

    /**
     * Adds a new stream descriptor to the MediaStreamSource .
     * @param descriptor The descriptor to add.
     */
    addStreamDescriptor(descriptor: undefined.IMediaStreamDescriptor): void;

    /**
     * Gets or sets the amount of data that is buffered by the MediaStreamSource . 
     */
    bufferTime: number;

    /**
     * Gets or sets whether or not the application supports changing its position in the media time-line. 
     */
    canSeek: boolean;

    /**
     * Gets or sets the duration of the media time-line. 
     */
    duration: number;

    /**
     * Gets or sets the Digital Rights Management (DRM) MediaProtectionManager used to protect the media. 
     */
    mediaProtectionManager: undefined.MediaProtectionManager;

    /**
     * Gets the music properties which are used for musicrelated metadata. 
     */
    musicProperties: undefined.MusicProperties;

    /**
     * Notifies the MediaStreamSource that an error has occurred which is preventing the application from continuing to deliver data to the MediaStreamSource.
     * @param errorStatus The cause of the error.
     */
    notifyError(errorStatus: undefined.MediaStreamSourceErrorStatus): void;

    /**
     * Occurs when the MediaStreamSource is shutting down. 
     */
    onclosed: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceClosedEventArgs>;
    addEventListener(
        type: "closed",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceClosedEventArgs>): void;
    removeEventListener(
        type: "closed",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceClosedEventArgs>): void;

    /**
     * Occurs when the MediaStreamSource is paused and stops requesting MediaStreamSample objects for an unspecified period of time, but is expected to resume requesting MediaStreamSample objects from the current position. 
     */
    onpaused: undefined.TypedEventHandler<undefined.MediaStreamSource, any>;
    addEventListener(
        type: "paused",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSource, any>): void;
    removeEventListener(
        type: "paused",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSource, any>): void;

    /**
     * Occurs when the MediaStreamSource request a MediaStreamSample for a specified stream. 
     */
    onsamplerequested: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceSampleRequestedEventArgs>;
    addEventListener(
        type: "samplerequested",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceSampleRequestedEventArgs>): void;
    removeEventListener(
        type: "samplerequested",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceSampleRequestedEventArgs>): void;

    /**
     * Occurs when the MediaStreamSource is ready to start requesting MediaStreamSample objects. The event can specify a position in the media time-line from which the first MediaStreamSample should be delivered. 
     */
    onstarting: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceStartingEventArgs>;
    addEventListener(
        type: "starting",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceStartingEventArgs>): void;
    removeEventListener(
        type: "starting",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceStartingEventArgs>): void;

    /**
     * Occurs when the MediaStreamSource will stop requesting MediaStreamSample objects for a certain stream and will start requesting MediaStreamSample objects from a different stream instead. 
     */
    onswitchstreamsrequested: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceSwitchStreamsRequestedEventArgs>;
    addEventListener(
        type: "switchstreamsrequested",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceSwitchStreamsRequestedEventArgs>): void;
    removeEventListener(
        type: "switchstreamsrequested",
        listener: undefined.TypedEventHandler<undefined.MediaStreamSource, undefined.MediaStreamSourceSwitchStreamsRequestedEventArgs>): void;

    /**
     * Sets the range of data that the application is currently buffering.
     * @param startOffset The smallest time stamp of a MediaStreamSample buffered by the application.
     * @param endOffset The largest time stamp of a MediaStreamSample buffered by the application.
     */
    setBufferedRange(startOffset: number, endOffset: number): void;

    /**
     * Gets or sets the thumbnail which is a reference to a stream for a video thumbnail image or music album art. 
     */
    thumbnail: undefined.IRandomAccessStreamReference;

    /**
     * Gets the video properties which are used for video related metadata. 
     */
    videoProperties: undefined.VideoProperties;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the MediaStreamSource.Closed event. 
 */
declare class MediaStreamSourceClosedEventArgs {

    /**
     * Gets the object that represents the notification that the MediaStreamSource has been closed. 
     */
    request: undefined.MediaStreamSourceClosedRequest
}


/**
 * Represents an object to be used by the MediaStreamSource.closed event to provide information to the application. 
 */
declare class MediaStreamSourceClosedRequest {

    /**
     * Gets the reason why the media stream source was closed. 
     */
    reason: undefined.MediaStreamSourceClosedReason
}


/**
 * Represents an object to be used by the MediaStreamSource.SampleRequest event to provide information to the application. 
 */
declare class MediaStreamSourceSampleRequest {

    /**
     * Defers assigning a MediaStreamSample to MediaStreamSourceSampleRequest object.
     * @return  The deferral.
     */
    getDeferral(): undefined.MediaStreamSourceSampleRequestDeferral;

    /**
     * Provides a status update to the MediaStreamSource while the application is temporarily unable to deliver a requested MediaStreamSample .
     * @param progress A value between 0 to 100 that indicates the progress towards being able to deliver the requested MediaStreamSample .
     */
    reportSampleProgress(progress: number): void;

    /**
     * Sets the MediaStreamSample requested by the MediaStreamSource . Applications deliver a MediaStreamSample to the MediaStreamSource by assigning a value to this property. 
     */
    sample: undefined.MediaStreamSample;

    /**
     * Gets the IMediaStreamDescriptor interface of the stream for which a MediaStreamSample is being requested. 
     */
    streamDescriptor: undefined.IMediaStreamDescriptor
}


/**
 * Provides a way for the application to asynchronously report that it has completed retrieving the MediaStreamSample . 
 */
declare class MediaStreamSourceSampleRequestDeferral {

    /**
     * Reports that the application has completed retrieving the MediaStreamSample . 
     */
    complete(): void
}


/**
 * Provides the data for the SampleRequested event. 
 */
declare class MediaStreamSourceSampleRequestedEventArgs {

    /**
     * Gets the object that represents the request for a MediaStreamSample . 
     */
    request: undefined.MediaStreamSourceSampleRequest
}


/**
 * Provides data for the MediaStreamSource.Starting event. 
 */
declare class MediaStreamSourceStartingEventArgs {

    /**
     * Gets the object that represents the request to start accumulating MediaStreamSample data. 
     */
    request: undefined.MediaStreamSourceStartingRequest
}


/**
 * Represents a request from the MediaStreamSource.Starting event for the application to start accumulating MediaStreamSample objects from a specific position in the media. 
 */
declare class MediaStreamSourceStartingRequest {

    /**
     * Defers completing the MediaStreamSource.Starting event.
     * @return  The deferral.
     */
    getDeferral(): undefined.MediaStreamSourceStartingRequestDeferral;

    /**
     * Specifies the starting position in the media time-line for subsequent MediaStreamSamples that will be delivered to the MediaStreamSource .
     * @param position The actual starting point in the media time-line chosen by the application.
     */
    setActualStartPosition(position: number): void;

    /**
     * Specifies a reference to a TimeSpan object which represents a time position in the media time-line from which the application should return MediaStreamSample objects. 
     */
    startPosition: number
}


/**
 * Provides a way for the application to asynchronously report that it has completed processing the MediaStreamSource.Starting event. 
 */
declare class MediaStreamSourceStartingRequestDeferral {

    /**
     * Reports that the application has completed processing the Starting event. 
     */
    complete(): void
}


/**
 * Represents an object to be used by the MediaStreamSource.SwitchStreamsRequest event to provide information to the application. 
 */
declare class MediaStreamSourceSwitchStreamsRequest {

    /**
     * Defers completing the MediaStreamSource.SwitchStreamsRequested event.
     * @return  The deferral.
     */
    getDeferral(): undefined.MediaStreamSourceSwitchStreamsRequestDeferral;

    /**
     * Gets the stream descriptor for the stream that is now selected by the MediaStreamSource . 
     */
    newStreamDescriptor: undefined.IMediaStreamDescriptor;

    /**
     * Gets the stream descriptor for the stream which is no longer selected by the MediaStreamSource . 
     */
    oldStreamDescriptor: undefined.IMediaStreamDescriptor
}


/**
 * Provides a way for the application to asynchronously report that it has completed the MediaStreamSource.SwitchStreamsRequested event. 
 */
declare class MediaStreamSourceSwitchStreamsRequestDeferral {

    /**
     * Reports that the application has completed processing the MediaStreamSource.SwitchStreamsRequested event. 
     */
    complete(): void
}


/**
 * Provides data for the MediaStreamSource.SwitchStreamsRequested event. 
 */
declare class MediaStreamSourceSwitchStreamsRequestedEventArgs {

    /**
     * Gets the object that represents the request to switch the streams. 
     */
    request: undefined.MediaStreamSourceSwitchStreamsRequest
}


/**
 * Represents an effect that analyzes video frames to determine if any of the supported variable photo sequence capture techniques may produce a higher-quality captured image. 
 */
declare class SceneAnalysisEffect {

    /**
     * Gets or sets the duration of the time window during which video frames are analyzed. 
     */
    desiredAnalysisInterval: number;

    /**
     * Gets or sets a HighDynamicRangeControl object that is used to enable or disable High Dynamic Range (HDR) analysis. 
     */
    highDynamicRangeAnalyzer: undefined.HighDynamicRangeControl;

    /**
     * Raised when the scene analysis is complete. 
     */
    onsceneanalyzed: undefined.TypedEventHandler<undefined.SceneAnalysisEffect, undefined.SceneAnalyzedEventArgs>;
    addEventListener(
        type: "sceneanalyzed",
        listener: undefined.TypedEventHandler<undefined.SceneAnalysisEffect, undefined.SceneAnalyzedEventArgs>): void;
    removeEventListener(
        type: "sceneanalyzed",
        listener: undefined.TypedEventHandler<undefined.SceneAnalysisEffect, undefined.SceneAnalyzedEventArgs>): void;

    /**
     * Sets properties on the IMediaExtension .
     * @param configuration The property set.
     */
    setProperties(configuration: undefined.IPropertySet): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the definition of a scene analysis video effect. 
 */
declare class SceneAnalysisEffectDefinition {

    /**
     * Initializes a new instance of the SceneAnalysisEffectDefinition class. 
     */
    constructor(): this;

    /**
     * Gets a string containing the activatable class ID of the scene analysis effect definition. 
     */
    activatableClassId: string;

    /**
     * Gets the set of properties for configuring the SceneAnalysisEffectDefinition object. 
     */
    properties: undefined.IPropertySet
}


/**
 * Represents a video frame that includes the results of the scene analysis operation. 
 */
declare class SceneAnalysisEffectFrame {

    /**
     * Disposes of the object and associated resources. 
     */
    close(): void;

    /**
     * Gets or sets the duration of the scene analysis effect frame. 
     */
    duration: number;

    /**
     * Gets the extended property set which enables getting and setting properties on the media frame. 
     */
    extendedProperties: undefined.IPropertySet;

    /**
     * Gets a CapturedFrameControlValues object that indicates the capture settings used for the frame. 
     */
    frameControlValues: undefined.CapturedFrameControlValues;

    /**
     * Gets a HighDynamicRangeOutput object that provides recommended FrameController objects and a value indicating the certainty of the HDR analysis. 
     */
    highDynamicRange: undefined.HighDynamicRangeOutput;

    /**
     * Gets or sets a value that indicates whether a video frame is the first frame after a gap in the stream. 
     */
    isDiscontinuous: boolean;

    /**
     * Gets a value indicating whether the frame is read-only. 
     */
    isReadOnly: boolean;

    /**
     * Gets or sets the relative time of the frame within the video stream. 
     */
    relativeTime: number;

    /**
     * Gets or sets a timestamp that is relative to the system and is correlatable across multiple media sources on the same device. 
     */
    systemRelativeTime: number;

    /**
     * Gets a string indicating the type of data the frame contains. 
     */
    type: string
}


/**
 * Provides data for the SceneAnalysisEffect::SceneAnalyzed event. 
 */
declare class SceneAnalyzedEventArgs {

    /**
     * Gets the result frame from the scene analysis operation. 
     */
    resultFrame: undefined.SceneAnalysisEffectFrame
}


/**
 * Represents a timed metadata track. The track contains a list of IMediaCue objects and raises events at the beginning and end of the time window of each cue. 
 */
declare class TimedMetadataTrack {

    /**
     * Initializes a new instance of the TimedMetadataTrack class.
     * @param id An identifier for the new timed metadata track.
     * @param language A string indicating the language of the new timed metadata track.
     * @param kind A value indicating the kind of metadata contained in the new track.
     */
    constructor(id: string, language: string, kind: undefined.TimedMetadataKind): this;

    /**
     * Gets the list of media cues in the TimedMetadataTrack that are currently active. A cue is considered active after its StartTime has been reached until its Duration has been exceeded. 
     */
    activeCues: undefined.IVectorView<undefined.IMediaCue>;

    /**
     * Adds the specified media cue to the TimedMetadataTrack .
     * @param cue The media cue to add.
     */
    addCue(cue: undefined.IMediaCue): void;

    /**
     * Gets a read-only list of the media cues in the TimedMetadataTrack . 
     */
    cues: undefined.IVectorView<undefined.IMediaCue>;

    /**
     * Gets the custom string value containing routing information for cues. 
     */
    dispatchType: string;

    /**
     * Gets the identifier for the timed metadata track. 
     */
    id: string;

    /**
     * Gets or sets the label for the timed metadata track. 
     */
    label: string;

    /**
     * Gets a string indicating the language of the timed metadata track. 
     */
    language: string;

    /**
     * Occurs when a media time window of a media cue is entered. The time window is defined by the StartTime and Duration of the cue. 
     */
    oncueentered: undefined.TypedEventHandler<undefined.TimedMetadataTrack, undefined.MediaCueEventArgs>;
    addEventListener(
        type: "cueentered",
        listener: undefined.TypedEventHandler<undefined.TimedMetadataTrack, undefined.MediaCueEventArgs>): void;
    removeEventListener(
        type: "cueentered",
        listener: undefined.TypedEventHandler<undefined.TimedMetadataTrack, undefined.MediaCueEventArgs>): void;

    /**
     * Occurs when a media time window of a media cue is exited. The time window is defined by the StartTime and Duration of the cue. 
     */
    oncueexited: undefined.TypedEventHandler<undefined.TimedMetadataTrack, undefined.MediaCueEventArgs>;
    addEventListener(
        type: "cueexited",
        listener: undefined.TypedEventHandler<undefined.TimedMetadataTrack, undefined.MediaCueEventArgs>): void;
    removeEventListener(
        type: "cueexited",
        listener: undefined.TypedEventHandler<undefined.TimedMetadataTrack, undefined.MediaCueEventArgs>): void;

    /**
     * Raised when an error occurs with the TimedMetadataTrack . 
     */
    ontrackfailed: undefined.TypedEventHandler<undefined.TimedMetadataTrack, undefined.TimedMetadataTrackFailedEventArgs>;
    addEventListener(
        type: "trackfailed",
        listener: undefined.TypedEventHandler<undefined.TimedMetadataTrack, undefined.TimedMetadataTrackFailedEventArgs>): void;
    removeEventListener(
        type: "trackfailed",
        listener: undefined.TypedEventHandler<undefined.TimedMetadataTrack, undefined.TimedMetadataTrackFailedEventArgs>): void;

    /**
     * Removes the specified media cue from the TimedMetadataTrack .
     * @param cue The media cue to remove.
     */
    removeCue(cue: undefined.IMediaCue): void;

    /**
     * Gets a value indicating the kind of metadata contained in the track. 
     */
    timedMetadataKind: undefined.TimedMetadataKind;

    /**
     * Gets a value specifying the type of the media track. For TimedMetadataTrack this value will always be MediaTrackKind::TimedMetadata . 
     */
    trackKind: undefined.MediaTrackKind;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides information about an error that occurred with a timed metadata track. 
 */
declare class TimedMetadataTrackError {

    /**
     * Gets the error code associated with the timed metadata track error. 
     */
    errorCode: undefined.TimedMetadataTrackErrorCode;

    /**
     * Gets the extended error code for the TimedMetadataTrackError . 
     */
    extendedError: Windows$WinRTError
}


/**
 * Provides data for the TimedMetadataTrack::TrackFailed event. 
 */
declare class TimedMetadataTrackFailedEventArgs {

    /**
     * Gets an object representing the error that occurred with the timed metadata track. 
     */
    error: undefined.TimedMetadataTrackError
}


/**
 * Represents a text cue in a TimedMetadataTrack . 
 */
declare class TimedTextCue {

    /**
     * Initializes a new instance of the TimedTextCue class. 
     */
    constructor(): this;

    /**
     * Gets or sets the TimedTextRegion of the cue, which defines the style of the rendering area for the cue. 
     */
    cueRegion: undefined.TimedTextRegion;

    /**
     * Gets or sets the TimedTextStyle of the cue, which defines the style of the rendered text. 
     */
    cueStyle: undefined.TimedTextStyle;

    /**
     * Gets or sets the duration of the cue. 
     */
    duration: number;

    /**
     * Gets or sets an identifier for the cue. 
     */
    id: string;

    /**
     * Gets the collection of TimedTextLine objects that convey the text of the cue. 
     */
    lines: undefined.IVector<undefined.TimedTextLine>;

    /**
     * Gets the start time of the cue. 
     */
    startTime: number
}


/**
 * Represents a line of text that is displayed with a TimedTextCue . 
 */
declare class TimedTextLine {

    /**
     * Initializes a new instance of the TimedTextLine class. 
     */
    constructor(): this;

    /**
     * Gets a list of TimedTextSubformat objects that provide formatting for substrings within the TimedTextLine . 
     */
    subformats: undefined.IVector<undefined.TimedTextSubformat>;

    /**
     * Gets or sets the text content of the TimedTextLine . 
     */
    text: string
}


/**
 * Exposes properties for customizing the appearance of the rendering area of a TimedTextCue . 
 */
declare class TimedTextRegion {

    /**
     * Initializes a new instance of the TimedTextRegion class. 
     */
    constructor(): this;

    /**
     * Gets or sets the background color of the TimedTextRegion . 
     */
    background: undefined.Color;

    /**
     * Gets or sets the display alignment of the TimedTextRegion . 
     */
    displayAlignment: undefined.TimedTextDisplayAlignment;

    /**
     * Gets or sets the extent of the TimedTextRegion , which is the rendered size of the region either in pixels or in percentage of available space. 
     */
    extent: undefined.TimedTextSize;

    /**
     * Gets or sets a value indicating whether text overflowing the region is clipped. 
     */
    isOverflowClipped: boolean;

    /**
     * Gets or sets a value that indicates the height of each line of content. 
     */
    lineHeight: undefined.TimedTextDouble;

    /**
     * Gets or sets a string representing the name of the TimedTextRegion . 
     */
    name: string;

    /**
     * Gets or sets a value that indicates the thickness of padding space between the boundaries of the content area and the content displayed by a TimedTextRegion . 
     */
    padding: undefined.TimedTextPadding;

    /**
     * Gets or sets the position of the TimedTextRegion , relative to the top left corner of the video frame. 
     */
    position: undefined.TimedTextPoint;

    /**
     * Gets a value indicating the method in which lines of text scroll through the region. 
     */
    scrollMode: undefined.TimedTextScrollMode;

    /**
     * Gets or sets a value indicating whether text wraps when it reaches the edge of the TimedTextRegion . 
     */
    textWrapping: undefined.TimedTextWrapping;

    /**
     * Gets or sets a value indicating the direction that text flows within the TimedTextRegion . 
     */
    writingMode: undefined.TimedTextWritingMode;

    /**
     * Gets or sets the Z-order of the TimedTextRegion , relative to other active regions on the screen, in case they overlap. 
     */
    zindex: number
}


/**
 * Represents a source of timed text data. 
 */
declare class TimedTextSource {

    /**
     * Creates a new instance of TimedTextSource from the provided stream.
     * @param stream The stream from which the timed text source is created.
     * @return  The new timed text source.
     */
    createFromStream(stream: undefined.IRandomAccessStream): undefined.TimedTextSource;

    /**
     * Creates a new instance of TimedTextSource with the specified default language from the provided stream.
     * @param stream The stream from which the timed text source is created.
     * @param defaultLanguage A string specifying the default language for the timed text source.
     * @return  The new timed text source.
     */
    createFromStream(
        stream: undefined.IRandomAccessStream,
        defaultLanguage: string): undefined.TimedTextSource;

    /**
     * Creates a new instance of TimedTextSource from the provided URI.
     * @param uri The URI from which the timed text source is created.
     * @return  The new timed text source.
     */
    createFromUri(uri: undefined.Uri): undefined.TimedTextSource;

    /**
     * Creates a new instance of TimedTextSource with the specified default language from the provided URI.
     * @param uri The URI from which the timed text source is created.
     * @param defaultLanguage A string specifying the default language for the timed text source.
     * @return  The new timed text source.
     */
    createFromUri(uri: undefined.Uri, defaultLanguage: string): undefined.TimedTextSource;

    /**
     * Occurs when the TimedTextSource is resolved. 
     */
    onresolved: undefined.TypedEventHandler<undefined.TimedTextSource, undefined.TimedTextSourceResolveResultEventArgs>;
    addEventListener(
        type: "resolved",
        listener: undefined.TypedEventHandler<undefined.TimedTextSource, undefined.TimedTextSourceResolveResultEventArgs>): void;
    removeEventListener(
        type: "resolved",
        listener: undefined.TypedEventHandler<undefined.TimedTextSource, undefined.TimedTextSourceResolveResultEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the TimedTextSource::Resolved event. 
 */
declare class TimedTextSourceResolveResultEventArgs {

    /**
     * Gets an object representing the asynchronous error that occurred when the TimedTextSource was resolved. 
     */
    error: undefined.TimedMetadataTrackError;

    /**
     * Gets the list of TimedMetadataTrack objects resulting from resolving the TimedTextSource . 
     */
    tracks: undefined.IVectorView<undefined.TimedMetadataTrack >
}


/**
 * Defines the style of the rendered text in a TimedTextCue . You can set the style of a substring within a TimedTextLine by using the Subformats property. 
 */
declare class TimedTextStyle {

    /**
     * Initializes a new instance of the TimedTextStyle class. 
     */
    constructor(): this;

    /**
     * Gets or sets the background color of timed text. 
     */
    background: undefined.Color;

    /**
     * Gets or sets a value indicating the direction that timed text is flowed. 
     */
    flowDirection: undefined.TimedTextFlowDirection;

    /**
     * Gets or sets the font family of timed text. 
     */
    fontFamily: string;

    /**
     * Gets or sets the font size of timed text. 
     */
    fontSize: undefined.TimedTextDouble;

    /**
     * Gets or sets the weight of timed text. 
     */
    fontWeight: undefined.TimedTextWeight;

    /**
     * Gets or sets the color of the timed text glyphs. 
     */
    foreground: undefined.Color;

    /**
     * Gets or sets a value indicating if the background color stays visible when no text is being displayed. 
     */
    isBackgroundAlwaysShown: boolean;

    /**
     * Gets or sets the alignment of timed text lines. 
     */
    lineAlignment: undefined.TimedTextLineAlignment;

    /**
     * Gets or sets the name of the timed text style. 
     */
    name: string;

    /**
     * Gets or sets the outline color of timed text. 
     */
    outlineColor: undefined.Color;

    /**
     * Gets or sets the radius of the blur applied to outline of the timed text. 
     */
    outlineRadius: undefined.TimedTextDouble;

    /**
     * Gets or sets the thickness of the outline of the timed text. 
     */
    outlineThickness: undefined.TimedTextDouble
}


/**
 * Defines a TimedTextStyle for a substring in a TimedTextLine . of the cue, which defines the style of the rendered text. 
 */
declare class TimedTextSubformat {

    /**
     * Initializes a new instance of the TimedTextSubformat class. 
     */
    constructor(): this;

    /**
     * Gets or sets the length of the substring to which the SubformatStyle applies. 
     */
    length: number;

    /**
     * Gets or sets the staring index of the substring to which the SubformatStyle applies. 
     */
    startIndex: number;

    /**
     * Gets or sets the TimedTextStyle object that conveys the formatting of a substring in a TimedTextLine . 
     */
    subformatStyle: undefined.TimedTextStyle
}


/**
 * Represents an effect that stabilizes a video stream. 
 */
declare class VideoStabilizationEffect {

    /**
     * Gets or sets a value indicating whether video stabilization is enabled. 
     */
    enabled: boolean;

    /**
     * Gets the recommended video stream configuration for video stabilization, given the specified video device controller and encoding properties.
     * @param controller The video device controller.
     * @param desiredProperties The encoding properties.
     * @return  An object representing the optimal video stream configuration for video stabilization.
     */
    getRecommendedStreamConfiguration(
        controller: undefined.VideoDeviceController,
        desiredProperties: undefined.VideoEncodingProperties): undefined.VideoStreamConfiguration;

    /**
     * Occurs when the value of the VideoStabilizationEffect::Enabled property changes. 
     */
    onenabledchanged: undefined.TypedEventHandler<undefined.VideoStabilizationEffect, undefined.VideoStabilizationEffectEnabledChangedEventArgs>;
    addEventListener(
        type: "enabledchanged",
        listener: undefined.TypedEventHandler<undefined.VideoStabilizationEffect, undefined.VideoStabilizationEffectEnabledChangedEventArgs>): void;
    removeEventListener(
        type: "enabledchanged",
        listener: undefined.TypedEventHandler<undefined.VideoStabilizationEffect, undefined.VideoStabilizationEffectEnabledChangedEventArgs>): void;

    /**
     * Sets properties on the IMediaExtension .
     * @param configuration The property set.
     */
    setProperties(configuration: undefined.IPropertySet): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the definition of a video stabilization effect. 
 */
declare class VideoStabilizationEffectDefinition {

    /**
     * Initializes a new instance of the VideoStabilizationEffectDefinition class. 
     */
    constructor(): this;

    /**
     * Gets a string containing the activatable class ID of the video stabilization effect definition. 
     */
    activatableClassId: string;

    /**
     * Gets the set of properties for configuring the VideoStabilizationEffectDefinition object. 
     */
    properties: undefined.IPropertySet
}


/**
 * Provides data for the VideoStabilizationEffect::EnabledChanged event. 
 */
declare class VideoStabilizationEffectEnabledChangedEventArgs {

    /**
     * Gets a value indicating the reason why the VideoStabilizationEffect::Enabled property changed. 
     */
    reason: undefined.VideoStabilizationEffectEnabledChangedReason
}


/**
 * Defines an video media stream. 
 */
declare class VideoStreamDescriptor {

    /**
     * Creates an instance of the VideoEncodingProperties class using the specified video encoding.
     * @param encodingProperties The encoding properties for the video stream.
     */
    constructor(encodingProperties: undefined.VideoEncodingProperties): this;

    /**
     * Gets the encoding properties on the video stream. 
     */
    encodingProperties: undefined.VideoEncodingProperties;

    /**
     * Specifies whether the stream is currently in use by the MediaStreamSource . 
     */
    isSelected: boolean;

    /**
     * Gets or sets the RFC-1766 language code for the stream. 
     */
    language: string;

    /**
     * Gets or sets the name of the stream. 
     */
    name: string
}


/**
 * Represents a video track. 
 */
declare class VideoTrack {

    /**
     * Gets or sets the identifier for the video track. 
     */
    id: string;

    /**
     * Gets or sets the label for the video track. 
     */
    label: string;

    /**
     * Gets or sets a string indicating the language of the video track. 
     */
    language: string;

    /**
     * Gets a value indicating the type of data the track contains. For VideoTrack objects, this value is always MediaTrackKind::Video . 
     */
    trackKind: undefined.MediaTrackKind
}


/**
 * Represents a media source that delivers media samples to a media pipeline. 
 */
declare interface Core$IMediaSource {}


/**
 * Defines the interface implemented by all media cues. 
 */
declare interface Core$IMediaCue {

    /**
     * Gets or sets the duration of the media cue. 
     */
    duration: number,

        /**
         * Gets or sets the identifier for the media cue. 
         */
        id: string,

        /**
         * Gets or sets the start time of the media cue. 
         */
        startTime: number
}


/**
 * Defines a media stream. 
 */
declare interface Core$IMediaStreamDescriptor {

    /**
     * Specifies whether the stream is currently in use by the MediaStreamSource . 
     */
    isSelected: boolean,

        /**
         * Gets or sets the RFC-1766 language code for the stream. 
         */
        language: string,

        /**
         * Gets or sets the name of the stream. 
         */
        name: string
}


/**
 * Represents a size that is used to convey the values of timed text style properties. 
 */
declare interface Core$TimedTextSize {

    /**
     * The height. 
     */
    height: number,

        /**
         * The units of the size, either pixels or percentage. 
         */
        unit: undefined.TimedTextUnit,

        /**
         * The width. 
         */
        width: number
}


/**
 * Represents a floating point value that is used to convey the values of timed text style properties. 
 */
declare interface Core$TimedTextDouble {

    /**
     * The units of the value, either pixels or percentage. 
     */
    unit: undefined.TimedTextUnit,

        /**
         * The value. 
         */
        value: number
}


/**
 * Represents the size of padding around a timed text region. 
 */
declare interface Core$TimedTextPadding {

    /**
     * The padding after the timed text region. 
     */
    after: number,

        /**
         * The padding before the timed text region. 
         */
        before: number,

        /**
         * The padding towards the end of the timed text. 
         */
        end: number,

        /**
         * The padding towards the start of the timed text. 
         */
        start: number,

        /**
         * The units in which the other members of the structure are expressed. 
         */
        unit: undefined.TimedTextUnit
}


/**
 * Represents 2D coordinate that is used to convey the values of timed text style properties. 
 */
declare interface Core$TimedTextPoint {

    /**
     * The units of the coordinates, either pixels or percentage. 
     */
    unit: undefined.TimedTextUnit,

        /**
         * The X coordinate of the point. 
         */
        x: number,

        /**
         * The Y coordinate of the point. 
         */
        y: number
}


/**
 * Represents a media track list that allows a single item to be selected at a time. 
 */
declare interface Core$ISingleSelectMediaTrackList {

    /**
     * Gets or set the currently selected media track in the list. 
     */
    selectedIndex: number
}


/**
 * Represents settings for an AdvancedPhotoControl object. 
 */
declare class AdvancedPhotoCaptureSettings {

    /**
     * Initializes a new instance of the AdvancedPhotoCaptureSettings class. 
     */
    constructor(): this;

    /**
     * Gets or sets the advanced capture mode for which an AdvancedPhotoControl will be configured. 
     */
    mode: undefined.AdvancedPhotoMode
}


/**
 * Provides functionality for controlling the advanced photo capture behavior on a capture device. 
 */
declare class AdvancedPhotoControl {

    /**
     * Configures the AdvancedPhotoControl object with the specified settings.
     * @param settings The object defining the configuration settings.
     */
    configure(settings: undefined.AdvancedPhotoCaptureSettings): void;

    /**
     * Gets the current advanced capture mode of the AdvancedPhotoControl . 
     */
    mode: undefined.AdvancedPhotoMode;

    /**
     * Gets a value indicating whether the AdvancedPhotoControl is supported on the current capture device. 
     */
    supported: boolean;

    /**
     * Gets a list of the advanced capture modes supported by the current capture device. 
     */
    supportedModes: undefined.IVectorView<undefined.AdvancedPhotoMode >
}


/**
 * Controls device settings on the microphone. 
 */
declare class AudioDeviceController {

    /**
     * Gets a list of the supported encoding properties for the device.
     * @param mediaStreamType The type of media stream for which to get the properties.
     * @return  A list of the supported encoding properties.
     */
    getAvailableMediaStreamProperties(
        mediaStreamType: undefined.MediaStreamType): undefined.IVectorView<undefined.IMediaEncodingProperties>;

    /**
     * Gets the encoding properties for the specified media stream type for the device.
     * @param mediaStreamType The type of media stream for which to get the properties.
     * @return  The encoding properties.
     */
    getMediaStreamProperties(mediaStreamType: undefined.MediaStreamType): undefined.IMediaEncodingProperties;

    /**
     * Mutes or unmutes the microphone. 
     */
    muted: boolean;

    /**
     * Sets the encoding properties asynchronously for the specified media stream type for the device.
     * @param mediaStreamType The type of media stream for which to set the properties.
     * @param mediaEncodingProperties The encoding properties to set.
     * @return  An IAsyncAction object that is used to control the asynchronous operation.
     */
    setMediaStreamPropertiesAsync(
        mediaStreamType: undefined.MediaStreamType,
        mediaEncodingProperties: undefined.IMediaEncodingProperties): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets the volume of the microphone. 
     */
    volumePercent: number
}


/**
 * Represents the properties, commands and events for handling calls on a telephony related device. 
 */
declare class CallControl {

    /**
     * Returns a CallControl class that represents the audio communications device specified by the DeviceInformation ID being passed.
     * @param deviceId The DeviceInformation ID of the specified audio communications device.
     * @return  A class that represents the specified audio communications device.
     */
    fromId(deviceId: string): undefined.CallControl;

    /**
     * Returns a CallControl class that represents the default audio communications device.
     * @return  A class that represents the default audio communications device.
     */
    getDefault(): undefined.CallControl;

    /**
     * Ends the specified call.
     * @param callToken The unique identifier of the specified call.
     */
    endCall(callToken: number): void;

    /**
     * Indicates whether the telephony device has a built-in ringer. 
     */
    hasRinger: boolean;

    /**
     * Indicates that the specified call is now active.
     * @param callToken The unique identifier of the specified call.
     */
    indicateActiveCall(callToken: number): void;

    /**
     * Informs the device that there is an incoming call.
     * @param enableRinger Specifies whether the device should activate its built-in ringer.
     * @param callerId A numeric string that specifies the incoming caller ID. This parameter can be null, and often is for many VoIP calls.
     * @return  A call token that uniquely identifies this call.
     */
    indicateNewIncomingCall(enableRinger: boolean, callerId: string): number;

    /**
     * Updates device indicators to indicate an outgoing call.
     * @return  A call token that uniquely identifies this call.
     */
    indicateNewOutgoingCall(): number;

    /**
     * Occurs when the device receives a request to answer a call. 
     */
    onanswerrequested: undefined.CallControlEventHandler;
    addEventListener(type: "answerrequested", listener: undefined.CallControlEventHandler): void;
    removeEventListener(type: "answerrequested", listener: undefined.CallControlEventHandler): void;

    /**
     * Occurs when the device receives a request for an audio transfer. 
     */
    onaudiotransferrequested: undefined.CallControlEventHandler;
    addEventListener(
        type: "audiotransferrequested",
        listener: undefined.CallControlEventHandler): void;
    removeEventListener(
        type: "audiotransferrequested",
        listener: undefined.CallControlEventHandler): void;

    /**
     * Occurs when a number is dialed from the device. 
     */
    ondialrequested: undefined.DialRequestedEventHandler;
    addEventListener(type: "dialrequested", listener: undefined.DialRequestedEventHandler): void;
    removeEventListener(type: "dialrequested", listener: undefined.DialRequestedEventHandler): void;

    /**
     * Occurs when the device receives a request to hang up a call. 
     */
    onhanguprequested: undefined.CallControlEventHandler;
    addEventListener(type: "hanguprequested", listener: undefined.CallControlEventHandler): void;
    removeEventListener(type: "hanguprequested", listener: undefined.CallControlEventHandler): void;

    /**
     * Occurs when a keypad button on the device has been pressed. 
     */
    onkeypadpressed: undefined.KeypadPressedEventHandler;
    addEventListener(type: "keypadpressed", listener: undefined.KeypadPressedEventHandler): void;
    removeEventListener(type: "keypadpressed", listener: undefined.KeypadPressedEventHandler): void;

    /**
     * Occurs when the device receives a request to redial. 
     */
    onredialrequested: undefined.RedialRequestedEventHandler;
    addEventListener(type: "redialrequested", listener: undefined.RedialRequestedEventHandler): void;
    removeEventListener(type: "redialrequested", listener: undefined.RedialRequestedEventHandler): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the intrinsics that describe the camera distortion model. 
 */
declare class CameraIntrinsics {

    /**
     * Initializes a new instance of the CameraIntrinsics class.
     * @param focalLength The focal length of the camera.
     * @param principalPoint The principal point of the camera.
     * @param radialDistortion The radial distortion coefficient of the camera.
     * @param tangentialDistortion The tangential distortion coefficient of the camera.
     * @param imageWidth The image width of the camera, in pixels.
     * @param imageHeight The image height of the camera, in pixels.
     */
    constructor(focalLength: undefined.Vector2, principalPoint: undefined.Vector2, radialDistortion: undefined.Vector3, tangentialDistortion: undefined.Vector2, imageWidth: number, imageHeight: number): this;

    /**
     * Gets the focal length of the camera. 
     */
    focalLength: undefined.Vector2;

    /**
     * Gets the image height of the camera, in pixels. 
     */
    imageHeight: number;

    /**
     * Gets the image width of the camera, in pixels. 
     */
    imageWidth: number;

    /**
     * Gets the principal point of the camera. 
     */
    principalPoint: undefined.Vector2;

    /**
     * Projects an array of camera space points into screen space pixel coordinates.
     * @param coordinates The array of camera space points to project into screen space.
     * @return  The array of screen space pixel coordinates.
     */
    projectManyOntoFrame(coordinates: undefined.Vector3): undefined.Point;

    /**
     * Projects a camera space point into screen space pixel coordinates.
     * @param coordinate The camera space point to project into screen space.
     * @return  The screen space pixel coordinates.
     */
    projectOntoFrame(coordinate: undefined.Vector3): undefined.Point;

    /**
     * Gets the radial distortion coefficient of the camera. 
     */
    radialDistortion: undefined.Vector3;

    /**
     * Gets the tangential distortion coefficient of the camera. 
     */
    tangentialDistortion: undefined.Vector2;

    /**
     * Unprojects pixel coordinates into a camera space ray from the camera origin, expressed as a X, Y coordinates on the plane at Z = 1.0.
     * @param pixelCoordinate The pixel coordinates to unproject into camera space.
     * @return  The X, Y coordinates of the unprojected pixel on the plane at Z = 1.0.
     */
    unprojectAtUnitDepth(pixelCoordinate: undefined.Point): undefined.Vector2;

    /**
     * Unprojects an array pixel coordinates into a camera space rays from the camera origin, expressed as a X, Y coordinates on the plane at Z = 1.0.
     * @param pixelCoordinates The array of pixel coordinates to unproject into camera space.
     * @return  The array of X, Y coordinates of the unprojected pixels on the plane at Z = 1.0.
     */
    unprojectPixelsAtUnitDepth(pixelCoordinates: undefined.Point): undefined.Vector2
}


/**
 * Provides information about the variable photo sequence capabilities of the capture device. 
 */
declare class FrameControlCapabilities {

    /**
     * Gets the exposure capabilities of the capture device for variable photo sequences. 
     */
    exposure: undefined.FrameExposureCapabilities;

    /**
     * Gets the exposure compensation capabilities of the capture device for variable photo sequences. 
     */
    exposureCompensation: undefined.FrameExposureCompensationCapabilities;

    /**
     * Gets the flash capabilities of the capture device for variable photo sequences. 
     */
    flash: undefined.FrameFlashCapabilities;

    /**
     * Gets the focus capabilities of the capture device for variable photo sequences. 
     */
    focus: undefined.FrameFocusCapabilities;

    /**
     * Gets the ISO speed capabilities of the capture device for variable photo sequences. 
     */
    isoSpeed: undefined.FrameIsoSpeedCapabilities;

    /**
     * Gets whether the capture device supports photo confirmation for variable photo sequences. 
     */
    photoConfirmationSupported: boolean
}


/**
 * Represents the settings for a frame in a variable photo sequence. 
 */
declare class FrameController {

    /**
     * Initializes a new instance of the FrameController class. 
     */
    constructor(): this;

    /**
     * Gets the exposure compensation settings for a frame in a variable photo sequence. 
     */
    exposureCompensationControl: undefined.FrameExposureCompensationControl;

    /**
     * Gets the exposure settings for a frame in a variable photo sequence. 
     */
    exposureControl: undefined.FrameExposureControl;

    /**
     * Gets the flash settings for a frame in a variable photo sequence. 
     */
    flashControl: undefined.FrameFlashControl;

    /**
     * Gets the focus settings for a frame in a variable photo sequence. 
     */
    focusControl: undefined.FrameFocusControl;

    /**
     * Gets the ISO speed settings for a frame in a variable photo sequence. 
     */
    isoSpeedControl: undefined.FrameIsoSpeedControl;

    /**
     * Gets or sets whether photo confirmation is enabled for a frame in a variable photo sequence. 
     */
    photoConfirmationEnabled: boolean
}


/**
 * Provides information about the exposure time capabilities of the capture device for frames in a variable photo sequences. 
 */
declare class FrameExposureCapabilities {

    /**
     * Gets the maximum exposure time supported by the capture device. 
     */
    max: number;

    /**
     * Gets the minimum exposure time supported by the capture device. 
     */
    min: number;

    /**
     * Gets the smallest exposure time increment supported by the capture device. 
     */
    step: number;

    /**
     * Gets a value that indicates if the capture device supports the exposure control for variable photo sequences. 
     */
    supported: boolean
}


/**
 * Provides information about the exposure compensation capabilities of the capture device for frames in a variable photo sequences. 
 */
declare class FrameExposureCompensationCapabilities {

    /**
     * Gets the maximum exposure compensation supported by the capture device. 
     */
    max: number;

    /**
     * Gets the minimum exposure compensation supported by the capture device. 
     */
    min: number;

    /**
     * Gets the smallest exposure time compensation increment supported by the capture device. 
     */
    step: number;

    /**
     * Gets a value that indicates if the capture device supports the frame exposure compensation control for frames in a variable photo sequence. 
     */
    supported: boolean
}


/**
 * Represents the exposure compensation settings for a frame in a variable photo sequence. 
 */
declare class FrameExposureCompensationControl {

    /**
     * Gets or sets the exposure compensation time for a frame in a variable photo sequence. 
     */
    value: number
}


/**
 * Represents the exposure time settings for a frame in a variable photo sequence. 
 */
declare class FrameExposureControl {

    /**
     * Gets or sets a value indicating whether auto exposure is enabled for a frame in a variable photo sequence. 
     */
    auto: boolean;

    /**
     * Gets or sets the exposure time for a frame in a variable photo sequence. 
     */
    value: number
}


/**
 * Provides information about the flash capabilities of the capture device for frames in a variable photo sequences. 
 */
declare class FrameFlashCapabilities {

    /**
     * Gets a value indicating whether flash power is supported for frames in a variable photo sequences. 
     */
    powerSupported: boolean;

    /**
     * Gets a value indicating whether red eye reduction is supported for frames in a variable photo sequences. 
     */
    redEyeReductionSupported: boolean;

    /**
     * Gets a value that indicates if the capture device supports the flash control for frames in a variable photo sequence. 
     */
    supported: boolean
}


/**
 * Represents the flash settings for a frame in a variable photo sequence. 
 */
declare class FrameFlashControl {

    /**
     * Gets or sets a value indicating whether flash settings are automatically set for a frame in a variable photo sequence. 
     */
    auto: boolean;

    /**
     * Gets or sets the flash mode for a frame in a variable photo sequence. 
     */
    mode: undefined.FrameFlashMode;

    /**
     * Gets or sets the flash power for a frame in a variable photo sequence. 
     */
    powerPercent: number;

    /**
     * Gets or sets a value indicating if red eye reduction is enabled for a frame in a variable photo sequence. 
     */
    redEyeReduction: boolean
}


/**
 * Provides information about the focus capabilities of the capture device for frames in a variable photo sequences. 
 */
declare class FrameFocusCapabilities {

    /**
     * Gets the maximum focus length supported by the capture device for a frame in a variable photo sequence, specified in millimeters. 
     */
    max: number;

    /**
     * Gets the minimum focus length supported by the capture device for a frame in a variable photo sequence, specified in millimeters. 
     */
    min: number;

    /**
     * Gets the smallest focus increment supported by the capture device for a frame in a variable photo sequence, specified in millimeters. 
     */
    step: number;

    /**
     * Gets a value that indicates if the capture device supports the focus control for frames in a variable photo sequence. 
     */
    supported: boolean
}


/**
 * Represents the focus settings for a frame in a variable photo sequence. 
 */
declare class FrameFocusControl {

    /**
     * Gets or sets the focus value for a frame in a variable photo sequence. 
     */
    value: number
}


/**
 * Provides information about the ISO speed capabilities of the capture device for frames in a variable photo sequences. 
 */
declare class FrameIsoSpeedCapabilities {

    /**
     * Gets the maximum ISO speed supported by the capture device for a frame in a variable photo sequence. 
     */
    max: number;

    /**
     * The minimum ISO speed supported by the capture device for a frame in a variable photo sequence. 
     */
    min: number;

    /**
     * Gets the smallest ISO speed increment supported by the capture device for a frame in a variable photo sequence, specified in millimeters. 
     */
    step: number;

    /**
     * Gets a value that indicates if the capture device supports the ISO speed control for frames in a variable photo sequence. 
     */
    supported: boolean
}


/**
 * Represents the ISO speed settings for a frame in a variable photo sequence. 
 */
declare class FrameIsoSpeedControl {

    /**
     * Gets or sets a value indicating whether ISO speed is automatically set for a frame in a variable photo sequence. 
     */
    auto: boolean;

    /**
     * Gets or sets the ISO speed for a frame in a variable photo sequence. 
     */
    value: number
}


/**
 * Represents the settings for a variable photo sequence. 
 */
declare class VariablePhotoSequenceController {

    /**
     * Gets the list of FrameController objects that determine the settings for each frame in a variable photo sequence. 
     */
    desiredFrameControllers: undefined.IVector<undefined.FrameController>;

    /**
     * Gets a FrameControlCapabilities object that provides information about the variable photo sequence capabilities of the capture device. 
     */
    frameCapabilities: undefined.FrameControlCapabilities;

    /**
     * Gets the current frame rate at which pictures can be taken in a variable photo sequence.
     * @return  The current frame rate at which pictures can be taken in a variable photo sequence.
     */
    getCurrentFrameRate(): undefined.MediaRatio;

    /**
     * Gets the highest frame rate supported when video and a variable photo sequence are being captured concurrently.
     * @param captureProperties The media encoding properties.
     * @return  The highest supported concurrent frame rate.
     */
    getHighestConcurrentFrameRate(captureProperties: undefined.IMediaEncodingProperties): undefined.MediaRatio;

    /**
     * Gets the maximum number of photos that can be taken per second in a variable photo sequence. 
     */
    maxPhotosPerSecond: number;

    /**
     * Gets or sets the number of photos that are taken per second in a variable photo sequence. 
     */
    photosPerSecondLimit: number;

    /**
     * Gets a value that indicates whether variable photo sequences are supported by the capture device. 
     */
    supported: boolean
}


/**
 * Contains information about a default audio capture device change event. 
 */
declare class DefaultAudioCaptureDeviceChangedEventArgs {

    /**
     * Gets the ID of the newly selected audio capture device that caused the change event. 
     */
    id: string;

    /**
     * Gets the role of the newly selected audio capture device that caused the change event. 
     */
    role: undefined.AudioDeviceRole
}


/**
 * Contains information about a default audio render device change event. 
 */
declare class DefaultAudioRenderDeviceChangedEventArgs {

    /**
     * Gets the ID of the newly selected default audio render device that caused the change event. 
     */
    id: string;

    /**
     * Gets the role of the newly selected default audio render device that caused the change event. 
     */
    role: undefined.AudioDeviceRole
}


/**
 * Contains information for the DialRequested event. 
 */
declare class DialRequestedEventArgs {

    /**
     * Returns the contact that was dialed. 
     */
    contact: any;

    /**
     * Indicates that the DialRequested event has been handled. 
     */
    handled(): void
}


/**
 * Provides functionality for modifying exposure levels of captured photos. 
 */
declare class ExposureCompensationControl {

    /**
     * Gets the maximum exposure time. 
     */
    max: number;

    /**
     * Gets the minimum exposure time. 
     */
    min: number;

    /**
     * Asynchronously sets the exposure compensation.
     * @param value The exposure compensation level to set the Value property to. The minimum and maximum values are specified by Min and Max .
     * @return  The object that is used to control the asynchronous operation.
     */
    setValueAsync(value: number): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the smallest exposure compensation increment supported by the capture device. 
     */
    step: number;

    /**
     * Gets a value that specifies if the capture device supports the exposure compensation control. 
     */
    supported: boolean;

    /**
     * Gets the exposure compensation level. 
     */
    value: number
}


/**
 * Provides functionality for controlling the exposure settings on a capture device. 
 */
declare class ExposureControl {

    /**
     * Gets a value that indicates if auto exposure is enabled. 
     */
    auto: boolean;

    /**
     * Gets the maximum exposure time. 
     */
    max: number;

    /**
     * Gets the minimum exposure time. 
     */
    min: number;

    /**
     * Asynchronously enables or disable auto exposure.
     * @param value Specifies whether or not to enable or disable auto exposure.
     * @return  The object that is used to control the asynchronous operation.
     */
    setAutoAsync(value: boolean): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously sets the exposure time.
     * @param shutterDuration The exposure time to set the Value property to. The minimum and maximum values are specified by Min and Max .
     * @return  The object that is used to control the asynchronous operation.
     */
    setValueAsync(shutterDuration: number): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the smallest exposure time increment supported by the capture device. 
     */
    step: number;

    /**
     * Gets a value that specifies if the capture device supports the exposure control. 
     */
    supported: boolean;

    /**
     * Gets the exposure time. 
     */
    value: number
}


/**
 * When supported, allows an app to specify whether the camera driver can dynamically adjust the frame rate of video capture in order to improve video quality in low-light conditions. 
 */
declare class ExposurePriorityVideoControl {

    /**
     * Gets or sets a value that specifies if ExposurePriorityVideoControl is enabled. 
     */
    enabled: boolean;

    /**
     * Gets or sets a value that specifies if ExposurePriorityVideoControl is supported on the current device. 
     */
    supported: boolean
}


/**
 * Provides functionality for controlling the flash settings on a capture device. 
 */
declare class FlashControl {

    /**
     * Gets or sets a value indicating whether focus assist light is enabled on the capture device. 
     */
    assistantLightEnabled: boolean;

    /**
     * Gets a value indicating whether focus assist light is supported by the capture device. 
     */
    assistantLightSupported: boolean;

    /**
     * Gets or sets a value that specifies if flash is automatically set. 
     */
    auto: boolean;

    /**
     * Gets a value that specifies if the flash on the capture device is enabled or disabled. 
     */
    enabled: boolean;

    /**
     * Gets or sets the intensity of the flash. 
     */
    powerPercent: number;

    /**
     * Gets a value that specifics if the device allows the torch LED power settings to be changed. 
     */
    powerSupported: boolean;

    /**
     * Gets a value that specifies if the red eye reduction is enabled or disabled. 
     */
    redEyeReduction: boolean;

    /**
     * Gets a value that specifies if the capture device supports red eye reduction. 
     */
    redEyeReductionSupported: boolean;

    /**
     * Gets a value that specifies if the capture device supports the flash control. 
     */
    supported: boolean
}


/**
 * Provides functionality for controlling the focus settings on a capture device. 
 */
declare class FocusControl {

    /**
     * Configures the FocusControl object with values specified in the provided FocusSettings object.
     * @param settings The focus settings to use to configure the FocusControl object.
     */
    configure(settings: undefined.FocusSettings): void;

    /**
     * Asynchronously focuses the device.
     * @return  The object that is used to control the asynchronous operation.
     */
    focusAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets a value that specifics if the capture device supports the FocusChanged event. 
     */
    focusChangedSupported: boolean;

    /**
     * Gets a MediaCaptureFocusState value indicating the current focus state of the capture device. 
     */
    focusState: undefined.MediaCaptureFocusState;

    /**
     * Locks the capture device's focus.
     * @return  An asynchronous action.
     */
    lockAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the maximum focus length. 
     */
    max: number;

    /**
     * Gets the minimum focus length. 
     */
    min: number;

    /**
     * Gets the capture device's current focus mode. 
     */
    mode: undefined.FocusMode;

    /**
     * Gets the focus preset. 
     */
    preset: undefined.FocusPreset;

    /**
     * Asynchronously sets the focus Preset .
     * @param preset The focus preset to set the Preset property to.
     * @return  The object that is used to control the asynchronous operation.
     */
    setPresetAsync(preset: undefined.FocusPreset): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously sets the focus Preset , specifying if the operation must complete before the device is focused.
     * @param preset The focus preset to set the Preset property to.
     * @param completeBeforeFocus Specifies if the asynchronous operation must complete before the device is focused.
     * @return  The object that is used to control the asynchronous operation.
     */
    setPresetAsync(
        preset: undefined.FocusPreset,
        completeBeforeFocus: boolean): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously sets the focus Value .
     * @param focus The value to set the focus to. The minimum and maximum values are specified by Min and Max .
     * @return  The object that is used to control the asynchronous operation.
     */
    setValueAsync(focus: number): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the smallest focus increment supported by the capture device. 
     */
    step: number;

    /**
     * Gets a value that specifies if the capture device supports the focus control. 
     */
    supported: boolean;

    /**
     * Gets a list of values indicating the manual focus distances that are supported by the capture device. 
     */
    supportedFocusDistances: undefined.IVectorView<undefined.ManualFocusDistance>;

    /**
     * Gets a list of values indicating the focus modes that are supported by the capture device. 
     */
    supportedFocusModes: undefined.IVectorView<undefined.FocusMode>;

    /**
     * Gets a list of values indicating the auto focus ranges that are supported by the capture device. 
     */
    supportedFocusRanges: undefined.IVectorView<undefined.AutoFocusRange>;

    /**
     * Gets the focus presets that the capture device supports. 
     */
    supportedPresets: undefined.IVectorView<undefined.FocusPreset>;

    /**
     * Unlocks the capture device's focus if it has previously been locked with a call to LockAsync .
     * @return  An asynchronous action.
     */
    unlockAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the current value that the focus is set to. 
     */
    value: number;

    /**
     * Gets a value that indicates whether WaitForFocus is supported by the capture device. 
     */
    waitForFocusSupported: boolean
}


/**
 * Represents settings for a FocusControl object. 
 */
declare class FocusSettings {

    /**
     * Initializes a new instance of the FocusSettings class. 
     */
    constructor(): this;

    /**
     * Gets or sets a value indicating the auto focus range setting. 
     */
    autoFocusRange: undefined.AutoFocusRange;

    /**
     * Gets or sets a value that indicates to the driver if it should disable determining a focus position when the focus search fails. 
     */
    disableDriverFallback: boolean;

    /**
     * Gets or sets a value indicating the manual focus distance setting. 
     */
    distance: undefined.ManualFocusDistance;

    /**
     * Gets or sets a value indicating the focus mode setting. 
     */
    mode: undefined.FocusMode;

    /**
     * Gets or sets the focus value setting. 
     */
    value: number;

    /**
     * Gets or sets a value indicating whether the capture device should wait for focus before capturing. 
     */
    waitForFocus: boolean
}


/**
 * When supported, allows an app to enable High Dynamic Range (HDR) video recording on the capture device. 
 */
declare class HdrVideoControl {

    /**
     * Gets or sets a value indicating the current High Dynamic Range (HDR) video recording mode of the capture device. 
     */
    mode: undefined.HdrVideoMode;

    /**
     * Gets a value that indicates if the capture device supports the HdrVideoControl . 
     */
    supported: boolean;

    /**
     * Gets the list of HdrVideoMode values indicating the modes supported by the capture device. 
     */
    supportedModes: undefined.IVectorView<undefined.HdrVideoMode >
}


/**
 * Provides functionality for controlling the ISO film speed settings on a capture device. 
 */
declare class IsoSpeedControl {

    /**
     * Gets a value indicating whether auto ISO speed is enabled. 
     */
    auto: boolean;

    /**
     * Gets the maximum ISO speed supported by the capture device. 
     */
    max: number;

    /**
     * Gets the minimum ISO speed supported by the capture device. 
     */
    min: number;

    /**
     * Gets the ISO film speed preset. 
     */
    preset: undefined.IsoSpeedPreset;

    /**
     * Sets the ISO speed to automatic.
     * @return  An asynchronous action.
     */
    setAutoAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously sets the ISO film speed Preset .
     * @param preset The ISO preset value to set the Preset property to.
     * @return  The object that is used to control the asynchronous operation.
     */
    setPresetAsync(preset: undefined.IsoSpeedPreset): undefined.IPromiseWithIAsyncAction;

    /**
     * Sets the ISO speed value.
     * @param isoSpeed The ISO speed value.
     * @return  An asynchronous action.
     */
    setValueAsync(isoSpeed: number): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the smallest ISO speed increment supported by the capture device. 
     */
    step: number;

    /**
     * Gets a value the specifies if the capture device supports the ISO speed control. 
     */
    supported: boolean;

    /**
     * Gets the ISO presets that the capture device supports. 
     */
    supportedPresets: undefined.IVectorView<undefined.IsoSpeedPreset>;

    /**
     * Gets the current ISO speed value. 
     */
    value: number
}


/**
 * Contains information for the KeypadPressed event. 
 */
declare class KeypadPressedEventArgs {

    /**
     * Returns the value of the keypad button on the device that was pressed. 
     */
    telephonyKey: undefined.TelephonyKey
}


/**
 * Provides functionality for managing the low shutter lag photo capture mode on the capture device. 
 */
declare class LowLagPhotoControl {

    /**
     * Gets or sets the desired size for thumbnails, which is the largest length of the image, either width or height. 
     */
    desiredThumbnailSize: number;

    /**
     * Gets the current frame rate at which pictures can be taken.
     * @return  The current frame rate.
     */
    getCurrentFrameRate(): undefined.MediaRatio;

    /**
     * Gets the highest frame rate supported when video and photos are being captured concurrently.
     * @param captureProperties The media encoding properties.
     * @return  The highest concurrent frames per second.
     */
    getHighestConcurrentFrameRate(captureProperties: undefined.IMediaEncodingProperties): undefined.MediaRatio;

    /**
     * Gets a value that specifies if hardware acceleration is supported for thumbnails. 
     */
    hardwareAcceleratedThumbnailSupported: number;

    /**
     * Gets a value that enables and disables thumbnail support. 
     */
    thumbnailEnabled: boolean;

    /**
     * Gets or sets the media format for the thumbnails. 
     */
    thumbnailFormat: undefined.MediaThumbnailFormat
}


/**
 * Provides functionality for managing the low shutter lag photo sequence mode on the capture device. 
 */
declare class LowLagPhotoSequenceControl {

    /**
     * Gets or sets the desired size for thumbnails, which is the largest length of the image, either width or height. 
     */
    desiredThumbnailSize: number;

    /**
     * Gets the current frame rate at which pictures can be taken.
     * @return  The current frame rate.
     */
    getCurrentFrameRate(): undefined.MediaRatio;

    /**
     * Gets the highest frame rate supported when video and photos sequences are being captured concurrently.
     * @param captureProperties The media encoding properties.
     * @return  The highest concurrent frames per second.
     */
    getHighestConcurrentFrameRate(captureProperties: undefined.IMediaEncodingProperties): undefined.MediaRatio;

    /**
     * Gets a value that specifies if hardware acceleration is supported for thumbnails in photo sequence mode. 
     */
    hardwareAcceleratedThumbnailSupported: number;

    /**
     * Gets the maximum number of past photos that can be stored. 
     */
    maxPastPhotos: number;

    /**
     * Gets the maximum number of photos that can be taken per second. 
     */
    maxPhotosPerSecond: number;

    /**
     * Gets or sets a value that specifies the number of past photos to store. 
     */
    pastPhotoLimit: number;

    /**
     * Gets or sets the number of photos that are taken per second. 
     */
    photosPerSecondLimit: number;

    /**
     * Gets a value that specifies if the capture device supports low shutter lag photo sequence mode. 
     */
    supported: boolean;

    /**
     * Gets a value that enables and disables thumbnail support in photo sequence mode. 
     */
    thumbnailEnabled: boolean;

    /**
     * Gets or sets the media format for the thumbnails. 
     */
    thumbnailFormat: undefined.MediaThumbnailFormat
}


/**
 * Provides methods used to select devices for capturing and rendering audio, and for capturing video. 
 */
declare class MediaDevice {

    /**
     * Returns the identifier string of a device for capturing audio.
     * @return  The identifier string of the audio capture device.
     */
    getAudioCaptureSelector(): string;

    /**
     * Returns the identifier string of a device for rendering audio.
     * @return  The identifier string of the audio rendering device.
     */
    getAudioRenderSelector(): string;

    /**
     * Returns the identifier string of the default device for capturing audio in the specified role.
     * @param role The specified audio device role (console, media, or communications).
     * @return  The identifier string of the default device.
     */
    getDefaultAudioCaptureId(role: undefined.AudioDeviceRole): string;

    /**
     * Returns the identifier string of the default device for rendering audio in the specified role.
     * @param role The specified audio device role (console, media, or communications).
     * @return  The identifier string of the default device.
     */
    getDefaultAudioRenderId(role: undefined.AudioDeviceRole): string;

    /**
     * Returns the identifier string of a device for capturing video.
     * @return  The identifier string of the video capture device.
     */
    getVideoCaptureSelector(): string;

    /**
     * Raised when the default audio capture device is changed. 
     */
    ondefaultaudiocapturedevicechanged: undefined.TypedEventHandler<any, undefined.DefaultAudioCaptureDeviceChangedEventArgs>;
    addEventListener(
        type: "defaultaudiocapturedevicechanged",
        listener: undefined.TypedEventHandler<any, undefined.DefaultAudioCaptureDeviceChangedEventArgs>): void;
    removeEventListener(
        type: "defaultaudiocapturedevicechanged",
        listener: undefined.TypedEventHandler<any, undefined.DefaultAudioCaptureDeviceChangedEventArgs>): void;

    /**
     * Raised when the default audio render device is changed. 
     */
    ondefaultaudiorenderdevicechanged: undefined.TypedEventHandler<any, undefined.DefaultAudioRenderDeviceChangedEventArgs>;
    addEventListener(
        type: "defaultaudiorenderdevicechanged",
        listener: undefined.TypedEventHandler<any, undefined.DefaultAudioRenderDeviceChangedEventArgs>): void;
    removeEventListener(
        type: "defaultaudiorenderdevicechanged",
        listener: undefined.TypedEventHandler<any, undefined.DefaultAudioRenderDeviceChangedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Gets or sets a device setting on a camera. 
 */
declare class MediaDeviceControl {

    /**
     * Gets the capabilities of the camera for this camera setting. 
     */
    capabilities: undefined.MediaDeviceControlCapabilities;

    /**
     * Indicates whether automatic adjustment of the camera setting is enabled.
     */
    tryGetAuto(): {
        value: boolean,
        returnValue: boolean
    };

    /**
     * Gets the value of the camera setting.
     */
    tryGetValue(): {
        value: number,
        returnValue: boolean
    };

    /**
     * Enables or disables automatic adjustment of the camera setting.
     * @param value True to enable automatic adjustment; or false to disable automatic adjustment. If false, call TrySetValue to adjust the setting.
     * @return  Returns true if the method succeeds, or false otherwise.
     */
    trySetAuto(value: boolean): boolean;

    /**
     * Sets the camera setting.
     * @param value The new value of the camera setting. The units depend on the setting.
     * @return  Returns true if the method succeeds, or false otherwise.
     */
    trySetValue(value: number): boolean
}


/**
 * Gets the capabilities of a camera setting. 
 */
declare class MediaDeviceControlCapabilities {

    /**
     * Queries whether the camera supports automatic adjustment of the setting. 
     */
    autoModeSupported: boolean;

    /**
     * Gets the default value of the camera setting. 
     */
    default: number;

    /**
     * Sets the maximum value of the camera setting. 
     */
    max: number;

    /**
     * Gets the minimum value of the camera setting. 
     */
    min: number;

    /**
     * Ges the step size for the setting. The step size is the smallest increment by which the property can change. 
     */
    step: number;

    /**
     * Indicates whether the camera supports this camera setting. 
     */
    supported: boolean
}


/**
 * When supported, allows an app to enable optical image stabilization on the capture device. 
 */
declare class OpticalImageStabilizationControl {

    /**
     * Gets or sets a value indicating the current optical image stabilization mode of the capture device. 
     */
    mode: undefined.OpticalImageStabilizationMode;

    /**
     * Gets a value that indicates if the capture device supports the OpticalImageStabilizationControl . 
     */
    supported: boolean;

    /**
     * Gets the list of OpticalImageStabilizationMode values indicating the modes supported by the capture device. 
     */
    supportedModes: undefined.IVectorView<undefined.OpticalImageStabilizationMode >
}


/**
 * Provides functionality for controlling the photo confirmation settings on a capture device. 
 */
declare class PhotoConfirmationControl {

    /**
     * Gets or sets a value indicating whether photo confirmation is enabled. 
     */
    enabled: boolean;

    /**
     * Gets or sets the desired pixel format for photo confirmation frames. 
     */
    pixelFormat: undefined.MediaPixelFormat;

    /**
     * Gets a value indicating whether photo confirmation is supported by the capture device. 
     */
    supported: boolean
}


/**
 * Contains information for the RedialRequested event. 
 */
declare class RedialRequestedEventArgs {

    /**
     * Indicates that the RedialRequested event has been handled. 
     */
    handled(): void
}


/**
 * Represents a region of interest which is a rectangular region on the image which is used for functions such as focus and exposure. 
 */
declare class RegionOfInterest {

    /**
     * Creates a new instance of the RegionOfInterest control. 
     */
    constructor(): this;

    /**
     * Gets or sets a value that specifies if auto exposure is enabled. 
     */
    autoExposureEnabled: boolean;

    /**
     * Gets or sets a value that specifies if auto focus is enabled. 
     */
    autoFocusEnabled: boolean;

    /**
     * Gets or sets a value that specifies if auto white balance is enabled. 
     */
    autoWhiteBalanceEnabled: boolean;

    /**
     * Gets or sets the rectangle that defines the region of focus. 
     */
    bounds: undefined.Rect;

    /**
     * Gets or sets a value indicating whether the Bounds Rect is in pixels or is mapped to a range of 0 to 1.0. 
     */
    boundsNormalized: boolean;

    /**
     * Gets or sets the type of region represented by the RegionOfInterest object. 
     */
    type: undefined.RegionOfInterestType;

    /**
     * Gets or sets the weight of the region of interest. 
     */
    weight: number
}


/**
 * Provides functionality to mange the regions of interest on a device. 
 */
declare class RegionsOfInterestControl {

    /**
     * Gets a value that specifies if auto exposure is supported on the capture device. 
     */
    autoExposureSupported: boolean;

    /**
     * Gets a value that specifies if auto focus is supported on the capture device. 
     */
    autoFocusSupported: boolean;

    /**
     * Gets a value that specifies if auto white balance is supported on the capture device. 
     */
    autoWhiteBalanceSupported: boolean;

    /**
     * Asynchronously clears the regions of interests.
     * @return  The object that is used to control the asynchronous operation.
     */
    clearRegionsAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the maximum number of regions of interest that can be specified. 
     */
    maxRegions: number;

    /**
     * Asynchronously sets the regions of interest.
     * @param regions The regions of interest.
     * @return  The object that is used to control the asynchronous operation.
     */
    setRegionsAsync(
        regions: undefined.IIterable<undefined.RegionOfInterest>): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously sets the regions of interest and specifies if the values should be locked.
     * @param regions The regions of interests.
     * @param lockValues Specifies if the values should be locked.
     * @return  The object that is used to control the asynchronous operation.
     */
    setRegionsAsync(
        regions: undefined.IIterable<undefined.RegionOfInterest>,
        lockValues: boolean): undefined.IPromiseWithIAsyncAction
}


/**
 * Provides functionality for controlling the scene mode settings on a capture device. 
 */
declare class SceneModeControl {

    /**
     * Asynchronously sets the color temperature Value .
     * @param sceneMode The scene mode to set the Value property to.
     * @return  The object that is used to control the asynchronous operation.
     */
    setValueAsync(sceneMode: undefined.CaptureSceneMode): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the scene modes supported on the capture device. 
     */
    supportedModes: undefined.IVectorView<undefined.CaptureSceneMode>;

    /**
     * Gets the current scene mod ethe capture device is set to. 
     */
    value: undefined.CaptureSceneMode
}


/**
 * Provides functionality for controlling the torch LED settings on a capture device. 
 */
declare class TorchControl {

    /**
     * Gets or sets a value that enables and disables the torch LED on the device. 
     */
    enabled: boolean;

    /**
     * Gets or sets the intensity of the torch LED. 
     */
    powerPercent: number;

    /**
     * Gets a value that specifics if the device allows the torch LED power settings to be changed. 
     */
    powerSupported: boolean;

    /**
     * Gets a value that specifies if the capture device supports the torch control. 
     */
    supported: boolean
}


/**
 * Controls device settings on the camera. 
 */
declare class VideoDeviceController {

    /**
     * Gets the advanced photo capture control for this video device. 
     */
    advancedPhotoControl: undefined.AdvancedPhotoControl;

    /**
     * Specifies whether back-light compensation is enabled on the camera. 
     */
    backlightCompensation: undefined.MediaDeviceControl;

    /**
     * Gets or sets the brightness level on the camera. 
     */
    brightness: undefined.MediaDeviceControl;

    /**
     * Gets or sets the contrast level on the camera. 
     */
    contrast: undefined.MediaDeviceControl;

    /**
     * Gets or sets a value that indicates the optimizations the capture device should use to prioritize high quality picture, low latency, or low power consumption during video capture. 
     */
    desiredOptimization: undefined.MediaCaptureOptimization;

    /**
     * Gets or sets the camera's exposure time. 
     */
    exposure: undefined.MediaDeviceControl;

    /**
     * Gets the exposure compensation control for this video device. 
     */
    exposureCompensationControl: undefined.ExposureCompensationControl;

    /**
     * Gets the exposure control for this video device. 
     */
    exposureControl: undefined.ExposureControl;

    /**
     * Gets the ExposurePriorityVideoControl associated with the VideoDeviceController . 
     */
    exposurePriorityVideoControl: undefined.ExposurePriorityVideoControl;

    /**
     * Gets the flash control for this video device. 
     */
    flashControl: undefined.FlashControl;

    /**
     * Gets or sets the camera's focus setting. 
     */
    focus: undefined.MediaDeviceControl;

    /**
     * Gets the focus control for this video device. 
     */
    focusControl: undefined.FocusControl;

    /**
     * Gets a list of the supported encoding properties for the video device.
     * @param mediaStreamType The type of media stream for which to get the properties.
     * @return  A list of the supported encoding properties.
     */
    getAvailableMediaStreamProperties(
        mediaStreamType: undefined.MediaStreamType): undefined.IVectorView<undefined.IMediaEncodingProperties>;

    /**
     * Gets a property on the camera. You can use this method to query properties that are specific to a particular camera.
     * @param propertyId The property identifier.
     * @return  The property value.
     */
    getDeviceProperty(propertyId: string): any;

    /**
     * Gets the encoding properties for the specified media stream type for the video device.
     * @param mediaStreamType The type of media stream for which to get the properties.
     * @return  The encoding properties.
     */
    getMediaStreamProperties(mediaStreamType: undefined.MediaStreamType): undefined.IMediaEncodingProperties;

    /**
     * Gets the HdrVideoControl associated with the VideoDeviceController . 
     */
    hdrVideoControl: undefined.HdrVideoControl;

    /**
     * Gets or sets the camera's hue setting. 
     */
    hue: undefined.MediaDeviceControl;

    /**
     * Gets the ISO film speed control for this video device. 
     */
    isoSpeedControl: undefined.IsoSpeedControl;

    /**
     * Gets the low shutter lag photo control for this video device. 
     */
    lowLagPhoto: undefined.LowLagPhotoControl;

    /**
     * Gets the low shutter lag photo sequence control for this video device. 
     */
    lowLagPhotoSequence: undefined.LowLagPhotoSequenceControl;

    /**
     * Gets the OpticalImageStabilizationControl associated with the VideoDeviceController . 
     */
    opticalImageStabilizationControl: undefined.OpticalImageStabilizationControl;

    /**
     * Gets or sets the camera's pan setting. 
     */
    pan: undefined.MediaDeviceControl;

    /**
     * Gets the photo confirmation control for this video device. 
     */
    photoConfirmationControl: undefined.PhotoConfirmationControl;

    /**
     * Gets or sets the primary use for the device. 
     */
    primaryUse: undefined.CaptureUse;

    /**
     * Gets the regions of interest control for this video device. 
     */
    regionsOfInterestControl: undefined.RegionsOfInterestControl;

    /**
     * Gets or sets the camera's roll setting. 
     */
    roll: undefined.MediaDeviceControl;

    /**
     * Gets the scene mode control for this video device. 
     */
    sceneModeControl: undefined.SceneModeControl;

    /**
     * Sets a property on the device. You can use this method to set properties that are specific to a particular device.
     * @param propertyId The property identifier.
     * @param propertyValue The new value of the property.
     */
    setDeviceProperty(propertyId: string, propertyValue: any): void;

    /**
     * Sets the encoding properties asynchronously for the specified media stream type for the video device.
     * @param mediaStreamType The type of media stream for which to set the properties.
     * @param mediaEncodingProperties The encoding properties to set.
     * @return  An IAsyncAction object that is used to control the asynchronous operation.
     */
    setMediaStreamPropertiesAsync(
        mediaStreamType: undefined.MediaStreamType,
        mediaEncodingProperties: undefined.IMediaEncodingProperties): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets the camera's tilt setting. 
     */
    tilt: undefined.MediaDeviceControl;

    /**
     * Gets the torch control for this video device. 
     */
    torchControl: undefined.TorchControl;

    /**
     * Gets the local power line frequency.
     */
    tryGetPowerlineFrequency(): {
        value: undefined.PowerlineFrequency,
        returnValue: boolean
    };

    /**
     * Sets the local power line frequency.
     * @param value The power line frequency.
     * @return  Returns true if the method succeeded, or false otherwise.
     */
    trySetPowerlineFrequency(value: undefined.PowerlineFrequency): boolean;

    /**
     * Gets the VariablePhotoSequenceController associated with the VideoDeviceController . 
     */
    variablePhotoSequenceController: undefined.VariablePhotoSequenceController;

    /**
     * Gets or sets the white balance on the camera. 
     */
    whiteBalance: undefined.MediaDeviceControl;

    /**
     * Gets the white balance control for this video device. 
     */
    whiteBalanceControl: undefined.WhiteBalanceControl;

    /**
     * Gets and sets the camera's zoom setting. 
     */
    zoom: undefined.MediaDeviceControl;

    /**
     * Gets the ZoomControl associated with the VideoDeviceController . 
     */
    zoomControl: undefined.ZoomControl
}


/**
 * Provides functionality for controlling the white balance settings on a capture device. 
 */
declare class WhiteBalanceControl {

    /**
     * Gets the maximum white balance value. 
     */
    max: number;

    /**
     * Gets the minimum white balance value. 
     */
    min: number;

    /**
     * Gets the color temperature preset. 
     */
    preset: undefined.ColorTemperaturePreset;

    /**
     * Asynchronously sets the color temperature Preset .
     * @param preset The color temperate preset to set the Preset property to.
     * @return  The object that is used to control the asynchronous operation.
     */
    setPresetAsync(preset: undefined.ColorTemperaturePreset): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously sets the color temperature Value .
     * @param temperature The temperature value to set the Value property to.
     * @return  The object that is used to control the asynchronous operation.
     */
    setValueAsync(temperature: number): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the step value. 
     */
    step: number;

    /**
     * Gets a value that specifies if the capture device supports the white balance control. 
     */
    supported: boolean;

    /**
     * Gets the color temperature value. 
     */
    value: number
}


/**
 * Provides functionality for controlling the zoom settings on a capture device. 
 */
declare class ZoomControl {

    /**
     * Configures the zoom control with the provided zoom settings.
     * @param settings The zoom settings.
     */
    configure(settings: undefined.ZoomSettings): void;

    /**
     * Gets the maximum zoom value supported by the capture device. 
     */
    max: number;

    /**
     * Gets the minimum zoom value supported by the capture device. 
     */
    min: number;

    /**
     * Gets a value indicating the current zoom transition mode. 
     */
    mode: undefined.ZoomTransitionMode;

    /**
     * Gets the smallest zoom value increment supported by the capture device. 
     */
    step: number;

    /**
     * Gets a value indicating whether zoom control is supported by the capture device. 
     */
    supported: boolean;

    /**
     * Gets the list of ZoomTransitionMode values indicating the modes supported by the capture device. 
     */
    supportedModes: undefined.IVectorView<undefined.ZoomTransitionMode>;

    /**
     * Gets or sets the zoom value to be used by the capture device. 
     */
    value: number
}


/**
 * Represents zoom settings that can be applied to the ZoomControl by calling the Configure method. 
 */
declare class ZoomSettings {

    /**
     * Initializes a new instance of the ZoomSettings class. 
     */
    constructor(): this;

    /**
     * Gets or sets a ZoomTransitionMode value indicating how the capture device should transition to the new zoom value specified with the Value property. 
     */
    mode: undefined.ZoomTransitionMode;

    /**
     * Gets or sets the zoom value to which the ZoomControl will transition. 
     */
    value: number
}


/**
 * Handles the AnswerRequested and AudioTransferRequested events. 
 */
declare type Devices$CallControlEventHandler = (ev: Windows$WinRTEvent<undefined.CallControl>) => void;


/**
 * Handles the DialRequested event. 
 */
declare type Devices$DialRequestedEventHandler = (
    ev: undefined.DialRequestedEventArgs & Windows$WinRTEvent<undefined.CallControl>) => void;


/**
 * Handles the KeypadPressed event. 
 */
declare type Devices$KeypadPressedEventHandler = (
    ev: undefined.KeypadPressedEventArgs & Windows$WinRTEvent<undefined.CallControl>) => void;


/**
 * Handles the RedialRequested event. 
 */
declare type Devices$RedialRequestedEventHandler = (
    ev: undefined.RedialRequestedEventArgs & Windows$WinRTEvent<undefined.CallControl>) => void;


/**
 * Represents a DIAL application running on a remote device. 
 */
declare class DialApp {

    /**
     * Gets the applications registered DIAL name. 
     */
    appName: string;

    /**
     * Gets the current status of the application on the remote device.
     * @return  The app status, a value from DialAppStateDetails .
     */
    getAppStateAsync(): undefined.IPromiseWithIAsyncOperation<undefined.DialAppStateDetails>;

    /**
     * Initiates the launching of the app on the remote device. When this method is called, the DialDevice is paired if necessary, the user is prompted to allow access to the device, connection is established, app existence is validated on the device, and finally the application is launched with the provided argument.
     * @param appArgument Optional.
     * @return  Indicates the result of attempting to launch the app.
     */
    requestLaunchAsync(
        appArgument: string): undefined.IPromiseWithIAsyncOperation<undefined.DialAppLaunchResult>;

    /**
     * Stops the app on the remote device, if the remote device supports this functionality.
     * @return  The result of sending the request to stop the app.
     */
    stopAsync(): undefined.IPromiseWithIAsyncOperation<undefined.DialAppStopResult >
}


/**
 * Represents the state of the DIAL app. 
 */
declare class DialAppStateDetails {

    /**
     * Gets the entire XML response that is provided by the app when state of the app was requested. 
     */
    fullXml: string;

    /**
     * Gets the state of the application at the time the GetAppStateAsync was completed. 
     */
    state: undefined.DialAppState
}


/**
 * Represents the remote device capable of running DIAL apps. 
 */
declare class DialDevice {

    /**
     * Indicates whether or not the device supports launching DIAL apps.
     * @param device The device you want to get information for.
     * @return  True if app launching is supported; false, otherwise.
     */
    deviceInfoSupportsDialAsync(
        device: undefined.DeviceInformation): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Returns a DialDevice object for a given a device ID (acquired from a query using the Windows.Devices.Enumeration APIs).
     * @param value The ID of the device you want a DialDevice object for.
     * @return  The DialDevice object for the given device ID.
     */
    fromIdAsync(value: string): undefined.IPromiseWithIAsyncOperation<undefined.DialDevice>;

    /**
     * Returns an AQS filter string to be used with the Windows.Devices.Enumeration APIs (such as the CreateWatcher API) for a given Dial app.
     * @param appName The name of the app.
     * @return  The AQS filter.
     */
    getDeviceSelector(appName: string): string;

    /**
     * Gets the friendly name for the DIAL device. 
     */
    friendlyName: string;

    /**
     * Creates a new DialApp object. This method does not establish a connection to the device or validate that the app exists. That is done when any function is called on the resulting DialApp object.
     * @param appName The name of the app. This becomes the AppName property of the new object.
     * @return  The DialApp object for the app.
     */
    getDialApp(appName: string): undefined.DialApp;

    /**
     * Gets the remote device's ID. You can use this ID with the Windows.Devices.Enumeration APIs as well. 
     */
    id: string;

    /**
     * Gets a stream containing the thumbnail image for the DIAL device. 
     */
    thumbnail: undefined.IRandomAccessStreamReference
}


/**
 * Represents a picker flyout that contains a list of remote devices for the user to choose from. 
 */
declare class DialDevicePicker {

    /**
     * Creates a new DialDevicePicker object. 
     */
    constructor(): this;

    /**
     * Used to change the colors of the picker. 
     */
    appearance: undefined.DevicePickerAppearance;

    /**
     * Gets the filter used to choose what devices to show in the picker. 
     */
    filter: undefined.DialDevicePickerFilter;

    /**
     * Hides the picker. 
     */
    hide(): void;

    /**
     * Indicates that the device picker was light dismissed, which means that the user clicked or touched anywhere other than the picker UI, and so the picker will be closed. 
     */
    ondialdevicepickerdismissed: undefined.TypedEventHandler<undefined.DialDevicePicker, any>;
    addEventListener(
        type: "dialdevicepickerdismissed",
        listener: undefined.TypedEventHandler<undefined.DialDevicePicker, any>): void;
    removeEventListener(
        type: "dialdevicepickerdismissed",
        listener: undefined.TypedEventHandler<undefined.DialDevicePicker, any>): void;

    /**
     * Indicates that the user selected a device from the picker. 
     */
    ondialdeviceselected: undefined.TypedEventHandler<undefined.DialDevicePicker, undefined.DialDeviceSelectedEventArgs>;
    addEventListener(
        type: "dialdeviceselected",
        listener: undefined.TypedEventHandler<undefined.DialDevicePicker, undefined.DialDeviceSelectedEventArgs>): void;
    removeEventListener(
        type: "dialdeviceselected",
        listener: undefined.TypedEventHandler<undefined.DialDevicePicker, undefined.DialDeviceSelectedEventArgs>): void;

    /**
     * Indicates that the user clicked on the disconnect button in the picker. 
     */
    ondisconnectbuttonclicked: undefined.TypedEventHandler<undefined.DialDevicePicker, undefined.DialDisconnectButtonClickedEventArgs>;
    addEventListener(
        type: "disconnectbuttonclicked",
        listener: undefined.TypedEventHandler<undefined.DialDevicePicker, undefined.DialDisconnectButtonClickedEventArgs>): void;
    removeEventListener(
        type: "disconnectbuttonclicked",
        listener: undefined.TypedEventHandler<undefined.DialDevicePicker, undefined.DialDisconnectButtonClickedEventArgs>): void;

    /**
     * Shows the picker. Call this method directly to show to show the picker, instead of showing it in response to an event.
     * @param selection The rectangle from which to show the picker.
     * @param preferredPlacement The edge of the rectangle from which to show the picker.
     * @return  The DialDevice object selected.
     */
    pickSingleDialDeviceAsync(
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement): undefined.IPromiseWithIAsyncOperation<undefined.DialDevice>;

    /**
     * Shows the picker. Call this method directly to show to show the picker, instead of showing it in response to an event.
     * @param selection The rectangle from which to show the picker.
     * @return  The device the user selected from the picker.
     */
    pickSingleDialDeviceAsync(
        selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<undefined.DialDevice>;

    /**
     * Updates the picker UI to reflect the status fo a given remote device.
     * @param device The remote device whose status you want to display.
     * @param status The status you want displayed.
     */
    setDisplayStatus(device: undefined.DialDevice, status: undefined.DialDeviceDisplayStatus): void;

    /**
     * Displays the picker to the user. When called, the picker flies out from the specified edge of the provided rectangle.
     * @param selection The rectangle from which you want the picker to show.
     * @param preferredPlacement The edge from which you want the picker to show.
     */
    show(selection: undefined.Rect, preferredPlacement: undefined.Placement): void;

    /**
     * Displays the picker to the user. When called, the picker flies out from an edge of the provided rectangle.
     * @param selection The rectangle from which you want the picker to show.
     */
    show(selection: undefined.Rect): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the filter used to determine which devices to show in a DialDevicePicker . The filter parameters are OR-ed together to build the resulting filter. 
 */
declare class DialDevicePickerFilter {

    /**
     * Gets a list of DIAL apps supported by the remote devices. Defaults to an empty list (no filter). You can add one or more app names and filter the devices list to those that can launch one the supported apps. 
     */
    supportedAppNames: undefined.IVector<string >
}


/**
 * Represents the event arguments for the DialDeviceSelected event on the DialDevicePicker object. 
 */
declare class DialDeviceSelectedEventArgs {

    /**
     * Gets the DialDevice object that represents the remote device that has been selected by the user in a DialDevicePicker . 
     */
    selectedDialDevice: undefined.DialDevice
}


/**
 * Represents the event arguments for the DisconnectButtonClicked event on the DialDevicePicker object. 
 */
declare class DialDisconnectButtonClickedEventArgs {

    /**
     * Gets the DialDevice object that represents the remote device that the user wants to disconnect. 
     */
    device: undefined.DialDevice
}


/**
 * Represents a single audio track for accompanying a video clip. 
 */
declare class BackgroundAudioTrack {

    /**
     * Creates a background audio track object with audio content copied from an embedded audio track object.
     * @param embeddedAudioTrack An embedded audio track to use as the source audio for the background audio track.
     * @return  A new background audio track object containing audio content copied from the embedded audio track.
     */
    createFromEmbeddedAudioTrack(
        embeddedAudioTrack: undefined.EmbeddedAudioTrack): undefined.BackgroundAudioTrack;

    /**
     * Creates a background audio track from an audio file.
     * @param file A StorageFile object representing the source audio file.
     * @return  A new background audio track object containing the contents of the audio file.
     */
    createFromFileAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.BackgroundAudioTrack>;

    /**
     * Gets the list of audio effect definitions for processing the background audio track. 
     */
    audioEffectDefinitions: undefined.IVector<undefined.IAudioEffectDefinition>;

    /**
     * Creates a BackgroundAudioTrack object that is identical to this instance.
     * @return  A BackgroundAudioTrack object that is a copy of this instance.
     */
    clone(): undefined.BackgroundAudioTrack;

    /**
     * Specifies how long to wait before starting background audio playback. 
     */
    delay: number;

    /**
     * Gets the AudioEncodingProperties for the background audio track.
     * @return  The AudioEncodingProperties for the background audio track.
     */
    getAudioEncodingProperties(): undefined.AudioEncodingProperties;

    /**
     * Original playback time of the background audio track, without the effects of the TrimTimeFromStart and TrimTimeFromEnd properties. 
     */
    originalDuration: number;

    /**
     * The amount of time to trim from the end of the background audio track. 
     */
    trimTimeFromEnd: number;

    /**
     * The amount of time to trim from the beginning of the background audio track. 
     */
    trimTimeFromStart: number;

    /**
     * Duration of the background audio track with TrimTimeFromStart and TrimTimeFromEnd applied to playback. 
     */
    trimmedDuration: number;

    /**
     * An associative collection for storing custom properties associated with the background audio track. 
     */
    userData: undefined.IMap<string, string>;

    /**
     * Gets or sets the volume of the background audio track. 
     */
    volume: number
}


/**
 * Represents an audio track embedded in the media clip. 
 */
declare class EmbeddedAudioTrack {

    /**
     * Gets the AudioEncodingProperties for the embedded audio track.
     * @return  The AudioEncodingProperties for the embedded audio track.
     */
    getAudioEncodingProperties(): undefined.AudioEncodingProperties
}


/**
 * Represents a single media object. 
 */
declare class MediaClip {

    /**
     * Creates a solid color video clip that displays a single color for a specified length of time. Solid color video clips are typically used to create an explicit gap between video segments.
     * @param color The color to display in the video clip.
     * @param originalDuration How long to display the color in the video clip.
     * @return  A new media clip object containing the color-based video clip.
     */
    createFromColor(color: undefined.Color, originalDuration: number): undefined.MediaClip;

    /**
     * Creates a video clip from a video file.
     * @param file A StorageFile object representing the source video file.
     * @return  A new media clip object containing a video clip of the video file.
     */
    createFromFileAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.MediaClip>;

    /**
     * Creates a video clip that displays a single image for a specified length of time.
     * @param file A StorageFile object representing the source image file.
     * @param originalDuration How long to display the image in the video clip.
     * @return  A new media clip object containing the image-based video clip.
     */
    createFromImageFileAsync(
        file: undefined.IStorageFile,
        originalDuration: number): undefined.IPromiseWithIAsyncOperation<undefined.MediaClip>;

    /**
     * Creates a video clip from a Direct3D surface.
     * @param surface The Direct3D surface.
     * @param originalDuration The initial duration of the created video clip.
     * @return  A new media clip object containing the video clip.
     */
    createFromSurface(
        surface: undefined.IDirect3DSurface,
        originalDuration: number): undefined.MediaClip;

    /**
     * Gets the list of audio effect definitions for processing the media clip. 
     */
    audioEffectDefinitions: undefined.IVector<undefined.IAudioEffectDefinition>;

    /**
     * Creates a MediaClip object that is identical to this instance.
     * @return  A MediaClip object that is a copy of this instance.
     */
    clone(): undefined.MediaClip;

    /**
     * The list of embedded audio tracks in this media clip. 
     */
    embeddedAudioTracks: undefined.IVectorView<undefined.EmbeddedAudioTrack>;

    /**
     * The time when the media clip stops playing within a MediaComposition . 
     */
    endTimeInComposition: number;

    /**
     * Gets the VideoEncodingProperties for the media clip.
     * @return  The VideoEncodingProperties for the media clip.
     */
    getVideoEncodingProperties(): undefined.VideoEncodingProperties;

    /**
     * Original playback time of the media clip, without the effects of TrimTimeFromStart and TrimTimeFromEnd properties. 
     */
    originalDuration: number;

    /**
     * The index of the audio track within the media clip that is used for playback. 
     */
    selectedEmbeddedAudioTrackIndex: number;

    /**
     * The time when the media clip starts playing within a MediaComposition . 
     */
    startTimeInComposition: number;

    /**
     * The amount of time to trim from the end of the media clip. 
     */
    trimTimeFromEnd: number;

    /**
     * The amount of time to trim from the beginning of the media clip. 
     */
    trimTimeFromStart: number;

    /**
     * Duration of the media clip with TrimTimeFromStart and TrimTimeFromEnd applied to playback. 
     */
    trimmedDuration: number;

    /**
     * An associative collection for storing custom properties associated with the media clip. 
     */
    userData: undefined.IMap<string, string>;

    /**
     * Gets the list of video effect definitions for processing the media clip. 
     */
    videoEffectDefinitions: undefined.IVector<undefined.IVideoEffectDefinition>;

    /**
     * Gets or sets the volume of the media clip. 
     */
    volume: number
}


/**
 * Represents a collection of media clips and background audio tracks. 
 */
declare class MediaComposition {

    /**
     * Asynchronously loads a MediaComposition from a StorageFile .
     * @param file The file from which to load the MediaComposition .
     * @return  An async operation which can be used to track the success or failure of the operation.
     */
    loadAsync(
        file: undefined.StorageFile): undefined.IPromiseWithIAsyncOperation<undefined.MediaComposition>;

    /**
     * Initializes a new instance of the MediaComposition class. 
     */
    constructor(): this;

    /**
     * A collection of background audio tracks for playback in the media composition. 
     */
    backgroundAudioTracks: undefined.IVector<undefined.BackgroundAudioTrack>;

    /**
     * A collection of media clips for playback in the media composition. 
     */
    clips: undefined.IVector<undefined.MediaClip>;

    /**
     * Creates a MediaComposition object that is identical to this instance.
     * @return  A MediaComposition object that is a copy of this instance.
     */
    clone(): undefined.MediaComposition;

    /**
     * Create a new default media encoding profile which can be modified if necessary.
     * @return  The newly created MediaEncodingProfile .
     */
    createDefaultEncodingProfile(): undefined.MediaEncodingProfile;

    /**
     * The total playback time of the media composition. 
     */
    duration: number;

    /**
     * Creates a new MediaStreamSource using the specified MediaEncodingProfile .
     * @param encodingProfile The MediaEncodingProfile used to specify the encoding properties of the new MediaStreamSource .
     * @return  The newly created MediaStreamSource .
     */
    generateMediaStreamSource(encodingProfile: undefined.MediaEncodingProfile): undefined.MediaStreamSource;

    /**
     * Creates a new MediaStreamSource .
     * @return  The newly created MediaStreamSource .
     */
    generateMediaStreamSource(): undefined.MediaStreamSource;

    /**
     * Creates a new MediaStreamSource used to preview the edited media.
     * @param scaledWidth The width of the preview media.
     * @param scaledHeight The height of the preview media.
     * @return  The new MediaStreamSource used to preview the edited media.
     */
    generatePreviewMediaStreamSource(scaledWidth: number, scaledHeight: number): undefined.MediaStreamSource;

    /**
     * Asynchronously gets an image stream that represents a thumbnail of the media composition.
     * @param timeFromStart Specifies the point in the timeline of the MediaComposition from which to render the thumbnail, offset from the start of the MediaComposition.
     * @param scaledWidth Specifies the target width at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
     * @param scaledHeight Specifies the target height at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
     * @param framePrecision Specifies the frame precision algorithm to use when retrieving the thumbnail.
     * @return  An image stream representing resulting thumbnail.
     */
    getThumbnailAsync(
        timeFromStart: number,
        scaledWidth: number,
        scaledHeight: number,
        framePrecision: undefined.VideoFramePrecision): undefined.IPromiseWithIAsyncOperation<undefined.ImageStream>;

    /**
     * Asynchronously gets a vector view of thumbnails of the media composition.
     * @param timesFromStart Specifies the points in the timeline of the MediaComposition from which to render the thumbnails, offset from the start of the MediaComposition.
     * @param scaledWidth Specifies the target width at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
     * @param scaledHeight Specifies the target height at which to render. The default is 0. scaledWidth and/or scaledHeight can be optional; see Remarks.
     * @param framePrecision Specifies the frame precision algorithm to use when retrieving the thumbnails.
     * @return  A vector view on the resulting thumbnails.
     */
    getThumbnailsAsync(
        timesFromStart: undefined.IIterable<number>,
        scaledWidth: number,
        scaledHeight: number,
        framePrecision: undefined.VideoFramePrecision): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the list of overlay layers for the media composition. 
     */
    overlayLayers: undefined.IVector<undefined.MediaOverlayLayer>;

    /**
     * Asynchronously renders the MediaComposition to the specified file.
     * @param destination The file to which this MediaComposition is rendered.
     * @return  An async operation which can be used to track the success or failure of the operation.
     */
    renderToFileAsync(
        destination: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.TranscodeFailureReason, number>;

    /**
     * Asynchronously renders the MediaComposition to a specified file using the indicated media trimming preference.
     * @param destination The file to which this MediaComposition is rendered.
     * @param trimmingPreference Specifies whether to be fast or precise when trimming the media.
     * @return  An async operation which can be used to track the success or failure of the operation.
     */
    renderToFileAsync(
        destination: undefined.IStorageFile,
        trimmingPreference: undefined.MediaTrimmingPreference): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.TranscodeFailureReason, number>;

    /**
     * Asynchronously renders the MediaComposition to a specified file using the indicated media trimming preference and encoding profile.
     * @param destination The file to which this MediaComposition is rendered.
     * @param trimmingPreference Specifies whether to be fast or precise when trimming the media.
     * @param encodingProfile Specifies the encoding profile to use for rendering the media.
     * @return  An async operation which can be used to track the success or failure of the operation.
     */
    renderToFileAsync(
        destination: undefined.IStorageFile,
        trimmingPreference: undefined.MediaTrimmingPreference,
        encodingProfile: undefined.MediaEncodingProfile): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.TranscodeFailureReason, number>;

    /**
     * Asynchronously serializes the MediaComposition to disk so that it can be loaded and modified in the future.
     * @param file The file to which the MediaComposition is saved.
     * @return  An async action which can be used to track the success or failure of the operation.
     */
    saveAsync(file: undefined.IStorageFile): undefined.IPromiseWithIAsyncAction;

    /**
     * An associative collection for storing custom properties associated with the media composition. 
     */
    userData: undefined.IMap<string, string >
}


/**
 * Represents an overlay that can be used in a media composition. 
 */
declare class MediaOverlay {

    /**
     * Initializes a new instance of the MediaOverlay class.
     * @param clip The media clip to be used for the overlay.
     */
    constructor(clip: undefined.MediaClip): this;

    /**
     * Initializes a new instance of the MediaOverlay class.
     * @param clip The media clip to be used for the overlay.
     * @param position The position of the overlay.
     * @param opacity The opacity of the overlay, in the range of 0.0 to 1.0, where 0.0 is completely transparent and 1.0 is completely opaque.
     */
    constructor(clip: undefined.MediaClip, position: undefined.Rect, opacity: number): this;

    /**
     * Gets or sets a value indicating whether audio is enabled for the MediaOverlay . 
     */
    audioEnabled: boolean;

    /**
     * Gets the media clip to be used for the overlay. 
     */
    clip: undefined.MediaClip;

    /**
     * Creates a MediaOverlay object that is identical to this instance.
     * @return  A MediaOverlay object that is a copy of this instance.
     */
    clone(): undefined.MediaOverlay;

    /**
     * Gets or sets the time span from the start of the clip after which the media overlay should be rendered. 
     */
    delay: number;

    /**
     * Gets the opacity of the overlay. 
     */
    opacity: number;

    /**
     * Gets the position of the overlay. 
     */
    position: undefined.Rect
}


/**
 * Represents a layer of a media overlay. 
 */
declare class MediaOverlayLayer {

    /**
     * Initializes a new instance of the MediaOverlayLayer class. 
     */
    constructor(): this;

    /**
     * Initializes a new instance of the MediaOverlayLayer class.
     * @param compositorDefinition The definition of the custom compositor associated with the media overlay layer.
     */
    constructor(compositorDefinition: undefined.IVideoCompositorDefinition): this;

    /**
     * Creates a MediaOverlayLayer object that is identical to this instance.
     * @return  A MediaOverlayLayer object that is a copy of this instance.
     */
    clone(): undefined.MediaOverlayLayer;

    /**
     * Gets the definition of the custom compositor associated with the media overlay layer, if there is one. 
     */
    customCompositorDefinition: undefined.IVideoCompositorDefinition;

    /**
     * Gets the list of overlays for this media overlay layer. 
     */
    overlays: undefined.IVector<undefined.MediaOverlay >
}


/**
 * Represent an audio capture effects manager which can be used to discover the audio processing chain on a device for a specific media category and audio processing mode. 
 */
declare class AudioCaptureEffectsManager {

    /**
     * Gets the list of audio effects on the device.
     * @return  The list of audio effects.
     */
    getAudioCaptureEffects(): undefined.IVectorView<undefined.AudioEffect>;

    /**
     * Occurs when audio process chain changes. 
     */
    onaudiocaptureeffectschanged: undefined.TypedEventHandler<undefined.AudioCaptureEffectsManager, any>;
    addEventListener(
        type: "audiocaptureeffectschanged",
        listener: undefined.TypedEventHandler<undefined.AudioCaptureEffectsManager, any>): void;
    removeEventListener(
        type: "audiocaptureeffectschanged",
        listener: undefined.TypedEventHandler<undefined.AudioCaptureEffectsManager, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an audio effect. 
 */
declare class AudioEffect {

    /**
     * Gets the type of the audio effect. 
     */
    audioEffectType: undefined.AudioEffectType
}


/**
 * Represents an audio effect definition. 
 */
declare class AudioEffectDefinition {

    /**
     * Creates a new AudioEffectDefinition object with the specified activatable class ID, configuring the object with the specified settings.
     * @param activatableClassId The activatable class ID of the audio effect definition.
     * @param props Configuration properties for the specified audio effect definition.
     */
    constructor(activatableClassId: string, props: undefined.IPropertySet): this;

    /**
     * Creates a new AudioEffectDefinition object with the specified activatable class ID.
     * @param activatableClassId The activatable class ID of the audio effect definition.
     */
    constructor(activatableClassId: string): this;

    /**
     * The activatable class ID of the audio effect definition. 
     */
    activatableClassId: string;

    /**
     * The set of properties for configuring an AudioEffectDefinition object. 
     */
    properties: undefined.IPropertySet
}


/**
 * Provides functionality for creating audio capture and render effects manager objects. 
 */
declare class AudioEffectsManager {

    /**
     * Creates a AudioCaptureEffectsManager object for the specified device for a specific media category.
     * @param deviceId The device id.
     * @param category The media category.
     * @return  The new audio capture effects manager.
     */
    createAudioCaptureEffectsManager(
        deviceId: string,
        category: undefined.MediaCategory): undefined.AudioCaptureEffectsManager;

    /**
     * Creates a AudioCaptureEffectsManager object for the specified device for a specific media category and audio processing mode.
     * @param deviceId The device id.
     * @param category The media category.
     * @param mode The audio processing mode.
     * @return  The new audio capture effects manager.
     */
    createAudioCaptureEffectsManager(
        deviceId: string,
        category: undefined.MediaCategory,
        mode: undefined.AudioProcessing): undefined.AudioCaptureEffectsManager;

    /**
     * Creates a AudioRenderEffectsManager object for the specified device for a specific media category.
     * @param deviceId The device id.
     * @param category The audio render category.
     * @param mode The audio precessing mode.
     * @return  The new audio render effects manager.
     */
    createAudioRenderEffectsManager(
        deviceId: string,
        category: undefined.AudioRenderCategory,
        mode: undefined.AudioProcessing): undefined.AudioRenderEffectsManager;

    /**
     * Creates a AudioRenderEffectsManager object for the specified device for a specific media category and audio processing mode.
     * @param deviceId The device id.
     * @param category The audio render category.
     * @return  The new audio render effects manager.
     */
    createAudioRenderEffectsManager(
        deviceId: string,
        category: undefined.AudioRenderCategory): undefined.AudioRenderEffectsManager
}


/**
 * Represent an audio render effects manager which can be used to discover the audio processing chain on a device for a specific media category and audio processing mode. 
 */
declare class AudioRenderEffectsManager {

    /**
     * Gets the label that is associated with this audio effects provider setting. 
     */
    effectsProviderSettingsLabel: string;

    /**
     * Gets the thumbnail image that is associated with this audio effects provider. 
     */
    effectsProviderThumbnail: undefined.IRandomAccessStreamWithContentType;

    /**
     * Gets the list of audio effects on the device.
     * @return  The list of audio effects.
     */
    getAudioRenderEffects(): undefined.IVectorView<undefined.AudioEffect>;

    /**
     * Occurs when audio process chain changes. 
     */
    onaudiorendereffectschanged: undefined.TypedEventHandler<undefined.AudioRenderEffectsManager, any>;
    addEventListener(
        type: "audiorendereffectschanged",
        listener: undefined.TypedEventHandler<undefined.AudioRenderEffectsManager, any>): void;
    removeEventListener(
        type: "audiorendereffectschanged",
        listener: undefined.TypedEventHandler<undefined.AudioRenderEffectsManager, any>): void;

    /**
     * Displays the audio effect settings page. 
     */
    showSettingsUI(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides context for performing a custom overlay operation within the CompositeFrame method. 
 */
declare class CompositeVideoFrameContext {

    /**
     * Gets the background frame for an overlay operation. 
     */
    backgroundFrame: undefined.VideoFrame;

    /**
     * Gets a MediaOverlay object for the provided Direct3D surface.
     * @param surfaceToOverlay The Direct3D surface.
     * @return  The created MediaOverlay object.
     */
    getOverlayForSurface(surfaceToOverlay: undefined.IDirect3DSurface): undefined.MediaOverlay;

    /**
     * Gets the output frame for an overlay operation. 
     */
    outputFrame: undefined.VideoFrame;

    /**
     * Gets the list of Direct3D surfaces to be used in an overlay operation. 
     */
    surfacesToOverlay: undefined.IVectorView<undefined.IDirect3DSurface >
}


/**
 * Provides context for performing a custom audio effect operation within the ProcessFrame method. 
 */
declare class ProcessAudioFrameContext {

    /**
     * Gets the input frame for an audio effect operation. 
     */
    inputFrame: undefined.AudioFrame;

    /**
     * Gets the output frame for an audio effect operation. 
     */
    outputFrame: undefined.AudioFrame
}


/**
 * Provides context for performing a custom video effect operation within the ProcessFrame method. 
 */
declare class ProcessVideoFrameContext {

    /**
     * Gets the input frame for a video effect operation. 
     */
    inputFrame: undefined.VideoFrame;

    /**
     * Gets the output frame for a video effect operation. 
     */
    outputFrame: undefined.VideoFrame
}


/**
 * Represents the definition of a custom video compositor. 
 */
declare class VideoCompositorDefinition {

    /**
     * Initializes a new instance of the VideoCompositorDefinition class.
     * @param activatableClassId The activatable class ID of the video compositor.
     * @param props The set of properties for configuring the video compositor object.
     */
    constructor(activatableClassId: string, props: undefined.IPropertySet): this;

    /**
     * Initializes a new instance of the VideoCompositorDefinition class.
     * @param activatableClassId The activatable class ID of the video compositor.
     */
    constructor(activatableClassId: string): this;

    /**
     * Gets the activatable class ID of the video compositor. 
     */
    activatableClassId: string;

    /**
     * Gets the set of properties for configuring the video compositor object. 
     */
    properties: undefined.IPropertySet
}


/**
 * Represents a video effect definition. 
 */
declare class VideoEffectDefinition {

    /**
     * Creates a new VideoEffectDefinition object with the specified activatable class ID, configuring the object with the specified settings.
     * @param activatableClassId The activatable class ID of the video effect definition.
     * @param props Configuration properties for the specified video effect definition.
     */
    constructor(activatableClassId: string, props: undefined.IPropertySet): this;

    /**
     * Creates a new VideoEffectDefinition object with the specified activatable class ID.
     * @param activatableClassId The activatable class ID of the video effect definition.
     */
    constructor(activatableClassId: string): this;

    /**
     * Gets the activatable class ID of the video effect definition. 
     */
    activatableClassId: string;

    /**
     * Gets the set of properties for configuring the VideoEffectDefinition object. 
     */
    properties: undefined.IPropertySet
}


/**
 * Represents the definition of a video transform effect. 
 */
declare class VideoTransformEffectDefinition {

    /**
     * Initializes a new instance of the VideoTransformEffectDefinition class. 
     */
    constructor(): this;

    /**
     * Gets the activatable class ID of the video transform effect definition. 
     */
    activatableClassId: string;

    /**
     * Gets or sets the rectangle within which the video will be cropped, specified in pixels. 
     */
    cropRectangle: undefined.Rect;

    /**
     * Gets or sets the direction in which the video will be mirrored. 
     */
    mirror: undefined.MediaMirroringOptions;

    /**
     * Gets or sets the output size of the video, in pixels. 
     */
    outputSize: undefined.Size;

    /**
     * Gets or sets the color that will be used to fill pixels in the frame that are not filled with video, such as when video is letterboxed. 
     */
    paddingColor: undefined.Color;

    /**
     * Gets or sets the media processing algorithm that is used for the video transform. 
     */
    processingAlgorithm: undefined.MediaVideoProcessingAlgorithm;

    /**
     * Gets the set of properties for configuring the VideoTransformEffectDefinition object. 
     */
    properties: undefined.IPropertySet;

    /**
     * Gets or sets the angle and direction in which the video will be rotated. 
     */
    rotation: undefined.MediaRotation
}


/**
 * Exposes the methods and properties of an AudioEffectDefinition object. Implement this interface when you create a custom audio effect definition. 
 */
declare interface Effects$IAudioEffectDefinition {

    /**
     * The activatable class ID of the audio effect definition. 
     */
    activatableClassId: string,

        /**
         * The set of properties for configuring an AudioEffectDefinition object. 
         */
        properties: undefined.IPropertySet
}


/**
 * Exposes the methods and properties of a VideoEffectDefinition object. Implement this interface when you create a custom video effect definition. 
 */
declare interface Effects$IVideoEffectDefinition {

    /**
     * The activatable class ID of the video effect definition. 
     */
    activatableClassId: string,

        /**
         * The set of properties for configuring the VideoEffectDefinition object. 
         */
        properties: undefined.IPropertySet
}


/**
 * The interface defining a custom video compositor definition. 
 */
declare interface Effects$IVideoCompositorDefinition {

    /**
     * Gets the activatable class ID of the video compositor. 
     */
    activatableClassId: string,

        /**
         * Gets the set of properties for configuring the video compositor object. 
         */
        properties: undefined.IPropertySet
}


/**
 * Represents a face that was detected in a SoftwareBitmap or a VideoFrame . 
 */
declare class DetectedFace {

    /**
     * Gets the bounds the detected face occupies in the SoftwareBitmap or VideoFrame . 
     */
    faceBox: undefined.BitmapBounds
}


/**
 * Detects faces in a SoftwareBitmap . 
 */
declare class FaceDetector {

    /**
     * Creates a new instance of the FaceDetector class.
     * @return  An asynchronous operation that returns a FaceDetector instance upon successful completion.
     */
    createAsync(): undefined.IPromiseWithIAsyncOperation<undefined.FaceDetector>;

    /**
     * Returns a list of the bitmap pixels formats supported by the FaceDetector on the current device.
     * @return  A list of the bitmap pixels formats supported by the FaceDetector on the current device.
     */
    getSupportedBitmapPixelFormats(): undefined.IVectorView<undefined.BitmapPixelFormat>;

    /**
     * Queries whether the specified bitmap pixel format is supported by the FaceDetector on the current device.
     * @param bitmapPixelFormat The bitmap pixel format for which support is queried.
     * @return  True if the specified bitmap pixel format is supported; otherwise, false.
     */
    isBitmapPixelFormatSupported(bitmapPixelFormat: undefined.BitmapPixelFormat): boolean;

    /**
     * Gets a value indicating whether the FaceDetector class is supported on the current device. 
     */
    isSupported: boolean;

    /**
     * Asynchronously detects faces in the provided SoftwareBitmap .
     * @param image The image data to be processed for face detection.
     * @return  An asynchronous operation that returns a list of DetectedFace objects upon successful completion.
     */
    detectFacesAsync(
        image: undefined.SoftwareBitmap): undefined.IPromiseWithIAsyncOperation<undefined.IVector<any >> ;

    /**
     * Asynchronously detects faces in the provided SoftwareBitmap within the specified search area.
     * @param image The image data to be processed for face detection.
     * @param searchArea The bounds within the SoftwareBitmap in which face detection will be performed.
     * @return  An asynchronous operation that returns a list of DetectedFace objects upon successful completion.
     */
    detectFacesAsync(
        image: undefined.SoftwareBitmap,
        searchArea: undefined.BitmapBounds): undefined.IPromiseWithIAsyncOperation<undefined.IVector<any >> ;

    /**
     * Gets or sets the maximum detectable face size, in pixels. 
     */
    maxDetectableFaceSize: undefined.BitmapSize;

    /**
     * Gets or sets the minimum detectable face size, in pixels. 
     */
    minDetectableFaceSize: undefined.BitmapSize
}


/**
 * Detects faces in VideoFrame objects and tracks faces across subsequent video frames. 
 */
declare class FaceTracker {

    /**
     * Creates a new instance of the FaceTracker class.
     * @return  An asynchronous operation that returns a FaceTracker instance upon successful completion.
     */
    createAsync(): undefined.IPromiseWithIAsyncOperation<undefined.FaceTracker>;

    /**
     * Returns a list of the bitmap pixels formats supported by the FaceTracker on the current device.
     * @return  A list of the bitmap pixels formats supported by the FaceTracker on the current device.
     */
    getSupportedBitmapPixelFormats(): undefined.IVectorView<undefined.BitmapPixelFormat>;

    /**
     * Queries whether the specified bitmap pixel format is supported by the FaceTracker on the current device.
     * @param bitmapPixelFormat The bitmap pixel format for which support is queried.
     * @return  True if the specified bitmap pixel format is supported; otherwise, false.
     */
    isBitmapPixelFormatSupported(bitmapPixelFormat: undefined.BitmapPixelFormat): boolean;

    /**
     * Gets a value indicating whether the FaceTracker class is supported on the current device. 
     */
    isSupported: boolean;

    /**
     * Gets or sets the maximum detectable face size, in pixels. 
     */
    maxDetectableFaceSize: undefined.BitmapSize;

    /**
     * Gets or sets the minimum detectable face size, in pixels. 
     */
    minDetectableFaceSize: undefined.BitmapSize;

    /**
     * Asynchronously processes a VideoFrame for face detection.
     * @param videoFrame The VideoFrame in which faces are detected or tracked.
     * @return  An asynchronous operation that returns a list of DetectedFace objects upon successful completion.
     */
    processNextFrameAsync(
        videoFrame: undefined.VideoFrame): undefined.IPromiseWithIAsyncOperation<undefined.IVector<any >>
}


/**
 * Provides properties for image information that is displayed by SystemMediaTransportControlsDisplayUpdater class. 
 */
declare class ImageDisplayProperties {

    /**
     * Gets or sets the subtitle of the image. 
     */
    subtitle: string;

    /**
     * Gets or sets the title of the image. 
     */
    title: string
}


/**
 * Represents the result of a operation that deletes imported media items from the source. 
 */
declare class PhotoImportDeleteImportedItemsFromSourceResult {

    /**
     * Gets a list of items that were deleted from the source. 
     */
    deletedItems: undefined.IVectorView<undefined.PhotoImportItem>;

    /**
     * Gets a value indicating whether the delete operation has succeeded. 
     */
    hasSucceeded: boolean;

    /**
     * Gets the number of photos deleted in the operation. 
     */
    photosCount: number;

    /**
     * Gets the size of the deleted photos, in bytes. 
     */
    photosSizeInBytes: number;

    /**
     * Gets the photo import session associated with the delete operation. 
     */
    session: undefined.PhotoImportSession;

    /**
     * Gets the number of sibling files deleted in the operation. 
     */
    siblingsCount: number;

    /**
     * Gets the size of the deleted sibling files, in bytes. 
     */
    siblingsSizeInBytes: number;

    /**
     * Gets the number of sidecar files deleted in the operation. 
     */
    sidecarsCount: number;

    /**
     * Gets the size of the deleted sidecar files, in bytes. 
     */
    sidecarsSizeInBytes: number;

    /**
     * Gets the total number of items deleted in the operation. 
     */
    totalCount: number;

    /**
     * Gets the total size of the all deleted items, in bytes. 
     */
    totalSizeInBytes: number;

    /**
     * Gets the number of videos deleted in the operation. 
     */
    videosCount: number;

    /**
     * Gets the size of the deleted videos, in bytes. 
     */
    videosSizeInBytes: number
}


/**
 * Represents the result of a operation that finds media items on a source. 
 */
declare class PhotoImportFindItemsResult {

    /**
     * Gets a list of items that were found on the source. 
     */
    foundItems: undefined.IVectorView<undefined.PhotoImportItem>;

    /**
     * Gets a value indicating whether the find operation has succeeded. 
     */
    hasSucceeded: boolean;

    /**
     * Asynchronously imports the selected items from the source.
     * @return  An asynchronous operation that returns a PhotoImportImportItemsResult on successful completion.
     */
    importItemsAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.PhotoImportImportItemsResult, undefined.PhotoImportProgress>;

    /**
     * Gets the photo import mode that determines which types of files are included in the ImportItemsAsync operation. 
     */
    importMode: undefined.PhotoImportImportMode;

    /**
     * Occurs when an item is imported. 
     */
    onitemimported: undefined.TypedEventHandler<undefined.PhotoImportFindItemsResult, undefined.PhotoImportItemImportedEventArgs>;
    addEventListener(
        type: "itemimported",
        listener: undefined.TypedEventHandler<undefined.PhotoImportFindItemsResult, undefined.PhotoImportItemImportedEventArgs>): void;
    removeEventListener(
        type: "itemimported",
        listener: undefined.TypedEventHandler<undefined.PhotoImportFindItemsResult, undefined.PhotoImportItemImportedEventArgs>): void;

    /**
     * Occurs when the set of items selected to be included in the ImportItemsAsync operation changes. 
     */
    onselectionchanged: undefined.TypedEventHandler<undefined.PhotoImportFindItemsResult, undefined.PhotoImportSelectionChangedEventArgs>;
    addEventListener(
        type: "selectionchanged",
        listener: undefined.TypedEventHandler<undefined.PhotoImportFindItemsResult, undefined.PhotoImportSelectionChangedEventArgs>): void;
    removeEventListener(
        type: "selectionchanged",
        listener: undefined.TypedEventHandler<undefined.PhotoImportFindItemsResult, undefined.PhotoImportSelectionChangedEventArgs>): void;

    /**
     * Gets the number of photos found on the source. 
     */
    photosCount: number;

    /**
     * Gets the size of the photos found on the source, in bytes. 
     */
    photosSizeInBytes: number;

    /**
     * Selects all items found on the source to be included in the ImportItemsAsync operation. 
     */
    selectAll(): void;

    /**
     * Selects all new items found on the source to be included in the ImportItemsAsync operation.
     * @return  An asynchronous operation.
     */
    selectNewAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Deselects all items found on the source, preventing them from being included in the ImportItemsAsync operation. 
     */
    selectNone(): void;

    /**
     * Gets the number of photos that are currently selected to be included in the ImportItemsAsync operation. 
     */
    selectedPhotosCount: number;

    /**
     * Gets the size of the photos that are currently selected to be included in the ImportItemsAsync operation, in bytes. 
     */
    selectedPhotosSizeInBytes: number;

    /**
     * Gets the number of sibling files that are currently selected to be included in the ImportItemsAsync operation. 
     */
    selectedSiblingsCount: number;

    /**
     * Gets the size of the sibling files that are currently selected to be included in the ImportItemsAsync operation, in bytes. 
     */
    selectedSiblingsSizeInBytes: number;

    /**
     * Gets the number of sidecar files that are currently selected to be included in the ImportItemsAsync operation. 
     */
    selectedSidecarsCount: number;

    /**
     * Gets the size of the sidecar files that are currently selected to be included in the ImportItemsAsync operation, in bytes. 
     */
    selectedSidecarsSizeInBytes: number;

    /**
     * Gets the total number of items that are currently selected to be included in the ImportItemsAsync operation. 
     */
    selectedTotalCount: number;

    /**
     * Gets the total size of the all items that are currently selected to be included in the ImportItemsAsync operation, in bytes. 
     */
    selectedTotalSizeInBytes: number;

    /**
     * Gets the number of videos that are currently selected to be included in the ImportItemsAsync operation. 
     */
    selectedVideosCount: number;

    /**
     * Gets the size of the videos that are currently selected to be included in the ImportItemsAsync operation, in bytes. 
     */
    selectedVideosSizeInBytes: number;

    /**
     * Gets the photo import session associated with the find operation. 
     */
    session: undefined.PhotoImportSession;

    /**
     * Sets the photo import mode that determines which types of files are included in the ImportItemsAsync operation.
     * @param value The photo import mode.
     */
    setImportMode(value: undefined.PhotoImportImportMode): void;

    /**
     * Gets the number of sibling files found on the source. 
     */
    siblingsCount: number;

    /**
     * Gets the size of the found sibling files, in bytes. 
     */
    siblingsSizeInBytes: number;

    /**
     * Gets the number of sidecar files found on the source. 
     */
    sidecarsCount: number;

    /**
     * Gets the size of the found sidecar files, in bytes. 
     */
    sidecarsSizeInBytes: number;

    /**
     * Gets the total number of items found on the source. 
     */
    totalCount: number;

    /**
     * Gets the total size of all items found on the source, in bytes. 
     */
    totalSizeInBytes: number;

    /**
     * Gets the number of videos found on the source. 
     */
    videosCount: number;

    /**
     * Gets the size of the videos found on the source, in bytes. 
     */
    videosSizeInBytes: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the result of a operation that imports media items from the source. 
 */
declare class PhotoImportImportItemsResult {

    /**
     * Asynchronously deletes the items that were imported from the source.
     * @return  An asynchronous operation that returns a PhotoImportDeleteImportedItemsFromSourceResult on successful completion.
     */
    deleteImportedItemsFromSourceAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.PhotoImportDeleteImportedItemsFromSourceResult, number>;

    /**
     * Gets a value indicating whether the import operation has succeeded. 
     */
    hasSucceeded: boolean;

    /**
     * Gets a list of items that were imported from the source. 
     */
    importedItems: undefined.IVectorView<undefined.PhotoImportItem>;

    /**
     * Gets the number of photos imported in the operation. 
     */
    photosCount: number;

    /**
     * Gets the size of the imported photos, in bytes. 
     */
    photosSizeInBytes: number;

    /**
     * Gets the photo import session associated with the import operation. 
     */
    session: undefined.PhotoImportSession;

    /**
     * Gets the number of sibling files imported in the operation. 
     */
    siblingsCount: number;

    /**
     * Gets the size of the imported sidecar files, in bytes. 
     */
    siblingsSizeInBytes: number;

    /**
     * Gets the number of sidecar files imported in the operation. 
     */
    sidecarsCount: number;

    /**
     * Gets the size of the imported sidecar files, in bytes. 
     */
    sidecarsSizeInBytes: number;

    /**
     * Gets the total number of items imported in the operation. 
     */
    totalCount: number;

    /**
     * Gets the total size of the all imported items, in bytes. 
     */
    totalSizeInBytes: number;

    /**
     * Gets the number of videos imported in the operation. 
     */
    videosCount: number;

    /**
     * Gets the size of the imported videos, in bytes. 
     */
    videosSizeInBytes: number
}


/**
 * Represents an media item that has been imported from a source. 
 */
declare class PhotoImportItem {

    /**
     * Gets the content type of the imported item. 
     */
    contentType: undefined.PhotoImportContentType;

    /**
     * Gets the creation date of the imported item. 
     */
    date: Date;

    /**
     * Gets a list of the names of files associated with this item that were deleted. 
     */
    deletedFileNames: undefined.IVectorView<string>;

    /**
     * Gets a list of the names of files associated with this item that were imported. 
     */
    importedFileNames: undefined.IVectorView<string>;

    /**
     * Gets a value indicating whether the item is currently selected for import. 
     */
    isSelected: boolean;

    /**
     * Gets the key used to identify the item. 
     */
    itemKey: number;

    /**
     * Gets the name of the item. 
     */
    name: string;

    /**
     * Gets the sibling file associated with the item, if one exists. 
     */
    sibling: undefined.PhotoImportSidecar;

    /**
     * Gets the list of sidecar files associated with the item, if any exists. 
     */
    sidecars: undefined.IVectorView<undefined.PhotoImportSidecar>;

    /**
     * Gets the size of the item, in bytes. 
     */
    sizeInBytes: number;

    /**
     * Gets a random access stream containing the thumbnail image associated with the item. 
     */
    thumbnail: undefined.IRandomAccessStreamReference;

    /**
     * Gets the list of video segments associated with the item. 
     */
    videoSegments: undefined.IVectorView<undefined.PhotoImportVideoSegment >
}


/**
 * Provides data for the PhotoImportFindItemsResult::ItemImported event. 
 */
declare class PhotoImportItemImportedEventArgs {

    /**
     * Gets the imported item associated with the PhotoImportFindItemsResult::ItemImported event. 
     */
    importedItem: undefined.PhotoImportItem
}


/**
 * Provides APIs for determining if photo import is supported on the current device, finding sources from which to import photos, and getting references to any pending photo import operations. 
 */
declare class PhotoImportManager {

    /**
     * Finds all currently available sources from which photos can be imported.
     * @return  An asynchronous operation that returns a list of available sources on successful completion.
     */
    findAllSourcesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the list of all pending photo import operations.
     * @return  The list of all pending photo operations.
     */
    getPendingOperations(): undefined.IVectorView<undefined.PhotoImportOperation>;

    /**
     * Gets a value indicating if photo import is supported on the current device.
     * @return  An asynchronous operation that returns true if photo import is supported. Otherwise, returns false.
     */
    isSupportedAsync(): undefined.IPromiseWithIAsyncOperation<boolean >
}


/**
 * Represents an in-progress photo import operation. 
 */
declare class PhotoImportOperation {

    /**
     * Causes in-progress delete from source operations to continue. 
     */
    continueDeletingImportedItemsFromSourceAsync: undefined.IAsyncOperationWithProgress<undefined.PhotoImportDeleteImportedItemsFromSourceResult, number>;

    /**
     * Causes in-progress find operations to continue. 
     */
    continueFindingItemsAsync: undefined.IAsyncOperationWithProgress<undefined.PhotoImportFindItemsResult, number>;

    /**
     * Causes in-progress import items operations to continue. 
     */
    continueImportingItemsAsync: undefined.IAsyncOperationWithProgress<undefined.PhotoImportImportItemsResult, undefined.PhotoImportProgress>;

    /**
     * Gets the photo import session associated with the operation. 
     */
    session: undefined.PhotoImportSession;

    /**
     * Gets the current stage of the in-progress operation. 
     */
    stage: undefined.PhotoImportStage
}


/**
 * Provides data for the PhotoImportFindItemsResult::SelectionChanged event. 
 */
declare class PhotoImportSelectionChangedEventArgs {

    /**
     * Gets a value indicating whether no items are selected after the selection has changed. 
     */
    isSelectionEmpty: boolean
}


/**
 * Represents a photo import session with a photo import source. 
 */
declare class PhotoImportSession {

    /**
     * Gets or sets a value specifying whether the session date should be appended to the destination folder name. 
     */
    appendSessionDateToDestinationFolder: boolean;

    /**
     * Closes the photo import session and releases associated resources. 
     */
    close(): void;

    /**
     * Gets or sets the prefix for the destination file name. 
     */
    destinationFileNamePrefix: string;

    /**
     * Gets or sets the destination folder for the photo import session. 
     */
    destinationFolder: undefined.IStorageFolder;

    /**
     * Asynchronously finds items on the source device that are available for import.
     * @param contentTypeFilter A value indicating whether the find operation includes images, videos, or both in the results.
     * @param itemSelectionMode A value indicating whether all items, no items, or only new items in the results are initially marked as selected.
     * @return  An asynchronous operation that returns a PhotoImportFindItemsResult on successful completion.
     */
    findItemsAsync(
        contentTypeFilter: undefined.PhotoImportContentTypeFilter,
        itemSelectionMode: undefined.PhotoImportItemSelectionMode): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.PhotoImportFindItemsResult, number>;

    /**
     * Gets a unique identifier for the import session. 
     */
    sessionId: string;

    /**
     * Gets an object representing the source device associated with the photo import session. 
     */
    source: undefined.PhotoImportSource;

    /**
     * Gets or sets a value indicating the method used for naming subfolders within the destination folder. 
     */
    subfolderCreationMode: undefined.PhotoImportSubfolderCreationMode
}


/**
 * Represents a sidecar file or a sibling file to a PhotoImportItem . 
 */
declare class PhotoImportSidecar {

    /**
     * Gets the date of the sidecar or sibling file. 
     */
    date: Date;

    /**
     * Gets the name of the sidecar or sibling file. 
     */
    name: string;

    /**
     * Gets the size of the sidecar or sibling file, in bytes. 
     */
    sizeInBytes: number
}


/**
 * Represents the source device for a photo import session. 
 */
declare class PhotoImportSource {

    /**
     * Creates a new instance of PhotoImportSource from the specified root folder.
     * @param sourceRootFolder The root folder from which the photo import source is created.
     * @return  An asynchronous operation that returns a PhotoImportSource upon successful completion.
     */
    fromFolderAsync(
        sourceRootFolder: undefined.IStorageFolder): undefined.IPromiseWithIAsyncOperation<undefined.PhotoImportSource>;

    /**
     * Creates a new instance of PhotoImportSource from the specified device ID.
     * @param sourceId The root folder from which the photo import source is created.
     * @return  An asynchronous operation that returns a PhotoImportSource upon successful completion.
     */
    fromIdAsync(
        sourceId: string): undefined.IPromiseWithIAsyncOperation<undefined.PhotoImportSource>;

    /**
     * The battery level of the source device. 
     */
    batteryLevelPercent: number;

    /**
     * Gets the connection protocol that is being used to communicate with the source device. 
     */
    connectionProtocol: string;

    /**
     * Gets a value indicating the transport mechanism that is being used for importing items from the source device. 
     */
    connectionTransport: undefined.PhotoImportConnectionTransport;

    /**
     * Creates a new photo import session.
     * @return  The new PhotoImportSession object.
     */
    createImportSession(): undefined.PhotoImportSession;

    /**
     * Gets the current date and time on the device. 
     */
    dateTime: Date;

    /**
     * Gets a human-readable description of the source device. 
     */
    description: string;

    /**
     * Gets the human-readable display name for the source device. 
     */
    displayName: string;

    /**
     * Gets a unique 16-byte identifier that is common across multiple transports supported by the device. 
     */
    id: string;

    /**
     * Gets a value indicating if the source device is locked. 
     */
    isLocked: boolean;

    /**
     * Gets a value indicating if the source device is a mass storage device. 
     */
    isMassStorage: boolean;

    /**
     * Gets the source device's human-readable manufacturer name. 
     */
    manufacturer: string;

    /**
     * Gets the device model name. 
     */
    model: string;

    /**
     * Gets a value indicating the type of power source being used by the source device, if it is known. 
     */
    powerSource: undefined.PhotoImportPowerSource;

    /**
     * Gets the serial number of the device. 
     */
    serialNumber: string;

    /**
     * Gets a list of objects representing the different storage media exposed by the source device. 
     */
    storageMedia: undefined.IVectorView<undefined.PhotoImportStorageMedium>;

    /**
     * Gets a reference to a stream containing the thumbnail image for the source device. 
     */
    thumbnail: undefined.IRandomAccessStreamReference;

    /**
     * Gets a value indicating the type of the source device. 
     */
    type: undefined.PhotoImportSourceType
}


/**
 * Represents a storage medium exposed by a photo import source device. 
 */
declare class PhotoImportStorageMedium {

    /**
     * Gets the available space on the storage medium, in bytes. 
     */
    availableSpaceInBytes: number;

    /**
     * Gets the capacity of the storage media, in bytes. 
     */
    capacityInBytes: number;

    /**
     * Gets a description of the storage medium. 
     */
    description: string;

    /**
     * Gets the name of the storage medium. 
     */
    name: string;

    /**
     * Refreshes the information about the storage medium. 
     */
    refresh(): void;

    /**
     * Gets the serial number of the storage medium. 
     */
    serialNumber: string;

    /**
     * Gets the type of the storage medium. 
     */
    storageMediumType: undefined.PhotoImportStorageMediumType;

    /**
     * Gets a value indicating the access modes supported by the storage medium. 
     */
    supportedAccessMode: undefined.PhotoImportAccessMode
}


/**
 * Represents an imported video segment. 
 */
declare class PhotoImportVideoSegment {

    /**
     * Gets the date of the imported video segment. 
     */
    date: Date;

    /**
     * Gets the name of the imported video segment. 
     */
    name: string;

    /**
     * Gets the sibling file associated with the imported video segment. 
     */
    sibling: undefined.PhotoImportSidecar;

    /**
     * Gets the sidecar file associated with the imported video segment. 
     */
    sidecars: undefined.IVectorView<undefined.PhotoImportSidecar>;

    /**
     * Gets the size of the imported video segment, in bytes. 
     */
    sizeInBytes: number
}


/**
 * The progress data for an asynchronous photo import operation. 
 */
declare interface Import$PhotoImportProgress {

    /**
     * The number of bytes that have been imported. 
     */
    bytesImported: number,

        /**
         * The current import progress, expressed as a floating point value from 0 to 1. 
         */
        importProgress: number,

        /**
         * The number of items that have been imported. 
         */
        itemsImported: number,

        /**
         * The total number of bytes to be imported. 
         */
        totalBytesToImport: number,

        /**
         * The total number of items to be imported. 
         */
        totalItemsToImport: number
}


/**
 * Describes the object that applications register with, to receive media focus and transport control notifications. 
 */
declare class MediaControl {

    /**
     * Gets or sets the path to the artwork for the album cover. 
     */
    albumArt: undefined.Uri;

    /**
     * Gets or sets the name of the artist. 
     */
    artistName: string;

    /**
     * Gets or sets the state of the Play button. 
     */
    isPlaying: boolean;

    /**
     * Event raised when a ChannelDown command is issued to the application. 
     */
    onchanneldownpressed: undefined.EventHandler<any>;
    addEventListener(type: "channeldownpressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "channeldownpressed", listener: undefined.EventHandler<any>): void;

    /**
     * Event raised when a ChannelUp command is issued to the application. 
     */
    onchanneluppressed: undefined.EventHandler<any>;
    addEventListener(type: "channeluppressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "channeluppressed", listener: undefined.EventHandler<any>): void;

    /**
     * Event raised when a FastForward command is issued to the application. 
     */
    onfastforwardpressed: undefined.EventHandler<any>;
    addEventListener(type: "fastforwardpressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "fastforwardpressed", listener: undefined.EventHandler<any>): void;

    /**
     * Event raised when a NextTrack command is issued to the application. 
     */
    onnexttrackpressed: undefined.EventHandler<any>;
    addEventListener(type: "nexttrackpressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "nexttrackpressed", listener: undefined.EventHandler<any>): void;

    /**
     * Event raised when a Pause command is issued to the application. 
     */
    onpausepressed: undefined.EventHandler<any>;
    addEventListener(type: "pausepressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "pausepressed", listener: undefined.EventHandler<any>): void;

    /**
     * Event raised when a PlayPauseToggle command is issued to the application. 
     */
    onplaypausetogglepressed: undefined.EventHandler<any>;
    addEventListener(type: "playpausetogglepressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "playpausetogglepressed", listener: undefined.EventHandler<any>): void;

    /**
     * Event raised when a Play command is issued to the application. 
     */
    onplaypressed: undefined.EventHandler<any>;
    addEventListener(type: "playpressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "playpressed", listener: undefined.EventHandler<any>): void;

    /**
     * Event raised when a PreviousTrack command is issued to the application. 
     */
    onprevioustrackpressed: undefined.EventHandler<any>;
    addEventListener(type: "previoustrackpressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "previoustrackpressed", listener: undefined.EventHandler<any>): void;

    /**
     * Event raised when a Record command is issued to the application. 
     */
    onrecordpressed: undefined.EventHandler<any>;
    addEventListener(type: "recordpressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "recordpressed", listener: undefined.EventHandler<any>): void;

    /**
     * Event raised when a Rewind command is issued to the application. 
     */
    onrewindpressed: undefined.EventHandler<any>;
    addEventListener(type: "rewindpressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "rewindpressed", listener: undefined.EventHandler<any>): void;

    /**
     * Event raised when the sound level changes. 
     */
    onsoundlevelchanged: undefined.EventHandler<any>;
    addEventListener(type: "soundlevelchanged", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "soundlevelchanged", listener: undefined.EventHandler<any>): void;

    /**
     * Event raised when a Stop command is issued to the application. 
     */
    onstoppressed: undefined.EventHandler<any>;
    addEventListener(type: "stoppressed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "stoppressed", listener: undefined.EventHandler<any>): void;

    /**
     * Gets the current sound level. 
     */
    soundLevel: undefined.SoundLevel;

    /**
     * Gets or sets the track name. 
     */
    trackName: string;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Registers a media parser or codec. 
 */
declare class MediaExtensionManager {

    /**
     * Creates a new MediaExtensionManager object that is used to register a media parser or codec. 
     */
    constructor(): this;

    /**
     * Registers an audio decoder for the specified input and output media types.
     * @param activatableClassId The class identifier of the activatable runtime class of the audio decoder. The runtime class must implement the IMediaExtension interface.
     * @param inputSubtype The guid identifier of the media type that the audio decoder accepts as input.
     * @param outputSubtype The guid identifier of the media type that is output by the audio decoder.
     */
    registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;

    /**
     * Registers an audio decoder for the specified input and output media types with an optional configuration parameter.
     * @param activatableClassId The class identifier of the activatable runtime class of the audio decoder. The runtime class must implement the IMediaExtension interface.
     * @param inputSubtype The guid identifier of the media type that the audio decoder accepts as input.
     * @param outputSubtype The guid identifier of the media type that is output by the audio decoder.
     * @param configuration An optional parameter that contains the configuration properties to be passed to the audio decoder.
     */
    registerAudioDecoder(
        activatableClassId: string,
        inputSubtype: string,
        outputSubtype: string,
        configuration: undefined.IPropertySet): void;

    /**
     * Registers an audio encoder for the specified input and output media types with an optional configuration parameter.
     * @param activatableClassId The class identifier of the activatable runtime class of the audio encoder. The runtime class must implement the IMediaExtension interface.
     * @param inputSubtype The guid identifier of the media type that the audio encoder accepts as input.
     * @param outputSubtype The guid identifier of the media type that is output by the audio encoder.
     * @param configuration An optional parameter that contains the configuration properties to be passed to the audio encoder.
     */
    registerAudioEncoder(
        activatableClassId: string,
        inputSubtype: string,
        outputSubtype: string,
        configuration: undefined.IPropertySet): void;

    /**
     * Registers an audio encoder for the specified input and output media types.
     * @param activatableClassId The class identifier of the activatable runtime class of the audio encoder. The runtime class must implement the IMediaExtension interface.
     * @param inputSubtype The guid identifier of the media type that the audio encoder accepts as input.
     * @param outputSubtype The guid identifier of the media type that is output by the audio encoder.
     */
    registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;

    /**
     * Registers a byte-stream handler by file name extension and MIME type.
     * @param activatableClassId The class identifier of the activatable runtime class of the byte-stream handler. The runtime class must implement the IMediaExtension interface.
     * @param fileExtension The file name extension that is registered for this byte-stream handler.
     * @param mimeType The MIME type that is registered for this byte-stream handler.
     */
    registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string): void;

    /**
     * Registers a byte-stream handler by file name extension and MIME type, with an optional configuration parameter.
     * @param activatableClassId The class identifier of the activatable runtime class of the byte-stream handler. The runtime class must implement the IMediaExtension interface.
     * @param fileExtension The file name extension that is registered for this byte-stream handler.
     * @param mimeType The MIME type that is registered for this byte-stream handler.
     * @param configuration An optional parameter that contains configuration properties for the byte-stream handler.
     */
    registerByteStreamHandler(
        activatableClassId: string,
        fileExtension: string,
        mimeType: string,
        configuration: undefined.IPropertySet): void;

    /**
     * Registers a scheme handler for the specified URL scheme with an optional configuration parameter.
     * @param activatableClassId The class identifier of the activatable runtime class of the scheme handler. The runtime class must implement the IMediaExtension interface.
     * @param scheme The URL scheme that will be recognized to invoke the scheme handler. For example, "myscheme://".
     * @param configuration An optional parameter that contains configuration properties for the scheme handler.
     */
    registerSchemeHandler(
        activatableClassId: string,
        scheme: string,
        configuration: undefined.IPropertySet): void;

    /**
     * Registers a scheme handler for the specified URL scheme.
     * @param activatableClassId The class identifier of the activatable runtime class of the scheme handler. The runtime class must implement the IMediaExtension interface.
     * @param scheme The URL scheme that will be recognized to invoke the scheme handler. For example, "myscheme://".
     */
    registerSchemeHandler(activatableClassId: string, scheme: string): void;

    /**
     * Registers an video decoder for the specified input and output media types.
     * @param activatableClassId The class identifier of the activatable runtime class of the video decoder. The runtime class must implement the IMediaExtension interface.
     * @param inputSubtype The guid identifier of the media type that the video decoder accepts as input.
     * @param outputSubtype The guid identifier of the media type that is output by the video decoder.
     */
    registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;

    /**
     * Registers a video decoder for the specified input and output media types with an optional configuration parameter.
     * @param activatableClassId The class identifier of the activatable runtime class of the video decoder. The runtime class must implement the IMediaExtension interface.
     * @param inputSubtype The guid identifier of the media type that the video decoder accepts as input.
     * @param outputSubtype The guid identifier of the media type that is output by the video decoder.
     * @param configuration An optional parameter that contains the configuration properties to be passed to the video decoder.
     */
    registerVideoDecoder(
        activatableClassId: string,
        inputSubtype: string,
        outputSubtype: string,
        configuration: undefined.IPropertySet): void;

    /**
     * Registers a video encoder for the specified input and output media types.
     * @param activatableClassId The class identifier of the activatable runtime class of the video encoder. The runtime class must implement the IMediaExtension interface.
     * @param inputSubtype The guid identifier of the media type that the video encoder accepts as input.
     * @param outputSubtype The guid identifier of the media type that is output by the video encoder.
     */
    registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;

    /**
     * Registers a video encoder for the specified input and output media types with an optional configuration parameter.
     * @param activatableClassId The class identifier of the activatable runtime class of the video encoder. The runtime class must implement the IMediaExtension interface.
     * @param inputSubtype The guid identifier of the media type that the video encoder accepts as input.
     * @param outputSubtype The guid identifier of the media type that is output by the video encoder.
     * @param configuration An optional parameter that contains the configuration properties to be passed to the video encoder.
     */
    registerVideoEncoder(
        activatableClassId: string,
        inputSubtype: string,
        outputSubtype: string,
        configuration: undefined.IPropertySet): void
}


/**
 * Provides a static list of media marker types. 
 */
declare class MediaMarkerTypes {

    /**
     * Gets the value of the Bookmark type which is returned as the string "Bookmark" 
     */
    bookmark: string
}


/**
 * Provides a media processing background task access to the set of arguments supplied in the call to MediaProcessingTrigger::RequestAsync . 
 */
declare class MediaProcessingTriggerDetails {

    /**
     * Gets a value set containing the arguments supplied in the call to MediaProcessingTrigger::RequestAsync . 
     */
    arguments: undefined.ValueSet
}


/**
 * Describes the format of an audio stream. 
 */
declare class AudioEncodingProperties {

    /**
     * Creates an instance of AudioEncodingProperties for Advanced Audio Coding (AAC) audio.
     * @param sampleRate The audio sampling rate.
     * @param channelCount The number of audio channels.
     * @param bitrate The audio bit rate.
     * @return  The audio encoding properties.
     */
    createAac(
        sampleRate: number,
        channelCount: number,
        bitrate: number): undefined.AudioEncodingProperties;

    /**
     * Creates an instance of AudioEncodingProperties for Advanced Audio Coding (AAC) audio in Audio Data Transport Stream (ADTS) format.
     * @param sampleRate The audio sampling rate.
     * @param channelCount The number of audio channels.
     * @param bitrate The audio bit rate.
     * @return  The audio encoding properties.
     */
    createAacAdts(
        sampleRate: number,
        channelCount: number,
        bitrate: number): undefined.AudioEncodingProperties;

    /**
     * Creates an instance of AudioEncodingProperties for MPEG Audio Layer-3 (MP3) audio.
     * @param sampleRate The audio sampling rate.
     * @param channelCount The number of audio channels.
     * @param bitrate The audio bit rate.
     * @return  The audio encoding properties.
     */
    createMp3(
        sampleRate: number,
        channelCount: number,
        bitrate: number): undefined.AudioEncodingProperties;

    /**
     * Creates an instance of AudioEncodingProperties for Pulse Code Modulation (PCM) audio.
     * @param sampleRate The audio sampling rate.
     * @param channelCount The number of audio channels.
     * @param bitsPerSample The audio bit depth.
     * @return  The audio encoding properties.
     */
    createPcm(
        sampleRate: number,
        channelCount: number,
        bitsPerSample: number): undefined.AudioEncodingProperties;

    /**
     * Creates an instance of AudioEncodingProperties for Windows Media Audio (WMA).
     * @param sampleRate The audio sampling rate.
     * @param channelCount The number of audio channels.
     * @param bitrate The audio bit rate.
     * @return  The audio encoding properties.
     */
    createWma(
        sampleRate: number,
        channelCount: number,
        bitrate: number): undefined.AudioEncodingProperties;

    /**
     * Creates a new instance of the AudioEncodingProperties class. 
     */
    constructor(): this;

    /**
     * Gets or sets the audio bit rate. 
     */
    bitrate: number;

    /**
     * Gets or sets the number of bits per audio sample. 
     */
    bitsPerSample: number;

    /**
     * Gets or sets the number of audio channels. 
     */
    channelCount: number;

    /**
     * Gets the media format user data.
     * @return  Receives the media format data.
     */
    getFormatUserData(): number[];

    /**
     * Gets additional format properties for the audio stream. 
     */
    properties: undefined.MediaPropertySet;

    /**
     * Gets or sets audio sampling rate. 
     */
    sampleRate: number;

    /**
     * Sets the media format user data.
     * @param value The media data to set.
     */
    setFormatUserData(value: number[]): void;

    /**
     * Gets or sets the subtype of the format. 
     */
    subtype: string;

    /**
     * Gets the format type. 
     */
    type: string
}


/**
 * Describes a media container format. 
 */
declare class ContainerEncodingProperties {

    /**
     * Creates a new instance of the ContainerEncodingProperties class. 
     */
    constructor(): this;

    /**
     * Gets additional format properties for the media container. 
     */
    properties: undefined.MediaPropertySet;

    /**
     * Gets or sets the subtype of the media container. 
     */
    subtype: string;

    /**
     * Gets the format type. 
     */
    type: string
}


/**
 * Provides properties for getting H.265 profile ids. 
 */
declare class H264ProfileIds {

    /**
     * Gets the H.264 baseline profile. 
     */
    baseline: number;

    /**
     * Gets the H.264 constrained baseline profile. 
     */
    constrainedBaseline: number;

    /**
     * Gets the H.264 extended profile. 
     */
    extended: number;

    /**
     * Gets the H.264 high profile. 
     */
    high: number;

    /**
     * Gets the H.264 high 10 profile. 
     */
    high10: number;

    /**
     * Gets the H.264 high 4:2:2 profile. 
     */
    high422: number;

    /**
     * Gets the H.264 high 4:4:4 profile. 
     */
    high444: number;

    /**
     * Gets the H.264 main profile. 
     */
    main: number;

    /**
     * Gets the H.264 multiview profile. 
     */
    multiviewHigh: number;

    /**
     * Gets the H.264 stereo high profile. 
     */
    stereoHigh: number
}


/**
 * Describes the format of an image stream. 
 */
declare class ImageEncodingProperties {

    /**
     * Creates an instance of ImageEncodingProperties for a BMP image.
     * @return  The image encoding properties.
     */
    createBmp(): undefined.ImageEncodingProperties;

    /**
     * Creates an instance of ImageEncodingProperties for a JPEG image.
     * @return  The properties for the image stream.
     */
    createJpeg(): undefined.ImageEncodingProperties;

    /**
     * Creates an instance of ImageEncodingProperties for a JPEG XR image.
     * @return  The properties for the image stream.
     */
    createJpegXR(): undefined.ImageEncodingProperties;

    /**
     * Creates an instance of ImageEncodingProperties for a PNG image.
     * @return  The properties for the image stream.
     */
    createPng(): undefined.ImageEncodingProperties;

    /**
     * Creates an instance of ImageEncodingProperties for an uncompressed image.
     * @param format The media pixel format.
     * @return  The image encoding properties.
     */
    createUncompressed(format: undefined.MediaPixelFormat): undefined.ImageEncodingProperties;

    /**
     * Creates a new instance of the ImageEncodingProperties class. 
     */
    constructor(): this;

    /**
     * Gets or sets the image height. 
     */
    height: number;

    /**
     * Gets additional format properties for the image stream. 
     */
    properties: undefined.MediaPropertySet;

    /**
     * Gets or sets the subtype of the format. 
     */
    subtype: string;

    /**
     * Gets the format type. 
     */
    type: string;

    /**
     * Gets or sets the image width. 
     */
    width: number
}


/**
 * Describes the encoding profile for an audio or video file. The encoding profile includes descriptions of the audio and video encoding formats, and a description of the media container. 
 */
declare class MediaEncodingProfile {

    /**
     * Creates an instance of MediaEncodingProfile for AVI.
     * @param quality The video quality.
     * @return  The media encoding profile.
     */
    createAvi(quality: undefined.VideoEncodingQuality): undefined.MediaEncodingProfile;

    /**
     * Creates an encoding profile from an existing media file.
     * @param file The media file from which to create the profile.
     * @return  An object that is used to control the asynchronous operation.
     */
    createFromFileAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.MediaEncodingProfile>;

    /**
     * Creates an encoding profile from a stream that contains media data.
     * @param stream The media stream from which to create the profile.
     * @return  An object that is used to control the asynchronous operation.
     */
    createFromStreamAsync(
        stream: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncOperation<undefined.MediaEncodingProfile>;

    /**
     * Creates an encoding profile for AAC audio.
     * @param quality Specifies whether to create a profile with a low bit rate, medium bit rate, or high bit rate.
     * @return  Returns a media encoding profile.
     */
    createM4a(quality: undefined.AudioEncodingQuality): undefined.MediaEncodingProfile;

    /**
     * Creates an encoding profile for MP3 (MPEG-1 layer 3) audio.
     * @param quality Specifies whether to create a profile with a low bit rate, medium bit rate, or high bit rate.
     * @return  Returns a media encoding profile.
     */
    createMp3(quality: undefined.AudioEncodingQuality): undefined.MediaEncodingProfile;

    /**
     * Creates an encoding profile for H.264 video.
     * @param quality Specifies the video resolution of the profile.
     * @return  Returns a media encoding profile.
     */
    createMp4(quality: undefined.VideoEncodingQuality): undefined.MediaEncodingProfile;

    /**
     * Creates an instance of MediaEncodingProfile for WAV
     * @param quality The audio encoding quality.
     * @return  The media encoding profile.
     */
    createWav(quality: undefined.AudioEncodingQuality): undefined.MediaEncodingProfile;

    /**
     * Creates an encoding profile for Windows Media Audio (WMA).
     * @param quality Specifies whether to create a profile with a low bit rate, medium bit rate, or high bit rate.
     * @return  Returns a media encoding profile.
     */
    createWma(quality: undefined.AudioEncodingQuality): undefined.MediaEncodingProfile;

    /**
     * Creates an encoding profile for Windows Media Video (WMV).
     * @param quality Specifies the video resolution of the profile.
     * @return  Returns a media encoding profile.
     */
    createWmv(quality: undefined.VideoEncodingQuality): undefined.MediaEncodingProfile;

    /**
     * Creates a new instance of the MediaEncodingProfile class. 
     */
    constructor(): this;

    /**
     * Gets or sets the encoding properties for the audio stream. 
     */
    audio: undefined.AudioEncodingProperties;

    /**
     * Gets or sets the properties of the media container. 
     */
    container: undefined.ContainerEncodingProperties;

    /**
     * Gets or sets the encoding properties for the video stream. 
     */
    video: undefined.VideoEncodingProperties
}


/**
 * Provides properties for getting the standard names for media subtypes. 
 */
declare class MediaEncodingSubtypes {

    /**
     * Gets the name for Advanced Audio Coding (AAC). 
     */
    aac: string;

    /**
     * Gets the name for Advanced Audio Coding (AAC) audio in Audio Data Transport Stream (ADTS) format. 
     */
    aacAdts: string;

    /**
     * Gets the name for Dolby Digital audio (AC-3). 
     */
    ac3: string;

    /**
     * Gets the name for Adaptive Multi-Rate (AmrNb). 
     */
    amrNb: string;

    /**
     * Gets the name for Adaptive Multi-Rate Wideband. 
     */
    amrWb: string;

    /**
     * Gets the name for RGB 32 with alpha channel. 
     */
    argb32: string;

    /**
     * Gets the name for Advanced Systems Format (ASF). 
     */
    asf: string;

    /**
     * Gets the name for Audio Video Interleave (AVI). 
     */
    avi: string;

    /**
     * Gets the name for BGRA8. 
     */
    bgra8: string;

    /**
     * Gets the name for BMP file format. 
     */
    bmp: string;

    /**
     * Gets the name Dolby Digital Plus (E-AC-3). 
     */
    eac3: string;

    /**
     * Gets the name for Uncompressed IEEE floating-point audio. 
     */
    float: string;

    /**
     * Gets the name for Graphics Interchange Format (GIF). 
     */
    gif: string;

    /**
     * Gets the name for H.263. 
     */
    h263: string;

    /**
     * The name for H.264. 
     */
    h264: string;

    /**
     * Get the name for H.264Es. 
     */
    h264Es: string;

    /**
     * Gets the name for High Efficiency Video Coding (HEVC). 
     */
    hevc: string;

    /**
     * Gets the name for HEVCES. 
     */
    hevcEs: string;

    /**
     * Gets the name for IYUV. 
     */
    iyuv: string;

    /**
     * Gets the name for JPEG. 
     */
    jpeg: string;

    /**
     * Gets the name for JPEG-XR. 
     */
    jpegXr: string;

    /**
     * Gets the name for Motion JPEG (MJPG). 
     */
    mjpg: string;

    /**
     * Gete the name for MPEG Audio Layer-3 (MP3). 
     */
    mp3: string;

    /**
     * Gets the name for MPEG. 
     */
    mpeg: string;

    /**
     * Gets the name for MPEG-1. 
     */
    mpeg1: string;

    /**
     * Gets the name for MPEG-2. 
     */
    mpeg2: string;

    /**
     * Gets the name for MPEG-4. 
     */
    mpeg4: string;

    /**
     * Gets the name for NV12. 
     */
    nv12: string;

    /**
     * Gets the name for PCM. 
     */
    pcm: string;

    /**
     * Gets the name for Portable Network Graphics (PNG). 
     */
    png: string;

    /**
     * Gets the name RGB 24. 
     */
    rgb24: string;

    /**
     * Gets the name for RGB 32. 
     */
    rgb32: string;

    /**
     * Gets the name for TIFF. 
     */
    tiff: string;

    /**
     * Gets the name for Waveform Audio File (WAVE). 
     */
    wave: string;

    /**
     * Gets the name for Windows Media Audio 8. 
     */
    wma8: string;

    /**
     * Gets the name for Windows Media Audio 8. 
     */
    wma9: string;

    /**
     * Gets the name for Windows Media Video 9. 
     */
    wmv3: string;

    /**
     * Gets the name for Windows Media Video 9 Advanced Profile. 
     */
    wvc1: string;

    /**
     * Gets the name for YUY2. 
     */
    yuy2: string;

    /**
     * Gets the name for YV12. 
     */
    yv12: string
}


/**
 * Represents a set of media properties. 
 */
declare class MediaPropertySet {

    /**
     * Creates an instance for MediaPropertySet . 
     */
    constructor(): this;

    /**
     * Removes all items from the property set. 
     */
    clear(): void;

    /**
     * Returns an iterator to enumerate the items in the property set.
     * @return  The iterator. The current position of the iterator is index 0, or the end of the property set if the property set is empty.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Returns an immutable view of the property set.
     * @return  The immutable view.
     */
    getView(): undefined.IMapView<string, any>;

    /**
     * Indicates whether the property set has an item with the specified key.
     * @param key The key.
     * @return  True if the property set has an item with the specified key; otherwise, false.
     */
    hasKey(key: string): boolean;

    /**
     * Adds an item to the property set.
     * @param key The key of the item to insert.
     * @param value The value of the item to insert.
     * @return  True if the method replaced a value that already existed for the key; false if this is a new key.
     */
    insert(key: string, value: any): boolean;

    /**
     * Retrieves the value for the specified key.
     * @param key The key.
     * @return  The value, if an item with the specified key exists. Otherwise, null.
     */
    lookup(key: string): any;

    /**
     * Removes an item from the property set.
     * @param key The key of the item to remove.
     */
    remove(key: string): void;

    /**
     * Removes a specific item from the MediaPropertySet .
     * @param key The key of the item to remove.
     * @return  true if the item was removed, otherwise false.
     */
    remove(key: string): boolean;

    /**
     * Gets the number of items contained in the property set. 
     */
    size: number
}


/**
 * Represents ratios used in media operations. 
 */
declare class MediaRatio {

    /**
     * The denominator of the MediaRatio. 
     */
    denominator: number;

    /**
     * The numerator of the MediaRatio. 
     */
    numerator: number
}


/**
 * Provides properties for getting MPEG-2 profile ids. 
 */
declare class Mpeg2ProfileIds {

    /**
     * Gets the MPEG-2 high profile. 
     */
    high: number;

    /**
     * Gets the MPEG-2 main profile. 
     */
    main: number;

    /**
     * Gets the MPEG-2 signal to noise ratio scalable profile. 
     */
    signalNoiseRatioScalable: number;

    /**
     * Gets the MPEG-2 simple profile. 
     */
    simple: number;

    /**
     * Gets the MPEG-2 spatially scalable profile. 
     */
    spatiallyScalable: number
}


/**
 * Describes the format of a video stream. 
 */
declare class VideoEncodingProperties {

    /**
     * Creates an instance of VideoEncodingProperties for a H.263 video.
     * @return  The video encoding properties.
     */
    createH264(): undefined.VideoEncodingProperties;

    /**
     * Creates an instance of VideoEncodingProperties for a MPEG-2 video.
     * @return  The video encoding properties.
     */
    createMpeg2(): undefined.VideoEncodingProperties;

    /**
     * Creates an instance of VideoEncodingProperties for a uncompressed video.
     * @param subtype The media subtype of the format.
     * @param width The video image width.
     * @param height The video image height.
     * @return  The video encoding properties.
     */
    createUncompressed(
        subtype: string,
        width: number,
        height: number): undefined.VideoEncodingProperties;

    /**
     * Creates a new instance of the VideoEncodingProperties class. 
     */
    constructor(): this;

    /**
     * Gets or sets the video bit rate. 
     */
    bitrate: number;

    /**
     * Gets or sets the video frame rate. 
     */
    frameRate: undefined.MediaRatio;

    /**
     * Gets the media format user data.
     * @return  Receives the media format data.
     */
    getFormatUserData(): number[];

    /**
     * Gets or sets the video image height. 
     */
    height: number;

    /**
     * Gets or sets the pixel aspect ratio. 
     */
    pixelAspectRatio: undefined.MediaRatio;

    /**
     * Gets or sets the media format profile. 
     */
    profileId: number;

    /**
     * Gets additional format properties for the video stream. 
     */
    properties: undefined.MediaPropertySet;

    /**
     * Sets the media format user data.
     * @param value The media data to set.
     */
    setFormatUserData(value: number[]): void;

    /**
     * Gets or sets the subtype of the format. 
     */
    subtype: string;

    /**
     * Gets the format type. 
     */
    type: string;

    /**
     * Gets or sets the video image width. 
     */
    width: number
}


/**
 * Describes the format of a media stream or media container. 
 */
declare interface MediaProperties$IMediaEncodingProperties {

    /**
     * Gets additional format properties. 
     */
    properties: undefined.MediaPropertySet,

        /**
         * Gets or sets the subtype of the format. 
         */
        subtype: string,

        /**
         * Gets the format type. 
         */
        type: string
}


/**
 * Provides properties for music information that is displayed by the SystemMediaTransportControlsDisplayUpdater class. 
 */
declare class MusicDisplayProperties {

    /**
     * Gets or sets the name of the album artist. 
     */
    albumArtist: string;

    /**
     * Gets or sets the album title. 
     */
    albumTitle: string;

    /**
     * Gets or set the name of the song artist. 
     */
    artist: string;

    /**
     * Gets a modifiable list of strings representing genre names. 
     */
    genres: undefined.IVector<string>;

    /**
     * Gets or set the title of the song. 
     */
    title: string;

    /**
     * Gets or sets the track number. 
     */
    trackNumber: number
}


/**
 * Provides optical character recognition (OCR) functionality. 
 */
declare class OcrEngine {

    /**
     * Returns a collection of all available OCR languages on the device. 
     */
    availableRecognizerLanguages: undefined.IVectorView<undefined.Language>;

    /**
     * Returns true if a specified language can be resolved to any of the available OCR languages. See language matching for a further explanation of language resolving.
     * @param language The language being used for text recognition.
     * @return  TRUE, if the specified language can be resolved to any of the available OCR languages; otherwise, FALSE.
     */
    isLanguageSupported(language: undefined.Language): boolean;

    /**
     * Gets the maximum image pixel dimensions supported by the OCR engine. 
     */
    maxImageDimension: number;

    /**
     * Creates a new instance of the OcrEngine class.
     * @param language The language being used for text recognition.
     * @return  If the specified language can be resolved to any of the OCR languages available on the device, returns new instance of OcrEngine class, otherwise returns null. See language matching for a further explanation of language resolving.
     */
    tryCreateFromLanguage(language: undefined.Language): undefined.OcrEngine;

    /**
     * Creates a new instance of the OcrEngine class.
     * @return  If any language from GlobalizationPreferences.Languages can be resolved to any of the available OCR languages returns new instance of OcrEngine class, otherwise returns null.
     */
    tryCreateFromUserProfileLanguages(): undefined.OcrEngine;

    /**
     * Scans the specified image for text in the language specified by the RecognizerLanguage property.
     * @param bitmap Represents an uncompressed bitmap.
     * @return  The result of the OCR that was initiated by the OcrEngine object.
     */
    recognizeAsync(
        bitmap: undefined.SoftwareBitmap): undefined.IPromiseWithIAsyncOperation<undefined.OcrResult>;

    /**
     * Gets the language being used for text recognition. 
     */
    recognizerLanguage: undefined.Language
}


/**
 * Represents a single line of text recognized by the OCR engine and returned as part of the OcrResult . 
 */
declare class OcrLine {

    /**
     * Gets the text of the recognized line. 
     */
    text: string;

    /**
     * Gets the collection of OcrWord objects that represents the words detected in the current line of text by the RecognizeAsync method. 
     */
    words: undefined.IVectorView<undefined.OcrWord >
}


/**
 * Contains the results of Optical Character Recognition (OCR). 
 */
declare class OcrResult {

    /**
     * Gets the collection of OcrLine objects that represents the lines of text detected in the image by the RecognizeAsync method. 
     */
    lines: undefined.IVectorView<undefined.OcrLine>;

    /**
     * Gets the recognized text. 
     */
    text: string;

    /**
     * Gets the clockwise rotation of the recognized text, in degrees, around the center of the image. 
     */
    textAngle: number
}


/**
 * Represents a single word in a line of text recognized by the OCR engine and returned as part of the OcrLine . 
 */
declare class OcrWord {

    /**
     * Gets the position and size in pixels of the recognized word from the top left corner of image when the value of TextAngle property is 0 (zero). 
     */
    boundingRect: undefined.Rect;

    /**
     * Gets the text of the recognized word. 
     */
    text: string
}


/**
 * Provides information about the CurrentTimeChangeRequested event. 
 */
declare class CurrentTimeChangeRequestedEventArgs {

    /**
     * Gets the new time that the Play To source audio or video stream has been changed to. 
     */
    time: number
}


/**
 * Provides information about the MuteChangeRequested event. 
 */
declare class MuteChangeRequestedEventArgs {

    /**
     * Gets a value that indicates whether mute or unmute was requested. 
     */
    mute: boolean
}


/**
 * Provides information about a Play To connection. 
 */
declare class PlayToConnection {

    /**
     * Occurs when an error is encountered for the Play To connection. 
     */
    onerror: undefined.TypedEventHandler<undefined.PlayToConnection, undefined.PlayToConnectionErrorEventArgs>;
    addEventListener(
        type: "error",
        listener: undefined.TypedEventHandler<undefined.PlayToConnection, undefined.PlayToConnectionErrorEventArgs>): void;
    removeEventListener(
        type: "error",
        listener: undefined.TypedEventHandler<undefined.PlayToConnection, undefined.PlayToConnectionErrorEventArgs>): void;

    /**
     * Occurs when the state of the Play To connection has changed. 
     */
    onstatechanged: undefined.TypedEventHandler<undefined.PlayToConnection, undefined.PlayToConnectionStateChangedEventArgs>;
    addEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.PlayToConnection, undefined.PlayToConnectionStateChangedEventArgs>): void;
    removeEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.PlayToConnection, undefined.PlayToConnectionStateChangedEventArgs>): void;

    /**
     * Occurs when the Play To connection is transferred to the next Play To source. 
     */
    ontransferred: undefined.TypedEventHandler<undefined.PlayToConnection, undefined.PlayToConnectionTransferredEventArgs>;
    addEventListener(
        type: "transferred",
        listener: undefined.TypedEventHandler<undefined.PlayToConnection, undefined.PlayToConnectionTransferredEventArgs>): void;
    removeEventListener(
        type: "transferred",
        listener: undefined.TypedEventHandler<undefined.PlayToConnection, undefined.PlayToConnectionTransferredEventArgs>): void;

    /**
     * Gets the state of the Play To connection. 
     */
    state: undefined.PlayToConnectionState;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides information about the Error event. 
 */
declare class PlayToConnectionErrorEventArgs {

    /**
     * Gets the error code for a Play To connection error. 
     */
    code: undefined.PlayToConnectionError;

    /**
     * Gets the error message for a Play To connection error. 
     */
    message: string
}


/**
 * Provides information about the StateChanged event. 
 */
declare class PlayToConnectionStateChangedEventArgs {

    /**
     * Gets the current state after the Play To connection state has changed. 
     */
    currentState: undefined.PlayToConnectionState;

    /**
     * Gets the previous state before the Play To connection state was changed. 
     */
    previousState: undefined.PlayToConnectionState
}


/**
 * Provides information about the Transferred event. 
 */
declare class PlayToConnectionTransferredEventArgs {

    /**
     * Gets the current Play To source that a connection was transferred to. 
     */
    currentSource: undefined.PlayToSource;

    /**
     * Gets the previous Play To source that a connection was transferred from. 
     */
    previousSource: undefined.PlayToSource
}


/**
 * Provides access to Play To capabilities. 
 */
declare class PlayToManager {

    /**
     * Gets the Play To manager for the current view.
     * @return  The Play To manager for the current view.
     */
    getForCurrentView(): undefined.PlayToManager;

    /**
     * Displays the Play To UI. 
     */
    showPlayToUI(): void;

    /**
     * Enables or disables the default source selection for Play To. 
     */
    defaultSourceSelection: boolean;

    /**
     * Occurs when a user requests media to stream to a Play To target device. 
     */
    onsourcerequested: undefined.TypedEventHandler<undefined.PlayToManager, undefined.PlayToSourceRequestedEventArgs>;
    addEventListener(
        type: "sourcerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToManager, undefined.PlayToSourceRequestedEventArgs>): void;
    removeEventListener(
        type: "sourcerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToManager, undefined.PlayToSourceRequestedEventArgs>): void;

    /**
     * Occurs when a Play To source element has been selected. 
     */
    onsourceselected: undefined.TypedEventHandler<undefined.PlayToManager, undefined.PlayToSourceSelectedEventArgs>;
    addEventListener(
        type: "sourceselected",
        listener: undefined.TypedEventHandler<undefined.PlayToManager, undefined.PlayToSourceSelectedEventArgs>): void;
    removeEventListener(
        type: "sourceselected",
        listener: undefined.TypedEventHandler<undefined.PlayToManager, undefined.PlayToSourceSelectedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a Play To target. 
 */
declare class PlayToReceiver {

    /**
     * Creates a new instance of a Play To receiver. 
     */
    constructor(): this;

    /**
     * Gets or sets the display name of the Play To target. 
     */
    friendlyName: string;

    /**
     * Notifies the Play To receiver that the duration of the audio or video playback has changed.
     * @param duration The new duration of the audio or video media.
     */
    notifyDurationChange(duration: number): void;

    /**
     * Notifies the Play To receiver that the audio or video playback has ended. 
     */
    notifyEnded(): void;

    /**
     * Notifies the Play To receiver that an error has occurred in displaying or playing the media. 
     */
    notifyError(): void;

    /**
     * Notifies the Play To receiver that metadata for the media has finished loading. 
     */
    notifyLoadedMetadata(): void;

    /**
     * Notifies the Play To receiver that the audio or video playback has been paused. 
     */
    notifyPaused(): void;

    /**
     * Notifies the Play To receiver that the audio or video playback has started. 
     */
    notifyPlaying(): void;

    /**
     * Notifies the Play To receiver that the rate of the audio or video playback has changed.
     * @param rate The new value of the playback rate.
     */
    notifyRateChange(rate: number): void;

    /**
     * Notifies the Play To receiver that the audio or video playback element has started at a new playback location. 
     */
    notifySeeked(): void;

    /**
     * Notifies the Play To receiver that the audio or video playback element is seeking a new playback location. 
     */
    notifySeeking(): void;

    /**
     * Notifies the Play To receiver that the audio or video playback has stopped. 
     */
    notifyStopped(): void;

    /**
     * Notifies the Play To receiver that the time location of the audio or video playback has changed.
     * @param currentTime The new time location of the playback.
     */
    notifyTimeUpdate(currentTime: number): void;

    /**
     * Notifies the Play To receiver that the volume of the audio or video playback has changed.
     * @param volume The new value for the volume.
     * @param mute True if the volume was muted; otherwise false.
     */
    notifyVolumeChange(volume: number, mute: boolean): void;

    /**
     * Occurs when the time location of the playback has changed. 
     */
    oncurrenttimechangerequested: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.CurrentTimeChangeRequestedEventArgs>;
    addEventListener(
        type: "currenttimechangerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.CurrentTimeChangeRequestedEventArgs>): void;
    removeEventListener(
        type: "currenttimechangerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.CurrentTimeChangeRequestedEventArgs>): void;

    /**
     * Occurs when the audio has been muted or unmuted. 
     */
    onmutechangerequested: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.MuteChangeRequestedEventArgs>;
    addEventListener(
        type: "mutechangerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.MuteChangeRequestedEventArgs>): void;
    removeEventListener(
        type: "mutechangerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.MuteChangeRequestedEventArgs>): void;

    /**
     * Occurs when audio or video playback has been paused. 
     */
    onpauserequested: undefined.TypedEventHandler<undefined.PlayToReceiver, any>;
    addEventListener(
        type: "pauserequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, any>): void;
    removeEventListener(
        type: "pauserequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, any>): void;

    /**
     * Occurs when the rate of audio or video playback has changed. 
     */
    onplaybackratechangerequested: undefined.TypedEventHandler<undefined.PlayToReceiver, any>;
    addEventListener(
        type: "playbackratechangerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, any>): void;
    removeEventListener(
        type: "playbackratechangerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, any>): void;

    /**
     * Occurs when audio or video playback starts. 
     */
    onplayrequested: undefined.TypedEventHandler<undefined.PlayToReceiver, any>;
    addEventListener(
        type: "playrequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, any>): void;
    removeEventListener(
        type: "playrequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, any>): void;

    /**
     * Occurs when the source media for the Play To receiver have changed. 
     */
    onsourcechangerequested: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.SourceChangeRequestedEventArgs>;
    addEventListener(
        type: "sourcechangerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.SourceChangeRequestedEventArgs>): void;
    removeEventListener(
        type: "sourcechangerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.SourceChangeRequestedEventArgs>): void;

    /**
     * Occurs when a request has been made for the Play To receiver to stop playing the streamed media. 
     */
    onstoprequested: undefined.TypedEventHandler<undefined.PlayToReceiver, any>;
    addEventListener(
        type: "stoprequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, any>): void;
    removeEventListener(
        type: "stoprequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, any>): void;

    /**
     * Occurs when the current playback position has changed. 
     */
    ontimeupdaterequested: undefined.TypedEventHandler<undefined.PlayToReceiver, any>;
    addEventListener(
        type: "timeupdaterequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, any>): void;
    removeEventListener(
        type: "timeupdaterequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, any>): void;

    /**
     * Occurs when the volume for the source audio or video has changed. 
     */
    onvolumechangerequested: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.VolumeChangeRequestedEventArgs>;
    addEventListener(
        type: "volumechangerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.VolumeChangeRequestedEventArgs>): void;
    removeEventListener(
        type: "volumechangerequested",
        listener: undefined.TypedEventHandler<undefined.PlayToReceiver, undefined.VolumeChangeRequestedEventArgs>): void;

    /**
     * Gets a set of custom properties for the Play To receiver. 
     */
    properties: undefined.IPropertySet;

    /**
     * Start receiving Play To commands.
     * @return  An asynchronous handler that's called when the start operation is complete.
     */
    startAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Stop receiving Play To commands.
     * @return  An asynchronous handler that's called when the stop operation is complete.
     */
    stopAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets a value that indicates whether the Play To target supports audio. 
     */
    supportsAudio: boolean;

    /**
     * Gets or sets a value that indicates whether the Play To target supports images. 
     */
    supportsImage: boolean;

    /**
     * Gets or sets a value that indicates whether the Play To target supports video. 
     */
    supportsVideo: boolean;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a media element to connect to a Play To target. 
 */
declare class PlayToSource {

    /**
     * Gets the connection to the Play To target. 
     */
    connection: undefined.PlayToConnection;

    /**
     * Gets or sets the next Play To source element. 
     */
    next: undefined.PlayToSource;

    /**
     * Connects the next Play To source element to the Play To target. 
     */
    playNext(): void;

    /**
     * Specifies a preferred Uniform Resource Identifier (URI) for the media stream, such as a cloud based media server, used is used for Play To by reference. 
     */
    preferredSourceUri: undefined.Uri
}


/**
 * Represents a deferred operation when you're supplying a source media element for Play To. 
 */
declare class PlayToSourceDeferral {

    /**
     * Ends the deferral. 
     */
    complete(): void
}


/**
 * Represents a request to connect a media element with a Play To target. 
 */
declare class PlayToSourceRequest {

    /**
     * Gets the time limit to supply the Play To source element. 
     */
    deadline: Date;

    /**
     * Displays an error message in the Play To UI.
     * @param errorString The error message to display in the Play To UI.
     */
    displayErrorString(errorString: string): void;

    /**
     * Defers connecting a media source to a Play To target.
     * @return  A deferral object that you can use to identify when the deferral is complete.
     */
    getDeferral(): undefined.PlayToSourceDeferral;

    /**
     * Sets the source element to connect to the Play To target.
     * @param value The source element to connect to the Play To target.
     */
    setSource(value: undefined.PlayToSource): void
}


/**
 * Provides information about the SourceRequested event. 
 */
declare class PlayToSourceRequestedEventArgs {

    /**
     * Gets the media object to connect to a Play To target. 
     */
    sourceRequest: undefined.PlayToSourceRequest
}


/**
 * Provides information about the SourceSelected event. 
 */
declare class PlayToSourceSelectedEventArgs {

    /**
     * Gets the display name of the selected Play To source. 
     */
    friendlyName: string;

    /**
     * Gets the display icon for the selected Play To source. 
     */
    icon: undefined.IRandomAccessStreamWithContentType;

    /**
     * Gets a value that indicates whether the selected Play To source supports audio. 
     */
    supportsAudio: boolean;

    /**
     * Gets a value that indicates whether the selected Play To source supports displaying images. 
     */
    supportsImage: boolean;

    /**
     * Gets a value that indicates whether the selected Play To source supports video. 
     */
    supportsVideo: boolean
}


/**
 * Provides information about the PlaybackRateChangeRequested event. 
 */
declare class PlaybackRateChangeRequestedEventArgs {

    /**
     * Gets the new playback rate. 
     */
    rate: number
}


/**
 * Provides information about the SourceChangeRequested event. 
 */
declare class SourceChangeRequestedEventArgs {

    /**
     * Gets the name of the album that contains the song in the audio stream. 
     */
    album: string;

    /**
     * Gets the author of the content in the media stream. 
     */
    author: string;

    /**
     * Gets the date that the content in the media stream was published. 
     */
    date: Date;

    /**
     * Gets the description of the content in the media stream. 
     */
    description: string;

    /**
     * Gets the names of the genres that the content in the media stream belongs to. 
     */
    genre: string;

    /**
     * Gets custom property names and values for the content in the media stream. 
     */
    properties: undefined.IMapView<string, any>;

    /**
     * Gets the rating for the content in the media stream. 
     */
    rating: number;

    /**
     * Gets the media stream for the Play To receiver. 
     */
    stream: undefined.IRandomAccessStreamWithContentType;

    /**
     * Gets the thumbnail image for the content in the media stream. 
     */
    thumbnail: undefined.IRandomAccessStreamReference;

    /**
     * Gets the title of the content in the media stream. 
     */
    title: string
}


/**
 * Provides information about the VolumeChangeRequested event. 
 */
declare class VolumeChangeRequestedEventArgs {

    /**
     * Gets the new volume level. 
     */
    volume: number
}


/**
 * Provides access to the media player while it is running in the background. 
 */
declare class BackgroundMediaPlayer {

    /**
     * Gets the current instance of the background media player. 
     */
    current: undefined.MediaPlayer;

    /**
     * Returns a Boolean value indicating if other media is currently playing on the device.
     * @return  Boolean value indicating if other media is currently playing on the device.
     */
    isMediaPlaying(): boolean;

    /**
     * Occurs when a message is received from the background task. 
     */
    onmessagereceivedfrombackground: undefined.EventHandler<any>;
    addEventListener(
        type: "messagereceivedfrombackground",
        listener: undefined.EventHandler<any>): void;
    removeEventListener(
        type: "messagereceivedfrombackground",
        listener: undefined.EventHandler<any>): void;

    /**
     * Occurs when a message is received from the foreground task. 
     */
    onmessagereceivedfromforeground: undefined.EventHandler<any>;
    addEventListener(
        type: "messagereceivedfromforeground",
        listener: undefined.EventHandler<any>): void;
    removeEventListener(
        type: "messagereceivedfromforeground",
        listener: undefined.EventHandler<any>): void;

    /**
     * Sends a message to the background media player.
     * @param value Set of values representing the message.
     */
    sendMessageToBackground(value: undefined.ValueSet): void;

    /**
     * Sends a message to the foreground task.
     * @param value Set of values representing the message.
     */
    sendMessageToForeground(value: undefined.ValueSet): void;

    /**
     * Shuts down the current background media player. 
     */
    shutdown(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the MediaPlaybackList::CurrentItemChanged event. 
 */
declare class CurrentMediaPlaybackItemChangedEventArgs {

    /**
     * Gets the new current MediaPlaybackItem . 
     */
    newItem: undefined.MediaPlaybackItem;

    /**
     * Gets the previous current MediaPlaybackItem . 
     */
    oldItem: undefined.MediaPlaybackItem
}


/**
 * Represents a read-only list of audio tracks, of which a single track can be selected at one time. 
 */
declare class MediaPlaybackAudioTrackList mixins Array<undefined.AudioTrack>{

    /**
     * Returns an iterator that iterates over the items in the collection.
     * @return  The iterator.
     */
    first(): undefined.IIterator<undefined.AudioTrack>;

    /**
     * Returns the audio track at the specified index.
     * @param index The zero-based index of the audio track.
     * @return  The audio track at the specified index.
     */
    getAt(index: number): undefined.AudioTrack;

    /**
     * Retrieves the audio tracks that start at the specified index in the list.
     * @param startIndex The zero-based index of the start of the audio tracks in the list.
     */
    getMany(startIndex: number): {
        items: undefined.AudioTrack,
        returnValue: number
    };

    /**
     * Retrieves the index of a specified audio track in the list.
     * @param value The audio track to find in the vector view.
     */
    indexOf(value: undefined.AudioTrack): {
        index: number,
        returnValue: boolean
    };

    /**
     * Occurs when the index of the currently selected audio track changes. 
     */
    onselectedindexchanged: undefined.TypedEventHandler<undefined.ISingleSelectMediaTrackList,
    any>;
    addEventListener(
        type: "selectedindexchanged",
        listener: undefined.TypedEventHandler<undefined.ISingleSelectMediaTrackList, any>): void;
    removeEventListener(
        type: "selectedindexchanged",
        listener: undefined.TypedEventHandler<undefined.ISingleSelectMediaTrackList, any>): void;

    /**
     * Gets or sets the index of the currently selected audio track in the list. 
     */
    selectedIndex: number;

    /**
     * Gets the number of audio tracks in the list. 
     */
    size: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void;
    indexOf(
        value: undefined.AudioTrack,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.AudioTrack, fromIndex?: number): number
}


/**
 * Represents a media item that can be played back. This class acts as a wrapper around a MediaSource that exposes the audio tracks, video tracks, and timed metadata tracks included in the media source. 
 */
declare class MediaPlaybackItem {
    findFromMediaSource: any;

    /**
     * Initializes a new instance of the MediaPlaybackItem class.
     * @param source The media source from which the MediaPlaybackItem is created.
     */
    constructor(source: undefined.MediaSource): this;

    /**
     * Gets a read-only list of audio tracks in the MediaSource associated with the MediaPlaybackItem . 
     */
    audioTracks: undefined.MediaPlaybackAudioTrackList;

    /**
     * Occurs when the list of audio tracks in the MediaSource associated with the MediaPlaybackItem changes. 
     */
    onaudiotrackschanged: undefined.TypedEventHandler<undefined.MediaPlaybackItem, undefined.IVectorChangedEventArgs>;
    addEventListener(
        type: "audiotrackschanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackItem, undefined.IVectorChangedEventArgs>): void;
    removeEventListener(
        type: "audiotrackschanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackItem, undefined.IVectorChangedEventArgs>): void;

    /**
     * Occurs when the list of timed metadata tracks in the MediaSource associated with the MediaPlaybackItem changes. 
     */
    ontimedmetadatatrackschanged: undefined.TypedEventHandler<undefined.MediaPlaybackItem, undefined.IVectorChangedEventArgs>;
    addEventListener(
        type: "timedmetadatatrackschanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackItem, undefined.IVectorChangedEventArgs>): void;
    removeEventListener(
        type: "timedmetadatatrackschanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackItem, undefined.IVectorChangedEventArgs>): void;

    /**
     * Occurs when the list of video tracks in the MediaSource associated with the MediaPlaybackItem changes. 
     */
    onvideotrackschanged: undefined.TypedEventHandler<undefined.MediaPlaybackItem, undefined.IVectorChangedEventArgs>;
    addEventListener(
        type: "videotrackschanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackItem, undefined.IVectorChangedEventArgs>): void;
    removeEventListener(
        type: "videotrackschanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackItem, undefined.IVectorChangedEventArgs>): void;

    /**
     * Gets the MediaSource object associated with the MediaPlaybackItem . 
     */
    source: undefined.MediaSource;

    /**
     * Gets a read-only list of timed metadata tracks in the MediaSource associated with the MediaPlaybackItem . 
     */
    timedMetadataTracks: undefined.MediaPlaybackTimedMetadataTrackList;

    /**
     * Gets a read-only list of video tracks in the MediaSource associated with the MediaPlaybackItem . 
     */
    videoTracks: undefined.MediaPlaybackVideoTrackList;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents an error that occurred trying to resolve a MediaPlaybackItem . 
 */
declare class MediaPlaybackItemError {

    /**
     * Gets the error code associated with the playback item error. 
     */
    errorCode: undefined.MediaPlaybackItemErrorCode;

    /**
     * Gets the extended error code for the MediaPlaybackItem error. 
     */
    extendedError: Windows$WinRTError
}


/**
 * Provides data for the MediaPlaybackList::ItemFailed event. 
 */
declare class MediaPlaybackItemFailedEventArgs {

    /**
     * Gets a wrapper object for the MediaPlaybackItem error that provides high-level information about the cause of the error. 
     */
    error: undefined.MediaPlaybackItemError;

    /**
     * Gets the MediaPlaybackItem associated with the error. 
     */
    item: undefined.MediaPlaybackItem
}


/**
 * Provides data for the MediaPlaybackList::ItemOpened event. 
 */
declare class MediaPlaybackItemOpenedEventArgs {

    /**
     * Gets the MediaPlaybackItem that was successfully opened. 
     */
    item: undefined.MediaPlaybackItem
}


/**
 * Represents a list of MediaPlaybackItem objects that can be played back. Provides methods for switching the currently playing item and enabling looping and shuffling. 
 */
declare class MediaPlaybackList {

    /**
     * Initializes a new instance of the MediaPlaybackList class. 
     */
    constructor(): this;

    /**
     * Gets or sets a value indicating whether the playback list will loop when the end of the list is reached. 
     */
    autoRepeatEnabled: boolean;

    /**
     * Gets the currently playing MediaPlaybackItem . 
     */
    currentItem: undefined.MediaPlaybackItem;

    /**
     * Gets the index of the current item in the MediaPlaybackList . 
     */
    currentItemIndex: number;

    /**
     * Gets an IObservableVector representation of the playback list. 
     */
    items: undefined.IObservableVector<undefined.MediaPlaybackItem>;

    /**
     * Gets or sets the maximum time before a MediaPlaybackItem in the list is expected to play that the media content associated with the item is retrieved. 
     */
    maxPrefetchTime: number;

    /**
     * Changes the current item of the MediaPlaybackList to the next item in the list.
     * @return  The new current MediaPlaybackItem .
     */
    moveNext(): undefined.MediaPlaybackItem;

    /**
     * Changes the current item of the MediaPlaybackList to the previous item in the list.
     * @return  The new current MediaPlaybackItem .
     */
    movePrevious(): undefined.MediaPlaybackItem;

    /**
     * Changes the current item of the MediaPlaybackList to the item with the specified index.
     * @param itemIndex The index of the item to make current.
     * @return  The new current MediaPlaybackItem .
     */
    moveTo(itemIndex: number): undefined.MediaPlaybackItem;

    /**
     * Occurs when the currently playing MediaPlaybackItem changes. 
     */
    oncurrentitemchanged: undefined.TypedEventHandler<undefined.MediaPlaybackList, undefined.CurrentMediaPlaybackItemChangedEventArgs>;
    addEventListener(
        type: "currentitemchanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackList, undefined.CurrentMediaPlaybackItemChangedEventArgs>): void;
    removeEventListener(
        type: "currentitemchanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackList, undefined.CurrentMediaPlaybackItemChangedEventArgs>): void;

    /**
     * Occurs when an error is encountered with a MediaPlaybackItem in the playback list. 
     */
    onitemfailed: undefined.TypedEventHandler<undefined.MediaPlaybackList, undefined.MediaPlaybackItemFailedEventArgs>;
    addEventListener(
        type: "itemfailed",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackList, undefined.MediaPlaybackItemFailedEventArgs>): void;
    removeEventListener(
        type: "itemfailed",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackList, undefined.MediaPlaybackItemFailedEventArgs>): void;

    /**
     * Occurs when a MediaPlaybackItem in the playback list is successfully opened. 
     */
    onitemopened: undefined.TypedEventHandler<undefined.MediaPlaybackList, undefined.MediaPlaybackItemOpenedEventArgs>;
    addEventListener(
        type: "itemopened",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackList, undefined.MediaPlaybackItemOpenedEventArgs>): void;
    removeEventListener(
        type: "itemopened",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackList, undefined.MediaPlaybackItemOpenedEventArgs>): void;

    /**
     * Sets the list of MediaPlaybackItem objects that will be played in shuffle mode, in the order in which they will be played.
     * @param value The list of MediaPlaybackItem objects that will be played in shuffle mode.
     */
    setShuffledItems(value: undefined.IIterable<undefined.MediaPlaybackItem>): void;

    /**
     * Gets or sets a value indicating whether the items in the playback list are played in a random order. 
     */
    shuffleEnabled: boolean;

    /**
     * Gets a read-only list of of MediaPlaybackItem objects that will be played in shuffle mode, in the order in which they will be played. 
     */
    shuffledItems: undefined.IVectorView<undefined.MediaPlaybackItem>;

    /**
     * Gets or sets the MediaPlaybackItem that will be played first. 
     */
    startingItem: undefined.MediaPlaybackItem;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a read-only list of timed metadata tracks. 
 */
declare class MediaPlaybackTimedMetadataTrackList mixins Array<undefined.TimedMetadataTrack>{

    /**
     * Returns an iterator that iterates over the items in the collection.
     * @return  The iterator.
     */
    first(): undefined.IIterator<undefined.TimedMetadataTrack>;

    /**
     * Returns the timed metadata track at the specified index.
     * @param index The zero-based index of the timed metadata track.
     * @return  The timed metadata track at the specified index.
     */
    getAt(index: number): undefined.TimedMetadataTrack;

    /**
     * Retrieves the timed metadata tracks that start at the specified index in the list.
     * @param startIndex The zero-based index of the start of the timed metadata tracks in the list.
     */
    getMany(
        startIndex: number): {
        items: undefined.TimedMetadataTrack,
        returnValue: number
    };

    /**
     * Gets the presentation mode of the timed metadata track with the specified index.
     * @param index The index of the timed metadata track for which the presentation mode is queried.
     * @return  The presentation mode.
     */
    getPresentationMode(index: number): undefined.TimedMetadataTrackPresentationMode;

    /**
     * Retrieves the index of a specified timed metadata track in the list.
     * @param value The timed metadata track to find in the vector view.
     */
    indexOf(value: undefined.TimedMetadataTrack): {
        index: number,
        returnValue: boolean
    };

    /**
     * Occurs when the presentation mode of the MediaPlaybackTimedMetadataTrackList changes. 
     */
    onpresentationmodechanged: undefined.TypedEventHandler<undefined.MediaPlaybackTimedMetadataTrackList,
    undefined.TimedMetadataPresentationModeChangedEventArgs>;
    addEventListener(
        type: "presentationmodechanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackTimedMetadataTrackList, undefined.TimedMetadataPresentationModeChangedEventArgs>): void;
    removeEventListener(
        type: "presentationmodechanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlaybackTimedMetadataTrackList, undefined.TimedMetadataPresentationModeChangedEventArgs>): void;

    /**
     * Sets the presentation mode of the timed metadata track with the specified index.
     * @param index The index of the timed metadata track for which the presentation mode is set.
     * @param value The presentation mode to set.
     */
    setPresentationMode(index: number, value: undefined.TimedMetadataTrackPresentationMode): void;

    /**
     * Gets the number of timed metadata tracks in the list. 
     */
    size: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void;
    indexOf(
        value: undefined.TimedMetadataTrack,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.TimedMetadataTrack, fromIndex?: number): number
}


/**
 * Represents a read-only list of video tracks, of which a single track can be selected at one time. 
 */
declare class MediaPlaybackVideoTrackList mixins Array<undefined.VideoTrack>{

    /**
     * Returns an iterator that iterates over the items in the collection.
     * @return  The iterator.
     */
    first(): undefined.IIterator<undefined.VideoTrack>;

    /**
     * Returns the video track at the specified index.
     * @param index The zero-based index of the video track.
     * @return  The video track at the specified index.
     */
    getAt(index: number): undefined.VideoTrack;

    /**
     * Retrieves the video tracks that start at the specified index in the list.
     * @param startIndex The zero-based index of the start of the video tracks in the list.
     */
    getMany(startIndex: number): {
        items: undefined.VideoTrack,
        returnValue: number
    };

    /**
     * Retrieves the index of a specified video track in the list.
     * @param value The video track to find in the vector view.
     */
    indexOf(value: undefined.VideoTrack): {
        index: number,
        returnValue: boolean
    };

    /**
     * Occurs when the index of the currently selected video track changes. 
     */
    onselectedindexchanged: undefined.TypedEventHandler<undefined.ISingleSelectMediaTrackList,
    any>;
    addEventListener(
        type: "selectedindexchanged",
        listener: undefined.TypedEventHandler<undefined.ISingleSelectMediaTrackList, any>): void;
    removeEventListener(
        type: "selectedindexchanged",
        listener: undefined.TypedEventHandler<undefined.ISingleSelectMediaTrackList, any>): void;

    /**
     * Gets or sets the index of the currently selected video track in the list. 
     */
    selectedIndex: number;

    /**
     * Gets the number of video tracks in the list. 
     */
    size: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void;
    indexOf(
        value: undefined.VideoTrack,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.VideoTrack, fromIndex?: number): number
}


/**
 * Provides access to media playback functionality such as play, pause, fast-forward, rewind, and volume. 
 */
declare class MediaPlayer {

    /**
     * Adds an audio effect to the playback stream of the MediaPlayer .
     * @param activatableClassId The activatable class ID of the audio effect to add to the playback stream.
     * @param effectOptional A value indicating whether the effect is optional.
     * @param configuration A property set containing configuration settings for the specified audio effect.
     */
    addAudioEffect(
        activatableClassId: string,
        effectOptional: boolean,
        configuration: undefined.IPropertySet): void;

    /**
     * Gets or sets the type of audio that is currently being played. 
     */
    audioCategory: undefined.MediaPlayerAudioCategory;

    /**
     * Gets or sets a value that describes the primary usage of the device that is being used to play back audio. 
     */
    audioDeviceType: undefined.MediaPlayerAudioDeviceType;

    /**
     * Gets or sets a Boolean value indicating if playback automatically starts after the media is loaded. 
     */
    autoPlay: boolean;

    /**
     * Gets the amount of buffering that is completed for the media content, expressed as a percentage. 
     */
    bufferingProgress: number;

    /**
     * Gets a Boolean value indicating if the media can be paused. 
     */
    canPause: boolean;

    /**
     * Gets a Boolean value indicating if the media supports seeking to a specific position. 
     */
    canSeek: boolean;

    /**
     * Gets the current state of media playback. 
     */
    currentState: undefined.MediaPlayerState;

    /**
     * Gets or sets a Boolean value indicating if the media will playback in a repeating loop. 
     */
    isLoopingEnabled: boolean;

    /**
     * Gets or sets a Boolean value indicating if the audio is muted. 
     */
    isMuted: boolean;

    /**
     * Gets a Boolean value indicating if the content is protected by a digital rights management system. 
     */
    isProtected: boolean;

    /**
     * Get the actual duration of the media without applying the PlaybackRate . 
     */
    naturalDuration: number;

    /**
     * Occurs when buffering has finished. 
     */
    onbufferingended: undefined.TypedEventHandler<undefined.MediaPlayer, any>;
    addEventListener(
        type: "bufferingended",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;
    removeEventListener(
        type: "bufferingended",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;

    /**
     * Occurs when buffering has started. 
     */
    onbufferingstarted: undefined.TypedEventHandler<undefined.MediaPlayer, any>;
    addEventListener(
        type: "bufferingstarted",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;
    removeEventListener(
        type: "bufferingstarted",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;

    /**
     * Occurs when the state of the media player has changed. 
     */
    oncurrentstatechanged: undefined.TypedEventHandler<undefined.MediaPlayer, any>;
    addEventListener(
        type: "currentstatechanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;
    removeEventListener(
        type: "currentstatechanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;

    /**
     * Occurs when the media has finished playback. 
     */
    onmediaended: undefined.TypedEventHandler<undefined.MediaPlayer, any>;
    addEventListener(
        type: "mediaended",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;
    removeEventListener(
        type: "mediaended",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;

    /**
     * Occurs when an error is encountered. 
     */
    onmediafailed: undefined.TypedEventHandler<undefined.MediaPlayer, undefined.MediaPlayerFailedEventArgs>;
    addEventListener(
        type: "mediafailed",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, undefined.MediaPlayerFailedEventArgs>): void;
    removeEventListener(
        type: "mediafailed",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, undefined.MediaPlayerFailedEventArgs>): void;

    /**
     * Occurs when the media is opened. 
     */
    onmediaopened: undefined.TypedEventHandler<undefined.MediaPlayer, any>;
    addEventListener(
        type: "mediaopened",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;
    removeEventListener(
        type: "mediaopened",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;

    /**
     * Occurs when the media playback rate has changed. 
     */
    onmediaplayerratechanged: undefined.TypedEventHandler<undefined.MediaPlayer, undefined.MediaPlayerRateChangedEventArgs>;
    addEventListener(
        type: "mediaplayerratechanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, undefined.MediaPlayerRateChangedEventArgs>): void;
    removeEventListener(
        type: "mediaplayerratechanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, undefined.MediaPlayerRateChangedEventArgs>): void;

    /**
     * Occurs when a media marker has been reached during playback. 
     */
    onplaybackmediamarkerreached: undefined.TypedEventHandler<undefined.MediaPlayer, undefined.PlaybackMediaMarkerReachedEventArgs>;
    addEventListener(
        type: "playbackmediamarkerreached",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, undefined.PlaybackMediaMarkerReachedEventArgs>): void;
    removeEventListener(
        type: "playbackmediamarkerreached",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, undefined.PlaybackMediaMarkerReachedEventArgs>): void;

    /**
     * Occurs when a seek operation has finished. 
     */
    onseekcompleted: undefined.TypedEventHandler<undefined.MediaPlayer, any>;
    addEventListener(
        type: "seekcompleted",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;
    removeEventListener(
        type: "seekcompleted",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;

    /**
     * Occurs when the volume of the audio has changed. 
     */
    onvolumechanged: undefined.TypedEventHandler<undefined.MediaPlayer, any>;
    addEventListener(
        type: "volumechanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;
    removeEventListener(
        type: "volumechanged",
        listener: undefined.TypedEventHandler<undefined.MediaPlayer, any>): void;

    /**
     * Pauses media playback. 
     */
    pause(): void;

    /**
     * Starts media playback. 
     */
    play(): void;

    /**
     * Gets the collection of timeline markers for the media. 
     */
    playbackMediaMarkers: undefined.PlaybackMediaMarkerSequence;

    /**
     * Gets or sets the playback rate, expressed as a percentage. 
     */
    playbackRate: number;

    /**
     * Gets or sets the playback position within the media. 
     */
    position: number;

    /**
     * Gets or sets the content protection manager for the media. 
     */
    protectionManager: undefined.MediaProtectionManager;

    /**
     * Removes all effects from the playback stream of the MediaPlayer . 
     */
    removeAllEffects(): void;

    /**
     * Set the media source to a file.
     * @param file The media source file.
     */
    setFileSource(file: undefined.IStorageFile): void;

    /**
     * Sets the media source for playback.
     * @param source The media source for playback.
     */
    setMediaSource(source: undefined.IMediaSource): void;

    /**
     * Sets the media source to a stream.
     * @param stream The media source stream.
     */
    setStreamSource(stream: undefined.IRandomAccessStream): void;

    /**
     * Sets the path to the media.
     * @param value The path to the media.
     */
    setUriSource(value: undefined.Uri): void;

    /**
     * Sets the playback source of the media player. 
     */
    source: undefined.IMediaPlaybackSource;

    /**
     * Gets an instance of the SystemMediaTransportControls class to enable user control of playback of the MediaPlayer and to allow the app to show information about the currently playing content in the system UI. 
     */
    systemMediaTransportControls: undefined.SystemMediaTransportControls;

    /**
     * Get or sets the audio volume for media playback. 
     */
    volume: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the MessageReceivedFromBackground and MessageReceivedFromForeground events. 
 */
declare class MediaPlayerDataReceivedEventArgs {

    /**
     * Gets the data from the MessageReceivedFromBackground or MessageReceivedFromForeground event. 
     */
    data: undefined.IMap<string, string >
}


/**
 * Provides the data for MediaFailed events. 
 */
declare class MediaPlayerFailedEventArgs {

    /**
     * Gets the MediaPlayerError value for the error that triggered the event. 
     */
    error: undefined.MediaPlayerError;

    /**
     * Gets a string describing the error that occurred. 
     */
    errorMessage: string;

    /**
     * Gets an HResult that indicates any extra data about the error that occurred. 
     */
    extendedErrorCode: Windows$WinRTError
}


/**
 * Provides the data for MediaPlayerRateChanged events. 
 */
declare class MediaPlayerRateChangedEventArgs {

    /**
     * Gets the new playback rate for the media. 
     */
    newRate: number
}


/**
 * Represents a marker at specific location in a media stream time-line. 
 */
declare class PlaybackMediaMarker {

    /**
     * Initializes a new instance of the PlaybackMediaMarker class with the specified offset into the media timeline, type string, and text.
     * @param value The media marker's offset into the media timeline.
     * @param mediaMarketType The type of the media marker.
     * @param text The text of the media marker.
     */
    constructor(value: number, mediaMarketType: string, text: string): this;

    /**
     * Initializes a new instance of the PlaybackMediaMarker class with the specified offset into the media timeline.
     * @param value The media marker's offset into the media timeline.
     */
    constructor(value: number): this;

    /**
     * Gets the type of the media marker. 
     */
    mediaMarkerType: string;

    /**
     * Gets the text associated with the marker. 
     */
    text: string;

    /**
     * Gets the offset in the media timeline where the marker occurs. 
     */
    time: number
}


/**
 * Provides data for PlaybackMediaMarkerReached events. 
 */
declare class PlaybackMediaMarkerReachedEventArgs {

    /**
     * Gets the PlaybackMediaMarker that was reached. 
     */
    playbackMediaMarker: undefined.PlaybackMediaMarker
}


/**
 * An ordered collection of PlaybackMediaMarker objects. 
 */
declare class PlaybackMediaMarkerSequence {

    /**
     * Initializes a new instance of the PlaybackMediaMarkerSequence class. 
     */
    constructor(): this;

    /**
     * Removes all elements from the sequence. 
     */
    clear(): void;

    /**
     * Gets an IIterator pointing at the first PlaybackMediaMarker in the sequence.
     * @return  Iterator pointing at the first media marker in the sequence.
     */
    first(): undefined.IIterator<undefined.PlaybackMediaMarker>;

    /**
     * Adds a PlaybackMediaMarker to the sequence in it's ordered position.
     * @param value The media marker to insert into the sequence.
     */
    insert(value: undefined.PlaybackMediaMarker): void;

    /**
     * Returns the number of items in the sequence. 
     */
    size: number
}


/**
 * Provides data for the MediaPlaybackTimedMetadataTrackList::PresentationModeChanged event. 
 */
declare class TimedMetadataPresentationModeChangedEventArgs {

    /**
     * Gets the new presentation mode. 
     */
    newPresentationMode: undefined.TimedMetadataTrackPresentationMode;

    /**
     * Gets the old presentation mode. 
     */
    oldPresentationMode: undefined.TimedMetadataTrackPresentationMode;

    /**
     * Gets the TimedMetadataTrack associated with the presentation mode change. 
     */
    track: undefined.TimedMetadataTrack
}

declare
var ateChangeRequestedEventArgs: any;

declare
var ositionChangeRequestedEventArgs: any;


/**
 * A marker interface that identifies the implementing class as a playback source. 
 */
declare interface Playback$IMediaPlaybackSource {}


/**
 * Provides data for the PlaybackPositionChangeRequested event. 
 */
declare class PlaybackPositionChangeRequestedEventArgs {

    /**
     * Gets a value indicating the requested offset into the media item. 
     */
    requestedPlaybackPosition: number
}


/**
 * Provides data for the PlaybackRateChangeRequested event. 
 */
declare class PlaybackRateChangeRequestedEventArgs {

    /**
     * Gets the requested playback rate. 
     */
    requestedPlaybackRate: number
}


/**
 * Provides access to a media playlist. 
 */
declare class Playlist {

    /**
     * Asynchronously loads files into a playlist.
     * @param file Represents the files to load.
     * @return  Represents the asynchronous operation for loading the playlist. The GetResults method of this IAsyncOperation object returns the playlist.
     */
    loadAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.Playlist>;

    /**
     * Creates a new instance of a Playlist object. 
     */
    constructor(): this;

    /**
     * The set of media files that make up the playlist. 
     */
    files: undefined.IVector<undefined.StorageFile>;

    /**
     * Asynchronously saves the playlist to a specified file and folder, in a specified format.
     * @param saveLocation The folder in which to save the playlist.
     * @param desiredName The name of the playlist to save.
     * @param option The action to take if the playlist is saved to an existing file. One of the values of the NameCollisionOption enumeration.
     * @param playlistFormat The playlist format. One of the values of the PlaylistFormat enumeration.
     * @return  Represents the asynchronous operation to save the playlist to a specified file and folder.
     */
    saveAsAsync(
        saveLocation: undefined.IStorageFolder,
        desiredName: string,
        option: undefined.NameCollisionOption,
        playlistFormat: undefined.PlaylistFormat): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Asynchronously saves the playlist to a specified file and folder.
     * @param saveLocation The folder in which to save the playlist.
     * @param desiredName The name of the playlist to save.
     * @param option The action to take if the playlist is saved to an existing file. One of the values of the NameCollisionOption enumeration.
     * @return  Represents the asynchronous operation to save the playlist to a specified file and folder.
     */
    saveAsAsync(
        saveLocation: undefined.IStorageFolder,
        desiredName: string,
        option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Asynchronously saves the playlist.
     * @return  Represents the asynchronous action to save the playlist.
     */
    saveAsync(): undefined.IPromiseWithIAsyncAction
}


/**
 * Contains event data for a MediaProtectionManager object when the load of binary data fails. 
 */
declare class ComponentLoadFailedEventArgs {

    /**
     * Returns an indication of the completion of the event. 
     */
    completion: undefined.MediaProtectionServiceCompletion;

    /**
     * Returns a list of components in the RevocationAndRenewalInformation object that need to be revoked and renewed with updated components. 
     */
    information: undefined.RevocationAndRenewalInformation
}


/**
 * Enables applications to initiate renewal of components which need updating in order to play protected media content. 
 */
declare class ComponentRenewal {

    /**
     * Initiates updating of critical content protection components after prompting the user.
     * @param information Revocation and renewal information.
     * @return  An object that is used to control the asynchronous operation.
     */
    renewSystemComponentsAsync(
        information: undefined.RevocationAndRenewalInformation): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.RenewalStatus, number >
}


/**
 * Contains a content protection manager object, for an application that handles protected media content. 
 */
declare class MediaProtectionManager {

    /**
     * Initializes a new instance of the MediaProtectionManager class. 
     */
    constructor(): this;

    /**
     * Fires when the load of binary data fails. 
     */
    oncomponentloadfailed: undefined.ComponentLoadFailedEventHandler;
    addEventListener(
        type: "componentloadfailed",
        listener: undefined.ComponentLoadFailedEventHandler): void;
    removeEventListener(
        type: "componentloadfailed",
        listener: undefined.ComponentLoadFailedEventHandler): void;

    /**
     * Fires when a reboot is needed after the component is renewed. 
     */
    onrebootneeded: undefined.RebootNeededEventHandler;
    addEventListener(type: "rebootneeded", listener: undefined.RebootNeededEventHandler): void;
    removeEventListener(type: "rebootneeded", listener: undefined.RebootNeededEventHandler): void;

    /**
     * Fires when a service is requested. 
     */
    onservicerequested: undefined.ServiceRequestedEventHandler;
    addEventListener(
        type: "servicerequested",
        listener: undefined.ServiceRequestedEventHandler): void;
    removeEventListener(
        type: "servicerequested",
        listener: undefined.ServiceRequestedEventHandler): void;

    /**
     * Gets a PropertySet object containing any properties attached to the protection manager. 
     */
    properties: undefined.IPropertySet;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a Protected Media Path (PMP) server to enable playback of protected content using digital rights management (DRM). 
 */
declare class MediaProtectionPMPServer {

    /**
     * Initializes a new instance of the MediaProtectionPMPServer class with the specified properties.
     * @param pProperties The set of properties used to initialize the server.
     */
    constructor(pProperties: undefined.IPropertySet): this;

    /**
     * Gets the property set for the MediaProtectionPMPServer . 
     */
    properties: undefined.IPropertySet
}


/**
 * Contains a method that indicates whether a protection service has completed successfully. 
 */
declare class MediaProtectionServiceCompletion {

    /**
     * Indicates whether a protection service has completed successfully.
     * @param success Indicates the successful completion of a protection service.
     */
    complete(success: boolean): void
}


/**
 * Creates PlayReady-ND sessions, coordinates with the download engine and the stream parser (for example, an MPEG-2 demuxer), manages the sample buffer, and listens to media stream source events. 
 */
declare class NDClient {

    /**
     * Creates a new instance of the NDClient class.
     * @param downloadEngine The download engine used to stream protected media content from a transmitter.
     * @param streamParser The stream parser used to parse data from a media stream.
     * @param pMessenger The messenger used to send messages between the PlayReady-ND receiver and transmitter.
     */
    constructor(downloadEngine: undefined.INDDownloadEngine, streamParser: undefined.INDStreamParser, pMessenger: undefined.INDMessenger): this;

    /**
     * Closes the current playback session regardless of whether it is in the registration, proximity detection, license fetch, or play state. 
     */
    close(): void;

    /**
     * Performs a license fetch between a client receiver and a transmitter.
     * @param licenseFetchDescriptor Descriptor for the license being fetched.
     * @return  The result of the asynchronous license fetch call.
     */
    licenseFetchAsync(
        licenseFetchDescriptor: undefined.INDLicenseFetchDescriptor): undefined.IPromiseWithIAsyncOperation<undefined.INDLicenseFetchResult>;

    /**
     * Notifies listeners that a closed caption acquisition operation has completed. 
     */
    onclosedcaptiondatareceived: undefined.TypedEventHandler<undefined.NDClient, undefined.INDClosedCaptionDataReceivedEventArgs>;
    addEventListener(
        type: "closedcaptiondatareceived",
        listener: undefined.TypedEventHandler<undefined.NDClient, undefined.INDClosedCaptionDataReceivedEventArgs>): void;
    removeEventListener(
        type: "closedcaptiondatareceived",
        listener: undefined.TypedEventHandler<undefined.NDClient, undefined.INDClosedCaptionDataReceivedEventArgs>): void;

    /**
     * Notifies listeners that a license fetch operation has completed. 
     */
    onlicensefetchcompleted: undefined.TypedEventHandler<undefined.NDClient, undefined.INDLicenseFetchCompletedEventArgs>;
    addEventListener(
        type: "licensefetchcompleted",
        listener: undefined.TypedEventHandler<undefined.NDClient, undefined.INDLicenseFetchCompletedEventArgs>): void;
    removeEventListener(
        type: "licensefetchcompleted",
        listener: undefined.TypedEventHandler<undefined.NDClient, undefined.INDLicenseFetchCompletedEventArgs>): void;

    /**
     * Notifies listeners that a proximity detection operation has completed. 
     */
    onproximitydetectioncompleted: undefined.TypedEventHandler<undefined.NDClient, undefined.INDProximityDetectionCompletedEventArgs>;
    addEventListener(
        type: "proximitydetectioncompleted",
        listener: undefined.TypedEventHandler<undefined.NDClient, undefined.INDProximityDetectionCompletedEventArgs>): void;
    removeEventListener(
        type: "proximitydetectioncompleted",
        listener: undefined.TypedEventHandler<undefined.NDClient, undefined.INDProximityDetectionCompletedEventArgs>): void;

    /**
     * Notifies listeners that a registration operation has completed. 
     */
    onregistrationcompleted: undefined.TypedEventHandler<undefined.NDClient, undefined.INDRegistrationCompletedEventArgs>;
    addEventListener(
        type: "registrationcompleted",
        listener: undefined.TypedEventHandler<undefined.NDClient, undefined.INDRegistrationCompletedEventArgs>): void;
    removeEventListener(
        type: "registrationcompleted",
        listener: undefined.TypedEventHandler<undefined.NDClient, undefined.INDRegistrationCompletedEventArgs>): void;

    /**
     * Notifies listeners that the app should start re-registration by calling the ReRegistrationAsync method. 
     */
    onreregistrationneeded: undefined.TypedEventHandler<undefined.NDClient, any>;
    addEventListener(
        type: "reregistrationneeded",
        listener: undefined.TypedEventHandler<undefined.NDClient, any>): void;
    removeEventListener(
        type: "reregistrationneeded",
        listener: undefined.TypedEventHandler<undefined.NDClient, any>): void;

    /**
     * Performs a proximity detection and reregistration between a client receiver and a transmitter.
     * @param registrationCustomData Custom data for the registration request.
     * @return  The result of the asynchronous reregistration call.
     */
    reRegistrationAsync(
        registrationCustomData: undefined.INDCustomData): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts the registration, proximity detection, and license fetch procedures between a client receiver and a transmitter.
     * @param contentUrl The URL of the streamed content.
     * @param startAsyncOptions The asynchronous start options. See the NDStartAsyncOptions enumeration for a detailed description of these options.
     * @param registrationCustomData The custom data type identifier that is used for registration with the transmitter.
     * @param licenseFetchDescriptor The descriptor used for license fetching.
     * @return  The result of the asynchronous start call.
     */
    startAsync(
        contentUrl: undefined.Uri,
        startAsyncOptions: number,
        registrationCustomData: undefined.INDCustomData,
        licenseFetchDescriptor: undefined.INDLicenseFetchDescriptor): undefined.IPromiseWithIAsyncOperation<undefined.INDStartResult>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains the custom data for one of the following PlayReady-ND messages: Registration Challenge, Registration Response, License Fetch Challenge, or License Fetch Response. 
 */
declare class NDCustomData {

    /**
     * Creates a new instance of the NDCustomData class.
     * @param customDataTypeIDBytes The type identifier for the custom data. Only a type identifier that is exactly 16 bytes in size is supported.
     * @param customDataBytes The custom data.
     */
    constructor(customDataTypeIDBytes: number[], customDataBytes: number[]): this;

    /**
     * Gets the custom data. 
     */
    customData: number;

    /**
     * Gets the 16-byte type identifier for the custom data. 
     */
    customDataTypeID: number
}


/**
 * Contains methods that a download engine plug-in uses to send notifications to a PlayReady-ND client. 
 */
declare class NDDownloadEngineNotifier {

    /**
     * Creates a new instance of the NDDownloadEngineNotifier class. 
     */
    constructor(): this;

    /**
     * Called by the download engine when a content identifier is received.
     * @param licenseFetchDescriptor The license from which the download engine receives the content identifier.
     */
    onContentIDReceived(licenseFetchDescriptor: undefined.INDLicenseFetchDescriptor): void;

    /**
     * Called by the download engine when it receives data.
     * @param dataBytes The byte array that holds the data.
     * @param bytesReceived The number of bytes received from the data stream.
     */
    onDataReceived(dataBytes: number[], bytesReceived: number): void;

    /**
     * Called by the download engine when it reaches the end of a PlayReady-ND media stream. 
     */
    onEndOfStream(): void;

    /**
     * Called by the download engine if an error occurs during downloading. 
     */
    onNetworkError(): void;

    /**
     * Called by the download engine once a PlayReady object is received.
     * @param dataBytes The byte array that holds the PlayReady object.
     */
    onPlayReadyObjectReceived(dataBytes: number[]): void;

    /**
     * Called by the download engine when a stream is opened. 
     */
    onStreamOpened(): void
}


/**
 * Retrieves and sets properties used for fetching a PlayReady-ND license. 
 */
declare class NDLicenseFetchDescriptor {

    /**
     * Creates a new instance of the NDLicenseFetchDescriptor class.
     * @param contentIDType The type of the content identifier.
     * @param contentIDBytes The content identifier.
     * @param licenseFetchChallengeCustomData The license fetch challenge custom data.
     */
    constructor(contentIDType: undefined.NDContentIDType, contentIDBytes: number[], licenseFetchChallengeCustomData: undefined.INDCustomData): this;

    /**
     * Gets the content identifer. 
     */
    contentID: number;

    /**
     * Gets the type of the content identifier. 
     */
    contentIDType: undefined.NDContentIDType;

    /**
     * Gets or sets custom data for a license fetch challenge. 
     */
    licenseFetchChallengeCustomData: undefined.INDCustomData
}


/**
 * Manages PlayReady-ND storage files. 
 */
declare class NDStorageFileHelper {

    /**
     * Creates a new instance of the NDStorageFileHelper class. 
     */
    constructor(): this;

    /**
     * Gets transmitter settings from the URLs associated with a StorageFile object if the URLs contain PlayReady-ND metadata.
     * @param file A storage file object that a media server has discovered.
     * @return  The transmitter settings found in the storage file.
     */
    getFileURLs(file: undefined.IStorageFile): undefined.IVector<string >
}


/**
 * Contains methods that a stream parser plug-in uses to send notifications to a PlayReady-ND client. 
 */
declare class NDStreamParserNotifier {

    /**
     * Creates a new instance of the NDStreamParserNotifier class. 
     */
    constructor(): this;

    /**
     * Called by the stream parser when it requests a setup decryptor.
     * @param descriptor The descriptor of the media stream being decrypted.
     * @param keyID The key identifier used for decryption.
     * @param proBytes The data for the setup decryptor.
     */
    onBeginSetupDecryptor(
        descriptor: undefined.IMediaStreamDescriptor,
        keyID: string,
        proBytes: number[]): void;

    /**
     * Called by a stream parser when it receives the content identifier.
     * @param licenseFetchDescriptor The license fetch descriptor containing the content identifier.
     */
    onContentIDReceived(licenseFetchDescriptor: undefined.INDLicenseFetchDescriptor): void;

    /**
     * Called by the stream parser when the media stream descriptor is created.
     * @param audioStreamDescriptors An array of audio stream descriptors that are part of the media stream descriptor.
     * @param videoStreamDescriptors An array of video stream descriptors that are part of the media stream descriptor.
     */
    onMediaStreamDescriptorCreated(
        audioStreamDescriptors: undefined.IVector<undefined.AudioStreamDescriptor>,
        videoStreamDescriptors: undefined.IVector<undefined.VideoStreamDescriptor>): void;

    /**
     * Called when the stream parser parses a sample from the media stream.
     * @param streamID The identifier for the media stream that is being parsed.
     * @param streamType The type of the media stream. This value can be Audio or Video.
     * @param streamSample The array of stream samples.
     * @param pts The presentation timestamp that indicates when to play the sample, in milliseconds. This value is relative to previous samples in the presentation. For example, if a given sample has a presentation time stamp of 1000 and some later sample has a presentation time stamp of 2000, the later sample occurs one second (1000ms) after the given sample.
     * @param ccFormat The closed caption format. This value can be ATSC, SCTE20, or Unknown.
     * @param ccDataBytes An array that contains the closed caption data.
     */
    onSampleParsed(
        streamID: number,
        streamType: undefined.NDMediaStreamType,
        streamSample: undefined.MediaStreamSample,
        pts: number,
        ccFormat: undefined.NDClosedCaptionFormat,
        ccDataBytes: number[]): void
}


/**
 * Sends PlayReady-ND messages and challenges using the TCP network protocol. 
 */
declare class NDTCPMessenger {

    /**
     * Creates a new instance of the NDTCPMessenger class.
     * @param remoteHostName The IP address of the remote host that will receive messages. The format is either an IPv4 address in dotted-decimal notation or an IPv6 address in colon-hex notation.
     * @param remoteHostPort The TCP port of the remote host that will receive messages.
     */
    constructor(remoteHostName: string, remoteHostPort: number): this;

    /**
     * Sends the specified data in an asynchronous license fetch request message.
     * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
     * @param challengeDataBytes The data for the challenge message.
     * @return  The result of the license fetch request.
     */
    sendLicenseFetchRequestAsync(
        sessionIDBytes: number[],
        challengeDataBytes: number[]): undefined.IPromiseWithIAsyncOperation<undefined.INDSendResult>;

    /**
     * Sends the specified data in an asynchronous proximity detection response message.
     * @param pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
     * @param transmitterChannelBytes The transmitter channel data.
     * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
     * @param responseDataBytes The data for the response message.
     * @return  The result of the proximity detection response operation.
     */
    sendProximityDetectionResponseAsync(
        pdType: undefined.NDProximityDetectionType,
        transmitterChannelBytes: number[],
        sessionIDBytes: number[],
        responseDataBytes: number[]): undefined.IPromiseWithIAsyncOperation<undefined.INDSendResult>;

    /**
     * Sends the specified data in an asynchronous proximity detection start message.
     * @param pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
     * @param transmitterChannelBytes The transmitter channel data.
     * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
     * @param challengeDataBytes The data for the challenge message.
     * @return  The result of the proximity detection start operation.
     */
    sendProximityDetectionStartAsync(
        pdType: undefined.NDProximityDetectionType,
        transmitterChannelBytes: number[],
        sessionIDBytes: number[],
        challengeDataBytes: number[]): undefined.IPromiseWithIAsyncOperation<undefined.INDSendResult>;

    /**
     * Sends the specified data in an asynchronous registration request message.
     * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
     * @param challengeDataBytes The data for the challenge message.
     * @return  The result of the registration request.
     */
    sendRegistrationRequestAsync(
        sessionIDBytes: number[],
        challengeDataBytes: number[]): undefined.IPromiseWithIAsyncOperation<undefined.INDSendResult >
}


/**
 * Represents the information in a PlayReady content header. 
 */
declare class PlayReadyContentHeader {

    /**
     * Initializes a new instance of the PlayReadyContentHeader class.
     * @param contentKeyId Identifier of the content encryption key.
     * @param contentKeyIdString String representation of the content key. If the contentKeyId parameter is specified, then this parameter is ignored.
     * @param contentEncryptionAlgorithm Encryption algorithm type used to encrypt the content.
     * @param licenseAcquisitionUrl The URL for the silent (no user interaction) license acquisition Web service.
     * @param licenseAcquisitionUserInterfaceUrl The URL for a non-silent license acquisition Web page.
     * @param customAttributes Contains custom data used by the content provider. The content author can add arbitrary XML inside this element. Microsoft code does not act on any data contained inside this element.
     * @param domainServiceId Service identifier for the domain service.
     */
    constructor(contentKeyId: string, contentKeyIdString: string, contentEncryptionAlgorithm: undefined.PlayReadyEncryptionAlgorithm, licenseAcquisitionUrl: undefined.Uri, licenseAcquisitionUserInterfaceUrl: undefined.Uri, customAttributes: string, domainServiceId: string): this;

    /**
     * Initializes a new instance of the PlayReadyContentHeader class.
     * @param headerBytes Raw data bytes representing a legacy WMDRM header.
     * @param licenseAcquisitionUrl The URL for the silent (no user interaction) license acquisition Web service.
     * @param licenseAcquisitionUserInterfaceUrl The URL for a non-silent license acquisition Web page.
     * @param customAttributes Contains custom data used by the content provider. The content author can add arbitrary XML inside this element. Microsoft code does not act on any data contained inside this element.
     * @param domainServiceId Service identifier for the domain service.
     */
    constructor(headerBytes: number[], licenseAcquisitionUrl: undefined.Uri, licenseAcquisitionUserInterfaceUrl: undefined.Uri, customAttributes: string, domainServiceId: string): this;

    /**
     * Initializes a new instance of the PlayReadyContentHeader class.
     * @param dwFlags Reserved. Set to 0.
     * @param contentKeyIds Identifiers of the content encryption keys.
     * @param contentKeyIdStrings String representations of the content keys. Each string must be a Base-64 encoded 16 byte value.
     * @param contentEncryptionAlgorithm Encryption algorithm type used to encrypt the content.
     * @param licenseAcquisitionUrl The URL for the silent (no user interaction) license acquisition Web service.
     * @param licenseAcquisitionUserInterfaceUrl The URL for a non-silent license acquisition Web page.
     * @param customAttributes Contains custom data used by the content provider. The content author can add arbitrary XML inside this element. Microsoft code does not act on any data contained inside this element.
     * @param domainServiceId Service identifier for the domain service.
     */
    constructor(dwFlags: number, contentKeyIds: string[], contentKeyIdStrings: string[], contentEncryptionAlgorithm: undefined.PlayReadyEncryptionAlgorithm, licenseAcquisitionUrl: undefined.Uri, licenseAcquisitionUserInterfaceUrl: undefined.Uri, customAttributes: string, domainServiceId: string): this;

    /**
     * Initializes a new instance of the PlayReadyContentHeader class.
     * @param headerBytes Raw data bytes representing a PlayReady content header.
     */
    constructor(headerBytes: number[]): this;

    /**
     * Gets the custom data used by the content provider. 
     */
    customAttributes: string;

    /**
     * Gets the decryptor setup value in the header if it is set. 
     */
    decryptorSetup: undefined.PlayReadyDecryptorSetup;

    /**
     * Gets the domain service identifier in the header if it is set. 
     */
    domainServiceId: string;

    /**
     * Gets the content encryption type in the header if it is set. 
     */
    encryptionType: undefined.PlayReadyEncryptionAlgorithm;

    /**
     * Retrieves the full PlayReady object as a byte array.
     * @return  The header containing the full PlayReady object.
     */
    getSerializedHeader(): number[];

    /**
     * Gets a new content header that contains any embedded license updates that were available. 
     */
    headerWithEmbeddedUpdates: undefined.PlayReadyContentHeader;

    /**
     * Gets the content key identifier value if it is set. 
     */
    keyId: string;

    /**
     * Gets the content key identifier string value if it is set. 
     */
    keyIdString: string;

    /**
     * Gets the content key identifier string values if they are set. 
     */
    keyIdStrings: string;

    /**
     * Gets the content key identifier values if they are set. 
     */
    keyIds: string;

    /**
     * Gets the license acquisition URL in the header if it is set. 
     */
    licenseAcquisitionUrl: undefined.Uri;

    /**
     * Gets the license acquisition user interface URL in the header if it is set. 
     */
    licenseAcquisitionUserInterfaceUrl: undefined.Uri
}


/**
 * Receives multiple service request objects that are necessary to enable the playback ability for a given content header. 
 */
declare class PlayReadyContentResolver {

    /**
     * Proactively initiates the service request chain for a given content header.
     * @param contentHeader Content header for the content the app wants to resolve all necessary service request operations.
     * @return  The first service request operation required to resolve the content.
     */
    serviceRequest(
        contentHeader: undefined.PlayReadyContentHeader): undefined.IPlayReadyServiceRequest
}


/**
 * Provides access to metadata about a domain to which the current system is a member. 
 */
declare class PlayReadyDomain {

    /**
     * Gets the current domain account identifier property. 
     */
    accountId: string;

    /**
     * Gets the URL used to join the domain. 
     */
    domainJoinUrl: undefined.Uri;

    /**
     * Gets the current domain friendly name. 
     */
    friendlyName: string;

    /**
     * Gets the current domain revision number. 
     */
    revision: number;

    /**
     * Gets the current domain service identifier property. 
     */
    serviceId: string
}


/**
 * Exposes the PlayReady PlayReadyDomain class iterator. 
 */
declare class PlayReadyDomainIterable {

    /**
     * Initializes a new instance of the PlayReadyDomainIterable class using the domain account identifier.
     * @param domainAccountId The domain account identifier.
     */
    constructor(domainAccountId: string): this;

    /**
     * Returns an iterator that iterates over the items in the PlayReady domain collection.
     * @return  The PlayReady domain iterator.
     */
    first(): undefined.IIterator<undefined.IPlayReadyDomain >
}


/**
 * Provides for iteration of the PlayReadyDomain class. 
 */
declare class PlayReadyDomainIterator {

    /**
     * Gets the current item in the PlayReady domain collection. 
     */
    current: undefined.IPlayReadyDomain;

    /**
     * Retrieves all items in the PlayReady domain collection.
     */
    getMany(): {
        items: undefined.IPlayReadyDomain,
        returnValue: number
    };

    /**
     * Gets a value that indicates whether there is a current item or the iterator is at the end of the PlayReady domain collection. 
     */
    hasCurrent: boolean;

    /**
     * Advances the enumerator to the next item in the collection.
     * @return  true if the iterator refers to a valid item that is in the collection or false if the iterator is at the end of the collection.
     */
    moveNext(): boolean
}


/**
 * Provides the service methods for joining a PlayReady domain. 
 */
declare class PlayReadyDomainJoinServiceRequest {

    /**
     * Initializes a new instance of the PlayReadyDomainJoinServiceRequest class. 
     */
    constructor(): this;

    /**
     * Begins an asynchronous service request operation.
     * @return  The asynchronous service action.
     */
    beginServiceRequest(): undefined.IAsyncAction;

    /**
     * Gets or sets the custom data of the request challenge. 
     */
    challengeCustomData: string;

    /**
     * Gets or sets the current domain account identifier property. 
     */
    domainAccountId: string;

    /**
     * Gets or sets the current domain friendly name property. 
     */
    domainFriendlyName: string;

    /**
     * Gets or sets the current domain service identifier property. 
     */
    domainServiceId: string;

    /**
     * Begins the process of manually enabling.
     * @return  The SOAP message to be used in a manual license acquisition challenge request.
     */
    generateManualEnablingChallenge(): undefined.PlayReadySoapMessage;

    /**
     * Returns a new service request interface.
     * @return  The new service request interface.
     */
    nextServiceRequest(): undefined.IPlayReadyServiceRequest;

    /**
     * Process the raw binary result of a manual enabling challenge.
     * @param responseBytes The response result to be processed.
     * @return  If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
     */
    processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

    /**
     * Gets the vendor content protection system identifier. 
     */
    protectionSystem: string;

    /**
     * Gets the custom data that was returned in the response from the service. 
     */
    responseCustomData: string;

    /**
     * Gets the GUID for the type of operation that the PlayReady domain join service request performs. 
     */
    type: string;

    /**
     * Gets or sets the URI used to perform a service request action. 
     */
    uri: undefined.Uri
}


/**
 * Provides the service methods for leaving a PlayReady domain. 
 */
declare class PlayReadyDomainLeaveServiceRequest {

    /**
     * Initializes a new instance of the PlayReadyDomainLeaveServiceRequest class. 
     */
    constructor(): this;

    /**
     * Begins an asynchronous service request operation.
     * @return  The asynchronous service action.
     */
    beginServiceRequest(): undefined.IAsyncAction;

    /**
     * Gets or sets the custom data of the request challenge. 
     */
    challengeCustomData: string;

    /**
     * Gets or sets the current domain account identifier property. 
     */
    domainAccountId: string;

    /**
     * Gets or sets the current domain account identifier. 
     */
    domainServiceId: string;

    /**
     * Begins the process of manually enabling.
     * @return  The SOAP message to be used in a manual license acquisition challenge request.
     */
    generateManualEnablingChallenge(): undefined.PlayReadySoapMessage;

    /**
     * Returns a new service request interface.
     * @return  The new service request interface.
     */
    nextServiceRequest(): undefined.IPlayReadyServiceRequest;

    /**
     * Process the raw binary result of a manual enabling challenge.
     * @param responseBytes The response result to be processed.
     * @return  If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
     */
    processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

    /**
     * Gets the vendor content protection system identifier. 
     */
    protectionSystem: string;

    /**
     * Gets the custom data that was returned in the response from the service. 
     */
    responseCustomData: string;

    /**
     * Gets the GUID for the type of operation that the PlayReady domain leave service request performs. 
     */
    type: string;

    /**
     * Gets or sets the URI used to perform a service request action. 
     */
    uri: undefined.Uri
}


/**
 * Creates the PlayReady ITA-specific serialized initialization data. 
 */
declare class PlayReadyITADataGenerator {

    /**
     * Initializes a new instance of the PlayReadyITADataGenerator class. 
     */
    constructor(): this;

    /**
     * Returns a serialized blob of the specified IPropertySet data that the PlayReady ITA can consume if wrapped in a content protection instantiation format.
     * @param guidCPSystemId The content protection system GUID.
     * @param countOfStreams The stream count.
     * @param configuration The data to be returned as a serialized blob.
     * @param format The format for the ITA serialized data.
     * @return  The serialized blob. See Remarks.
     */
    generateData(
        guidCPSystemId: string,
        countOfStreams: number,
        configuration: undefined.IPropertySet,
        format: undefined.PlayReadyITADataFormat): number[]
}


/**
 * Provides the service methods for requesting platform individualization. 
 */
declare class PlayReadyIndividualizationServiceRequest {

    /**
     * Initializes a new instance of the PlayReadyIndividualizationServiceRequest class. 
     */
    constructor(): this;

    /**
     * Begins an asynchronous service request operation.
     * @return  The asynchronous service action.
     */
    beginServiceRequest(): undefined.IAsyncAction;

    /**
     * Gets or sets the custom data of the request challenge. This property is not supported in this class. 
     */
    challengeCustomData: string;

    /**
     * Begins the process of manually enabling. This method is not supported in this class.
     * @return  This method always returns 0x80070032 (the request is not supported).
     */
    generateManualEnablingChallenge(): undefined.PlayReadySoapMessage;

    /**
     * Returns a new service request interface.
     * @return  The new service request interface.
     */
    nextServiceRequest(): undefined.IPlayReadyServiceRequest;

    /**
     * Process the raw binary result of a manual enabling challenge. This method is not supported in this class.
     * @param responseBytes The response result to be processed.
     * @return  This method always returns 0x80070032 (the request is not supported).
     */
    processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

    /**
     * Gets the vendor content protection system identifier. 
     */
    protectionSystem: string;

    /**
     * Gets the custom data that was returned in the response from the service. This property is not supported in this class. 
     */
    responseCustomData: string;

    /**
     * Gets the GUID for the type of operation that the PlayReady individualization service request performs. 
     */
    type: string;

    /**
     * Gets or sets the URI used to perform a service request action. This property is not supported in this class. 
     */
    uri: undefined.Uri
}


/**
 * Represents the properties of a PlayReady license. 
 */
declare class PlayReadyLicense {

    /**
     * Gets the chain depth of the license chain represented by the current PlayReadyLicense class. 
     */
    chainDepth: number;

    /**
     * Gets the domain account identifier to which this license is bound. 
     */
    domainAccountID: string;

    /**
     * Gets the expiration date of the current license. 
     */
    expirationDate: Date;

    /**
     * Gets the amount of time, in seconds, before the current license expires after the media is first played. 
     */
    expireAfterFirstPlay: number;

    /**
     * Gets the state of the license. 
     */
    fullyEvaluated: boolean;

    /**
     * Gets the key identifier (KID) of the license at the specified chain depth.
     * @param chainDepth The depth of the license in the chain for which to retrieve the KID. This value is a 0-based index.
     * @return  The KID of the license. This return value is sensitive to the underlying platform's endianness. Carefully test your app on all platforms you intend to support to ensure that correct endianness is used on each platform.
     */
    getKIDAtChainDepth(chainDepth: number): string;

    /**
     * Gets whether this license is usable for playback. 
     */
    usableForPlay: boolean
}


/**
 * Provides the service methods for obtaining PlayReady licenses. 
 */
declare class PlayReadyLicenseAcquisitionServiceRequest {

    /**
     * Initializes a new instance of the PlayReadyLicenseAcquisitionServiceRequest class. 
     */
    constructor(): this;

    /**
     * Begins an asynchronous service request operation.
     * @return  The asynchronous service action.
     */
    beginServiceRequest(): undefined.IAsyncAction;

    /**
     * Gets or sets the custom data of the request challenge. 
     */
    challengeCustomData: string;

    /**
     * Gets or sets the current content header property. 
     */
    contentHeader: undefined.PlayReadyContentHeader;

    /**
     * Gets or sets the current domain service identifier property that overrides a service identifier in the content header. 
     */
    domainServiceId: string;

    /**
     * Begins the process of manually enabling.
     * @return  The SOAP message to be used in a manual license acquisition challenge request.
     */
    generateManualEnablingChallenge(): undefined.PlayReadySoapMessage;

    /**
     * Returns a new service request interface.
     * @return  The new service request interface.
     */
    nextServiceRequest(): undefined.IPlayReadyServiceRequest;

    /**
     * Process the raw binary result of a manual enabling challenge.
     * @param responseBytes The response result to be processed.
     * @return  If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
     */
    processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

    /**
     * Gets the vendor content protection system identifier. 
     */
    protectionSystem: string;

    /**
     * Gets the custom data that was returned in the response from the service. 
     */
    responseCustomData: string;

    /**
     * Gets the GUID for the type of operation that the PlayReady license acquisition service request performs. 
     */
    type: string;

    /**
     * Gets or sets the URI used to perform a service request action. 
     */
    uri: undefined.Uri
}


/**
 * Exposes the PlayReadyLicense class iterator. 
 */
declare class PlayReadyLicenseIterable {

    /**
     * Initializes a new instance of the PlayReadyLicenseIterable class.
     * @param contentHeader The content header used to locate associated licenses.
     * @param fullyEvaluated Indicates whether evaluated license chains should be enumerated or if all licenses (including those that are unusable) should be enumerated. This parameter is true if evaluated license chains should be enumerated, or false if all licenses should be enumerated.
     */
    constructor(contentHeader: undefined.PlayReadyContentHeader, fullyEvaluated: boolean): this;

    /**
     * Initializes a new instance of the PlayReadyLicenseIterable class. 
     */
    constructor(): this;

    /**
     * Returns an iterator that iterates over the items in the PlayReady license collection.
     * @return  The PlayReady license iterator.
     */
    first(): undefined.IIterator<undefined.IPlayReadyLicense >
}


/**
 * Provides for iteration of the PlayReadyLicense class. 
 */
declare class PlayReadyLicenseIterator {

    /**
     * Gets the current item in the PlayReady license collection. 
     */
    current: undefined.IPlayReadyLicense;

    /**
     * Retrieves all items in the PlayReady license collection.
     */
    getMany(): {
        items: undefined.IPlayReadyLicense,
        returnValue: number
    };

    /**
     * Gets a value that indicates whether there is a current item or the iterator is at the end of the PlayReady license collection. 
     */
    hasCurrent: boolean;

    /**
     * Advances the enumerator to the next item in the collection.
     * @return  true if the iterator refers to a valid item that is in the collection or false if the iterator is at the end of the collection.
     */
    moveNext(): boolean
}


/**
 * Performs license management operations. 
 */
declare class PlayReadyLicenseManagement {

    /**
     * Deletes licenses that match the specified content header.
     * @param contentHeader Content header with a key identifier with which to match licenses.
     * @return  The asynchronous operation performing the deletion.
     */
    deleteLicenses(contentHeader: undefined.PlayReadyContentHeader): undefined.IAsyncAction
}


/**
 * Creates a media session and binds license acquisition to that media session. 
 */
declare class PlayReadyLicenseSession {

    /**
     * Initializes a new instance of the PlayReadyLicenseSession class.
     * @param configuration The configuration data for the license session.
     */
    constructor(configuration: undefined.IPropertySet): this;

    /**
     * Updates the media protection manger with the appropriate settings so the media foundation can be used for playback.
     * @param mpm The media protection manager to be updated.
     */
    configureMediaProtectionManager(mpm: undefined.MediaProtectionManager): void;

    /**
     * Creates a license acquisition service request whose license will be tied to the media session.
     * @return  The license acquisition service request.
     */
    createLAServiceRequest(): undefined.IPlayReadyLicenseAcquisitionServiceRequest
}


/**
 * Provides the service methods for content metering operations. 
 */
declare class PlayReadyMeteringReportServiceRequest {

    /**
     * Initializes a new instance of the PlayReadyMeteringReportServiceRequest class. 
     */
    constructor(): this;

    /**
     * Begins an asynchronous service request operation.
     * @return  The asynchronous service action.
     */
    beginServiceRequest(): undefined.IAsyncAction;

    /**
     * Gets or sets the custom data of the request challenge. 
     */
    challengeCustomData: string;

    /**
     * Begins the process of manually enabling.
     * @return  The SOAP message to be used in a manual license acquisition challenge request.
     */
    generateManualEnablingChallenge(): undefined.PlayReadySoapMessage;

    /**
     * Gets or sets the current metering certificate property. 
     */
    meteringCertificate: number;

    /**
     * Returns a new service request interface.
     * @return  The new service request interface.
     */
    nextServiceRequest(): undefined.IPlayReadyServiceRequest;

    /**
     * Process the raw binary result of a manual enabling challenge.
     * @param responseBytes The response result to be processed.
     * @return  If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
     */
    processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

    /**
     * Gets the vendor content protection system identifier. 
     */
    protectionSystem: string;

    /**
     * Gets the custom data that was returned in the response from the service. 
     */
    responseCustomData: string;

    /**
     * Gets the GUID for the type of operation that the PlayReady metering report service request performs. 
     */
    type: string;

    /**
     * Gets or sets the URI used to perform a service request action. 
     */
    uri: undefined.Uri
}


/**
 * Updates the revocation data required by PlayReady. 
 */
declare class PlayReadyRevocationServiceRequest {

    /**
     * Initializes a new instance of the PlayReadyRevocationServiceRequest class. 
     */
    constructor(): this;

    /**
     * Begins an asynchronous service request operation.
     * @return  The asynchronous service action.
     */
    beginServiceRequest(): undefined.IAsyncAction;

    /**
     * Gets or sets the custom data of the request challenge. This property is not supported in this class. 
     */
    challengeCustomData: string;

    /**
     * Begins the process of manually enabling. This method is not supported in this class.
     * @return  This method always returns 0x80070032 (the request is not supported).
     */
    generateManualEnablingChallenge(): undefined.PlayReadySoapMessage;

    /**
     * Returns a new service request interface.
     * @return  The new service request interface.
     */
    nextServiceRequest(): undefined.IPlayReadyServiceRequest;

    /**
     * Process the raw binary result of a manual enabling challenge. This method is not supported in this class.
     * @param responseBytes The response result to be processed.
     * @return  This method always returns 0x80070032 (the request is not supported).
     */
    processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

    /**
     * Gets the vendor content protection system identifier. 
     */
    protectionSystem: string;

    /**
     * Gets the custom data that was returned in the response from the service. This property is not supported in this class. 
     */
    responseCustomData: string;

    /**
     * Gets the GUID for the type of operation that the PlayReady revocation service request performs. 
     */
    type: string;

    /**
     * Gets or sets the URI used to perform a service request action. This property is not supported in this class. 
     */
    uri: undefined.Uri
}


/**
 * Enumerates PlayReady secure stop service requests. 
 */
declare class PlayReadySecureStopIterable {

    /**
     * Initializes a new instance of the PlayReadySecureStopIterable class.
     * @param publisherCertBytes The raw binary body of the publisher certificate.
     */
    constructor(publisherCertBytes: number[]): this;

    /**
     * Returns an iterator that iterates over the items in the PlayReady secure stop collection.
     * @return  The PlayReady secure stop iterator.
     */
    first(): undefined.IIterator<undefined.IPlayReadySecureStopServiceRequest >
}


/**
 * Provides for iteration of the IPlayReadySecureStopServiceRequest interface. 
 */
declare class PlayReadySecureStopIterator {

    /**
     * Gets the current item in the PlayReady secure stop collection. 
     */
    current: undefined.IPlayReadySecureStopServiceRequest;

    /**
     * Retrieves all items in the PlayReady secure stop collection.
     */
    getMany(): {
        items: undefined.IPlayReadySecureStopServiceRequest,
        returnValue: number
    };

    /**
     * Gets a value that indicates whether there is a current item or the iterator is at the end of the PlayReady secure stop collection. 
     */
    hasCurrent: boolean;

    /**
     * Advances the enumerator to the next item in the collection.
     * @return  true if the iterator refers to a valid item that is in the collection or false if the iterator is at the end of the collection.
     */
    moveNext(): boolean
}


/**
 * Manages secure stop messages. 
 */
declare class PlayReadySecureStopServiceRequest {

    /**
     * Initializes a new instance of the PlayReadySecureStopServiceRequest class for the specified secure stop session.
     * @param sessionID The secure stop session identifier.
     * @param publisherCertBytes The raw binary body of the publisher certificate.
     */
    constructor(sessionID: string, publisherCertBytes: number[]): this;

    /**
     * Initializes a new instance of the PlayReadySecureStopServiceRequest class to include all secure stop sessions.
     * @param publisherCertBytes The raw binary body of the publisher certificate.
     */
    constructor(publisherCertBytes: number[]): this;

    /**
     * Begins an asynchronous service request operation.
     * @return  The asynchronous service action.
     */
    beginServiceRequest(): undefined.IAsyncAction;

    /**
     * Gets or sets the custom data of the request challenge. 
     */
    challengeCustomData: string;

    /**
     * Begins the process of manually enabling.
     * @return  The SOAP message to be used in a manual license acquisition challenge request.
     */
    generateManualEnablingChallenge(): undefined.PlayReadySoapMessage;

    /**
     * Returns a new service request interface.
     * @return  The new service request interface.
     */
    nextServiceRequest(): undefined.IPlayReadyServiceRequest;

    /**
     * Process the raw binary result of a manual enabling challenge.
     * @param responseBytes The response result to be processed.
     * @return  If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
     */
    processManualEnablingResponse(responseBytes: number[]): Windows$WinRTError;

    /**
     * Gets the vendor content protection system identifier. 
     */
    protectionSystem: string;

    /**
     * Gets the current publisher certificate property. 
     */
    publisherCertificate: number;

    /**
     * Gets the custom data that was returned in the response from the service. 
     */
    responseCustomData: string;

    /**
     * Gets the session identifier property. 
     */
    sessionID: string;

    /**
     * Gets the secure stop session's start time property. 
     */
    startTime: Date;

    /**
     * Gets the secure stop session's stopped flag property which indicates whether the secure stop session for this request was cleanly shut down. 
     */
    stopped: boolean;

    /**
     * Gets the GUID for the type of operation that the PlayReady secure stop service request performs. 
     */
    type: string;

    /**
     * Gets the secure stop session's update/stop time property. 
     */
    updateTime: Date;

    /**
     * Gets or sets the URI used to perform a service request action. 
     */
    uri: undefined.Uri
}


/**
 * Contains a SOAP message used in manual challenge requests. 
 */
declare class PlayReadySoapMessage {

    /**
     * Retrieves the contents of the SOAP message.
     * @return  The contents of the SOAP message.
     */
    getMessageBody(): number[];

    /**
     * Gets a collection of the SOAP headers applied to the current SOAP request or SOAP response. 
     */
    messageHeaders: undefined.IPropertySet;

    /**
     * Gets the base URL of the XML Web service. 
     */
    uri: undefined.Uri
}


/**
 * Provides support for returning static or constant data. 
 */
declare class PlayReadyStatics {

    /**
     * Queries whether the specified hardware digital rights management (DRM) feature is supported on the system.
     * @param hwdrmFeature The hardware DRM feature to query.
     * @return  true if the hardware DRM feature is supported, otherwise false.
     */
    checkSupportedHardware(hwdrmFeature: undefined.PlayReadyHardwareDRMFeatures): boolean;

    /**
     * Gets the type of a PlayReady domain join service request. 
     */
    domainJoinServiceRequestType: string;

    /**
     * Gets the type of a PlayReady domain leave service request. 
     */
    domainLeaveServiceRequestType: string;

    /**
     * Gets the type of a PlayReady individualization service request. 
     */
    individualizationServiceRequestType: string;

    /**
     * Gets the type of a PlayReady license acquisition service request. 
     */
    licenseAcquirerServiceRequestType: string;

    /**
     * Gets the PlayReady media protection system identifier. 
     */
    mediaProtectionSystemId: string;

    /**
     * Gets the type of a PlayReady metering service request. 
     */
    meteringReportServiceRequestType: string;

    /**
     * Gets the current certificate security level. 
     */
    playReadyCertificateSecurityLevel: number;

    /**
     * Gets the PlayReady runtime security version. 
     */
    playReadySecurityVersion: number;

    /**
     * Gets the type of a PlayReady revocation service request. 
     */
    revocationServiceRequestType: string;

    /**
     * Gets the type of a PlayReady secure stop service request. 
     */
    secureStopServiceRequestType: string
}


/**
 * Retrieves and sets properties used for fetching a PlayReady-ND license. 
 */
declare interface PlayReady$INDLicenseFetchDescriptor {

    /**
     * Gets the content identifier used for fetching a license. 
     */
    contentID: number,

        /**
         * Gets the type of the content identifier used for fetching a license. 
         */
        contentIDType: undefined.NDContentIDType,

        /**
         * Gets or sets custom data for a license fetch challenge. 
         */
        licenseFetchChallengeCustomData: undefined.INDCustomData
}


/**
 * Provides the result of the PlayReady-ND license fetch. 
 */
declare interface PlayReady$INDLicenseFetchResult {

    /**
     * Gets the custom data from a license fetch response. 
     */
    responseCustomData: undefined.INDCustomData
}


/**
 * Specifies arguments for a PlayReady-ND ClosedCaptionDataReceived event. 
 */
declare interface PlayReady$INDClosedCaptionDataReceivedEventArgs {

    /**
     * Gets the closed caption data. 
     */
    closedCaptionData: number,

        /**
         * Gets the format of the closed caption data. 
         */
        closedCaptionDataFormat: undefined.NDClosedCaptionFormat,

        /**
         * Gets the timestamp of the closed caption data. 
         */
        presentationTimestamp: number
}


/**
 * Gets custom data from a PlayReady-ND license fetch operation. This custom data is an argument from a PlayReady-ND LicenseFetchCompleted event. 
 */
declare interface PlayReady$INDLicenseFetchCompletedEventArgs {

    /**
     * Gets custom data from a license fetch response. 
     */
    responseCustomData: undefined.INDCustomData
}


/**
 * Provides arguments for the PlayReady-ND ProximityDetectionCompleted event. Apps fire this event after they complete the proximity detection process. 
 */
declare interface PlayReady$INDProximityDetectionCompletedEventArgs {

    /**
     * Gets the number of retries that occurred during a proximity detection operation. 
     */
    proximityDetectionRetryCount: number
}


/**
 * Provides arguments for the PlayReady-ND RegistrationCompleted event. 
 */
declare interface PlayReady$INDRegistrationCompletedEventArgs {

    /**
     * Gets custom data from a registration response. 
     */
    responseCustomData: undefined.INDCustomData,

        /**
         * Gets or sets whether to accept or reject a transmitter's certificate. 
         */
        transmitterCertificateAccepted: boolean,

        /**
         * Gets transmitter properties from the transmitter's certificate to verify the transmitter. 
         */
        transmitterProperties: undefined.INDTransmitterProperties
}


/**
 * Contains the custom data for one of the following PlayReady-ND messages: Registration Challenge, Registration Response, License Fetch Challenge, or License Fetch Response. 
 */
declare interface PlayReady$INDCustomData {

    /**
     * Gets the custom data. 
     */
    customData: number,

        /**
         * Gets the 16-byte type identifier for the custom data. 
         */
        customDataTypeID: number
}


/**
 * Provides the StartAsync result that contains the created PlayReady-ND MediaStreamSource instance. 
 */
declare interface PlayReady$INDStartResult {

    /**
     * Gets the MediaStreamSource object for the data that the transmitter streams. 
     */
    mediaStreamSource: undefined.MediaStreamSource
}


/**
 * Provides the PlayReady-ND download engine used to stream protected media content from a transmitter. 
 */
declare interface PlayReady$INDDownloadEngine {

    /**
     * Notifies the download engine to stop downloading and disconnect from the remote server. 
     */
    close(): void,

        /**
         * Notifies the download engine to open the content specified by a URL.
         * @param uri The URI from which the download engine gets content.
         * @param sessionIDBytes The session identifier used to identify the session. The session identifier must be 16 bytes.
         */
        open(uri: undefined.Uri, sessionIDBytes: Array<number>): void,

        /**
         * Notifies the download engine to pause downloading. 
         */
        pause(): void,

        /**
         * Notifies the download engine to resume a paused download. 
         */
        resume(): void,

        /**
         * Notifies the download engine to go to a specified time position in the media stream.
         * @param startPosition The position within the media stream to which to seek.
         */
        seek(startPosition: number): void,

        /**
         * Gets the maximum threshold of the sample buffer. 
         */
        bufferFullMaxThresholdInSamples: number,

        /**
         * Gets the minimum number of samples a sample buffer can hold before a download engine resumes downloading. 
         */
        bufferFullMinThresholdInSamples: number,

        /**
         * Gets whether the download engine supports seeking. 
         */
        canSeek: boolean,

        /**
         * Gets the download engine notifier that will provide notification of download stream events from the transmitter. 
         */
        notifier: undefined.NDDownloadEngineNotifier
}


/**
 * Parses data from a PlayReady-ND media stream. 
 */
declare interface PlayReady$INDStreamParser {

    /**
     * Notifies a PlayReady-ND stream parser to be ready for the beginning of a new media stream. 
     */
    beginOfStream(): void,

        /**
         * Notifies a PlayReady-ND stream parser that the end of a media stream has been reached. 
         */
        endOfStream(): void,

        /**
         * Retrieves the stream type (audio or video) and stream identifier of the media stream descriptor.
         * @param descriptor The media stream from which this method gets information.
         */
        getStreamInformation(
            descriptor: undefined.IMediaStreamDescriptor): {
            streamType: undefined.NDMediaStreamType,
            returnValue: number
        },

        /**
         * Parses samples from a PlayReady-ND media stream.
         * @param dataBytes The data to be parsed.
         */
        parseData(dataBytes: Array<number>): void,

        /**
         * Gets the stream parser notifier that will provide notification of stream parser events from the transmitter. 
         */
        notifier: undefined.NDStreamParserNotifier
}


/**
 * Sends registration, proximity detection, and license fetch messages between PlayReady-ND receivers and transmitters. 
 */
declare interface PlayReady$INDMessenger {

    /**
     * Sends the specified data in an asynchronous license fetch request message.
     * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
     * @param challengeDataBytes The data for the challenge message.
     * @return  The result of the license fetch request.
     */
    sendLicenseFetchRequestAsync(
            sessionIDBytes: Array<number>,
            challengeDataBytes: Array<number>): undefined.IPromiseWithIAsyncOperation<undefined.INDSendResult>,

        /**
         * Sends the specified data in an asynchronous proximity detection response message.
         * @param pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
         * @param transmitterChannelBytes The transmitter channel data.
         * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
         * @param responseDataBytes The data for the response message.
         * @return  The result of the proximity detection response operation.
         */
        sendProximityDetectionResponseAsync(
            pdType: undefined.NDProximityDetectionType,
            transmitterChannelBytes: Array<number>,
            sessionIDBytes: Array<number>,
            responseDataBytes: Array<number>): undefined.IPromiseWithIAsyncOperation<undefined.INDSendResult>,

        /**
         * Sends the specified data in an asynchronous proximity detection start message.
         * @param pdType The type of proximity detection operation. This value can be UDP, TCP, or Transport-Agnostic.
         * @param transmitterChannelBytes The transmitter channel data.
         * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
         * @param challengeDataBytes The data for the challenge message.
         * @return  The result of the proximity detection start operation.
         */
        sendProximityDetectionStartAsync(
            pdType: undefined.NDProximityDetectionType,
            transmitterChannelBytes: Array<number>,
            sessionIDBytes: Array<number>,
            challengeDataBytes: Array<number>): undefined.IPromiseWithIAsyncOperation<undefined.INDSendResult>,

        /**
         * Sends the specified data in an asynchronous registration request message.
         * @param sessionIDBytes The session identifier. The session identifier must be 16 bytes.
         * @param challengeDataBytes The data for the challenge message.
         * @return  The result of the license fetch request.
         */
        sendRegistrationRequestAsync(
            sessionIDBytes: Array<number>,
            challengeDataBytes: Array<number>): undefined.IPromiseWithIAsyncOperation<undefined.INDSendResult >
}


/**
 * Provides the result, in the form of a response message, from the PlayReady-ND messenger. 
 */
declare interface PlayReady$INDSendResult {

    /**
     * Gets the response message from a messenger. 
     */
    response: number
}


/**
 * Base interface for all service request interfaces. 
 */
declare type PlayReady$IPlayReadyServiceRequest = {

    /**
     * Begins an asynchronous service request operation.
     * @return  The asynchronous service action.
     */
    beginServiceRequest(): undefined.IAsyncAction,

    /**
     * Begins the process of manually enabling.
     * @return  Begins the process of manually enabling.
     */
    generateManualEnablingChallenge(): undefined.PlayReadySoapMessage,

    /**
     * Returns a new service request interface.
     * @return  The new service request interface.
     */
    nextServiceRequest(): undefined.IPlayReadyServiceRequest,

    /**
     * Processes the raw binary result of a manual enabling challenge.
     * @param responseBytes The response result to be processed.
     * @return  If the methods succeeds, it returns S_OK. If it fails, it returns an error code.
     */
    processManualEnablingResponse(responseBytes: Array<number>): Windows$WinRTError,

    /**
     * Gets or sets the custom data of the request challenge. 
     */
    challengeCustomData: string,

    /**
     * Gets the custom data that was returned in the response from the service. 
     */
    responseCustomData: string,

    /**
     * Gets or sets the URI used to perform a service request action. 
     */
    uri: undefined.Uri
}


/**
 * Provides access to metadata about a domain to which the current system is a member. 
 */
declare interface PlayReady$IPlayReadyDomain {

    /**
     * Gets the current domain account identifier property. 
     */
    accountId: string,

        /**
         * Gets the URL used to join the domain. 
         */
        domainJoinUrl: undefined.Uri,

        /**
         * Gets the current domain friendly name. 
         */
        friendlyName: string,

        /**
         * Gets the current domain revision number. 
         */
        revision: number,

        /**
         * Gets the current domain service identifier property. 
         */
        serviceId: string
}


/**
 * Contains information about a PlayReady license. 
 */
declare interface PlayReady$IPlayReadyLicense {

    /**
     * Gets the key identifier (KID) of the license at the specified chain depth.
     * @param chainDepth The depth of the license in the chain for which to retrieve the KID. This value is a 0-based index.
     * @return  The KID of the license. This return value is sensitive to the underlying platform's endianness. Carefully test your app on all platforms you intend to support to ensure that correct endianness is used on each platform.
     */
    getKIDAtChainDepth(chainDepth: number): string,

        /**
         * Gets the chain depth of the license chain represented by the current IPlayReadyLicense interface. 
         */
        chainDepth: number,

        /**
         * Gets the domain account identifier to which this license is bound. 
         */
        domainAccountID: string,

        /**
         * Gets the expiration date of the current license. 
         */
        expirationDate: Date,

        /**
         * Gets the amount of time, in seconds, before the current license expires after the media is first played. 
         */
        expireAfterFirstPlay: number,

        /**
         * Gets the state of the license. 
         */
        fullyEvaluated: boolean,

        /**
         * Gets whether this license is usable for playback. 
         */
        usableForPlay: boolean
}


/**
 * Performs a license acquisition process. 
 */
declare type PlayReady$IPlayReadyLicenseAcquisitionServiceRequest = {

        /**
         * Gets the current content header property. 
         */
        contentHeader: undefined.PlayReadyContentHeader,

        /**
         * Gets the current domain service identifier property that overrides a service identifier in the content header. 
         */
        domainServiceId: string
    } & &



    /**
     * Manages secure stop messages. 
     */
    declare type PlayReady$IPlayReadySecureStopServiceRequest = {

        /**
         * Gets the current publisher certificate property. 
         */
        publisherCertificate: number,

        /**
         * Gets the secure stop session identifier property. 
         */
        sessionID: string,

        /**
         * Gets the secure stop session's start time property. 
         */
        startTime: Date,

        /**
         * Gets the secure stop session's stopped flag property which indicates whether the secure stop session for this request was cleanly shut down. 
         */
        stopped: boolean,

        /**
         * Gets the secure stop session's update/stop time property. 
         */
        updateTime: Date
    } & &



    /**
     * Provides the property values for a PlayReady-ND transmitter certificate. 
     */
    declare interface PlayReady$INDTransmitterProperties {

        /**
         * Gets the certificate type for the transmitter. 
         */
        certificateType: undefined.NDCertificateType,

            /**
             * Gets the client identifier from the transmitter certificate. 
             */
            clientID: number,

            /**
             * Gets the expiration date and time from the transmitter certificate. 
             */
            expirationDate: Date,

            /**
             * Gets the model digest from a transmitter certificate. 
             */
            modelDigest: number,

            /**
             * Gets the model manufacturer name from a transmitter certificate. 
             */
            modelManufacturerName: string,

            /**
             * Gets the model name from a transmitter certificate. 
             */
            modelName: string,

            /**
             * Gets the model number from a transmitter certificate. 
             */
            modelNumber: string,

            /**
             * Gets the platform identifier from a transmitter certificate. 
             */
            platformIdentifier: undefined.NDCertificatePlatformID,

            /**
             * Gets the security level from a transmitter certificate. 
             */
            securityLevel: number,

            /**
             * Gets the security version from a transmitter certificate. 
             */
            securityVersion: number,

            /**
             * Gets the list of supported features from the transmitter certificate. 
             */
            supportedFeatures: undefined.NDCertificateFeature
    }

declare class ProtectionCapabilities {
    isTypeSupported: any
}

declare
var notSupported: any;

declare
var maybe: any;

declare
var probably: any;


/**
 * Contains information about components that need to be revoked and renewed. 
 */
declare class RevocationAndRenewalInformation {

    /**
     * Returns a list of components that need to be revoked and renewed with updated components. 
     */
    items: undefined.IVector<undefined.RevocationAndRenewalItem >
}


/**
 * Represents a component that is being revoked and renewed with a trusted component. 
 */
declare class RevocationAndRenewalItem {

    /**
     * Returns the header hash for the component being revoked. 
     */
    headerHash: string;

    /**
     * Returns the name for the component being revoked. 
     */
    name: string;

    /**
     * Returns the public key hash for the component. 
     */
    publicKeyHash: string;

    /**
     * Returns the reason for revocation of component. 
     */
    reasons: undefined.RevocationAndRenewalReasons;

    /**
     * Returns the GUID for the renewal object. 
     */
    renewalId: string
}


/**
 * Contains event data for a MediaProtectionManager object when a service is requested. 
 */
declare class ServiceRequestedEventArgs {

    /**
     * Returns an indication of the completion of the service request. 
     */
    completion: undefined.MediaProtectionServiceCompletion;

    /**
     * Gets the MediaPlaybackItem associated with the service request. 
     */
    mediaPlaybackItem: undefined.MediaPlaybackItem;

    /**
     * Contains the service request. 
     */
    request: undefined.IMediaProtectionServiceRequest
}


/**
 * Represents the method that handles the data passed by the MediaProtectionManager when a load of binary data fails. 
 */
declare type Protection$ComponentLoadFailedEventHandler = (
    ev: undefined.ComponentLoadFailedEventArgs & Windows$WinRTEvent<undefined.MediaProtectionManager>) => void;


/**
 * Represents the method that handles the data passed by the MediaProtectionManager that requires a reboot. 
 */
declare type Protection$RebootNeededEventHandler = (ev: Windows$WinRTEvent<undefined.MediaProtectionManager>) => void;


/**
 * Represents the method that handles the data passed by the MediaProtectionManager when the resume operation is completed. 
 */
declare type Protection$ServiceRequestedEventHandler = (
    ev: undefined.ServiceRequestedEventArgs & Windows$WinRTEvent<undefined.MediaProtectionManager>) => void;


/**
 * Allows a content enabler object to be exposed directly to an application rather than through a wrapper supplied by the ContentEnabler object. 
 */
declare interface Protection$IMediaProtectionServiceRequest {

    /**
     * Allows the application to identify the content protection system being used and therefore how to interpret the protection task. 
     */
    protectionSystem: string,

        /**
         * Retrieves the GUID for the type of operation that the IMediaProtectionServiceRequest performs. 
         */
        type: string
}




/**
 * Provides data for the ShuffleEnabledChangeRequested event. 
 */
declare class ShuffleEnabledChangeRequestedEventArgs {

    /**
     * Gets a value indicating whether the request is to enable or disable shuffle. 
     */
    requestedShuffleEnabled: boolean
}


/**
 * Contains event data for the SpeechContinuousRecognitionSession.Completed event. 
 */
declare class SpeechContinuousRecognitionCompletedEventArgs {

    /**
     * Gets the result of a speech recognition session, or the result of a grammar constraint compilation. 
     */
    status: undefined.SpeechRecognitionResultStatus
}


/**
 * Contains event data for the SpeechContinuousRecognitionSession.ResultGenerated event. 
 */
declare class SpeechContinuousRecognitionResultGeneratedEventArgs {

    /**
     * Gets the complete recognition result returned by the speech recognizer at the end of a dictation session ( SpeechRecognitionResultStatus is set to Success). 
     */
    result: undefined.SpeechRecognitionResult
}


/**
 * Manages speech input for free-form dictation, or an arbitrary sequence of words or phrases that are defined in a grammar set. 
 */
declare class SpeechContinuousRecognitionSession {

    /**
     * Gets or sets the time threshold at which the continuous recognition session ends due to lack of audio input. 
     */
    autoStopSilenceTimeout: number;

    /**
     * Asynchronously cancel the continuous speech recognition session and discard all pending recognition results.
     * @return  An asynchronous handler called when the operation is complete.
     */
    cancelAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Occurs when a continuous recognition session ends. 
     */
    oncompleted: undefined.TypedEventHandler<undefined.SpeechContinuousRecognitionSession, undefined.SpeechContinuousRecognitionCompletedEventArgs>;
    addEventListener(
        type: "completed",
        listener: undefined.TypedEventHandler<undefined.SpeechContinuousRecognitionSession, undefined.SpeechContinuousRecognitionCompletedEventArgs>): void;
    removeEventListener(
        type: "completed",
        listener: undefined.TypedEventHandler<undefined.SpeechContinuousRecognitionSession, undefined.SpeechContinuousRecognitionCompletedEventArgs>): void;

    /**
     * Occurs when the speech recognizer returns the result from a continuous recognition session. 
     */
    onresultgenerated: undefined.TypedEventHandler<undefined.SpeechContinuousRecognitionSession, undefined.SpeechContinuousRecognitionResultGeneratedEventArgs>;
    addEventListener(
        type: "resultgenerated",
        listener: undefined.TypedEventHandler<undefined.SpeechContinuousRecognitionSession, undefined.SpeechContinuousRecognitionResultGeneratedEventArgs>): void;
    removeEventListener(
        type: "resultgenerated",
        listener: undefined.TypedEventHandler<undefined.SpeechContinuousRecognitionSession, undefined.SpeechContinuousRecognitionResultGeneratedEventArgs>): void;

    /**
     * Asynchronously pause a continuous speech recognition session.
     * @return  An asynchronous handler called when the operation is complete.
     */
    pauseAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Resumes a continuous speech recognition session, if paused. 
     */
    resume(): void;

    /**
     * Overload
     * @param mode The speech recognition behavior.
     * @return  An asynchronous handler called when the operation is complete.
     */
    startAsync(
        mode: undefined.SpeechContinuousRecognitionMode): undefined.IPromiseWithIAsyncAction;

    /**
     * Overload
     * @return  An asynchronous handler called when the operation is complete.
     */
    startAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously end a continuous speech recognition session and pass all pending recognition results to the ResultGenerated event.
     * @return  An asynchronous handler called when the operation is complete.
     */
    stopAsync(): undefined.IPromiseWithIAsyncAction;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * The result of compiling the constraints set for a SpeechRecognizer object. 
 */
declare class SpeechRecognitionCompilationResult {

    /**
     * Gets the result state ( SpeechRecognitionResultStatus ) from the compiling of grammar constraints. 
     */
    status: undefined.SpeechRecognitionResultStatus
}


/**
 * A constraint for a SpeechRecognizer object based on a Speech Recognition Grammar Specification (SRGS) file. 
 */
declare class SpeechRecognitionGrammarFileConstraint {

    /**
     * Creates an instance of the SpeechRecognitionGrammarFileConstraint class from a file object.
     * @param file An object representing a SRGS grammar file.
     */
    constructor(file: undefined.StorageFile): this;

    /**
     * Creates an instance of the SpeechRecognitionGrammarFileConstraint class from a file object and a tag.
     * @param file An object representing a SRGS grammar file.
     * @param tag The tag to assign to the constraint.
     */
    constructor(file: undefined.StorageFile, tag: string): this;

    /**
     * Gets the StorageFile object representing the Speech Recognition Grammar Specification (SRGS) grammar file. 
     */
    grammarFile: undefined.StorageFile;

    /**
     * Gets or sets whether the constraint can be used by the speech recognizer to perform recognition. 
     */
    isEnabled: boolean;

    /**
     * Gets or sets the weighted value of the constraint. 
     */
    probability: undefined.SpeechRecognitionConstraintProbability;

    /**
     * Gets or sets a tag that can be useful for identifying the constraint. 
     */
    tag: string;

    /**
     * Gets the type of the constraint. 
     */
    type: undefined.SpeechRecognitionConstraintType
}


/**
 * A recognition result fragment returned by the speech recognizer during an ongoing dictation session. 
 */
declare class SpeechRecognitionHypothesis {

    /**
     * Gets the text of the hypothesis, or recognition result fragment, returned by the speech recognizer during an ongoing dictation session. 
     */
    text: string
}


/**
 * Contains event data for the SpeechRecognizer.HypothesisGenerated event. 
 */
declare class SpeechRecognitionHypothesisGeneratedEventArgs {

    /**
     * Gets a recognition result fragment returned by the speech recognizer during an ongoing dictation session. 
     */
    hypothesis: undefined.SpeechRecognitionHypothesis
}


/**
 * A constraint for a SpeechRecognizer object based on a list of words or phrases. When initialized, this object is added to the Constraints collection. 
 */
declare class SpeechRecognitionListConstraint {

    /**
     * Creates an instance of the SpeechRecognitionListConstraint class from an array of words or phrases.
     * @param commands A string array of words or phrases that make up the constraint.
     */
    constructor(commands: undefined.IIterable<string>): this;

    /**
     * Creates an instance of the SpeechRecognitionListConstraint class from an array of words or phrases and a tag.
     * @param commands A string array of words or phrases that make up the constraint.
     * @param tag The tag to assign to the constraint.
     */
    constructor(commands: undefined.IIterable<string>, tag: string): this;

    /**
     * Gets the array of words or phrases that make up the constraint. 
     */
    commands: undefined.IVector<string>;

    /**
     * Gets or sets whether the constraint can be used by the speech recognizer to perform recognition. 
     */
    isEnabled: boolean;

    /**
     * Gets or sets the weighted value of the constraint. 
     */
    probability: undefined.SpeechRecognitionConstraintProbability;

    /**
     * Gets or sets a tag that can be useful for identifying the constraint. 
     */
    tag: string;

    /**
     * Gets the type of the constraint. 
     */
    type: undefined.SpeechRecognitionConstraintType
}


/**
 * Provides data for the SpeechRecognitionQualityDegradingEvent event. 
 */
declare class SpeechRecognitionQualityDegradingEventArgs {

    /**
     * Gets the audio problem that occurred. 
     */
    problem: undefined.SpeechRecognitionAudioProblem
}


/**
 * The result of a speech recognition session. 
 */
declare class SpeechRecognitionResult {

    /**
     * Gets a value that indicates the confidence of the speech recognizer in the recognition result. 
     */
    confidence: undefined.SpeechRecognitionConfidence;

    /**
     * Gets the constraint that was triggered to return the recognized phrase. 
     */
    constraint: undefined.ISpeechRecognitionConstraint;

    /**
     * Gets a collection of recognition result alternatives, ordered by RawConfidence from most likely to least likely. The first item in the collection is the recognition result indicated by the parent object.
     * @param maxAlternates The maximum number of speech recognition results to return in the collection.
     * @return  A collection of speech recognition results, ordered by confidence from most likely to least likely.
     */
    getAlternates(
        maxAlternates: number): undefined.IVectorView<undefined.SpeechRecognitionResult>;

    /**
     * Gets the amount of time required for the utterance. 
     */
    phraseDuration: number;

    /**
     * Gets the start time of the utterance. 
     */
    phraseStartTime: Date;

    /**
     * Gets a value that indicates the relative confidence of the SpeechRecognitionResult when compared with a collection of alternatives returned with the recognition result. 
     */
    rawConfidence: number;

    /**
     * Gets the hierarchy of rule elements that were triggered to return the recognized phrase. 
     */
    rulePath: undefined.IVectorView<string>;

    /**
     * Gets an interpretation object containing the semantic properties of a recognized phrase in a Speech Recognition Grammar Specification (SRGS) grammar. 
     */
    semanticInterpretation: undefined.SpeechRecognitionSemanticInterpretation;

    /**
     * Gets the result state ( SpeechRecognitionResultStatus ) of a speech recognition session. 
     */
    status: undefined.SpeechRecognitionResultStatus;

    /**
     * Gets the recognized phrase of the speech recognition session. 
     */
    text: string
}


/**
 * Represents the semantic properties of a recognized phrase in a Speech Recognition Grammar Specification (SRGS) grammar. 
 */
declare class SpeechRecognitionSemanticInterpretation {

    /**
     * Gets a dictionary of the semantic properties. 
     */
    properties: undefined.IMapView<string, undefined.IVectorView<any >>
}


/**
 * A pre-defined grammar constraint (specifed by SpeechRecognitionScenario ) provided through a web service. 
 */
declare class SpeechRecognitionTopicConstraint {

    /**
     * Creates an instance of the SpeechRecognitionTopicConstraint class by using a pre-defined scenario type, context, and an identifier.
     * @param scenario A predefined scenario type.
     * @param topicHint A subject, or context hint, used to optimize recognition.
     * @param tag Identifier for the constraint.
     */
    constructor(scenario: undefined.SpeechRecognitionScenario, topicHint: string, tag: string): this;

    /**
     * Creates an instance of the SpeechRecognitionTopicConstraint class by using a pre-defined scenario type and context.
     * @param scenario A predefined scenario type.
     * @param topicHint A subject, or context hint, used to optimize recognition.
     */
    constructor(scenario: undefined.SpeechRecognitionScenario, topicHint: string): this;

    /**
     * Gets or sets whether the constraint can be used by the SpeechRecognizer object to perform recognition. 
     */
    isEnabled: boolean;

    /**
     * Gets or sets the weighted value of the constraint. 
     */
    probability: undefined.SpeechRecognitionConstraintProbability;

    /**
     * Gets the predefined scenario type for the constraint. 
     */
    scenario: undefined.SpeechRecognitionScenario;

    /**
     * Gets or sets a tag that can be useful for identifying the constraint. 
     */
    tag: string;

    /**
     * Gets the topic hint for the constraint. 
     */
    topicHint: string;

    /**
     * Gets the type of the constraint. 
     */
    type: undefined.SpeechRecognitionConstraintType
}


/**
 * A constraint for a SpeechRecognizer object based on a Voice Command Definition (VCD) file. 
 */
declare class SpeechRecognitionVoiceCommandDefinitionConstraint {

    /**
     * Gets or sets whether the constraint can be used by the SpeechRecognizer object to perform recognition. 
     */
    isEnabled: boolean;

    /**
     * Gets or sets the weighted value of the constraint. 
     */
    probability: undefined.SpeechRecognitionConstraintProbability;

    /**
     * Gets or sets a tag that can be useful for identifying the constraint. 
     */
    tag: string;

    /**
     * Gets the type of the constraint. 
     */
    type: undefined.SpeechRecognitionConstraintType
}


/**
 * Enables speech recognition with either a default or a custom graphical user interface (GUI). 
 */
declare class SpeechRecognizer {

    /**
     * Gets the collection of languages supported by the custom grammars of the SpeechRecognitionGrammarFileConstraint and SpeechRecognitionListConstraint objects specified in the Constraints property. 
     */
    supportedGrammarLanguages: undefined.IVectorView<undefined.Language>;

    /**
     * Gets the collection of languages supported by the pre-defined, web-service grammars of the SpeechRecognitionTopicConstraint objects specified in the Constraints property. 
     */
    supportedTopicLanguages: undefined.IVectorView<undefined.Language>;

    /**
     * Gets the language of the device specified in Settings>Time & Language>Speech. 
     */
    systemSpeechLanguage: undefined.Language;

    /**
     * Creates a new instance of the SpeechRecognizer class. 
     */
    constructor(): this;

    /**
     * Creates a new instance of the SpeechRecognizer class with a language specifier.
     * @param language The spoken language to use for recognition.
     */
    constructor(language: undefined.Language): this;

    /**
     * Disposes the speech recognizer by freeing, releasing, or resetting allocated resources. 
     */
    close(): void;

    /**
     * Asynchronously compile all constraints specified by the Constraints property.
     * @return  The result of the constraints compilation as a SpeechRecognitionCompilationResult object.
     */
    compileConstraintsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.SpeechRecognitionCompilationResult>;

    /**
     * Gets the collection of constraint objects that are associated with the SpeechRecognizer object. 
     */
    constraints: undefined.IVector<undefined.ISpeechRecognitionConstraint>;

    /**
     * Gets the continuous recognition session object ( SpeechContinuousRecognitionSession ) associated with this SpeechRecognizer . 
     */
    continuousRecognitionSession: undefined.SpeechContinuousRecognitionSession;

    /**
     * Gets the language used for speech recognition. 
     */
    currentLanguage: undefined.Language;

    /**
     * Occurs during an ongoing dictation session when a recognition result fragment is returned by the speech recognizer. 
     */
    onhypothesisgenerated: undefined.TypedEventHandler<undefined.SpeechRecognizer, undefined.SpeechRecognitionHypothesisGeneratedEventArgs>;
    addEventListener(
        type: "hypothesisgenerated",
        listener: undefined.TypedEventHandler<undefined.SpeechRecognizer, undefined.SpeechRecognitionHypothesisGeneratedEventArgs>): void;
    removeEventListener(
        type: "hypothesisgenerated",
        listener: undefined.TypedEventHandler<undefined.SpeechRecognizer, undefined.SpeechRecognitionHypothesisGeneratedEventArgs>): void;

    /**
     * This event is raised when an audio problem is detected that might affect recognition accuracy. 
     */
    onrecognitionqualitydegrading: undefined.TypedEventHandler<undefined.SpeechRecognizer, undefined.SpeechRecognitionQualityDegradingEventArgs>;
    addEventListener(
        type: "recognitionqualitydegrading",
        listener: undefined.TypedEventHandler<undefined.SpeechRecognizer, undefined.SpeechRecognitionQualityDegradingEventArgs>): void;
    removeEventListener(
        type: "recognitionqualitydegrading",
        listener: undefined.TypedEventHandler<undefined.SpeechRecognizer, undefined.SpeechRecognitionQualityDegradingEventArgs>): void;

    /**
     * This event is raised when a change occurs to the State property during audio capture. 
     */
    onstatechanged: undefined.TypedEventHandler<undefined.SpeechRecognizer, undefined.SpeechRecognizerStateChangedEventArgs>;
    addEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.SpeechRecognizer, undefined.SpeechRecognizerStateChangedEventArgs>): void;
    removeEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.SpeechRecognizer, undefined.SpeechRecognizerStateChangedEventArgs>): void;

    /**
     * Begins a speech recognition session for a SpeechRecognizer object.
     * @return  The result of the speech recognition session that was initiated by the SpeechRecognizer object.
     */
    recognizeAsync(): undefined.IPromiseWithIAsyncOperation<undefined.SpeechRecognitionResult>;

    /**
     * Asynchronously starts a speech recognition session that includes additional UI mechanisms, including prompts, examples, text-to-speech (TTS), and confirmations.
     * @return  The result of the speech recognition session as a SpeechRecognitionResult object.
     */
    recognizeWithUIAsync(): undefined.IPromiseWithIAsyncOperation<undefined.SpeechRecognitionResult>;

    /**
     * Gets the state of the speech recognizer. 
     */
    state: undefined.SpeechRecognizerState;

    /**
     * Asynchronously ends the speech recognition session.
     * @return  No object or value is returned when this method completes.
     */
    stopRecognitionAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets how long a speech recognizer ignores silence or unrecognizable sounds (babble) and continues listening for speech input. 
     */
    timeouts: undefined.SpeechRecognizerTimeouts;

    /**
     * Gets the UI settings for the RecognizeWithUIAsync method. 
     */
    uiOptions: undefined.SpeechRecognizerUIOptions;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the SpeechRecognizer.StateChangedEvent event. 
 */
declare class SpeechRecognizerStateChangedEventArgs {

    /**
     * Gets the audio capture state. 
     */
    state: undefined.SpeechRecognizerState
}


/**
 * The timespan that a speech recognizer ignores silence or unrecognizable sounds (babble) and continues listening for speech input. 
 */
declare class SpeechRecognizerTimeouts {

    /**
     * Gets and sets the length of time that a SpeechRecognizer continues to listen while receiving unrecognizable sounds (babble) before it assumes speech input has ended and finalizes the recognition operation. 
     */
    babbleTimeout: number;

    /**
     * Gets and sets the length of time, after recognition results have been generated, that a SpeechRecognizer detects silence and assumes speech input has ended. 
     */
    endSilenceTimeout: number;

    /**
     * Gets and sets the length of time, before any recognition results have been generated, that a SpeechRecognizer detects silence and assumes speech input has ended. 
     */
    initialSilenceTimeout: number
}


/**
 * Specifies the UI settings for the SpeechRecognizer.RecognizeWithUIAsync method. 
 */
declare class SpeechRecognizerUIOptions {

    /**
     * Gets or sets the heading text that is displayed on the Listening screen. The default is "Listening...". 
     */
    audiblePrompt: string;

    /**
     * Gets or sets the example text shown on the Listening screen. 
     */
    exampleText: string;

    /**
     * Gets or sets whether the recognized text is spoken back to the user on the Heard you say screen. 
     */
    isReadBackEnabled: boolean;

    /**
     * Gets or sets whether a Heard you say screen is shown to the user after speech recognition is completed. 
     */
    showConfirmation: boolean
}


/**
 * Represents a constraint for a SpeechRecognizer object. 
 */
declare interface SpeechRecognition$ISpeechRecognitionConstraint {

    /**
     * Gets or sets whether the constraint can be used by the SpeechRecognizer object to perform recognition. 
     */
    isEnabled: boolean,

        /**
         * Gets or sets the weighted value of the constraint. 
         */
        probability: undefined.SpeechRecognitionConstraintProbability,

        /**
         * Gets or sets a tag that can be useful for identifying the constraint. 
         */
        tag: string,

        /**
         * Gets the type of the constraint. 
         */
        type: undefined.SpeechRecognitionConstraintType
}


/**
 * Supports reading and writing audio data generated by the speech synthesis engine (voice) to/from a random access stream. 
 */
declare class SpeechSynthesisStream {

    /**
     * Gets whether SpeechSynthesisStream can be read from. 
     */
    canRead: boolean;

    /**
     * Gets a value that indicates whether SpeechSynthesisStream can be written to. 
     */
    canWrite: boolean;

    /**
     * Creates a copy of SpeechSynthesisStream that references the same bytes as the original stream.
     * @return  The new stream.
     */
    cloneStream(): undefined.IRandomAccessStream;

    /**
     * Releases system resources that are exposed by SpeechSynthesisStream . 
     */
    close(): void;

    /**
     * Gets the MIME type of the content of SpeechSynthesisStream . 
     */
    contentType: string;

    /**
     * Flushes data asynchronously in a sequential stream.
     * @return  An asynchronous operation. For more information, see FlushAsync method.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Retrieves an input stream at a specified location in SpeechSynthesisStream .
     * @param position The location in the stream at which to begin.
     * @return  The input stream.
     */
    getInputStreamAt(position: number): undefined.IInputStream;

    /**
     * Retrieves an output stream at a specified location in SpeechSynthesisStream .
     * @param position The location in the stream at which to begin.
     * @return  The output stream.
     */
    getOutputStreamAt(position: number): undefined.IOutputStream;

    /**
     * Gets the collection of timeline markers associated with SpeechSynthesisStream . 
     */
    markers: undefined.IVectorView<undefined.IMediaMarker>;

    /**
     * Gets the position within SpeechSynthesisStream . 
     */
    position: number;

    /**
     * Reads data asynchronously in a sequential stream.
     * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
     * @param count The number of bytes to read that is less than or equal to the Capacity value.
     * @param options Specifies the type of the asynchronous read operation.
     * @return  An asynchronous operation that includes progress updates. For more information, see ReadAsync method.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Goes to the specified position within SpeechSynthesisStream .
     * @param position The desired position within the stream.
     */
    seek(position: number): void;

    /**
     * Gets or sets the size of the SpeechSynthesisStream . 
     */
    size: number;

    /**
     * Writes data asynchronously in a sequential stream.
     * @param buffer The buffer into which the asynchronous writer operation places the bytes to write.
     * @return  An asynchronous operation that includes progress updates. For more information, see WriteAsync method.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides access to the functionality of an installed speech synthesis engine (voice). 
 */
declare class SpeechSynthesizer {

    /**
     * Gets a collection of all installed speech synthesis engines (voices). 
     */
    allVoices: undefined.IVectorView<undefined.VoiceInformation>;

    /**
     * Gets the default speech synthesis engine (voice). 
     */
    defaultVoice: undefined.VoiceInformation;

    /**
     * Initializes a new instance of a SpeechSynthesizer object. 
     */
    constructor(): this;

    /**
     * Closes the SpeechSynthesizer and releases system resources. 
     */
    close(): void;

    /**
     * Asynchronously generate speech output from a string containing Speech Synthesis Markup Language (SSML).
     * @param Ssml The SSML-modified text to speak.
     * @return  A SpeechSynthesisStream that represents the speech generated from the Speech Synthesis Markup Language (SSML).
     */
    synthesizeSsmlToStreamAsync(
        Ssml: string): undefined.IPromiseWithIAsyncOperation<undefined.SpeechSynthesisStream>;

    /**
     * Asynchronously generate speech output from a string.
     * @param text The text to speak.
     * @return  A SpeechSynthesisStream that represents the speech generated from the text.
     */
    synthesizeTextToStreamAsync(
        text: string): undefined.IPromiseWithIAsyncOperation<undefined.SpeechSynthesisStream>;

    /**
     * Gets or sets the speech synthesis engine (voice). 
     */
    voice: undefined.VoiceInformation
}


/**
 * Provides info about an installed speech synthesis engine (voice). 
 */
declare class VoiceInformation {

    /**
     * Gets the description of the speech synthesis engine (voice). 
     */
    description: string;

    /**
     * Gets the display name associated with the speech synthesis engine (voice). 
     */
    displayName: string;

    /**
     * Gets the gender setting of the speech synthesis engine (voice). 
     */
    gender: undefined.VoiceGender;

    /**
     * Gets the unique ID of the speech synthesis engine (voice). 
     */
    id: string;

    /**
     * Gets the normalized BCP-47 language tag of the speech synthesis engine (voice). 
     */
    language: string
}


/**
 * Represents the source of adaptive streaming content. 
 */
declare class AdaptiveMediaSource {

    /**
     * Asynchronously creates a AdaptiveMediaSource object from the provided input stream.
     * @param stream The input stream from which the AdaptiveMediaSource is created.
     * @param uri The URI of the source. This is used by the AdaptiveMediaSource to resolve relative URIs.
     * @param contentType A string that identifies the MIME content type of the source. This can be an Http Live Streaming (HLS) or a Dynamic Adaptive Streaming over HTTP (DASH) content type.
     * @param httpClient The HttpClient instance that the AdaptiveMediaSource should use for downloading resources. This allows you to specify custom HTTP headers for the requests.
     * @return  Returns an AdaptiveMediaSourceCreationResult upon successful completion.
     */
    createFromStreamAsync(
        stream: undefined.IInputStream,
        uri: undefined.Uri,
        contentType: string,
        httpClient: undefined.HttpClient): undefined.IPromiseWithIAsyncOperation<undefined.AdaptiveMediaSourceCreationResult>;

    /**
     * Asynchronously creates a AdaptiveMediaSource object from the provided input stream.
     * @param stream The input stream from which the AdaptiveMediaSource is created.
     * @param uri The URI of the source. This is used by the AdaptiveMediaSource to resolve relative URIs.
     * @param contentType A string that identifies the MIME content type of the source. This can be an Http Live Streaming (HLS) or a Dynamic Adaptive Streaming over HTTP (DASH) content type.
     * @return  Returns an AdaptiveMediaSourceCreationResult upon successful completion.
     */
    createFromStreamAsync(
        stream: undefined.IInputStream,
        uri: undefined.Uri,
        contentType: string): undefined.IPromiseWithIAsyncOperation<undefined.AdaptiveMediaSourceCreationResult>;

    /**
     * Asynchronously creates a AdaptiveMediaSource object from the Uniform Resource Identifier (URI) of the source.
     * @param uri T he URI of the source.
     * @return  Returns an AdaptiveMediaSourceCreationResult upon successful completion.
     */
    createFromUriAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperation<undefined.AdaptiveMediaSourceCreationResult>;

    /**
     * Asynchronously creates a AdaptiveMediaSource object from the Uniform Resource Identifier (URI) of the source.
     * @param uri T he URI of the source.
     * @param httpClient The HttpClient instance that the AdaptiveMediaSource should use for downloading resources. This allows you to specify custom HTTP headers for the requests.
     * @return  Returns an AdaptiveMediaSourceCreationResult upon successful completion.
     */
    createFromUriAsync(
        uri: undefined.Uri,
        httpClient: undefined.HttpClient): undefined.IPromiseWithIAsyncOperation<undefined.AdaptiveMediaSourceCreationResult>;

    /**
     * Determines whether the content type of the source is supported.
     * @param contentType A string that identifies the content type of the source. Can be a Http Live Streaming (HLS) or Dynamic Adaptive Streaming over HTTP (DASH) content type.
     * @return  Returns a value that indicates whether the content type of the source is supported. true if supported; otherwise, false.
     */
    isContentTypeSupported(contentType: string): boolean;
    advancedSettings: any;

    /**
     * Gets a value indicating if the content streamed by the media source contains only audio. 
     */
    audioOnlyPlayback: boolean;

    /**
     * Gets the available adaptive bit rates of the adaptive streaming manifest that is the source of the adaptive streaming object. 
     */
    availableBitrates: undefined.IVectorView<number>;

    /**
     * Gets a value indicating the current download bitrate for the media source. 
     */
    currentDownloadBitrate: number;

    /**
     * Gets a value indicating the current playback bitrate for the media source. 
     */
    currentPlaybackBitrate: number;

    /**
     * Gets or sets the desired starting offset for the live playback of the media source. 
     */
    desiredLiveOffset: number;

    /**
     * Gets or sets the desired maximum bitrate for the media source. 
     */
    desiredMaxBitrate: number;

    /**
     * Gets or sets the desired minimum bitrate for the media source. 
     */
    desiredMinBitrate: number;

    /**
     * Gets a value indicating the inbound bits per second statistic over the time window specified by the InboundBitsPerSecondWindow property. 
     */
    inboundBitsPerSecond: number;

    /**
     * Gets or sets the time span over which the InboundBitsPerSecond property is calculated. 
     */
    inboundBitsPerSecondWindow: number;

    /**
     * Gets and sets the initial bit rate to use for playback of the media source. 
     */
    initialBitrate: number;

    /**
     * Gets a value that indicates whether the media source is live. 
     */
    isLive: boolean;

    /**
     * Occurs when the CurrentDownloadBitrate changes. 
     */
    ondownloadbitratechanged: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadBitrateChangedEventArgs>;
    addEventListener(
        type: "downloadbitratechanged",
        listener: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadBitrateChangedEventArgs>): void;
    removeEventListener(
        type: "downloadbitratechanged",
        listener: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadBitrateChangedEventArgs>): void;

    /**
     * Occurs when a resource download operation completes 
     */
    ondownloadcompleted: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadCompletedEventArgs>;
    addEventListener(
        type: "downloadcompleted",
        listener: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadCompletedEventArgs>): void;
    removeEventListener(
        type: "downloadcompleted",
        listener: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadCompletedEventArgs>): void;

    /**
     * Occurs when a resource download operation fails. 
     */
    ondownloadfailed: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadFailedEventArgs>;
    addEventListener(
        type: "downloadfailed",
        listener: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadFailedEventArgs>): void;
    removeEventListener(
        type: "downloadfailed",
        listener: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadFailedEventArgs>): void;

    /**
     * Occurs when a resource download operation is requested. 
     */
    ondownloadrequested: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadRequestedEventArgs>;
    addEventListener(
        type: "downloadrequested",
        listener: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadRequestedEventArgs>): void;
    removeEventListener(
        type: "downloadrequested",
        listener: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourceDownloadRequestedEventArgs>): void;

    /**
     * Occurs when the CurrentPlaybackBitrate changes. 
     */
    onplaybackbitratechanged: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>;
    addEventListener(
        type: "playbackbitratechanged",
        listener: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>): void;
    removeEventListener(
        type: "playbackbitratechanged",
        listener: undefined.TypedEventHandler<undefined.AdaptiveMediaSource, undefined.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}

declare class AdaptiveMediaSourceAdvancedSettings {
    allSegmentsIndependent: any;
    bitrateDowngradeTriggerRatio: any;
    desiredBitrateHeadroomRatio: any
}


/**
 * Represents the result of the creation of a AdaptiveMediaSource object. 
 */
declare class AdaptiveMediaSourceCreationResult {

    /**
     * Gets the HTTP response message, if any, returned from an attempt to create a AdaptiveMediaSource object. 
     */
    httpResponseMessage: undefined.HttpResponseMessage;

    /**
     * Gets the AdaptiveMediaSource object that represents the source of adaptive streaming content. 
     */
    mediaSource: undefined.AdaptiveMediaSource;

    /**
     * Gets the status of an attempt to create a AdaptiveMediaSource object. 
     */
    status: undefined.AdaptiveMediaSourceCreationStatus
}


/**
 * Provides data for the DownloadBitrateChanged event. 
 */
declare class AdaptiveMediaSourceDownloadBitrateChangedEventArgs {

    /**
     * Gets a value indicating the new download bitrate for the media source. 
     */
    newValue: number;

    /**
     * Gets a value indicating the previous download bitrate for the media source. 
     */
    oldValue: number
}


/**
 * Provides data for the DownloadCompleted event. 
 */
declare class AdaptiveMediaSourceDownloadCompletedEventArgs {

    /**
     * Gets the http response message, if any, returned from the completed media download request. 
     */
    httpResponseMessage: undefined.HttpResponseMessage;

    /**
     * Gets the byte range length of the completed media download request. 
     */
    resourceByteRangeLength: number;

    /**
     * Gets the byte range offset of the completed media download request. 
     */
    resourceByteRangeOffset: number;

    /**
     * Gets the resource type of the completed media download request. 
     */
    resourceType: undefined.AdaptiveMediaSourceResourceType;

    /**
     * Gets the resource URI of the completed media download request. 
     */
    resourceUri: undefined.Uri
}


/**
 * Provides data for the DownloadFailed event. 
 */
declare class AdaptiveMediaSourceDownloadFailedEventArgs {

    /**
     * Gets the http response message, if any, returned from the failed media download request. 
     */
    httpResponseMessage: undefined.HttpResponseMessage;

    /**
     * Gets the byte range length of the failed media download request. 
     */
    resourceByteRangeLength: number;

    /**
     * Gets the byte range offset of the failed media download request. 
     */
    resourceByteRangeOffset: number;

    /**
     * Gets the resource type of the failed media download request. 
     */
    resourceType: undefined.AdaptiveMediaSourceResourceType;

    /**
     * Gets the resource URI of the failed media download request. 
     */
    resourceUri: undefined.Uri
}


/**
 * Represents a deferral that can be used to defer the completion of the DownloadRequested event so that the app can asynchronously download media content. 
 */
declare class AdaptiveMediaSourceDownloadRequestedDeferral {

    /**
     * Informs the system that an asynchronous operation associated with a DownloadRequested event has finished. 
     */
    complete(): void
}


/**
 * Provides data for the DownloadRequested event. 
 */
declare class AdaptiveMediaSourceDownloadRequestedEventArgs {

    /**
     * Gets a deferral that can be used to defer the completion of the DownloadRequested event so that the app can asynchronously download media content.
     * @return  A deferral that can be used to defer the completion of the DownloadRequested event.
     */
    getDeferral(): undefined.AdaptiveMediaSourceDownloadRequestedDeferral;

    /**
     * Gets the byte range length of the media download request. 
     */
    resourceByteRangeLength: number;

    /**
     * Gets the byte range offset of the media download request. 
     */
    resourceByteRangeOffset: number;

    /**
     * Gets the resource type of the media download request. 
     */
    resourceType: undefined.AdaptiveMediaSourceResourceType;

    /**
     * Gets the resource URI of the media download request. 
     */
    resourceUri: undefined.Uri;

    /**
     * Gets an AdaptiveMediaSourceDownloadResult object representing the result of the media download request. 
     */
    result: undefined.AdaptiveMediaSourceDownloadResult
}


/**
 * Represents the results of a resource download operation. 
 */
declare class AdaptiveMediaSourceDownloadResult {

    /**
     * Gets or sets a buffer containing the downloaded resource. 
     */
    buffer: undefined.IBuffer;

    /**
     * Gets or sets a string that identifies the MIME content type of the downloaded resource. 
     */
    contentType: string;

    /**
     * Gets or sets an integer value that represents extended status information about the resource download operation. 
     */
    extendedStatus: number;

    /**
     * Gets or sets an input stream containing the downloaded resource. 
     */
    inputStream: undefined.IInputStream;

    /**
     * Gets or sets the Uniform Resource Identifier (URI) of the downloaded resource. 
     */
    resourceUri: undefined.Uri
}


/**
 * Provides data for the PlaybackBitrateChanged event. 
 */
declare class AdaptiveMediaSourcePlaybackBitrateChangedEventArgs {

    /**
     * Gets a value indicating whether the media source contains only audio data. 
     */
    audioOnly: boolean;

    /**
     * Gets the new playback bitrate. 
     */
    newValue: number;

    /**
     * Gets the old playback bitrate. 
     */
    oldValue: number
}


/**
 * Represents an object that enables integrate with the system media transport controls and support for media commands. 
 */
declare class SystemMediaTransportControls {

    /**
     * The system transport controls for the current view.
     * @return  The system transport controls for the current view.
     */
    getForCurrentView(): undefined.SystemMediaTransportControls;

    /**
     * Gets or sets a value representing the current auto-repeat mode of the SystemMediaTransportControls . 
     */
    autoRepeatMode: undefined.MediaPlaybackAutoRepeatMode;

    /**
     * Gets the display updater for the SystemMediaTransportControls which enable updating the information displayed about the currently playing song. 
     */
    displayUpdater: undefined.SystemMediaTransportControlsDisplayUpdater;

    /**
     * Gets or sets a value that specifies if the channel down button is supported. 
     */
    isChannelDownEnabled: boolean;

    /**
     * Gets or sets a value that specifies if the channel up button is supported. 
     */
    isChannelUpEnabled: boolean;

    /**
     * Enables and disables the system media transport controls for the app. 
     */
    isEnabled: boolean;

    /**
     * Gets or sets a value that specifies if the fast forward button is supported. 
     */
    isFastForwardEnabled: boolean;

    /**
     * Gets or sets a value that specifies if the next button is supported. 
     */
    isNextEnabled: boolean;

    /**
     * Gets or sets a value that specifies if the pause button is supported. true if the pause button is supported; otherwise, false. 
     */
    isPauseEnabled: boolean;

    /**
     * Gets or sets a value that specifies if the play button is supported. 
     */
    isPlayEnabled: boolean;

    /**
     * Gets or sets a value that specifies if the previous button is supported. 
     */
    isPreviousEnabled: boolean;

    /**
     * Gets or sets a value that specifies if the record button is supported. true if the record button is supported; otherwise, false. 
     */
    isRecordEnabled: boolean;

    /**
     * Gets or sets a value that specifies if the rewind button is supported. 
     */
    isRewindEnabled: boolean;

    /**
     * Gets or sets a value that specifies if the stop button is supported. 
     */
    isStopEnabled: boolean;

    /**
     * Occurs when the user modifies the SystemMediaTransportControls auto-repeat mode. 
     */
    onautorepeatmodechangerequested: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.AutoRepeatModeChangeRequestedEventArgs>;
    addEventListener(
        type: "autorepeatmodechangerequested",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.AutoRepeatModeChangeRequestedEventArgs>): void;
    removeEventListener(
        type: "autorepeatmodechangerequested",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.AutoRepeatModeChangeRequestedEventArgs>): void;

    /**
     * Occurs when a button is pressed on the SystemMediaTransportControls . 
     */
    onbuttonpressed: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.SystemMediaTransportControlsButtonPressedEventArgs>;
    addEventListener(
        type: "buttonpressed",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.SystemMediaTransportControlsButtonPressedEventArgs>): void;
    removeEventListener(
        type: "buttonpressed",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.SystemMediaTransportControlsButtonPressedEventArgs>): void;

    /**
     * Occurs when the user modifies the playback position of the SystemMediaTransportControls . 
     */
    onplaybackpositionchangerequested: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.PlaybackPositionChangeRequestedEventArgs>;
    addEventListener(
        type: "playbackpositionchangerequested",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.PlaybackPositionChangeRequestedEventArgs>): void;
    removeEventListener(
        type: "playbackpositionchangerequested",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.PlaybackPositionChangeRequestedEventArgs>): void;

    /**
     * Occurs when the user modifies the SystemMediaTransportControls playback rate. 
     */
    onplaybackratechangerequested: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, any>;
    addEventListener(
        type: "playbackratechangerequested",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, any>): void;
    removeEventListener(
        type: "playbackratechangerequested",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, any>): void;

    /**
     * Occurs when a property on the SystemMediaTransportControls has changed. 
     */
    onpropertychanged: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.SystemMediaTransportControlsPropertyChangedEventArgs>;
    addEventListener(
        type: "propertychanged",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.SystemMediaTransportControlsPropertyChangedEventArgs>): void;
    removeEventListener(
        type: "propertychanged",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.SystemMediaTransportControlsPropertyChangedEventArgs>): void;

    /**
     * Occurs when the user modifies the SystemMediaTransportControls shuffle state. 
     */
    onshuffleenabledchangerequested: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.ShuffleEnabledChangeRequestedEventArgs>;
    addEventListener(
        type: "shuffleenabledchangerequested",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.ShuffleEnabledChangeRequestedEventArgs>): void;
    removeEventListener(
        type: "shuffleenabledchangerequested",
        listener: undefined.TypedEventHandler<undefined.SystemMediaTransportControls, undefined.ShuffleEnabledChangeRequestedEventArgs>): void;

    /**
     * Gets or sets the playback rate of the SystemMediaTransportControls . 
     */
    playbackRate: number;

    /**
     * Gets the playback status of the media. 
     */
    playbackStatus: undefined.MediaPlaybackStatus;

    /**
     * Gets or sets a value representing the current shuffle state of the SystemMediaTransportControls . 
     */
    shuffleEnabled: boolean;

    /**
     * Gets the sound level of the media for the capture and render streams. 
     */
    soundLevel: undefined.SoundLevel;

    /**
     * Updates the SystemMediaTransportControls timeline properties with the values in the provided object.
     * @param timelineProperties The object representing the new timeline property values.
     */
    updateTimelineProperties(
        timelineProperties: undefined.SystemMediaTransportControlsTimelineProperties): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the SystemMediaTransportControls.ButtonPressed event. 
 */
declare class SystemMediaTransportControlsButtonPressedEventArgs {

    /**
     * Gets the button on the SystemMediaTransportControls that was pressed. 
     */
    button: undefined.SystemMediaTransportControlsButton
}


/**
 * Provides functionality to update the music information that is displayed on the SystemMediaTransportControls . 
 */
declare class SystemMediaTransportControlsDisplayUpdater {

    /**
     * Gets or sets the media id of the app. 
     */
    appMediaId: string;

    /**
     * Clears out all of the media metadata. 
     */
    clearAll(): void;

    /**
     * Initialize the media properties using the specified file.
     * @param type The type of media.
     * @param source The file to initialize the media properties.
     * @return  When this method completes, it returns a boolean value that indicates true if the operation succeeded; otherwise, false.
     */
    copyFromFileAsync(
        type: undefined.MediaPlaybackType,
        source: undefined.StorageFile): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets the image properties associated with the currently playing media. 
     */
    imageProperties: undefined.ImageDisplayProperties;

    /**
     * Gets the music properties associated with the currently playing media. 
     */
    musicProperties: undefined.MusicDisplayProperties;

    /**
     * Gets or sets thumbnail image associated with the currently playing media. 
     */
    thumbnail: undefined.RandomAccessStreamReference;

    /**
     * Gets or sets the type of media. 
     */
    type: undefined.MediaPlaybackType;

    /**
     * Updates the metadata for the currently playing media. 
     */
    update(): void;

    /**
     * Gets the video properties associated with the currently playing media. 
     */
    videoProperties: undefined.VideoDisplayProperties
}


/**
 * Occurs when a property is changed on the SystemMediaTransportControls . 
 */
declare class SystemMediaTransportControlsPropertyChangedEventArgs {

    /**
     * The property that was changed on the SystemMediaTransportControls . 
     */
    property: undefined.SystemMediaTransportControlsProperty
}


/**
 * Represents timeline properties of the SystemMediaTransportControls . Pass an instance of this class to the UpdateTimelineProperties method to update the properties. 
 */
declare class SystemMediaTransportControlsTimelineProperties {

    /**
     * Initializes a new instance of the SystemMediaTransportControlsTimelineProperties class. 
     */
    constructor(): this;

    /**
     * Gets or sets a value representing the end time of the currently playing media item. 
     */
    endTime: number;

    /**
     * Gets or sets a value indicating the latest time within the currently playing media item to which the user can seek. 
     */
    maxSeekTime: number;

    /**
     * Gets or sets a value indicating the earliest time within the currently playing media item to which the user can seek. 
     */
    minSeekTime: number;

    /**
     * Gets or sets a value representing the current playback position within the currently playing media item. 
     */
    position: number;

    /**
     * Gets or sets a value representing the start time of the currently playing media item. 
     */
    startTime: number
}


/**
 * Transcodes audio and video files. 
 */
declare class MediaTranscoder {

    /**
     * Creates a new instance of the MediaTranscoder class. 
     */
    constructor(): this;

    /**
     * Adds the specified audio effect with configuration properties, and indicates whether the effect is required.
     * @param activatableClassId The identifier of the audio effect.
     * @param effectRequired Indicates whether the audio effect is required.
     * @param configuration Configuration properties for the audio effect.
     */
    addAudioEffect(
        activatableClassId: string,
        effectRequired: boolean,
        configuration: undefined.IPropertySet): void;

    /**
     * Adds the specified audio effect.
     * @param activatableClassId The identifier of the audio effect.
     */
    addAudioEffect(activatableClassId: string): void;

    /**
     * Adds the specified video effect.
     * @param activatableClassId The identifier of the video effect.
     */
    addVideoEffect(activatableClassId: string): void;

    /**
     * Adds the specified video effect with configuration properties and indicates whether the effect is required.
     * @param activatableClassId The identifier of the video effect.
     * @param effectRequired Indicates whether the video effect is required.
     * @param configuration Configuration properties for the video effect.
     */
    addVideoEffect(
        activatableClassId: string,
        effectRequired: boolean,
        configuration: undefined.IPropertySet): void;

    /**
     * Specifies whether the media transcoder always re-encodes the source. 
     */
    alwaysReencode: boolean;

    /**
     * Removes all audio and video effects from the transcode session. 
     */
    clearEffects(): void;

    /**
     * Specifies whether hardware acceleration is enabled. 
     */
    hardwareAccelerationEnabled: boolean;

    /**
     * Asynchronously initializes the trancode operation on the specified file and returns a PrepareTranscodeResult object which can be used to start the transcode operation.
     * @param source The source file.
     * @param destination The destination file.
     * @param profile The profile to use for the operation.
     * @return  When this method completes, a PrepareTranscodeResult object is returned which can be used to start the transcode.
     */
    prepareFileTranscodeAsync(
        source: undefined.IStorageFile,
        destination: undefined.IStorageFile,
        profile: undefined.MediaEncodingProfile): undefined.IPromiseWithIAsyncOperation<undefined.PrepareTranscodeResult>;

    /**
     * Asynchronously initializes the trancode operation on the specified media source and returns a PrepareTranscodeResult object which can be used to start the transcode operation.
     * @param source The media source to perform the transcode operation on.
     * @param destination The destination stream for the transcoded media data.
     * @param profile The profile to use for the operation.
     * @return  When this method completes, a PrepareTranscodeResult object is returned which can be used to start the transcode.
     */
    prepareMediaStreamSourceTranscodeAsync(
        source: undefined.IMediaSource,
        destination: undefined.IRandomAccessStream,
        profile: undefined.MediaEncodingProfile): undefined.IPromiseWithIAsyncOperation<undefined.PrepareTranscodeResult>;

    /**
     * Asynchronously initializes the trancode operation on the specified stream and returns a PrepareTranscodeResult object which can be used to start the transcode operation.
     * @param source The source stream.
     * @param destination The destination stream.
     * @param profile The profile to use for the operation.
     * @return  When this method completes, a PrepareTranscodeResult object is returned which can be used to start the transcode.
     */
    prepareStreamTranscodeAsync(
        source: undefined.IRandomAccessStream,
        destination: undefined.IRandomAccessStream,
        profile: undefined.MediaEncodingProfile): undefined.IPromiseWithIAsyncOperation<undefined.PrepareTranscodeResult>;

    /**
     * Gets or sets the time interval to trim from the start of the output. 
     */
    trimStartTime: number;

    /**
     * Gets or sets the time interval to trim from the end of the output. 
     */
    trimStopTime: number;

    /**
     * Gets or sets the video processing algorithm which will be used for transcoding. 
     */
    videoProcessingAlgorithm: undefined.MediaVideoProcessingAlgorithm
}


/**
 * Represents an asynchronous media transcode deferral operation which can be used to start the transcode operation. 
 */
declare class PrepareTranscodeResult {

    /**
     * Indicates whether the trancode operation can be performed successfully. 
     */
    canTranscode: boolean;

    /**
     * Specifies the reason for the transcode failure. 
     */
    failureReason: undefined.TranscodeFailureReason;

    /**
     * Creates an object to perform an asynchronous media transcode operation on media data.
     * @return  An object that is used to control the asynchronous operation.
     */
    transcodeAsync(): undefined.IPromiseWithIAsyncActionWithProgress<number >
}


/**
 * Provides properties for video information that is displayed by SystemMediaTransportControlsDisplayUpdater class. 
 */
declare class VideoDisplayProperties {

    /**
     * Gets a modifiable list of strings representing genre names. 
     */
    genres: undefined.IVector<string>;

    /**
     * Gets or sets the subtitle of the video. 
     */
    subtitle: string;

    /**
     * Gets or sets the title of the video. 
     */
    title: string
}


/**
 * Provides video-related effects. 
 */
declare class VideoEffects {

    /**
     * Represents a video stabilization effect which can be used on a video object to reduce the shakiness in the video. 
     */
    videoStabilization: string
}


/**
 * Represents a single frame of video data. 
 */
declare class VideoFrame {

    /**
     * Initializes a new instance of the VideoFrame class.
     * @param format The pixel format of the video frame.
     * @param width The width of the video frame, in pixels.
     * @param height The height of the video frame, in pixels.
     * @param alpha The alpha mode of the video frame.
     */
    constructor(format: undefined.BitmapPixelFormat, width: number, height: number, alpha: undefined.BitmapAlphaMode): this;

    /**
     * Initializes a new instance of the VideoFrame class.
     * @param format The pixel format of the video frame.
     * @param width The width of the video frame, in pixels.
     * @param height The height of the video frame, in pixels.
     */
    constructor(format: undefined.BitmapPixelFormat, width: number, height: number): this;

    /**
     * Disposes of the object and associated resources. 
     */
    close(): void;

    /**
     * Copies the current VideoFrame into a provided VideoFrame object.
     * @param frame The target video frame into which the current frame will be copied.
     * @return  An asynchronous action.
     */
    copyToAsync(frame: undefined.VideoFrame): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the IDirect3DSurface object containing the pixel data of the video frame, when one is present. 
     */
    direct3DSurface: undefined.IDirect3DSurface;

    /**
     * Gets or sets the duration of the video frame. 
     */
    duration: number;

    /**
     * Gets the extended property set which enables getting and setting properties on the media frame. 
     */
    extendedProperties: undefined.IPropertySet;

    /**
     * Gets or sets a value that indicates whether an video frame is the first frame after a gap in the stream. 
     */
    isDiscontinuous: boolean;

    /**
     * Gets a value indicating whether the video frame is read-only. 
     */
    isReadOnly: boolean;

    /**
     * Gets or sets the relative time of the frame within the video stream. 
     */
    relativeTime: number;

    /**
     * Gets the SoftwareBitmap object containing the pixel data of the video frame, when one is present. 
     */
    softwareBitmap: undefined.SoftwareBitmap;

    /**
     * Gets or sets a timestamp that is relative to the system and is correlatable across multiple media sources on the same device. 
     */
    systemRelativeTime: number;

    /**
     * Gets a string indicating the type of video data the video frame contains. 
     */
    type: string
}


/**
 * Encapsulates the method needed to set the configuration properties on a registered media parser or codec. 
 */
declare interface Media$IMediaExtension {

    /**
     * Sets the configuration properties that were supplied when the media parser or codec was registered.
     * @param configuration The configuration properties for the media parser or codec.
     */
    setProperties(configuration: undefined.IPropertySet): void
}


/**
 * Represents a marker at specific location in a media stream time-line. 
 */
declare interface Media$IMediaMarker {

    /**
     * Gets the type of the media marker. 
     */
    mediaMarkerType: string,

        /**
         * Gets the text associated with the marker. 
         */
        text: string,

        /**
         * Gets the offset in the media time-line that the marker occurs. 
         */
        time: number
}


/**
 * Used to configure downloads prior to the actual creation of the download operation using CreateDownload . For an overview of Background Transfer capabilities, see Transferring data in the background. Download the Background Transfer sample for examples in JavaScript, C#, and C++. 
 */
declare class BackgroundDownloader {

    /**
     * Returns a collection of pending downloads that are not associated with a group.
     * @return  A collection of pending downloads for the current application instance.
     */
    getCurrentDownloadsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Returns a collection of pending downloads for a specific Group .
     * @param group A string indicating a specific group of transfers.
     * @return  A collection of pending downloads for the specific group.
     */
    getCurrentDownloadsAsync(
        group: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets all downloads associated with the provided BackgroundTransferGroup .
     * @param group Contains information used to identify a group of downloads.
     * @return  A list of downloads currently associated with the specified group.
     */
    getCurrentDownloadsForTransferGroupAsync(
        group: undefined.BackgroundTransferGroup): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Used to request an unconstrained download operation. When this method is called the user is provided with a UI prompt that they can use to indicate their consent for an unconstrained operation.
     * @param operations The download operation to run unconstrained.
     * @return  Indicates if the operations will run unconstrained.
     */
    requestUnconstrainedDownloadsAsync(
        operations: undefined.IIterable<undefined.DownloadOperation>): undefined.IPromiseWithIAsyncOperation<undefined.UnconstrainedTransferRequestResult>;

    /**
     * Creates a new BackgroundDownloader object. 
     */
    constructor(): this;

    /**
     * Creates a new BackgroundDownloader object with a BackgroundTransferCompletionGroup .
     * @param completionGroup The completion group to associate with this BackgroundDownloader object.
     */
    constructor(completionGroup: undefined.BackgroundTransferCompletionGroup): this;

    /**
     * Gets the BackgroundTransferCompletionGroup associated with the BackgroundDownloader . 
     */
    completionGroup: undefined.BackgroundTransferCompletionGroup;

    /**
     * Gets or sets the cost policy for the background download operation. 
     */
    costPolicy: undefined.BackgroundTransferCostPolicy;

    /**
     * Initializes a DownloadOperation object that contains the specified Uri and the file that the response is written to.
     * @param uri The location of the resource.
     * @param resultFile The file that the response will be written to.
     * @return  The resultant download operation.
     */
    createDownload(
        uri: undefined.Uri,
        resultFile: undefined.IStorageFile): undefined.DownloadOperation;

    /**
     * Initializes a DownloadOperation object with the resource Uri , the file that the response is written to, and the request entity body.
     * @param uri The location of the resource.
     * @param resultFile The file that the response will be written to.
     * @param requestBodyFile A file that represents the request entity body, which contains additional data the server requires before the download can begin. The file this object points to must be valid for the duration of the download.
     * @return  The resultant download operation.
     */
    createDownload(
        uri: undefined.Uri,
        resultFile: undefined.IStorageFile,
        requestBodyFile: undefined.IStorageFile): undefined.DownloadOperation;

    /**
     * Creates an asynchronous download operation that includes a URI, the file that the response will be written to, and the IInputStream object from which the file contents are read.
     * @param uri The location of the resource.
     * @param resultFile Represents the file that the response will be written to.
     * @param requestBodyStream A stream that represents the request entity body.
     * @return  The resultant asynchronous download operation.
     */
    createDownloadAsync(
        uri: undefined.Uri,
        resultFile: undefined.IStorageFile,
        requestBodyStream: undefined.IInputStream): undefined.IPromiseWithIAsyncOperation<undefined.DownloadOperation>;

    /**
     * Gets or sets the TileNotification used to define the visuals, identification tag, and expiration time of a tile notification used to update the app tile when indicating failure of a download to the user. 
     */
    failureTileNotification: undefined.TileNotification;

    /**
     * Gets or sets the ToastNotification that defines the content, associated metadata, and events used in a toast notification to indicate failure of a download to the user. 
     */
    failureToastNotification: undefined.ToastNotification;

    /**
     * Gets or sets a string value (e.g. a GUID) indicating the group the transfer will belong to. A download operation with a group ID will only appear in operation enumerations using GetCurrentDownloadsAsync(String) with the specific group string value. 
     */
    group: string;

    /**
     * Gets or sets the HTTP method used for the background download. The default method used for download operations is GET. 
     */
    method: string;

    /**
     * Gets or sets the proxy credentials for the background transfer. 
     */
    proxyCredential: undefined.PasswordCredential;

    /**
     * Gets or sets the credentials to use to authenticate with the origin server. 
     */
    serverCredential: undefined.PasswordCredential;

    /**
     * Used to set an HTTP request header.
     * @param headerName The header name.
     * @param headerValue The header value.
     */
    setRequestHeader(headerName: string, headerValue: string): void;

    /**
     * Gets or sets the TileNotification used to define the visuals, identification tag, and expiration time of a tile notification used to update the app tile when indicating success of a download to the user. 
     */
    successTileNotification: undefined.TileNotification;

    /**
     * Gets or sets the ToastNotification that defines the content, associated metadata, and events used in a toast notification to indicate success of a download to the user. 
     */
    successToastNotification: undefined.ToastNotification;

    /**
     * Gets or sets the group that a download operation will belong to. 
     */
    transferGroup: undefined.BackgroundTransferGroup
}


/**
 * Represents a set of background transfer operations ( DownloadOperation or UploadOperation objects) that trigger a background task once all the operations are done (if the operations completed successfully) or fail with an error. 
 */
declare class BackgroundTransferCompletionGroup {

    /**
     * Creates a new BackgroundTransferCompletionGroup object. 
     */
    constructor(): this;

    /**
     * Indicates that the BackgroundTransferCompletionGroup is complete and no more background transfer operations ( DownloadOperation or UploadOperation objects) will be added t the completion group. 
     */
    enable(): void;

    /**
     * Gets a value that indicates if Enable method on a BackgroundTransferCompletionGroup has already been called. 
     */
    isEnabled: boolean;

    /**
     * Gets the IBackgroundTrigger used to set up the background task associated with the BackgroundTransferCompletionGroup . 
     */
    trigger: undefined.IBackgroundTrigger
}


/**
 * Contains information about a BackgroundTransferCompletionGroup that can be only accessed from the Run method on the IBackgroundTask . 
 */
declare class BackgroundTransferCompletionGroupTriggerDetails {

    /**
     * Gets the list of DownloadOperation objects associated with the BackgroundTransferCompletionGroup . 
     */
    downloads: undefined.IVectorView<undefined.DownloadOperation>;

    /**
     * Gets the list of UploadOperation objects associated with the BackgroundTransferCompletionGroup . 
     */
    uploads: undefined.IVectorView<undefined.UploadOperation >
}


/**
 * Represents a content part of a multi-part transfer request. Each BackgroundTransferContentPart object can represent either a single string of text content or a single file payload, but not both. 
 */
declare class BackgroundTransferContentPart {

    /**
     * Creates a BackgroundTransferContentPart object. 
     */
    constructor(): this;

    /**
     * Creates a BackgroundTransferContentPart object that identifies the file content and the name of the file that it represents.
     * @param name Identifies the content.
     * @param fileName The fully qualified file name, including the local path.
     */
    constructor(name: string, fileName: string): this;

    /**
     * Creates a BackgroundTransferContentPart object that identifies the content it represents.
     * @param name Identifies the content.
     */
    constructor(name: string): this;

    /**
     * Sets the source file for a BackgroundTransferContentPart containing the file for upload.
     * @param value The source file.
     */
    setFile(value: undefined.IStorageFile): void;

    /**
     * Sets content disposition header values that indicate the nature of the information that this BackgroundTransferContentPart represents.
     * @param headerName The header name.
     * @param headerValue The header value.
     */
    setHeader(headerName: string, headerValue: string): void;

    /**
     * Use this method to set text information that the BackgroundTransferContentPart represents.
     * @param value A string value used to represent text information. (e.g. api_sig, api_key, auth_token, etc...)
     */
    setText(value: string): void
}


/**
 * Used to provide errors encountered during a transfer operation. 
 */
declare class BackgroundTransferError {

    /**
     * Gets the specific error using the returned HRESULT value. Possible values are defined by WebErrorStatus .
     * @param hresult An HRESULT returned during the operation.
     * @return  The error encountered.
     */
    getStatus(hresult: number): undefined.WebErrorStatus
}


/**
 * A named group used to associate multiple download or upload operations. This class makes it easy for your app to create these groups and to complete downloads and uploads simultaneously, in serial, or based on priority. 
 */
declare class BackgroundTransferGroup {

    /**
     * Creates a transfer group using the provided group name.
     * @param name The name of the group. If a group with the this name already exists, this method will return a reference to the existing group object.
     * @return  The new BackgroundTransferGroup .
     */
    createGroup(name: string): undefined.BackgroundTransferGroup;

    /**
     * Gets the name of the group. 
     */
    name: string;

    /**
     * Gets or sets the property used to specify if transfers within this group run simultaneously or in serial. Possible values are defined by BackgroundTransferBehavior . 
     */
    transferBehavior: undefined.BackgroundTransferBehavior
}


/**
 * Used to configure upload prior to the actual creation of the upload operation using CreateUpload . For an overview of Background Transfer capabilities, see Transferring data in the background. Download the Background Transfer sample for examples in JavaScript, C#, and C++. 
 */
declare class BackgroundUploader {

    /**
     * Returns a collection of pending uploads for a specific Group .
     * @param group A string indicating a specific group of uploads.
     * @return  A collection of pending uploads for the specific group.
     */
    getCurrentUploadsAsync(
        group: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Returns a collection of pending uploads that are not associated with a group.
     * @return  A collection of pending uploads for the current application instance.
     */
    getCurrentUploadsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets all uploads associated with the provided BackgroundTransferGroup .
     * @param group Contains information used to identify a group of uploads.
     * @return  A list of uploads currently associated with the specified group.
     */
    getCurrentUploadsForTransferGroupAsync(
        group: undefined.BackgroundTransferGroup): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Used to request an unconstrained upload operation. When this method is called the user is provided with a UI prompt that they can use to indicate their consent for an unconstrained operation.
     * @param operations The upload operation to run unconstrained.
     * @return  Indicates if the operations will run unconstrained.
     */
    requestUnconstrainedUploadsAsync(
        operations: undefined.IIterable<undefined.UploadOperation>): undefined.IPromiseWithIAsyncOperation<undefined.UnconstrainedTransferRequestResult>;

    /**
     * Instantiates a new BackgroundUploader object. 
     */
    constructor(): this;

    /**
     * Instantiates a new BackgroundUploader object as a member of a completion group.
     * @param completionGroup The completion group that the created BackgroundUploader instance is to be a member of.
     */
    constructor(completionGroup: undefined.BackgroundTransferCompletionGroup): this;

    /**
     * Gets the BackgroundTransferCompletionGroup associated with the BackgroundUploader . 
     */
    completionGroup: undefined.BackgroundTransferCompletionGroup;

    /**
     * Gets or sets the cost policy for the background upload operation. 
     */
    costPolicy: undefined.BackgroundTransferCostPolicy;

    /**
     * Initializes an UploadOperation that indicates the location for and file for upload.
     * @param uri The location for the upload.
     * @param sourceFile The file for upload.
     * @return  The resultant upload operation.
     */
    createUpload(
        uri: undefined.Uri,
        sourceFile: undefined.IStorageFile): undefined.UploadOperation;

    /**
     * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI and one or more BackgroundTransferContentPart objects.
     * @param uri The location for the upload.
     * @param parts One or more BackgroundTransferContentPart objects.
     * @return  The resultant asynchronous UploadOperation
     */
    createUploadAsync(
        uri: undefined.Uri,
        parts: undefined.IIterable<undefined.BackgroundTransferContentPart>): undefined.IPromiseWithIAsyncOperation<undefined.UploadOperation>;

    /**
     * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI, multipart subtype, one or more BackgroundTransferContentPart objects, and the delimiter boundary value used to separate each part.
     * @param uri The location for the upload.
     * @param parts One or more BackgroundTransferContentPart objects.
     * @param subType The multipart subtype. For example, "related" for content of type "multipart/ related".
     * @param boundary A string that is used to identify the delimiter used to indicate separation between provided content parts.
     * @return  The resultant asynchronous UploadOperation
     */
    createUploadAsync(
        uri: undefined.Uri,
        parts: undefined.IIterable<undefined.BackgroundTransferContentPart>,
        subType: string,
        boundary: string): undefined.IPromiseWithIAsyncOperation<undefined.UploadOperation>;

    /**
     * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI, one or more BackgroundTransferContentPart objects, and the multipart subtype.
     * @param uri The location for the upload.
     * @param parts One or more BackgroundTransferContentPart objects.
     * @param subType The multipart subtype. For example, "related" for content of type "multipart/ related".
     * @return  The resultant asynchronous UploadOperation .
     */
    createUploadAsync(
        uri: undefined.Uri,
        parts: undefined.IIterable<undefined.BackgroundTransferContentPart>,
        subType: string): undefined.IPromiseWithIAsyncOperation<undefined.UploadOperation>;

    /**
     * Returns an asynchronous operation that, on completion, returns an UploadOperation with the specified URI and the source stream.
     * @param uri The URI associated with the resource.
     * @param sourceStream Represents the source stream.
     * @return  The resultant asynchronous upload operation.
     */
    createUploadFromStreamAsync(
        uri: undefined.Uri,
        sourceStream: undefined.IInputStream): undefined.IPromiseWithIAsyncOperation<undefined.UploadOperation>;

    /**
     * Gets and sets the TileNotification used to define the visuals, identification tag, and expiration time of a tile notification used to update the app tile when indicating failure of an upload to the user. 
     */
    failureTileNotification: undefined.TileNotification;

    /**
     * Gets or sets the ToastNotification that defines the content, associated metadata, and events used in a toast notification to indicate failure of an upload to the user. 
     */
    failureToastNotification: undefined.ToastNotification;

    /**
     * Gets or sets a string value (e.g. a GUID) indicating the group the upload will belong to. An upload operation with a group ID will only appear in operation enumerations using GetCurrentDownloadsAsync(String) with the specific group string value. 
     */
    group: string;

    /**
     * Gets or sets the HTTP method used for the upload. The default method used for upload operations is POST. 
     */
    method: string;

    /**
     * Gets or sets the proxy credentials for the upload. 
     */
    proxyCredential: undefined.PasswordCredential;

    /**
     * Gets or sets the credentials to use to authenticate with the origin server. 
     */
    serverCredential: undefined.PasswordCredential;

    /**
     * Used to set an HTTP request header.
     * @param headerName The header name.
     * @param headerValue The header value.
     */
    setRequestHeader(headerName: string, headerValue: string): void;

    /**
     * Gets and sets the TileNotification used to define the visuals, identification tag, and expiration time of a tile notification used to update the app tile when indicating success of an upload to the user. 
     */
    successTileNotification: undefined.TileNotification;

    /**
     * Gets or sets the ToastNotification that defines the content, associated metadata, and events used in a toast notification to indicate success of an upload to the user. 
     */
    successToastNotification: undefined.ToastNotification;

    /**
     * Gets or sets the group that an upload operation will belong to. 
     */
    transferGroup: undefined.BackgroundTransferGroup
}


/**
 * Provides properties for specifying web resources to be prefetched. Windows will use heuristics to attempt to download the specified resources in advance of your app being launched by the user. 
 */
declare class ContentPrefetcher {

    /**
     * Array of URIs to download when prefetch is performed for the app. 
     */
    contentUris: undefined.IVector<undefined.Uri>;

    /**
     * Specifies the location of a well-formed XML file that contains a list of resources to be prefetched. 
     */
    indirectContentUri: undefined.Uri;

    /**
     * Gets the date and time of the last successful content prefetch operation. 
     */
    lastSuccessfulPrefetchTime: Date
}


/**
 * Performs an asynchronous download operation. The Background Transfer sample demonstrates this functionality. For an overview of Background Transfer capabilities, see Transferring data in the background. Download the Background Transfer sample for examples in JavaScript, C#, and C++. 
 */
declare class DownloadOperation {

    /**
     * Returns an asynchronous operation that can be used to monitor progress and completion of the attached download. Calling this method allows an app to attach download operations that were started in a previous app instance.
     * @return  Download operation with callback.
     */
    attachAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.DownloadOperation, undefined.DownloadOperation>;

    /**
     * Gets and sets the cost policy for the download. 
     */
    costPolicy: undefined.BackgroundTransferCostPolicy;

    /**
     * Gets the response information.
     * @return  Contains the data returned by a server response.
     */
    getResponseInformation(): undefined.ResponseInformation;

    /**
     * Gets the partially downloaded response at the specified position.
     * @param position The position at which to start reading.
     * @return  The result stream.
     */
    getResultStreamAt(position: number): undefined.IInputStream;

    /**
     * Gets a string value indicating the group the transfer belongs to. 
     */
    group: string;

    /**
     * This is a unique identifier for a specific download operation. A GUID associated to a download operation will not change for the duration of the download. 
     */
    guid: string;

    /**
     * Gets the method to use for the download. 
     */
    method: string;

    /**
     * Pauses a download operation. 
     */
    pause(): void;

    /**
     * Gets or sets the transfer priority of this download operation when within a BackgroundTransferGroup . Possible values are defined by BackgroundTransferPriority . 
     */
    priority: undefined.BackgroundTransferPriority;

    /**
     * Gets the current progress of the upload operation. 
     */
    progress: undefined.BackgroundDownloadProgress;

    /**
     * Gets the URI from which to download the file. 
     */
    requestedUri: undefined.Uri;

    /**
     * Returns the IStorageFile object provided by the caller when creating the DownloadOperation object using CreateDownload . 
     */
    resultFile: undefined.IStorageFile;

    /**
     * Resumes a paused download operation. 
     */
    resume(): void;

    /**
     * Starts an asynchronous download operation.
     * @return  An asynchronous download operation that includes progress updates.
     */
    startAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.DownloadOperation, undefined.DownloadOperation>;

    /**
     * Gets the group that this download operation belongs to. 
     */
    transferGroup: undefined.BackgroundTransferGroup
}


/**
 * Represents data that is returned by a server response. 
 */
declare class ResponseInformation {

    /**
     * Gets the URI that contains the requested data. 
     */
    actualUri: undefined.Uri;

    /**
     * Gets all response headers sent by the server. 
     */
    headers: undefined.IMapView<string, string>;

    /**
     * Gets a value that specifies whether the download is resumable. 
     */
    isResumable: boolean;

    /**
     * Gets the status code returned by the server. 
     */
    statusCode: number
}


/**
 * Represents the result a request for unconstrained transfers from a BackgroundDownloader or BackgroundUploader object. 
 */
declare class UnconstrainedTransferRequestResult {

    /**
     * Gets a value that indicates if the download or upload operations will run without the resource restrictions normally associated with background network operations while a device running on battery. 
     */
    isUnconstrained: boolean
}


/**
 * Performs an asynchronous upload operation. For an overview of Background Transfer capabilities, see Transferring data in the background. Download the Background Transfer sample for examples in JavaScript, C#, and C++. 
 */
declare class UploadOperation {

    /**
     * Returns an asynchronous operation that can be used to monitor progress and completion of the attached upload. Calling this method allows an app to attach upload operations that were started in a previous app instance.
     * @return  Upload operation with callback.
     */
    attachAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.UploadOperation, undefined.UploadOperation>;

    /**
     * Gets and sets the cost policy for the upload. 
     */
    costPolicy: undefined.BackgroundTransferCostPolicy;

    /**
     * Gets the response information.
     * @return  Contains the data returned by a server response.
     */
    getResponseInformation(): undefined.ResponseInformation;

    /**
     * Gets the partially uploaded response at the specified location.
     * @param position The position at which to start reading.
     * @return  The result stream.
     */
    getResultStreamAt(position: number): undefined.IInputStream;

    /**
     * Gets a string value indicating the group the upload belongs to. 
     */
    group: string;

    /**
     * This is a unique identifier for a specific upload operation. A GUID associated to a upload operation will not change for the duration of the upload. 
     */
    guid: string;

    /**
     * Gets the method to use for the upload. 
     */
    method: string;

    /**
     * Gets or sets the transfer priority of this upload operation when within a BackgroundTransferGroup . Possible values are defined by BackgroundTransferPriority . 
     */
    priority: undefined.BackgroundTransferPriority;

    /**
     * Gets the current progress of the upload operation. 
     */
    progress: undefined.BackgroundUploadProgress;

    /**
     * Gets the URI to upload from. 
     */
    requestedUri: undefined.Uri;

    /**
     * Specifies the IStorageFile to upload. 
     */
    sourceFile: undefined.IStorageFile;

    /**
     * Starts an asynchronous upload operation.
     * @return  An asynchronous upload operation that includes progress updates.
     */
    startAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.UploadOperation, undefined.UploadOperation>;

    /**
     * Gets the group that this upload operation belongs to. 
     */
    transferGroup: undefined.BackgroundTransferGroup
}


/**
 * Contains status information about the download operation. 
 */
declare interface BackgroundTransfer$BackgroundDownloadProgress {

    /**
     * The total number of bytes received. This value does not include bytes received as response headers. 
     */
    bytesReceived: number,

        /**
         * true if the download request response has changed; otherwise, false. 
         */
        hasResponseChanged: boolean,

        /**
         * true if a data transfer operation has restarted; otherwise false. 
         */
        hasRestarted: boolean,

        /**
         * The current status of the download operation. 
         */
        status: undefined.BackgroundTransferStatus,

        /**
         * The total number of bytes of data to download. If this number is unknown, this value is set to 0. 
         */
        totalBytesToReceive: number
}


/**
 * Contains status information about the upload operation. 
 */
declare interface BackgroundTransfer$BackgroundUploadProgress {

    /**
     * The total number of bytes received. This value does not include bytes received as part of response headers. If the upload operation has restarted, this value may be smaller than in the previous progress report. 
     */
    bytesReceived: number,

        /**
         * The total number of bytes sent. If the upload operation has restarted, this value may be smaller than in the previous progress report. 
         */
        bytesSent: number,

        /**
         * TRUE if the upload request response has changed; otherwise, FALSE. 
         */
        hasResponseChanged: boolean,

        /**
         * true if a upload transfer operation has restarted; otherwise false. 
         */
        hasRestarted: boolean,

        /**
         * The current status of the upload operation. 
         */
        status: undefined.BackgroundTransferStatus,

        /**
         * The total number of bytes of data to upload. If this number is unknown, this value is set to 0. 
         */
        totalBytesToReceive: number,

        /**
         * The total number of bytes to upload. 
         */
        totalBytesToSend: number
}


/**
 * Provides access to property values containing information on current usage of the attributed network connection. 
 */
declare class AttributedNetworkUsage {

    /**
     * Gets the Id of the of the app. 
     */
    attributionId: string;

    /**
     * Gets the name of the app. 
     */
    attributionName: string;

    /**
     * Gets the thumbnail of the app. 
     */
    attributionThumbnail: undefined.IRandomAccessStreamReference;

    /**
     * Gets the number of bytes received by the app over the network. 
     */
    bytesReceived: number;

    /**
     * Gets the number of bytes sent by the app over the network. 
     */
    bytesSent: number
}


/**
 * This class contains properties used to specify an Access Point Name (APN) for a 3GPP based cellular Data Connection (PDP context). A CellularApnContext object is passed with a AcquireConnectionAsync call to establish a connection to a specific access point. 
 */
declare class CellularApnContext {

    /**
     * Creates an instance of CellularApnContext . 
     */
    constructor(): this;

    /**
     * Indicates the name of the access point to establish a connection with. 
     */
    accessPointName: string;

    /**
     * Indicates the authentication method, as defined by CellularApnAuthenticationType , that is used by the access point. 
     */
    authenticationType: undefined.CellularApnAuthenticationType;

    /**
     * Indicates if data compression will be used at the data link for header and data transfer. 
     */
    isCompressionEnabled: boolean;

    /**
     * Indicates the password used to authenticate when connecting to the access point. 
     */
    password: string;

    /**
     * Indicates the provider ID associated with the access point. 
     */
    providerId: string;

    /**
     * Indicates the user name used to authenticate when connecting to the access point. 
     */
    userName: string
}


/**
 * Provides access to property values that indicate the current cost of a network connection. 
 */
declare class ConnectionCost {

    /**
     * Gets a value that indicates if a connection is approaching the data usage allowance specified by the data plan. 
     */
    approachingDataLimit: boolean;

    /**
     * Gets a value that indicates whether background data usage has been restricted. 
     */
    backgroundDataUsageRestricted: boolean;

    /**
     * Gets a value that indicates the current network cost for a connection. 
     */
    networkCostType: undefined.NetworkCostType;

    /**
     * Gets a value that indicates if the connection has exceeded the data usage allowance specified by the data plan. 
     */
    overDataLimit: boolean;

    /**
     * Gets a value that indicates whether the connection is connected to a network outside of the home provider. 
     */
    roaming: boolean
}


/**
 * Represents a network connection, which includes either the currently connected network or prior network connections. Provides information about the connection status and connectivity statistics. 
 */
declare class ConnectionProfile {

    /**
     * Gets network usage data for each individual application. This method is only supported in a Windows Phone Store app.
     * @param startTime The start time of the usage window.
     * @param endTime The end time of the usage window.
     * @param states The state of the connection profile for which usage data should be returned.
     * @return  When the method completes, it returns a list of AttributedNetworkUsage objects, which indicate the sent and received values, in bytes, and the total amount of time the app was connected during the corresponding time interval.
     */
    getAttributedNetworkUsageAsync(
        startTime: Date,
        endTime: Date,
        states: undefined.NetworkUsageStates): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the cost information for the connection.
     * @return  The cost information for the connection.
     */
    getConnectionCost(): undefined.ConnectionCost;

    /**
     * Gets a list of ConnectivityInterval objects, which indicate the timestamp for when the network connection began, and a time-span for the duration of that connection.
     * @param startTime The start time over which to retrieve data. Can be no more than 60 days prior to the current time.
     * @param endTime The end time over which to retrieve data.
     * @param states The state of the connection profile for which usage data should be returned.
     * @return  When the method completes, it returns a list of ConnectivityInterval objects, which indicate the start time and duration for the current or prior connections.
     */
    getConnectivityIntervalsAsync(
        startTime: Date,
        endTime: Date,
        states: undefined.NetworkUsageStates): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the current status of the data plan associated with the connection.
     * @return  Current data plan status information.
     */
    getDataPlanStatus(): undefined.DataPlanStatus;

    /**
     * Gets the current domain authentication status for a network connection. Possible values are defined by DomainConnectivityLevel .
     * @return  A value indicating the authentication status for a connection to a network domain.
     */
    getDomainConnectivityLevel(): undefined.DomainConnectivityLevel;

    /**
     * Gets the estimated data usage for a connection over a specific period of time and roaming state.
     * @param StartTime The start date/time for the usage data request.
     * @param EndTime The end date/time for the usage data request.
     * @param States The roaming state to scope the request to.
     * @return  The requested local data usage information.
     */
    getLocalUsage(
        StartTime: Date,
        EndTime: Date,
        States: undefined.RoamingStates): undefined.DataUsage;

    /**
     * Gets the estimated data usage for a connection during over a specific period of time.
     * @param StartTime The start date/time for the usage data request.
     * @param EndTime The end date/time for the usage data request.
     * @return  The requested local data usage information.
     */
    getLocalUsage(StartTime: Date, EndTime: Date): undefined.DataUsage;

    /**
     * Gets the network connectivity level for this connection. This value indicates what network resources, if any, are currently available.
     * @return  The level of network connectivity.
     */
    getNetworkConnectivityLevel(): undefined.NetworkConnectivityLevel;

    /**
     * Retrieves names associated with the network with which the connection is currently established.
     * @return  An array of string values representing friendly names used to identify the local endpoint.
     */
    getNetworkNames(): undefined.IVectorView<string>;

    /**
     * Gets a list of the estimated data traffic and connection duration over a specified period of time, for a specific network usage state.
     * @param startTime The start time over which to retrieve data. Can be no more than 60 days prior to the current time. If the specified granularity is PerMinute, the start time can be no more than 120 minutes prior to the current time.
     * @param endTime The end time over which to retrieve data.
     * @param granularity The desired granularity of the returned usage statistics. Each elements in the list corresponds to the network usage per the specified granularity, e.g., usage per hour.
     * @param states The state of the connection profile for which usage data should be returned.
     * @return  When the method completes, it returns a list of NetworkUsage objects, which indicate the sent and received values, in bytes, and the total amount of time the profile was connected during the corresponding time interval.
     */
    getNetworkUsageAsync(
        startTime: Date,
        endTime: Date,
        granularity: undefined.DataUsageGranularity,
        states: undefined.NetworkUsageStates): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets a value that indicates the current number of signal bars displayed by the Windows UI for the connection.
     * @return  An integer value within a range of 0-5 that corresponds to the number of signal bars displayed by the UI.
     */
    getSignalBars(): number;

    /**
     * Gets a value that indicates if connection profile is a WLAN (WiFi) connection. This determines whether or not WlanConnectionProfileDetails is null. 
     */
    isWlanConnectionProfile: boolean;

    /**
     * Gets a value that indicates if connection profile is a WWAN (mobile) connection. This determines whether or not WwanConnectionProfileDetails is null. 
     */
    isWwanConnectionProfile: boolean;

    /**
     * Gets the object representing the network adapter providing connectivity for the connection. 
     */
    networkAdapter: undefined.NetworkAdapter;

    /**
     * Retrieves the security settings for the network. 
     */
    networkSecuritySettings: undefined.NetworkSecuritySettings;

    /**
     * Gets the name of the connection profile. 
     */
    profileName: string;

    /**
     * Gets the ID of the network operator who provisioned the connection profile. 
     */
    serviceProviderGuid: string;

    /**
     * Gets a WlanConnectionProfileDetails object that provides a method for retrieving information specific to a WLAN (WiFi) connection. 
     */
    wlanConnectionProfileDetails: undefined.WlanConnectionProfileDetails;

    /**
     * Gets a WwanConnectionProfileDetails object containing the properties and methods used to retrieve information specific to mobile broadband connections. 
     */
    wwanConnectionProfileDetails: undefined.WwanConnectionProfileDetails
}


/**
 * The ConnectionProfileFilter class defines a set of properties that are used to improve the relevance of FindConnectionProfilesAsync results. 
 */
declare class ConnectionProfileFilter {

    /**
     * Creates an instance of ConnectionProfileFilter , which contains a set of properties that are used to improve the relevance of FindConnectionProfilesAsync results. 
     */
    constructor(): this;

    /**
     * Gets or sets whether background data usage is restricted by this connection profile filter. 
     */
    isBackgroundDataUsageRestricted: boolean;

    /**
     * Indicates if connection profiles that represent currently established connections are included in query results. 
     */
    isConnected: boolean;

    /**
     * Gets or sets whether the data limit has been exceeded under the current connection profile filter. 
     */
    isOverDataLimit: boolean;

    /**
     * Gets or sets whether roaming is active in the connection profile filter. 
     */
    isRoaming: boolean;

    /**
     * Indicates if connection profiles that represent WLAN (WiFi) connections are included in query results. 
     */
    isWlanConnectionProfile: boolean;

    /**
     * Indicates if connection profiles that represent WWAN (mobile) connections are included in query results. 
     */
    isWwanConnectionProfile: boolean;

    /**
     * Defines a specific NetworkCostType value to query for. 
     */
    networkCostType: undefined.NetworkCostType;

    /**
     * Gets available data as raw data. 
     */
    rawData: undefined.IBuffer;

    /**
     * Indicates a specific network operator ID to query for. 
     */
    serviceProviderGuid: string
}


/**
 * The ConnectionSession class is used to represent a connection to an access point established with AcquireConnectionAsync . 
 */
declare class ConnectionSession {

    /**
     * Closes the connection to the access point. 
     */
    close(): void;

    /**
     * Retrieves the ConnectionProfile associated with the connection session. 
     */
    connectionProfile: undefined.ConnectionProfile
}


/**
 * Provides the start time and duration for an established or prior connection. 
 */
declare class ConnectivityInterval {

    /**
     * Indicates the duration of connectivity. 
     */
    connectionDuration: number;

    /**
     * Indicates when the connection was initially established. 
     */
    startTime: Date
}


/**
 * Methods defined by the ConnectivityManager class enable enforcement of traffic routing on a specific network adapter for the specified destination suffix. Once a policy is set using AddHttpRoutePolicy , traffic that matches the policy will either be routed or dropped. 
 */
declare class ConnectivityManager {

    /**
     * Establishes a connection to a specific access point on a network. The request is defined using a CellularApnContext object.
     * @param CellularApnContext Provides specific details about the APN.
     * @return  The established APN connection.
     */
    acquireConnectionAsync(
        CellularApnContext: undefined.CellularApnContext): undefined.IPromiseWithIAsyncOperation<undefined.ConnectionSession>;

    /**
     * Specifies a RoutePolicy that the Http stack (WinInet) will follow when routing traffic.
     * @param RoutePolicy Indicates the policy for traffic routing.
     */
    addHttpRoutePolicy(RoutePolicy: undefined.RoutePolicy): void;

    /**
     * Removes a previously specified RoutePolicy from the Http stack (WinInet).
     * @param RoutePolicy The RoutePolicy to remove.
     */
    removeHttpRoutePolicy(RoutePolicy: undefined.RoutePolicy): void
}


/**
 * Represents the current status information for the data plan associated with a connection. 
 */
declare class DataPlanStatus {

    /**
     * Gets a value indicating the maximum data transfer allowance for a connection within each billing cycle, as defined by the data plan. 
     */
    dataLimitInMegabytes: number;

    /**
     * Gets a DataPlanUsage object that indicates the amount of data transferred over the connection, in megabytes, and the last time this value was refreshed. 
     */
    dataPlanUsage: undefined.DataPlanUsage;

    /**
     * Gets a value indicating the nominal rate of the inbound data transfer occurring on the connection. 
     */
    inboundBitsPerSecond: number;

    /**
     * Gets a value indicates the maximum size of a transfer that is allowed without user consent on a metered network. 
     */
    maxTransferSizeInMegabytes: number;

    /**
     * Gets a value indicating the date and time of the next billing cycle. 
     */
    nextBillingCycle: Date;

    /**
     * Gets a value indicating the nominal rate of the outbound data transfer. 
     */
    outboundBitsPerSecond: number
}


/**
 * Represents data plan specific data usage information for a connection. 
 */
declare class DataPlanUsage {

    /**
     * Gets a DateTime object indicating the date and time when the MegabytesUsed property was last updated. 
     */
    lastSyncTime: Date;

    /**
     * Gets a value indicating the total amount of data transferred, in megabytes, over the connection. 
     */
    megabytesUsed: number
}


/**
 * Represents data usage information returned by the ConnectionProfile.GetLocalUsage method. 
 */
declare class DataUsage {

    /**
     * Gets a value indicating the number of bytes received by a connection over a specific period of time. 
     */
    bytesReceived: number;

    /**
     * Gets a value indicating the number of bytes sent by the connection over a specific period of time. 
     */
    bytesSent: number
}


/**
 * Represents the association between an IP address and an adapter on the network. 
 */
declare class IPInformation {

    /**
     * Retrieves the network adapter associated with the IP address. 
     */
    networkAdapter: undefined.NetworkAdapter;

    /**
     * Retrieves the length of the prefix, or network part of the IP address. 
     */
    prefixLength: number
}


/**
 * Represents physical identification data for a specific NetworkAdapter object. 
 */
declare class LanIdentifier {

    /**
     * Gets a LanIdentifierData object containing locality identification information for the network adapter's connection. 
     */
    infrastructureId: undefined.LanIdentifierData;

    /**
     * Gets the adapter GUID that identifies the network adapter to associate with the locality information. 
     */
    networkAdapterId: string;

    /**
     * Gets a LanIdentifierData object containing the port ID from the Link Layer Discovery Protocol (LLDP) locality information for an Ethernet type network adapter. 
     */
    portId: undefined.LanIdentifierData
}


/**
 * Represents the port specific data that enables LAN locality capabilities. 
 */
declare class LanIdentifierData {

    /**
     * Gets a value indicating the type of data stored in the value field of the LanIdentifierData object according to the Link Layer Discovery Protocol (LLDP) protocol. 
     */
    type: number;

    /**
     * Gets the serialized value. 
     */
    value: undefined.IVectorView<number >
}


/**
 * Represents a network adapter. 
 */
declare class NetworkAdapter {

    /**
     * Gets the connection profile currently associated with the network adapter.
     * @return  The connection profile associated with this network adapter.
     */
    getConnectedProfileAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ConnectionProfile>;

    /**
     * Gets a value indicating the network interface type as defined by the Internet Assigned Names Authority (IANA) for the NetworkAdapter . 
     */
    ianaInterfaceType: number;

    /**
     * Gets a value indicating the maximum inbound data transfer rate in bits per second. 
     */
    inboundMaxBitsPerSecond: number;

    /**
     * Gets the network adapter ID. 
     */
    networkAdapterId: string;

    /**
     * Gets the NetworkItem object that represents the connected network. 
     */
    networkItem: undefined.NetworkItem;

    /**
     * Gets a value indicating the maximum outbound speed in bits per second. 
     */
    outboundMaxBitsPerSecond: number
}


/**
 * Provides access to network connection information for the local machine. 
 */
declare class NetworkInformation {

    /**
     * Returns an array of ConnectionProfile objects that match the filtering criteria defined by ConnectionProfileFilter .
     * @param pProfileFilter Provides the filtering criteria.
     * @return  An array of ConnectionProfile objects.
     */
    findConnectionProfilesAsync(
        pProfileFilter: undefined.ConnectionProfileFilter): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets a list of profiles for connections, active or otherwise, on the local machine.
     * @return  An array of ConnectionProfile objects.
     */
    getConnectionProfiles(): undefined.IVectorView<undefined.ConnectionProfile>;

    /**
     * Gets a list of host names associated with the local machine.
     * @return  An array of host names for the local machine.
     */
    getHostNames(): undefined.IVectorView<undefined.HostName>;

    /**
     * Gets the connection profile associated with the internet connection currently used by the local machine.
     * @return  The profile for the connection currently used to connect the machine to the Internet, or null if there is no connection profile with a suitable connection.
     */
    getInternetConnectionProfile(): undefined.ConnectionProfile;

    /**
     * Gets an array of LanIdentifier objects that contain locality information for each NetworkAdapter object that currently connected to a network.
     * @return  An array of LanIdentifier objects.
     */
    getLanIdentifiers(): undefined.IVectorView<undefined.LanIdentifier>;

    /**
     * Gets proxy configuration for a connection using the specified URI.
     * @param uri The proxy configuration URI.
     * @return  Information about the connection proxy.
     */
    getProxyConfigurationAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperation<undefined.ProxyConfiguration>;

    /**
     * Gets a sorted list of EndpointPair objects.
     * @param destinationList A list of EndpointPair objects to be sorted.
     * @param sortOptions Indicates sorting options for the returned array.
     * @return  A sorted array of EndpointPair objects.
     */
    getSortedEndpointPairs(
        destinationList: undefined.IIterable<undefined.EndpointPair>,
        sortOptions: undefined.HostNameSortOptions): undefined.IVectorView<undefined.EndpointPair>;

    /**
     * Occurs when the network status changes for a connection. 
     */
    onnetworkstatuschanged: undefined.NetworkStatusChangedEventHandler;
    addEventListener(
        type: "networkstatuschanged",
        listener: undefined.NetworkStatusChangedEventHandler): void;
    removeEventListener(
        type: "networkstatuschanged",
        listener: undefined.NetworkStatusChangedEventHandler): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a connected network. 
 */
declare class NetworkItem {

    /**
     * Gets a NetworkTypes value indicating the network type for a NetworkItem .
     * @return  The type of a network.
     */
    getNetworkTypes(): undefined.NetworkTypes;

    /**
     * Gets the network ID. 
     */
    networkId: string
}


/**
 * Represents the current network security settings. 
 */
declare class NetworkSecuritySettings {

    /**
     * Retrieves the type of authentication used by the network. 
     */
    networkAuthenticationType: undefined.NetworkAuthenticationType;

    /**
     * Retrieves the type of encryption used by the network. 
     */
    networkEncryptionType: undefined.NetworkEncryptionType
}


/**
 * Indicates which properties of a network have changed after a network state change background trigger. 
 */
declare class NetworkStateChangeEventDetails {

    /**
     * Indicates if a connected network has a new connection cost. 
     */
    hasNewConnectionCost: boolean;

    /**
     * Indicates a connected network has a new domain connectivity level. 
     */
    hasNewDomainConnectivityLevel: boolean;

    /**
     * Indicates if the list of host names returned by GetHostNames has changed. 
     */
    hasNewHostNameList: boolean;

    /**
     * Indicates if the local machine has a new connection profile associated with the current internet connection. 
     */
    hasNewInternetConnectionProfile: boolean;

    /**
     * Indicates if the network connectivity level for any connection profiles has changed. 
     */
    hasNewNetworkConnectivityLevel: boolean;

    /**
     * Gets a value indicating whether the network state change event shows a new tethering client count. 
     */
    hasNewTetheringClientCount: boolean;

    /**
     * Gets a value that indicates whether the tethering operational state has changed. 
     */
    hasNewTetheringOperationalState: boolean;

    /**
     * Indicates if the network state change event represents a change to the registration state of a WWAN connection. The current registration state can be retrieved from WwanConnectionProfileDetails.GetNetworkRegistrationState . 
     */
    hasNewWwanRegistrationState: boolean
}


/**
 * Represents network usage statistics returned by the ConnectionProfile . GetNetworkUsageAsync method. 
 */
declare class NetworkUsage {

    /**
     * Indicates the number of bytes received by the connection of a specific period of time. 
     */
    bytesReceived: number;

    /**
     * Indicates the number of bytes sent by a connection over a specific period of time. 
     */
    bytesSent: number;

    /**
     * Indicates the duration of connectivity. 
     */
    connectionDuration: number
}


/**
 * Represents the proxy configuration for the current user. 
 */
declare class ProxyConfiguration {

    /**
     * Gets a value that indicates if this configuration can connect directly. 
     */
    canConnectDirectly: boolean;

    /**
     * Gets a list of URIs for the proxies from the proxy configuration. 
     */
    proxyUris: undefined.IVectorView<undefined.Uri >
}


/**
 * The RoutePolicy class is used to represent the traffic routing policy for a special PDP Context/APN. 
 */
declare class RoutePolicy {

    /**
     * Creates an instance of RoutePolicy using the defined connection profile and host name values.
     * @param connectionProfile The connection profile
     * @param hostName The host name for the route policy to the special PDP context.
     * @param type The domain type of hostName when the HostNameType value indicates a domain name.
     */
    constructor(connectionProfile: undefined.ConnectionProfile, hostName: undefined.HostName, type: undefined.DomainNameType): this;

    /**
     * Retrieves the connection profile for an access point connection. 
     */
    connectionProfile: undefined.ConnectionProfile;

    /**
     * Provides the host name for the route policy to the special PDP context. 
     */
    hostName: undefined.HostName;

    /**
     * Indicates if the HostName is a suffix or a fully qualified domain name reference. Possible values are defined by DomainNameType . 
     */
    hostNameType: undefined.DomainNameType
}


/**
 * Used to access information specific to a WLAN connection. 
 */
declare class WlanConnectionProfileDetails {

    /**
     * Retrieves the Service Set Identifier (SSID) for a WLAN connection.
     * @return  The service set identifier (SSID).
     */
    getConnectedSsid(): string
}


/**
 * Used to access information specific to a WWAN connection. 
 */
declare class WwanConnectionProfileDetails {

    /**
     * Indicates the name of the access point used to establish the WWAN connection. 
     */
    accessPointName: string;

    /**
     * Indicates the class of data service offered by the network currently in use for the WWAN connection.
     * @return  The class of data service currently provided.
     */
    getCurrentDataClass(): undefined.WwanDataClass;

    /**
     * Retrieves the current network registration state for the WWAN connection.
     * @return  The current network registration state.
     */
    getNetworkRegistrationState(): undefined.WwanNetworkRegistrationState;

    /**
     * Indicates the Home Network Provider ID. 
     */
    homeProviderId: string
}


/**
 * Defines the desired state of the connection profile for which usage data is returned by the method GetNetworkUsageAsync . 
 */
declare interface Connectivity$NetworkUsageStates {

    /**
     * Defines the desired roaming state of the network connection. 
     */
    roaming: undefined.TriStates,

        /**
         * Defines the desired sharing state of the network connection. 
         */
        shared: undefined.TriStates
}


/**
 * Represents the method that handles network status change notifications. This method is called when any properties exposed by the NetworkInformation object changes while the app is active. 
 */
declare type Connectivity$NetworkStatusChangedEventHandler = (ev: Windows$WinRTEvent<any>) => void;


/**
 * Provides data for the local endpoint and remote endpoint for a network connection used by network apps. 
 */
declare class EndpointPair {

    /**
     * Creates a new EndpointPair object.
     * @param localHostName The local hostname or IP address for the EndpointPair object.
     * @param localServiceName The local service name or the local TCP or UDP port number for the EndpointPair object.
     * @param remoteHostName The remote hostname or IP address for the EndpointPair object.
     * @param remoteServiceName The remote service name or the remote TCP or UDP port number for the EndpointPair object.
     */
    constructor(localHostName: undefined.HostName, localServiceName: string, remoteHostName: undefined.HostName, remoteServiceName: string): this;

    /**
     * Get or set the local hostname for the EndpointPair object. 
     */
    localHostName: undefined.HostName;

    /**
     * Get or set the local service name for the EndpointPair object. 
     */
    localServiceName: string;

    /**
     * Get or set the remote hostname for the EndpointPair object. 
     */
    remoteHostName: undefined.HostName;

    /**
     * Get or set the remote service name for the EndpointPair object. 
     */
    remoteServiceName: string
}


/**
 * Provides data for a hostname or an IP address. 
 */
declare class HostName {

    /**
     * Compares two strings to determine if they represent the same hostname.
     * @param value1 A hostname or IP address.
     * @param value2 A hostname or IP address.
     * @return  The return value indicates the lexicographic relation of value1 to value2. If the two parameters represent the same canonical hostname, then zero is returned. If value1 is less than value2, the return value is less than zero. If value1 is greater than value2, the return vale is greater than zero.
     */
    compare(value1: string, value2: string): number;

    /**
     * Creates a new HostName object from a string that contains a hostname or an IP address.
     * @param hostName A string that contains a hostname or an IP address.
     */
    constructor(hostName: string): this;

    /**
     * Gets the canonical name for the HostName object. 
     */
    canonicalName: string;

    /**
     * Gets the display name for the HostName object. 
     */
    displayName: string;

    /**
     * Gets the IPInformation object for a local IP address assigned to a HostName object. 
     */
    ipInformation: undefined.IPInformation;

    /**
     * Determines whether the specified HostName object has an equivalent value to the current HostName object.
     * @param hostName A HostName object that is compared with the current HostName.
     * @return  A Boolean value that indicates whether the specified HostName object is equal to the current HostName object.
     */
    isEqual(hostName: undefined.HostName): boolean;

    /**
     * Gets the original string used to construct the HostName object. 
     */
    rawName: string;

    /**
     * Gets the HostNameType of the HostName object. 
     */
    type: undefined.HostNameType
}


/**
 * Provides the authentication context that contains details of the current authentication attempt and provides methods to perform the authentication. 
 */
declare class HotspotAuthenticationContext {

    /**
     * Gets the context of an authentication attempt.
     * @param evenToken The event token retrieved from the network operator hotspot authentication event . The token is a GUID in string format.
     */
    tryGetAuthenticationContext(
        evenToken: string): {
        context: undefined.HotspotAuthenticationContext,
        returnValue: boolean
    };

    /**
     * Aborts the current authentication attempt and disconnects the WLAN interface from the hotspot.
     * @param markAsManual If true, Windows disables the auto-connect property for the corresponding WLAN profile and avoids future auto-connects to this hotspot. Otherwise, false.
     */
    abortAuthentication(markAsManual: boolean): void;

    /**
     * Gets the HTTPS URL specified in the Wireless Internet Service Provider roaming (WISPr) redirect message. 
     */
    authenticationUrl: undefined.Uri;

    /**
     * Provides credentials to Windows for hotspot authentication
     * @param userName The UserName parameter of the Wireless Internet Service Provider roaming (WISPr) authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
     * @param password The Password parameter of the WISPr authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
     * @param extraParameters Additional parameters to be appended to the authentication string. IssueCredentials appends this parameter after an "&" character to the HTTP POST string as is without any encoding. This can be used to add multiple parameters. The default for this parameter is an empty string.
     * @param markAsManualConnectOnFailure If true, an application permanently disables the auto-connect property on a connection. If authentication fails, the connection will be disconnected and not retried in the current user session. Otherwise, false.
     */
    issueCredentials(
        userName: string,
        password: string,
        extraParameters: string,
        markAsManualConnectOnFailure: boolean): void;

    /**
     * Asynchronously provides credentials to Windows for hotspot authentication Windows does not cache these credentials and another authentication event will be raised when the system connects to the same hotspot again.
     * @param userName The UserName parameter of the Wireless Internet Service Provider roaming (WISPr) authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
     * @param password The Password parameter of the WISPr authentication protocol. IssueCredentials performs URL encoding before submitting the value to the server. If this string is empty, the corresponding authentication parameter is skipped.
     * @param extraParameters Additional parameters to be appended to the authentication string. IssueCredentials appends this parameter after an "&" character to the HTTP POST string as is without any encoding. This can be used to add multiple parameters. The default for this parameter is an empty string.
     * @param markAsManualConnectOnFailure If true, an application permanently disables the auto-connect property on a connection. If authentication fails, the connection will be disconnected and not retried in the current user session. Otherwise, false.
     * @return  Results of the Hotspot authentication request.
     */
    issueCredentialsAsync(
        userName: string,
        password: string,
        extraParameters: string,
        markAsManualConnectOnFailure: boolean): undefined.IPromiseWithIAsyncOperation<undefined.HotspotCredentialsAuthenticationResult>;

    /**
     * Gets the network interface that is connected to the WLAN access point of the hotspot. 
     */
    networkAdapter: undefined.NetworkAdapter;

    /**
     * Gets the URL of the web page where the Wireless Internet Service Provider roaming (WISPr) redirect message was found. 
     */
    redirectMessageUrl: undefined.Uri;

    /**
     * Gets the XML blob of the Wireless Internet Service Provider roaming (WISPr) redirect message of the hotspot. 
     */
    redirectMessageXml: undefined.XmlDocument;

    /**
     * Skips Wireless Internet Service Provider roaming (WISPr) Windows authentication. 
     */
    skipAuthentication(): void;

    /**
     * Called by a background task handler to launch the foreground application when there is an authentication attempt to complete.
     * @param packageRelativeApplicationId The foreground application ID within its application package. The application must belong to the same package as the background task handler.
     * @param applicationParameters Optional command line parameters that are passed to the application at launch.
     */
    triggerAttentionRequired(packageRelativeApplicationId: string, applicationParameters: string): void;

    /**
     * Gets the SSID of the WLAN access point of the hotspot. 
     */
    wirelessNetworkId: number
}


/**
 * Provides the content of the event that is raised for background task handlers for the hotspot authentication event. 
 */
declare class HotspotAuthenticationEventDetails {

    /**
     * Gets a GUID that uniquely identifies the authentication attempt for which this event was raised. 
     */
    eventToken: string
}


/**
 * Represents the results of a Hotspot authentication request. 
 */
declare class HotspotCredentialsAuthenticationResult {

    /**
     * Provides the XML blob containing the WISPr authentication reply message from the server. 
     */
    authenticationReplyXml: undefined.XmlDocument;

    /**
     * Indicates if a network error has occurred that prevented the authentication attempt. If true, the other properties should not be examined. 
     */
    hasNetworkErrorOccurred: boolean;

    /**
     * Provides the most recent Logoff URL as returned from the server in the authentication reply or from an earlier redirect message. If no Logoff URL was provided by the server, this property returns an empty URI. 
     */
    logoffUrl: undefined.Uri;

    /**
     * Provides the WISPr Response Code for the authentication attempt as returned from the server. Possible values are defined by HotspotAuthenticationResponseCode . 
     */
    responseCode: undefined.HotspotAuthenticationResponseCode
}


/**
 * Static class that provides well known CSIM file paths. 
 */
declare class KnownCSimFilePaths {

    /**
     * Static property that gets the EFSPN path. 
     */
    efSpn: undefined.IVectorView<number>;

    /**
     * Static property that gets the GID1 path. 
     */
    gid1: undefined.IVectorView<number>;

    /**
     * Static property that gets the GID2 path. 
     */
    gid2: undefined.IVectorView<number >
}


/**
 * Static class that provides known RUIM file paths. 
 */
declare class KnownRuimFilePaths {

    /**
     * Static property that gets the EFSPN path. 
     */
    efSpn: undefined.IVectorView<number>;

    /**
     * Static property that gets the GID1 path. 
     */
    gid1: undefined.IVectorView<number>;

    /**
     * Static property that gets the GID2 path. 
     */
    gid2: undefined.IVectorView<number >
}


/**
 * Static class that provides known SIM file paths. 
 */
declare class KnownSimFilePaths {

    /**
     * Static property that gets the EFONS path. 
     */
    efOns: undefined.IVectorView<number>;

    /**
     * Static property that gets the EFSPN path. 
     */
    efSpn: undefined.IVectorView<number>;

    /**
     * Static property that gets the GID1 path. 
     */
    gid1: undefined.IVectorView<number>;

    /**
     * Static property that gets the GID2 path. 
     */
    gid2: undefined.IVectorView<number >
}


/**
 * Static class that provides known USIM file paths. 
 */
declare class KnownUSimFilePaths {

    /**
     * Static property that gets the EFOPL path. 
     */
    efOpl: undefined.IVectorView<number>;

    /**
     * Static property that gets the EFPNN path. 
     */
    efPnn: undefined.IVectorView<number>;

    /**
     * Static property that gets the EFSPN path. 
     */
    efSpn: undefined.IVectorView<number>;

    /**
     * Static property that gets the GID1 path. 
     */
    gid1: undefined.IVectorView<number>;

    /**
     * Static property that gets the GID2 path. 
     */
    gid2: undefined.IVectorView<number >
}


/**
 * Represents a mobile broadband account and related information about the network provider for the account. 
 */
declare class MobileBroadbandAccount {

    /**
     * A list of all network account IDs for the network service provider. 
     */
    availableNetworkAccountIds: undefined.IVectorView<string>;

    /**
     * Creates a mobile broadband account for the mobile device associated with the supplied network account ID.
     * @param networkAccountId The network account ID to use to select the corresponding mobile broadband device to use for the account.
     * @return  A mobile broadband account for the mobile device associated with the supplied network account ID.
     */
    createFromNetworkAccountId(networkAccountId: string): undefined.MobileBroadbandAccount;

    /**
     * Gets the mobile broadband device information associated with this account. 
     */
    currentDeviceInformation: undefined.MobileBroadbandDeviceInformation;

    /**
     * Gets the Mobile Broadband network object for this account. 
     */
    currentNetwork: undefined.MobileBroadbandNetwork;

    /**
     * Retrieves an array of ConnectionProfile objects that represent connections associated with the Mobile Broadband account.
     * @return  An array of ConnectionProfile objects.
     */
    getConnectionProfiles(): undefined.IVectorView<undefined.ConnectionProfile>;

    /**
     * Gets a unique identifier for the mobile broadband account. 
     */
    networkAccountId: string;

    /**
     * A unique identifier for the network provider for the mobile broadband account. 
     */
    serviceProviderGuid: string;

    /**
     * The name of the network provider for the mobile broadband account. 
     */
    serviceProviderName: string
}


/**
 * Provides information for the AccountAdded and AccountRemoved events. 
 */
declare class MobileBroadbandAccountEventArgs {

    /**
     * Gets the network account Id that was added or removed. 
     */
    networkAccountId: string
}


/**
 * Provides information for the AccountUpdated event. 
 */
declare class MobileBroadbandAccountUpdatedEventArgs {

    /**
     * Gets a value indicating whether the device information has changed for the account. 
     */
    hasDeviceInformationChanged: boolean;

    /**
     * Gets a value that indicates if the CurrentNetwork was updated for the account. 
     */
    hasNetworkChanged: boolean;

    /**
     * Gets the network account Id of the updated account. 
     */
    networkAccountId: string
}


/**
 * Provides information regarding availability of and updates to Mobile Broadband Accounts. 
 */
declare class MobileBroadbandAccountWatcher {

    /**
     * Creates a new instance of a MobileBroadbandAccountWatcher . 
     */
    constructor(): this;

    /**
     * Occurs when a Mobile Broadband Account is added to the client. 
     */
    onaccountadded: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, undefined.MobileBroadbandAccountEventArgs>;
    addEventListener(
        type: "accountadded",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, undefined.MobileBroadbandAccountEventArgs>): void;
    removeEventListener(
        type: "accountadded",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, undefined.MobileBroadbandAccountEventArgs>): void;

    /**
     * Occurs when a Mobile Broadband Account is removed from the client. 
     */
    onaccountremoved: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, undefined.MobileBroadbandAccountEventArgs>;
    addEventListener(
        type: "accountremoved",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, undefined.MobileBroadbandAccountEventArgs>): void;
    removeEventListener(
        type: "accountremoved",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, undefined.MobileBroadbandAccountEventArgs>): void;

    /**
     * Occurs when a Mobile Broadband Account is updated on the client. 
     */
    onaccountupdated: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, undefined.MobileBroadbandAccountUpdatedEventArgs>;
    addEventListener(
        type: "accountupdated",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, undefined.MobileBroadbandAccountUpdatedEventArgs>): void;
    removeEventListener(
        type: "accountupdated",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, undefined.MobileBroadbandAccountUpdatedEventArgs>): void;

    /**
     * Occurs when the account watcher has finished enumerating accounts for the client. 
     */
    onenumerationcompleted: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, any>;
    addEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, any>): void;
    removeEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, any>): void;

    /**
     * Occurs when the MobileBroadbandAccountWatcher has stopped. 
     */
    onstopped: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, any>;
    addEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, any>): void;
    removeEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandAccountWatcher, any>): void;

    /**
     * Starts the account watcher. 
     */
    start(): void;

    /**
     * Gets the status of the account watcher. 
     */
    status: undefined.MobileBroadbandAccountWatcherStatus;

    /**
     * Stops the account watcher. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents the current state of the mobile broadband network device for the account. 
 */
declare class MobileBroadbandDeviceInformation {

    /**
     * Gets the cellular technology used by the mobile broadband network device. 
     */
    cellularClass: undefined.CellularClass;

    /**
     * Gets a value indicating the radio state of the device. 
     */
    currentRadioState: undefined.MobileBroadbandRadioState;

    /**
     * Gets the name of the data class when the DataClasses property returns Custom. 
     */
    customDataClass: string;

    /**
     * Gets the cellular data services supported by the mobile broadband network device. 
     */
    dataClasses: undefined.DataClasses;

    /**
     * Gets the DeviceInformation Id of the mobile broadband device. 
     */
    deviceId: string;

    /**
     * Gets a value indicating the type of Mobile Broadband device. 
     */
    deviceType: undefined.MobileBroadbandDeviceType;

    /**
     * Gets the device-specific firmware information for the mobile broadband network device. 
     */
    firmwareInformation: string;

    /**
     * Gets the name of the manufacturer of the mobile broadband network device. 
     */
    manufacturer: string;

    /**
     * Gets the value that uniquely identifies the mobile broadband device to the network provider. 
     */
    mobileEquipmentId: string;

    /**
     * Gets the name of the model of the mobile broadband network device. 
     */
    model: string;

    /**
     * Gets the readiness status of the mobile broadband network device. 
     */
    networkDeviceStatus: undefined.NetworkDeviceStatus;

    /**
     * Gets a MobileBroadbandPinManager object for the mobile broadband device. 
     */
    pinManager: undefined.MobileBroadbandPinManager;

    /**
     * Gets the revision of the mobile broadband device. 
     */
    revision: string;

    /**
     * Gets the serial number of the mobile broadband device. 
     */
    serialNumber: string;

    /**
     * Gets the SIM integrated circuit card identifier (ICCID) for the mobile broadband network device. 
     */
    simIccId: string;

    /**
     * Gets the subscriber identifier for the mobile broadband network device. 
     */
    subscriberId: string;

    /**
     * Gets the telephone numbers for the mobile broadband device. 
     */
    telephoneNumbers: undefined.IVectorView<string >
}


/**
 * Represents a mobile broadband device service. 
 */
declare class MobileBroadbandDeviceService {

    /**
     * Gets the unique device service identity for the mobile broadband device service. 
     */
    deviceServiceId: string;

    /**
     * Opens a new MobileBroadbandDeviceServiceCommandSession for the mobile broadband device service.
     * @return  A new command session for the mobile broadband device service.
     */
    openCommandSession(): undefined.MobileBroadbandDeviceServiceCommandSession;

    /**
     * Opens a new MobileBroadbandDeviceServiceDataSession for the mobile broadband device service.
     * @return  A new data session for the Mobile Broadband device service.
     */
    openDataSession(): undefined.MobileBroadbandDeviceServiceDataSession;

    /**
     * Gets a list of supported device service commands for the mobile broadband device service. 
     */
    supportedCommands: undefined.IVectorView<number >
}


/**
 * Represents the result of a mobile broadband device service command. 
 */
declare class MobileBroadbandDeviceServiceCommandResult {

    /**
     * Gets the response data from the command execution on a mobile broadband device service. 
     */
    responseData: undefined.IBuffer;

    /**
     * Gets the status code of the command execution on a mobile broadband device service. 
     */
    statusCode: number
}


/**
 * Represents a device service command session which allows the caller to submit predefined commands to the modem on a mobile broadband device service. 
 */
declare class MobileBroadbandDeviceServiceCommandSession {

    /**
     * Closes the command session on a mobile broadband device service. 
     */
    closeSession(): void;

    /**
     * Starts an asynchronous operation on a mobile broadband device service to send a query command to the command session.
     * @param commandId The command identifier for the query command to be executed.
     * @param data The data to be submitted as part of the command.
     * @return  An asynchronous operation that returns the result of the command.
     */
    sendQueryCommandAsync(
        commandId: number,
        data: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.MobileBroadbandDeviceServiceCommandResult>;

    /**
     * Starts an asynchronous operation on a mobile broadband device service to send a set command to the command session.
     * @param commandId The command identifier for the set command to be executed.
     * @param data The data to be submitted as part of the command.
     * @return  An asynchronous operation that returns the result of the command.
     */
    sendSetCommandAsync(
        commandId: number,
        data: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.MobileBroadbandDeviceServiceCommandResult >
}


/**
 * Provides data for a DataReceived event on a MobileBroadbandDeviceServiceDataSession when data is received . 
 */
declare class MobileBroadbandDeviceServiceDataReceivedEventArgs {

    /**
     * Gets the data received on the MobileBroadbandDeviceServiceDataSession . 
     */
    receivedData: undefined.IBuffer
}


/**
 * Represents a device service data session which allows the caller to write data to the modem on a mobile broadband device service. 
 */
declare class MobileBroadbandDeviceServiceDataSession {

    /**
     * Closes the data session on a mobile broadband device service. 
     */
    closeSession(): void;

    /**
     * An event that indicates that data was received on the MobileBroadbandDeviceServiceDataSession object after the WriteDataAsync method was called. 
     */
    ondatareceived: undefined.TypedEventHandler<undefined.MobileBroadbandDeviceServiceDataSession, undefined.MobileBroadbandDeviceServiceDataReceivedEventArgs>;
    addEventListener(
        type: "datareceived",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandDeviceServiceDataSession, undefined.MobileBroadbandDeviceServiceDataReceivedEventArgs>): void;
    removeEventListener(
        type: "datareceived",
        listener: undefined.TypedEventHandler<undefined.MobileBroadbandDeviceServiceDataSession, undefined.MobileBroadbandDeviceServiceDataReceivedEventArgs>): void;

    /**
     * Starts an asynchronous operation on a mobile broadband device service to write data to the data session.
     * @param value The data to be submitted as part of the write operation.
     * @return  An asynchronous operation that returns the result of the write operation.
     */
    writeDataAsync(value: undefined.IBuffer): undefined.IPromiseWithIAsyncAction;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains information about a mobile broadband device service. 
 */
declare class MobileBroadbandDeviceServiceInformation {

    /**
     * Gets the unique device service identifier for the mobile broadband device. 
     */
    deviceServiceId: string;

    /**
     * Determines if the mobile broadband device service is able to read data. 
     */
    isDataReadSupported: boolean;

    /**
     * Determines if the mobile broadband device service is able to write data. 
     */
    isDataWriteSupported: boolean
}


/**
 * Provides details for a network device service notification. 
 */
declare class MobileBroadbandDeviceServiceTriggerDetails {

    /**
     * Gets the device ID of the device that triggered a broadband device service event. 
     */
    deviceId: string;

    /**
     * Gets the device service identifier for the device service trigger event. 
     */
    deviceServiceId: string;

    /**
     * Gets the received data associated with the triggered event. 
     */
    receivedData: undefined.IBuffer
}


/**
 * Represents a mobile broadband modem. 
 */
declare class MobileBroadbandModem {

    /**
     * Determine if a mobile broadband device is a Wireless WAN device.
     * @param deviceId The mobile broadband device ID
     * @return  The mobile broadband modem.
     */
    fromId(deviceId: string): undefined.MobileBroadbandModem;

    /**
     * Determines the default mobile broadband modem.
     * @return  The mobile broadband modem.
     */
    getDefault(): undefined.MobileBroadbandModem;

    /**
     * Gets a device selector for the mobile broadband modem.
     * @return  A device selector for the mobile broadband modem.
     */
    getDeviceSelector(): string;

    /**
     * Gets the MobileBroadbandAccount associated currently with the mobile broadband modem. 
     */
    currentAccount: undefined.MobileBroadbandAccount;

    /**
     * Gets an object that describes the mobile broadband network that this modem us currently attached to. 
     */
    currentNetwork: undefined.MobileBroadbandNetwork;

    /**
     * Gets the MobileBroadbandDeviceInformation for the mobile broadband modem. 
     */
    deviceInformation: undefined.MobileBroadbandDeviceInformation;

    /**
     * Gets a list of the device services available for the mobile broadband modem. 
     */
    deviceServices: undefined.IVectorView<undefined.MobileBroadbandDeviceServiceInformation>;

    /**
     * Asynchronously retrieves mobile broadband modem configuration information.
     * @return  An asynchronous retrieval operation. On successful completion, contains a MobileBroadbandModemConfiguration object representing the current configuration.
     */
    getCurrentConfigurationAsync(): undefined.IPromiseWithIAsyncOperation<undefined.MobileBroadbandModemConfiguration>;

    /**
     * Gets a specific device service for the mobile broadband modem.
     * @param deviceServiceId The unique device service identifier for the device service to be retrieved.
     * @return  The mobile broadband device service retrieved.
     */
    getDeviceService(deviceServiceId: string): undefined.MobileBroadbandDeviceService;

    /**
     * Gets a value indicating whether the mobile broadband modem allows a reset operation. 
     */
    isResetSupported: boolean;

    /**
     * Gets the maximum device service command size, in bytes, for the mobile broadband modem. 
     */
    maxDeviceServiceCommandSizeInBytes: number;

    /**
     * Gets the maximum device service data size, in bytes, for the mobile broadband modem. 
     */
    maxDeviceServiceDataSizeInBytes: number;

    /**
     * Asynchronously performs a reset operation on the mobile broadband modem.
     * @return  An asynchronous reset operation.
     */
    resetAsync(): undefined.IPromiseWithIAsyncAction
}


/**
 * Contains details about the mobile broadband modem configuration. 
 */
declare class MobileBroadbandModemConfiguration {

    /**
     * Gets the home provider ID associated with the mobile broadband modem. 
     */
    homeProviderId: string;

    /**
     * Gets the home provider name for the mobile broadband modem. 
     */
    homeProviderName: string;

    /**
     * Gets an object representing the Universal Integrated Circuit Card (UICC), commonly called a "SIM card", associated with the mobile broadband modem. 
     */
    uicc: undefined.MobileBroadbandUicc
}


/**
 * Represents a mobile broadband network and the current network state. 
 */
declare class MobileBroadbandNetwork {

    /**
     * The name of the currently connected access point. 
     */
    accessPointName: string;

    /**
     * Attempts to get the latest network activation error. 
     */
    activationNetworkError: number;

    /**
     * Asynchronously retrieves a value indicating whether this network currently supports voice calls.
     * @return  An asynchronous retrieval operation. On successful completion, contains a value indicating whether the network supports voice calls (if true) or not.
     */
    getVoiceCallSupportAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets the unique network interface that identifies the mobile broadband network. 
     */
    networkAdapter: undefined.NetworkAdapter;

    /**
     * Gets the current network registration state. 
     */
    networkRegistrationState: undefined.NetworkRegistrationState;

    /**
     * Gets the latest packet attach network error. 
     */
    packetAttachNetworkError: number;

    /**
     * Gets the data class of the current mobile network. 
     */
    registeredDataClass: undefined.DataClasses;

    /**
     * Gets the provider ID for the currently registered mobile network. 
     */
    registeredProviderId: string;

    /**
     * Gets the provider name for the currently registered mobile network. 
     */
    registeredProviderName: string;

    /**
     * Gets the latest network registration error. 
     */
    registrationNetworkError: number;

    /**
     * Gets a list of all UICC apps available on the SIM card that can be used for registration on a mobile network. This list includes UICC apps that are not currently used for registration, but could potentially could be used for registration. 
     */
    registrationUiccApps: undefined.IVectorView<undefined.MobileBroadbandUiccApp>;

    /**
     * Displays the connect UI for a specific mobile network. 
     */
    showConnectionUI(): void
}


/**
 * Provides details about one network registration state change. 
 */
declare class MobileBroadbandNetworkRegistrationStateChange {

    /**
     * Gets the unique identifier of the device associated with a network registration state change. 
     */
    deviceId: string;

    /**
     * Gets an object which contains details about the network associated with this network state change. 
     */
    network: undefined.MobileBroadbandNetwork
}


/**
 * Provides details for a network registration state change notification. 
 */
declare class MobileBroadbandNetworkRegistrationStateChangeTriggerDetails {

    /**
     * Gets the collection of network registration state changes associated with this notification. 
     */
    networkRegistrationStateChanges: undefined.IVectorView<undefined.MobileBroadbandNetworkRegistrationStateChange >
}


/**
 * Contains the properties and methods associated with a mobile broadband PIN. 
 */
declare class MobileBroadbandPin {

    /**
     * Gets the number of attempts remaining before the mobile broadband PIN is blocked. 
     */
    attemptsRemaining: number;

    /**
     * Starts an asynchronous operation to change an already-enabled mobile broadband PIN.
     * @param currentPin The current mobile broadband PIN.
     * @param newPin The new mobile broadband PIN.
     * @return  An asynchronous operation that returns the result.
     */
    changeAsync(
        currentPin: string,
        newPin: string): undefined.IPromiseWithIAsyncOperation<undefined.MobileBroadbandPinOperationResult>;

    /**
     * Starts an asynchronous operation to disable a previously-enabled mobile broadband PIN.
     * @param currentPin The current mobile broadband PIN.
     * @return  An asynchronous operation that returns the result.
     */
    disableAsync(
        currentPin: string): undefined.IPromiseWithIAsyncOperation<undefined.MobileBroadbandPinOperationResult>;

    /**
     * Starts an asynchronous operation to enable a previously-disabled mobile broadband PIN.
     * @param currentPin The current mobile broadband PIN.
     * @return  An asynchronous operation that returns the result.
     */
    enableAsync(
        currentPin: string): undefined.IPromiseWithIAsyncOperation<undefined.MobileBroadbandPinOperationResult>;

    /**
     * Gets a boolean value that indicates if the mobile broadband PIN is enabled. 
     */
    enabled: boolean;

    /**
     * Starts an asynchronous operation to get the current mobile broadband PIN from the user.
     * @param currentPin The current mobile broadband PIN.
     * @return  An asynchronous operation that returns the result.
     */
    enterAsync(
        currentPin: string): undefined.IPromiseWithIAsyncOperation<undefined.MobileBroadbandPinOperationResult>;

    /**
     * Gets the format for a mobile broadband PIN. 
     */
    format: undefined.MobileBroadbandPinFormat;

    /**
     * Gets the lock state for a mobile broadband PIN. 
     */
    lockState: undefined.MobileBroadbandPinLockState;

    /**
     * Gets the maximum length, in bytes, of the mobile broadband PIN. 
     */
    maxLength: number;

    /**
     * Gets the minimum length, in bytes, of the mobile broadband PIN. 
     */
    minLength: number;

    /**
     * Gets the PIN type for a mobile broadband PIN. 
     */
    type: undefined.MobileBroadbandPinType;

    /**
     * Starts an asynchronous operation to unblock a previously-blocked mobile broadband PIN using a PIN unlock key (PUK).
     * @param pinUnblockKey The PIN unblock key.
     * @param newPin The new mobile broadband PIN.
     * @return  An asynchronous operation that returns the result.
     */
    unblockAsync(
        pinUnblockKey: string,
        newPin: string): undefined.IPromiseWithIAsyncOperation<undefined.MobileBroadbandPinOperationResult >
}


/**
 * Contains details of a PIN lock state change notification. 
 */
declare class MobileBroadbandPinLockStateChange {

    /**
     * Gets the device identifier associated with a PIN lock state change. 
     */
    deviceId: string;

    /**
     * Gets a value representing the new PIN lock state after a PIN lock state change. 
     */
    pinLockState: undefined.MobileBroadbandPinLockState;

    /**
     * Gets a value representing the type of PIN involved in a PIN lock state change. 
     */
    pinType: undefined.MobileBroadbandPinType
}


/**
 * Provides details for a network registration state change notification. 
 */
declare class MobileBroadbandPinLockStateChangeTriggerDetails {

    /**
     * Gets the collection of PIN lock state change details associated with a notification. 
     */
    pinLockStateChanges: undefined.IVectorView<undefined.MobileBroadbandPinLockStateChange >
}


/**
 * Defines the PIN manager for a given mobile broadband modem and SIM Card. 
 */
declare class MobileBroadbandPinManager {

    /**
     * Gets the mobile broadband PIN of a specific PIN type.
     * @param pinType The mobile broadband PIN type.
     * @return  The mobile broadband PIN returned. This value is either provided by the end user or from a cache if allowed. .
     */
    getPin(pinType: undefined.MobileBroadbandPinType): undefined.MobileBroadbandPin;

    /**
     * Gets a list of the supported PIN types for the mobile broadband modem and SIM Card. 
     */
    supportedPins: undefined.IVectorView<undefined.MobileBroadbandPinType >
}


/**
 * Represents the result of a mobile broadband PIN operation. 
 */
declare class MobileBroadbandPinOperationResult {

    /**
     * Gets the number of PIN entry attempts remaining until the mobile broadband PIN is blocked. 
     */
    attemptsRemaining: number;

    /**
     * Gets a value indicating whether the PIN operation was successful. 
     */
    isSuccessful: boolean
}


/**
 * Contains details of a radio state change notification. 
 */
declare class MobileBroadbandRadioStateChange {

    /**
     * Gets the device ID of the device whose radio state changed. 
     */
    deviceId: string;

    /**
     * Gets the new state of the radio. 
     */
    radioState: undefined.MobileBroadbandRadioState
}


/**
 * Provides details for a radio state change notification. 
 */
declare class MobileBroadbandRadioStateChangeTriggerDetails {

    /**
     * Gets the collection of radio state change details associated with a notification. 
     */
    radioStateChanges: undefined.IVectorView<undefined.MobileBroadbandRadioStateChange >
}


/**
 * Represents a Universal Integrated Circuit Card (UICC), normally called a SIM Card on a mobile broadband device. 
 */
declare class MobileBroadbandUicc {

    /**
     * Asynchronously retrieves a list of mobile broadband UICC (SIM card) applications.
     * @return  An asynchronous retrieval operation. On successful completion, returns an object with the results of the retrieval operation.
     */
    getUiccAppsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.MobileBroadbandUiccAppsResult>;

    /**
     * Gets the unique SIM Card identity on a mobile broadband device. 
     */
    simIccId: string
}


/**
 * Represents a UICC (SIM card) application. 
 */
declare class MobileBroadbandUiccApp {

    /**
     * Asynchronously retrieves details about a UICC application.
     * @param uiccFilePath A sequence of characters specifying the UICC file path of the application. Use the MobileBroadbandUiccApp.Id property value of this instance, to get app record details for this application.
     * @return  An asynchronous retrieval operation. On successful completion, returns a MobileBroadbandUiccAppRecordDetailsResult instance initialized for the specified application's details.
     */
    getRecordDetailsAsync(
        uiccFilePath: undefined.IIterable<number>): undefined.IPromiseWithIAsyncOperation<undefined.MobileBroadbandUiccAppRecordDetailsResult>;

    /**
     * Gets the ID of this UICC application. 
     */
    id: undefined.IBuffer;

    /**
     * Gets what kind of UICC application this instance represents. 
     */
    kind: undefined.UiccAppKind;

    /**
     * Asynchronously reads a UICC application record.
     * @param uiccFilePath A sequence of characters specifying the path to the UICC application.
     * @param recordIndex The record index within the UICC application's records.
     * @return  An asynchronous retrieval operation. On successful completion, returns a MobileBroadbandUiccAppReadRecordResult with the result of the operation.
     */
    readRecordAsync(
        uiccFilePath: undefined.IIterable<number>,
        recordIndex: number): undefined.IPromiseWithIAsyncOperation<undefined.MobileBroadbandUiccAppReadRecordResult >
}


/**
 * Encapsulates the results of a UICC application record read operation. 
 */
declare class MobileBroadbandUiccAppReadRecordResult {

    /**
     * Gets the data returned by the application record read operation. Note that if Status is not Success, this value may be invalid or empty. 
     */
    data: undefined.IBuffer;

    /**
     * Gets a value which indicates whether the record read completed successfully. 
     */
    status: undefined.MobileBroadbandUiccAppOperationStatus
}


/**
 * Contains details about results of a UICC application record read operation initiated with MobileBroadbandUiccAppClass.GetRecordDetailsAsync . 
 */
declare class MobileBroadbandUiccAppRecordDetailsResult {

    /**
     * Gets an enumeration value specifying what kind of record this is. 
     */
    kind: undefined.UiccAppRecordKind;

    /**
     * Gets a value specifying how read access to this record is determined. 
     */
    readAccessCondition: undefined.UiccAccessCondition;

    /**
     * Gets the count of this record in the list of records provided by this UICC application. 
     */
    recordCount: number;

    /**
     * Gets the size in bytes of this record. 
     */
    recordSize: number;

    /**
     * Gets the status of the operation to retrieve UICC application record details. If this value is not Success, then other properties might not contain valid values. 
     */
    status: undefined.MobileBroadbandUiccAppOperationStatus;

    /**
     * Gets a value specifying how write access to this record is determined. 
     */
    writeAccessCondition: undefined.UiccAccessCondition
}


/**
 * Reports results of a call to MobileBroadbandUicc.GetUiccAppsAsync . 
 */
declare class MobileBroadbandUiccAppsResult {

    /**
     * Gets the status of the completed MobileBroadbandUicc.GetUiccAppsAsync operation. If this value is not Success, then other properties may not be valid. 
     */
    status: undefined.MobileBroadbandUiccAppOperationStatus;

    /**
     * A list of UICC applications retrieved using MobileBroadbandUicc.GetUiccAppsAsync . Note that this is only valid when Status is Success. 
     */
    uiccApps: undefined.IVectorView<undefined.MobileBroadbandUiccApp >
}


/**
 * Provides details for a network operator notification. 
 */
declare class NetworkOperatorNotificationEventDetails {

    /**
     * Used to indicate if tethering is permitted for a device. If it is not, a reason can be provided.
     * @param allow true if tethering is permitted; otherwise, false.
     * @param entitlementFailureReason The reason tethering is not permitted.
     */
    authorizeTethering(allow: boolean, entitlementFailureReason: string): void;

    /**
     * Gets the data-coding scheme (DCS) of the received message. 
     */
    encodingType: number;

    /**
     * Gets the message for the network operator notification. 
     */
    message: string;

    /**
     * Gets a unique identifier for the mobile broadband account that received the notification. 
     */
    networkAccountId: string;

    /**
     * Gets the type of the network notification. 
     */
    notificationType: undefined.NetworkOperatorEventMessageType;

    /**
     * Gets the identifier of the provisioned rule that matched and triggered the notification. 
     */
    ruleId: string;

    /**
     * Gets an SMS message for the mobile broadband account that received the notification. 
     */
    smsMessage: undefined.ISmsMessage
}


/**
 * Provides the ability to configure and create a NetworkOperatorTetheringAccessPointConfiguration object that contains a specific network account ID (SSID) and specifies the passphrase used to authenticate clients trying to establish a network connection to the tethering network. 
 */
declare class NetworkOperatorTetheringAccessPointConfiguration {

    /**
     * Creates an instance of the NetworkOperatorTetheringAccessPointConfiguration . 
     */
    constructor(): this;

    /**
     * Gets or sets the passphrase used to authenticate the connection. 
     */
    passphrase: string;

    /**
     * Gets or sets the network account ID. 
     */
    ssid: string
}


/**
 * Contains details about a tethering client. 
 */
declare class NetworkOperatorTetheringClient {

    /**
     * Gets a list of hostnames used by this tethering client. 
     */
    hostNames: undefined.IVectorView<undefined.HostName>;

    /**
     * Gets the MAC address of this tethering client. 
     */
    macAddress: string
}


/**
 * This interface exposes the methods and properties used to control and configure tethering capabilities for a specific network account. 
 */
declare class NetworkOperatorTetheringManager {

    /**
     * Creates a NetworkOperatorTetheringManager using the given profile.
     * @param profile Connection profile to be used.
     * @return  The resulting manager object.
     */
    createFromConnectionProfile(
        profile: undefined.ConnectionProfile): undefined.NetworkOperatorTetheringManager;

    /**
     * Creates an instance of NetworkOperatorTetheringManager for a specific network account using the provided network account ID for the mobile broadband device.
     * @param networkAccountId The network account ID.
     * @return  A NetworkOperatorTetheringManager object.
     */
    createFromNetworkAccountId(networkAccountId: string): undefined.NetworkOperatorTetheringManager;

    /**
     * Indicates if a device is capable of creating a tethering network. Possible values are defined by TetheringCapability .
     * @param networkAccountId The network account ID.
     * @return  The tethering capabilities of a network account.
     */
    getTetheringCapability(networkAccountId: string): undefined.TetheringCapability;

    /**
     * Gets tethering capabilities, based on the given connection profile.
     * @param profile Connection profile to be checked.
     * @return  Tethering capabilities of the connection profile.
     */
    getTetheringCapabilityFromConnectionProfile(profile: undefined.ConnectionProfile): undefined.TetheringCapability;

    /**
     * Gets the current number of connected clients on the tethering network. 
     */
    clientCount: number;

    /**
     * Use this method to provide tethering network configuration details for the tethering network.
     * @param configuration Provides a network account ID (SSID) and specifies the passphrase used for authentication when establishing a tethered network connection.
     * @return  The asynchronous action.
     */
    configureAccessPointAsync(
        configuration: undefined.NetworkOperatorTetheringAccessPointConfiguration): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the current access point configuration for a network account as defined by a NetworkOperatorTetheringAccessPointConfiguration object.
     * @return  Indicates the network account id and specifies the pass-phrase used for authentication when establishing a connection over the tethering network.
     */
    getCurrentAccessPointConfiguration(): undefined.NetworkOperatorTetheringAccessPointConfiguration;

    /**
     * Retrieves a list of tethering clients for this NetworkOperatorTetheringManager .
     * @return  A list of clients.
     */
    getTetheringClients(): undefined.IVectorView<undefined.NetworkOperatorTetheringClient>;

    /**
     * Gets the maximum number of client connections over a tethered network. 
     */
    maxClientCount: number;

    /**
     * Establishes the tethering network.
     * @return  The result of the tethering network operation.
     */
    startTetheringAsync(): undefined.IPromiseWithIAsyncOperation<undefined.NetworkOperatorTetheringOperationResult>;

    /**
     * Shuts down the tethering network.
     * @return  The result of the tethering network operation.
     */
    stopTetheringAsync(): undefined.IPromiseWithIAsyncOperation<undefined.NetworkOperatorTetheringOperationResult>;

    /**
     * Gets the current operational state of the tethering feature. Possible values are defined by TetheringOperationalState 
     */
    tetheringOperationalState: undefined.TetheringOperationalState
}


/**
 * Represents the results of a StartTetheringAsync or StopTetheringAsync operation. In addition to the TetheringOperationStatus value, it can include an optional error message string that provides mobile operator specific context to the error. 
 */
declare class NetworkOperatorTetheringOperationResult {

    /**
     * An optional error message string that provides mobile operator specific context to the error. 
     */
    additionalErrorMessage: string;

    /**
     * Indicates the result of a tethering operation. Possible values are defined by TetheringOperationStatus . 
     */
    status: undefined.TetheringOperationStatus
}


/**
 * The results object returned to the application when the provisioning operation has completed. 
 */
declare class ProvisionFromXmlDocumentResults {

    /**
     * Determines whether all elements specified in the provisioning XML were applied. 
     */
    allElementsProvisioned: boolean;

    /**
     * Indicates which elements in the provisioning profile could not be successfully provisioned. 
     */
    provisionResultsXml: string
}


/**
 * Updates cost and usage information for a mobile broadband profile. 
 */
declare class ProvisionedProfile {

    /**
     * Called by the application to update the cost for a specific profile.
     * @param value Updates the cost for the profile.
     */
    updateCost(value: undefined.NetworkCostType): void;

    /**
     * Called by the application to update the usage for a specific profile.
     * @param value Updates the usage for a profile.
     */
    updateUsage(value: undefined.ProfileUsage): void
}


/**
 * Represents an agent that provisions connectivity and subscription information with a network provider. 
 */
declare class ProvisioningAgent {

    /**
     * Creates a provisioning agent for the mobile device associated with the supplied network account ID.
     * @param networkAccountId The network account ID to use to select the corresponding mobile broadband device to use for the provisioning agent.
     * @return  The provisioning agent for the mobile device associated with the supplied network account ID.
     */
    createFromNetworkAccountId(networkAccountId: string): undefined.ProvisioningAgent;

    /**
     * Creates a new instance of a ProvisioningAgent . 
     */
    constructor(): this;

    /**
     * Retrieves cost and plan information associated with the mobile broadband profile.
     * @param mediaType The media type that the profile belongs to.
     * @param profileName The name of the profile that the cost will be applied to.
     * @return  The profile.
     */
    getProvisionedProfile(
        mediaType: undefined.ProfileMediaType,
        profileName: string): undefined.ProvisionedProfile;

    /**
     * Provisions a device for network connectivity asynchronously, based on the supplied XML document.
     * @param provisioningXmlDocument An instance of CarrierControlSchema that contains the network connectivity provisioning information.
     * @return  An asynchronous handler to start the provisioning attempt and track its completion.
     */
    provisionFromXmlDocumentAsync(
        provisioningXmlDocument: string): undefined.IPromiseWithIAsyncOperation<undefined.ProvisionFromXmlDocumentResults >
}


/**
 * Represents a USSD message that is used for sending messages to and receiving messages from the network. 
 */
declare class UssdMessage {

    /**
     * Creates a new instance of a UssdMessage and encodes the supplied string into the message payload.
     * @param messageText The payload for the UssdMessage.
     */
    constructor(messageText: string): this;

    /**
     * Gets or sets the encoding scheme of the payload of this UssdMessage . 
     */
    dataCodingScheme: number;

    /**
     * Gets the raw payload of this UssdMessage .
     * @return  The raw payload of this UssdMessage .
     */
    getPayload(): number[];

    /**
     * Gets or sets the payload of this UssdMessage as text. 
     */
    payloadAsText: string;

    /**
     * Sets the raw payload of this UssdMessage .
     * @param value The raw payload of this UssdMessage .
     */
    setPayload(value: number[]): void
}


/**
 * Represents the network response after sending a USSD message. 
 */
declare class UssdReply {

    /**
     * Gets the message for the USSD response. 
     */
    message: undefined.UssdMessage;

    /**
     * Gets the result code for the USSD response. 
     */
    resultCode: undefined.UssdResultCode
}


/**
 * Represents a session of the USSD network protocol. 
 */
declare class UssdSession {

    /**
     * Creates a USSD session for the mobile device associated with the supplied network account ID.
     * @param networkAccountId The network account ID to use to select the corresponding mobile broadband device to use for the USSD session.
     * @return  The USSD session for the mobile device associated with the supplied network account ID.
     */
    createFromNetworkAccountId(networkAccountId: string): undefined.UssdSession;

    /**
     * Creates a USSD session for the mobile device associated with the supplied network interface ID.
     * @param networkInterfaceId The network interface ID to use to select the corresponding mobile broadband device to use for the USSD session.
     * @return  The USSD session for the mobile device associated with the supplied network interface ID.
     */
    createFromNetworkInterfaceId(networkInterfaceId: string): undefined.UssdSession;

    /**
     * Closes the USSD session with the network. 
     */
    close(): void;

    /**
     * Sends a message to a USSD session and returns a handler to retrieve the reply asynchronously.
     * @param message The message to send to the USSD session.
     * @return  An asynchronous handler to retrieve the USSD response to the sent message.
     */
    sendMessageAndGetReplyAsync(
        message: undefined.UssdMessage): undefined.IPromiseWithIAsyncOperation<undefined.UssdReply >
}


/**
 * Used to update the usage of plan data. 
 */
declare interface NetworkOperators$ProfileUsage {

    /**
     * The last time UsageInMegabytes was updated. 
     */
    lastSyncTime: Date,

        /**
         * Updates the usage in megabytes. 
         */
        usageInMegabytes: number
}


/**
 * Contains properties that are passed to an application with the ConnectionRequested event. 
 */
declare class ConnectionRequestedEventArgs {

    /**
     * Gets the information for a peer that's requesting a connection. 
     */
    peerInformation: undefined.PeerInformation
}


/**
 * Enables you to discover other instances of your app on nearby devices and create a socket connection between the peer apps by using a tap gesture or by browsing. For creating Bluetooth socket connections on Windows 8.1 and later, use Windows.Devices.Bluetooth.Rfcomm instead. 
 */
declare class PeerFinder {

    /**
     * Specifies whether the PeerFinder class may connect a StreamSocket object by using Bluetooth. 
     */
    allowBluetooth: boolean;

    /**
     * Specifies whether the PeerFinder class may connect to a StreamSocket object using TCP/IP. 
     */
    allowInfrastructure: boolean;

    /**
     * Specifies whether the PeerFinder class may connect a StreamSocket object by using Wi-Fi Direct. 
     */
    allowWiFiDirect: boolean;

    /**
     * Gets a list of alternate appId values to match with peer applications on other platforms. 
     */
    alternateIdentities: undefined.IMap<string, string>;

    /**
     * Connects to a peer discovered by a call to the FindAllPeersAsync method.
     * @param peerInformation A peer information object representing the peer to connect to.
     * @return  An asynchronous operation for connecting to a remote peer using the supplied StreamSocket object.
     */
    connectAsync(
        peerInformation: undefined.PeerInformation): undefined.IPromiseWithIAsyncOperation<undefined.StreamSocket>;

    /**
     * Creates a new instance of a PeerWatcher object for dynamic discovery of peer apps.
     * @return  An instance of a PeerWatcher object for dynamic discovery of peer apps.
     */
    createWatcher(): undefined.PeerWatcher;

    /**
     * Gets or sets user or device data to include during device discovery. 
     */
    discoveryData: undefined.IBuffer;

    /**
     * Gets or sets the name that identifies your computer to remote peers. 
     */
    displayName: string;

    /**
     * Asynchronously browses for peer devices that are running the same app within wireless range.
     * @return  The asynchronous operation for browsing for peer devices that are running your app.
     */
    findAllPeersAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Occurs when a remote peer requests a connection using the ConnectAsync method. 
     */
    onconnectionrequested: undefined.TypedEventHandler<any, undefined.ConnectionRequestedEventArgs>;
    addEventListener(
        type: "connectionrequested",
        listener: undefined.TypedEventHandler<any, undefined.ConnectionRequestedEventArgs>): void;
    removeEventListener(
        type: "connectionrequested",
        listener: undefined.TypedEventHandler<any, undefined.ConnectionRequestedEventArgs>): void;

    /**
     * Occurs during a tap gesture from a remote peer. 
     */
    ontriggeredconnectionstatechanged: undefined.TypedEventHandler<any, undefined.TriggeredConnectionStateChangedEventArgs>;
    addEventListener(
        type: "triggeredconnectionstatechanged",
        listener: undefined.TypedEventHandler<any, undefined.TriggeredConnectionStateChangedEventArgs>): void;
    removeEventListener(
        type: "triggeredconnectionstatechanged",
        listener: undefined.TypedEventHandler<any, undefined.TriggeredConnectionStateChangedEventArgs>): void;

    /**
     * Gets or sets the role of the app in peer-to-peer connections. 
     */
    role: undefined.PeerRole;

    /**
     * Makes an app discoverable to remote peers.
     * @param peerMessage The message to deliver to the proximate device.
     */
    start(peerMessage: string): void;

    /**
     * Makes an app discoverable to remote peers. 
     */
    start(): void;

    /**
     * Stops advertising for a peer connection. 
     */
    stop(): void;

    /**
     * Gets a value that indicates which discovery options are available to use with the PeerFinder class. 
     */
    supportedDiscoveryTypes: undefined.PeerDiscoveryTypes;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains information that identifies a peer. 
 */
declare class PeerInformation {

    /**
     * Gets the device data included during device discovery. 
     */
    discoveryData: undefined.IBuffer;

    /**
     * Gets the display name of the peer. 
     */
    displayName: string;

    /**
     * Gets the hostname or IP address of the peer. 
     */
    hostName: undefined.HostName;

    /**
     * Gets the app id for the peer app. 
     */
    id: string;

    /**
     * Gets the service name or TCP port number of the peer. 
     */
    serviceName: string
}


/**
 * Dynamically discovers peer apps within wireless range. 
 */
declare class PeerWatcher {

    /**
     * Occurs when a peer app is found within wireless range. 
     */
    onadded: undefined.TypedEventHandler<undefined.PeerWatcher, undefined.PeerInformation>;
    addEventListener(
        type: "added",
        listener: undefined.TypedEventHandler<undefined.PeerWatcher, undefined.PeerInformation>): void;
    removeEventListener(
        type: "added",
        listener: undefined.TypedEventHandler<undefined.PeerWatcher, undefined.PeerInformation>): void;

    /**
     * Occurs after a scan operation is complete and all peer apps within wireless range have been found. 
     */
    onenumerationcompleted: undefined.TypedEventHandler<undefined.PeerWatcher, any>;
    addEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.PeerWatcher, any>): void;
    removeEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.PeerWatcher, any>): void;

    /**
     * Occurs when a peer app is no longer within wireless range. 
     */
    onremoved: undefined.TypedEventHandler<undefined.PeerWatcher, undefined.PeerInformation>;
    addEventListener(
        type: "removed",
        listener: undefined.TypedEventHandler<undefined.PeerWatcher, undefined.PeerInformation>): void;
    removeEventListener(
        type: "removed",
        listener: undefined.TypedEventHandler<undefined.PeerWatcher, undefined.PeerInformation>): void;

    /**
     * Occurs when the PeerWatcher object has been stopped. 
     */
    onstopped: undefined.TypedEventHandler<undefined.PeerWatcher, any>;
    addEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.PeerWatcher, any>): void;
    removeEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.PeerWatcher, any>): void;

    /**
     * Occurs when the DisplayName or DiscoveryData for a peer app within wireless range has changed. 
     */
    onupdated: undefined.TypedEventHandler<undefined.PeerWatcher, undefined.PeerInformation>;
    addEventListener(
        type: "updated",
        listener: undefined.TypedEventHandler<undefined.PeerWatcher, undefined.PeerInformation>): void;
    removeEventListener(
        type: "updated",
        listener: undefined.TypedEventHandler<undefined.PeerWatcher, undefined.PeerInformation>): void;

    /**
     * Begin dynamically searching for peer apps within wireless range. 
     */
    start(): void;

    /**
     * Gets the current state of the PeerWatcher object. 
     */
    status: undefined.PeerWatcherStatus;

    /**
     * Stop dynamically searching for peer apps within wireless range. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Enables you to publish messages to proximate devices or subscribe to messages from proximate devices. 
 */
declare class ProximityDevice {

    /**
     * Creates an instance of a ProximityDevice class and activates the specified proximity device interface.
     * @param deviceId The DeviceInformation Id of a proximity device.
     * @return  A new ProximityDevice that uses the specified proximity device interface. Throws a System.IO.FileNotFoundException exception if the specified proximity device interface isunavailable.
     */
    fromId(deviceId: string): undefined.ProximityDevice;

    /**
     * Creates an instance of a ProximityDevice class and activates the default proximity provider.
     * @return  A new proximity device that uses the default proximity provider. Returns NULL if no proximity devices are installed.
     */
    getDefault(): undefined.ProximityDevice;

    /**
     * Returns the class selection string that you can use to enumerate proximity devices.
     * @return  The class selection string for proximity devices.
     */
    getDeviceSelector(): string;

    /**
     * Gets the transfer rate of a proximity device. 
     */
    bitsPerSecond: number;

    /**
     * Gets the DeviceInformation Id for a proximity device. 
     */
    deviceId: string;

    /**
     * Gets the maximum size of a published message that this proximity device supports. 
     */
    maxMessageBytes: number;

    /**
     * Occurs when a device enters the proximate range. 
     */
    ondevicearrived: undefined.DeviceArrivedEventHandler;
    addEventListener(type: "devicearrived", listener: undefined.DeviceArrivedEventHandler): void;
    removeEventListener(type: "devicearrived", listener: undefined.DeviceArrivedEventHandler): void;

    /**
     * Occurs when a device leaves the proximate range. 
     */
    ondevicedeparted: undefined.DeviceDepartedEventHandler;
    addEventListener(type: "devicedeparted", listener: undefined.DeviceDepartedEventHandler): void;
    removeEventListener(type: "devicedeparted", listener: undefined.DeviceDepartedEventHandler): void;

    /**
     * Publishes a message that contains binary data to subscribers of the specified message type.
     * @param messageType The type of message to deliver to subscribers.
     * @param message The binary message data to deliver to subscribers.
     * @return  A unique publication ID for the published message.
     */
    publishBinaryMessage(messageType: string, message: undefined.IBuffer): number;

    /**
     * Publishes a message that contains binary data to subscribers of the specified message type. The specified handler is called when the message has been transmitted.
     * @param messageType The type of message to deliver to subscribers.
     * @param message The binary message data to deliver to subscribers.
     * @param messageTransmittedHandler The handler to call when the message has been transmitted.
     * @return  A unique publication ID for the published message.
     */
    publishBinaryMessage(
        messageType: string,
        message: undefined.IBuffer,
        messageTransmittedHandler: undefined.MessageTransmittedHandler): number;

    /**
     * Publishes a message to subscribers of the specified message type.
     * @param messageType The type of message to deliver to subscribers.
     * @param message The message to deliver to subscribers.
     * @return  A unique publication ID for the published message. Pass this value to the StopPublishingMessage method to stop publishing the message.
     */
    publishMessage(messageType: string, message: string): number;

    /**
     * Publishes a message to subscribers of the specified message type. The specified handler is called when the message has been transmitted.
     * @param messageType The type of message to deliver to subscribers.
     * @param message The message to deliver to subscribers.
     * @param messageTransmittedHandler The handler to call when the message has been transmitted.
     * @return  A unique publication ID for the published message.
     */
    publishMessage(
        messageType: string,
        message: string,
        messageTransmittedHandler: undefined.MessageTransmittedHandler): number;

    /**
     * Publishes a Uniform Resource Identifier (URI) to a proximate device. The specified handler is called when the message has been transmitted.
     * @param message The URI to publish.
     * @param messageTransmittedHandler The handler to call when the message has been transmitted.
     * @return  The publication ID of the message.
     */
    publishUriMessage(
        message: undefined.Uri,
        messageTransmittedHandler: undefined.MessageTransmittedHandler): number;

    /**
     * Publishes a Uniform Resource Identifier (URI) to a proximate device.
     * @param message The URI to publish.
     * @return  The publication ID of the message.
     */
    publishUriMessage(message: undefined.Uri): number;

    /**
     * Stops publishing a message.
     * @param messageId The publication ID for the message.
     */
    stopPublishingMessage(messageId: number): void;

    /**
     * Cancels a message subscription.
     * @param subscriptionId The subscription ID for the message.
     */
    stopSubscribingForMessage(subscriptionId: number): void;

    /**
     * Creates a subscription for a specified message type.
     * @param messageType The type of message to deliver to this subscription.
     * @param messageReceivedHandler The handler that the proximity provider will call when it delivers a message.
     * @return  A unique ID for the subscription.
     */
    subscribeForMessage(
        messageType: string,
        messageReceivedHandler: undefined.MessageReceivedHandler): number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a message that's received from a subscription. 
 */
declare class ProximityMessage {

    /**
     * Gets the binary data of the message. 
     */
    data: undefined.IBuffer;

    /**
     * Gets the message data as text. 
     */
    dataAsString: string;

    /**
     * Gets the type of the message. 
     */
    messageType: string;

    /**
     * Gets the subscription ID of the message. 
     */
    subscriptionId: number
}


/**
 * Contains properties that the TriggeredConnectionStateChanged event passes to an application. 
 */
declare class TriggeredConnectionStateChangedEventArgs {

    /**
     * Gets the unique identifier for the connection in progress. 
     */
    id: number;

    /**
     * Gets the StreamSocket instance for the connection. 
     */
    socket: undefined.StreamSocket;

    /**
     * Gets the state of the connection in progress. 
     */
    state: undefined.TriggeredConnectState
}


/**
 * Describes the method that handles the DeviceArrived event. 
 */
declare type Proximity$DeviceArrivedEventHandler = (ev: Windows$WinRTEvent<undefined.ProximityDevice>) => void;


/**
 * Describes the method that handles the DeviceDeparted event. 
 */
declare type Proximity$DeviceDepartedEventHandler = (ev: Windows$WinRTEvent<undefined.ProximityDevice>) => void;


/**
 * Describes the method that will handle the event that's fired when a published message has been transmitted. 
 */
declare type Proximity$MessageTransmittedHandler = (sender: undefined.ProximityDevice, messageId: number) => void;


/**
 * Describes the method that will handle the event that's fired when a message that has been subscribed to has been received. 
 */
declare type Proximity$MessageReceivedHandler = (sender: undefined.ProximityDevice, message: undefined.ProximityMessage) => void;


/**
 * Represents a delivery vehicle and addressing mechanism for push notifications. The channel Uniform Resource Identifier (URI) represented by this interface is used by a third-party application server to communicate with the Windows Push Notification Services (WNS). The push notification channel is used by the client to intercept notifications. 
 */
declare class PushNotificationChannel {

    /**
     * Explicitly invalidates this channel. Any notifications pushed to this channel after this method is called are not delivered. 
     */
    close(): void;

    /**
     * Gets the time at which the channel expires. Notifications sent to this channel after this time are rejected. 
     */
    expirationTime: Date;

    /**
     * Fires when a push notification has arrived on this channel. 
     */
    onpushnotificationreceived: undefined.TypedEventHandler<undefined.PushNotificationChannel, undefined.PushNotificationReceivedEventArgs>;
    addEventListener(
        type: "pushnotificationreceived",
        listener: undefined.TypedEventHandler<undefined.PushNotificationChannel, undefined.PushNotificationReceivedEventArgs>): void;
    removeEventListener(
        type: "pushnotificationreceived",
        listener: undefined.TypedEventHandler<undefined.PushNotificationChannel, undefined.PushNotificationReceivedEventArgs>): void;

    /**
     * Gets the Uniform Resource Identifier (URI) to which an app server sends a push notification intended for an application or secondary tile bound to this channel. This URI is transmitted to and stored by the third-party app server. 
     */
    uri: string;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Creates objects that you use to retrieve push notification channels from the Windows Push Notification Services (WNS). These channels are bound to an app or secondary tile . 
 */
declare class PushNotificationChannelManager {

    /**
     * Creates an object, bound to a specified app, through which you retrieve a push notification channel from Windows Push Notification Services (WNS). The specified app must be in the same package as the calling app.
     * @param applicationId The Package Relative Application ID (PRAID) of the app to bind to the push notification channel.
     * @return  The object, bound to the app specified in applicationId, that is used to request a PushNotificationChannel from the WNS.
     */
    createPushNotificationChannelForApplicationAsync(
        applicationId: string): undefined.IPromiseWithIAsyncOperation<undefined.PushNotificationChannel>;

    /**
     * Creates an object, bound to the calling app, through which you retrieve a push notification channel from Windows Push Notification Services (WNS).
     * @return  The object, bound to the calling app, that is used to request a PushNotificationChannel from the WNS.
     */
    createPushNotificationChannelForApplicationAsync(): undefined.IPromiseWithIAsyncOperation<undefined.PushNotificationChannel>;

    /**
     * Creates an object, bound to a secondary tile , through which you retrieve a push notification channel from Windows Push Notification Services (WNS). The tile can be a secondary tile of the calling app or any other app in the same package.
     * @param tileId The ID of the secondary tile to bind to the push notification channel.
     * @return  The object, bound to the secondary tile, that is used to request a PushNotificationChannel from the WNS.
     */
    createPushNotificationChannelForSecondaryTileAsync(
        tileId: string): undefined.IPromiseWithIAsyncOperation<undefined.PushNotificationChannel >
}


/**
 * Encapsulates a push notification that has been received from the app server, identifying the type and supplying the content of the notification. Windows passes this information in the PushNotificationReceived event. 
 */
declare class PushNotificationReceivedEventArgs {

    /**
     * Gets the content of a badge update to perform in response to this push notification. 
     */
    badgeNotification: undefined.BadgeNotification;

    /**
     * Gets or sets whether Windows should perform its default handling of the notification. 
     */
    cancel: boolean;

    /**
     * Gets the type of push notification that has been received from the app server. 
     */
    notificationType: undefined.PushNotificationType;
    rawNotification: any;

    /**
     * Gets the content of a tile update to perform in response to this push notification. 
     */
    tileNotification: undefined.TileNotification;

    /**
     * Gets the content of a toast to display in response to this push notification. 
     */
    toastNotification: undefined.ToastNotification
}


/**
 * Encapsulates the app-defined content of a raw notification (a push notification that does not involve UI). Its contents can be used in an app's background task, if the app has that capability, or otherwise consumed by the app and acted on as needed. 
 */
declare class RawNotification {

    /**
     * Gets the content of the raw notification as a string. This string specifies a background task associated with the app. 
     */
    content: string
}


/**
 * Encapsulates detailed information about the result of an attempt to register a service instance using DNS-SD. 
 */
declare class DnssdRegistrationResult {

    /**
     * Constructor. 
     */
    constructor(): this;

    /**
     * Indicates whether the instance name was changed in the course of the registration process. 
     */
    hasInstanceNameChanged: boolean;

    /**
     * The IP address of the successfully-created service instance. 
     */
    ipAddress: undefined.HostName;

    /**
     * An enumeration value indicating the result of a service instance registration attempt. 
     */
    status: undefined.DnssdRegistrationStatus
}


/**
 * Encapsulates an instance of a service that uses DNS Service Discovery (DNS-SD). 
 */
declare class DnssdServiceInstance {

    /**
     * Creates a new DnssdServiceInstance object with the specified instance name, host name, and port.
     * @param DnssdServiceInstanceName The service instance name for the service instance being created.
     * @param hostName The hostname for the service instance being created.
     * @param port The port number for the service instance being created.
     */
    constructor(DnssdServiceInstanceName: string, hostName: undefined.HostName, port: number): this;

    /**
     * Gets or sets the DNS-SD service instance name for this DnssdServiceInstance . 
     */
    dnssdServiceInstanceName: string;

    /**
     * Gets or sets the hostname of the host for this DnssdServiceInstance . 
     */
    hostName: undefined.HostName;

    /**
     * Gets or sets the port number used by this DnssdServiceInstance . 
     */
    port: number;

    /**
     * Gets or sets the priority value to assign to this service instance, as defined in RFC 2782. Clients use Priority to decide which of several equivalent service instances to attach to. 
     */
    priority: number;

    /**
     * Asynchronously registers a datagram (UDP) socket listener for the service, on a given socket and network adapter.
     * @param socket Describes the socket that this service instance uses to listen for new service clients.
     * @param adapter Specifies the network adapter this service uses to listen for new service clients.
     * @return  On successful completion of the asynchronous operation, returns an object describing the results of registration.
     */
    registerDatagramSocketAsync(
        socket: undefined.DatagramSocket,
        adapter: undefined.NetworkAdapter): undefined.IPromiseWithIAsyncOperation<undefined.DnssdRegistrationResult>;

    /**
     * Asynchronously registers a datagram (UDP) socket listener for the service, on a given socket.
     * @param socket Describes the socket that this service instance uses to listen for new service clients.
     * @return  On successful completion of the asynchronous operation, returns an object describing the results of registration.
     */
    registerDatagramSocketAsync(
        socket: undefined.DatagramSocket): undefined.IPromiseWithIAsyncOperation<undefined.DnssdRegistrationResult>;

    /**
     * Asynchronously registers a stream (TCP) socket listener for the service, on the given socket and network adapter.
     * @param socket Describes the socket that this service instance uses to listen for new service clients.
     * @param adapter Specifies the network adapter this service uses to listen for new service clients.
     * @return  On successful completion of the asynchronous operation, returns an object describing the results of registration.
     */
    registerStreamSocketListenerAsync(
        socket: undefined.StreamSocketListener,
        adapter: undefined.NetworkAdapter): undefined.IPromiseWithIAsyncOperation<undefined.DnssdRegistrationResult>;

    /**
     * Asynchronously registers a stream (TCP) socket listener for the service, on the given socket.
     * @param socket Describes the socket that this service instance uses to listen for new service clients.
     * @return  On successful completion of the asynchronous operation, returns an object describing the results of registration.
     */
    registerStreamSocketListenerAsync(
        socket: undefined.StreamSocketListener): undefined.IPromiseWithIAsyncOperation<undefined.DnssdRegistrationResult>;

    /**
     * Gets the attributes of this service instance, as a list of [name, value] pairs of strings. Attributes can be inspected by service clients to determine additional information about a service instance. 
     */
    textAttributes: undefined.IMap<string, string>;

    /**
     * Gets or sets the weight value assigned to this service instance, as defined in RFC 2782. Clients use the Weight value to choose between servers with the same Priority value. 
     */
    weight: number
}


/**
 * A collection of DNS Service Discovery (DNS-SD) service instances. 
 */
declare class DnssdServiceInstanceCollection mixins Array<undefined.DnssdServiceInstance>{

    /**
     * Gets an iterator that is initialized to refer to the first item in the instance collection.
     * @return  Gets an iterator instance initialized to the first item in the service instance collection. Your code can use this iterator to enumerate all members of the collection.
     */
    first(): undefined.IIterator<undefined.DnssdServiceInstance>;

    /**
     * Gets the DnssdServiceInstance at a given index into the DnssdServiceInstanceCollection .
     * @param index The index of the instance to be retrieved. Indices are 0-based. If your code specifies an index that is out of bounds, an exception is thrown. The maximum valid index is equal to one less than the DnssdServiceInstanceCollection.Size value.
     * @return  The DnssdServiceInstance at the given index in the collection.
     */
    getAt(index: number): undefined.DnssdServiceInstance;

    /**
     * Gets multiple DnssdServiceInstance objects from a DNS-SD service instance collection.
     * @param startIndex Index of the first collection item to be retrieved.
     */
    getMany(
        startIndex: number): {
        items: undefined.DnssdServiceInstance,
        returnValue: number
    };

    /**
     * Gets a value indicating whether a given DnssdServiceInstance is at the specified index in this service instance collection.
     * @param value The DnssdServiceInstance to get the index of.
     */
    indexOf(value: undefined.DnssdServiceInstance): {
        index: number,
        returnValue: boolean
    };

    /**
     * Gets the number of items in the collection 
     */
    size: number;
    indexOf(
        value: undefined.DnssdServiceInstance,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.DnssdServiceInstance, fromIndex?: number): number
}


/**
 * Maintains a collection of available DNS Service Discovery (DNS-SD) service instances. 
 */
declare class DnssdServiceWatcher {

    /**
     * Event that is triggered when a DnssdServiceWatcher has added a DNS Service Discovery (DNS-SD) instance to its collection of available service instances. 
     */
    onadded: undefined.TypedEventHandler<undefined.DnssdServiceWatcher, undefined.DnssdServiceInstance>;
    addEventListener(
        type: "added",
        listener: undefined.TypedEventHandler<undefined.DnssdServiceWatcher, undefined.DnssdServiceInstance>): void;
    removeEventListener(
        type: "added",
        listener: undefined.TypedEventHandler<undefined.DnssdServiceWatcher, undefined.DnssdServiceInstance>): void;

    /**
     * Event triggered when a DnssdServiceWatcher has finished enumerating available DNS Service Discovery (DNS-SD) service instances. 
     */
    onenumerationcompleted: undefined.TypedEventHandler<undefined.DnssdServiceWatcher, any>;
    addEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.DnssdServiceWatcher, any>): void;
    removeEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.DnssdServiceWatcher, any>): void;

    /**
     * Event triggered when an in-progress enumeration has been stopped. 
     */
    onstopped: undefined.TypedEventHandler<undefined.DnssdServiceWatcher, any>;
    addEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.DnssdServiceWatcher, any>): void;
    removeEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.DnssdServiceWatcher, any>): void;

    /**
     * Starts an enumeration of the network for available DNS Service Discovery (DNS-SD) service instances. 
     */
    start(): void;

    /**
     * Gets the current status of the DnssdServiceWatcherStatus . 
     */
    status: undefined.DnssdServiceWatcherStatus;

    /**
     * Stops an in-progress enumeration of available DNS Service Discovery (DNS-SD) service instances. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Supports network communication using a UDP datagram socket. 
 */
declare class DatagramSocket {

    /**
     * Gets a list of EndpointPair objects based on a remote hostname and remote service name and the sort order to be used.
     * @param remoteHostName The remote hostname or IP address.
     * @param remoteServiceName The remote service name or UDP port.
     * @param sortOptions The sort order to use when returning the list.
     * @return  A list of EndpointPair objects.
     */
    getEndpointPairsAsync(
        remoteHostName: undefined.HostName,
        remoteServiceName: string,
        sortOptions: undefined.HostNameSortOptions): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets a list of EndpointPair objects based on a remote hostname and remote service name that can be used to send datagrams to a remote network destination.
     * @param remoteHostName The remote hostname or IP address.
     * @param remoteServiceName The remote service name or UDP port.
     * @return  A list of EndpointPair objects.
     */
    getEndpointPairsAsync(
        remoteHostName: undefined.HostName,
        remoteServiceName: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Creates a new DatagramSocket object. 
     */
    constructor(): this;

    /**
     * Starts a bind operation on a DatagramSocket to a local hostname and a local service name.
     * @param localHostName The local hostname or IP address on which to bind the DatagramSocket object.
     * @param localServiceName The local service name or UDP port on which to bind the DatagramSocket object.
     * @return  An asynchronous bind operation on a DatagramSocket object.
     */
    bindEndpointAsync(
        localHostName: undefined.HostName,
        localServiceName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts a bind operation on a DatagramSocket to a local service name.
     * @param localServiceName The local service name or UDP port on which to bind the DatagramSocket object.
     * @return  An asynchronous bind operation on a DatagramSocket object.
     */
    bindServiceNameAsync(localServiceName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts a bind operation on a DatagramSocket to a local service name and specific network interface.
     * @param localServiceName The local service name or UDP port on which to bind the DatagramSocket object.
     * @param adapter The network adapter on which to bind the DatagramSocket object.
     * @return  An asynchronous bind operation on a DatagramSocket object.
     */
    bindServiceNameAsync(
        localServiceName: string,
        adapter: undefined.NetworkAdapter): undefined.IPromiseWithIAsyncAction;

    /**
     * Cancels pending reads and writes over a DatagramSocket object.
     * @return  An asynchronous cancel operation on a DatagramSocket object.
     */
    cancelIOAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Closes the DatagramSocket object and aborts any pending operation on the DatagramSocket. 
     */
    close(): void;

    /**
     * Starts a connect operation on a DatagramSocket to a remote destination specified by a remote hostname and a remote service name.
     * @param remoteHostName The hostname or IP address of the remote network destination.
     * @param remoteServiceName The service name or UDP port of the remote network destination.
     * @return  An asynchronous connect operation on a DatagramSocket object.
     */
    connectAsync(
        remoteHostName: undefined.HostName,
        remoteServiceName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts a connect operation on a DatagramSocket to a remote network destination specified as an EndpointPair object.
     * @param endpointPair An EndpointPair object that specifies local hostname or IP address, local service name or UDP port, the remote hostname or remote IP address, and the remote service name or remote UDP port for the remote network destination.
     * @return  An asynchronous connect operation on a DatagramSocket object.
     */
    connectAsync(endpointPair: undefined.EndpointPair): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets socket control data on a DatagramSocket object. 
     */
    control: undefined.DatagramSocketControl;

    /**
     * Enables your app's background task to be triggered by the socket broker when traffic for this DatagramSocket arrives while the app is not active.
     * @param taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this DatagramSocket .
     */
    enableTransferOwnership(taskId: string): void;

    /**
     * Enables your app's background task to be triggered by the socket broker when traffic for this DatagramSocket arrives while the system is in connected standby.
     * @param taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this DatagramSocket .
     * @param connectedStandbyAction Specifies whether to enable or disable the activation of the background task when traffic arrives.
     */
    enableTransferOwnership(
        taskId: string,
        connectedStandbyAction: undefined.SocketActivityConnectedStandbyAction): void;

    /**
     * Starts an operation to get an IOutputStream to a remote destination specified by a remote hostname and a remote service name that can then be used to send network data.
     * @param remoteHostName The remote hostname or remote IP address.
     * @param remoteServiceName The remote service name or remote UDP port.
     * @return  An IOutputStream that representing the asynchronous operation.
     */
    getOutputStreamAsync(
        remoteHostName: undefined.HostName,
        remoteServiceName: string): undefined.IPromiseWithIAsyncOperation<undefined.IOutputStream>;

    /**
     * Starts an operation to get an IOutputStream to a remote network destination specified by an EndpointPair object that can then be used to send network data.
     * @param endpointPair An endpoint pair that represents the local hostname or local IP address, the local service name or local UDP port, the remote hostname or remote IP address, and the remote service name or remote UDP port.
     * @return  An IOutputStream that represents the asynchronous operation.
     */
    getOutputStreamAsync(
        endpointPair: undefined.EndpointPair): undefined.IPromiseWithIAsyncOperation<undefined.IOutputStream>;

    /**
     * Gets socket information on the local and remote hostnames and local and remote service names for the DatagramSocket object. 
     */
    information: undefined.DatagramSocketInformation;

    /**
     * Joins a DatagramSocket object to a multicast group.
     * @param host The hostname or IP address for the multicast group.
     */
    joinMulticastGroup(host: undefined.HostName): void;

    /**
     * An event that indicates that a message was received on the DatagramSocket object. 
     */
    onmessagereceived: undefined.TypedEventHandler<undefined.DatagramSocket, undefined.DatagramSocketMessageReceivedEventArgs>;
    addEventListener(
        type: "messagereceived",
        listener: undefined.TypedEventHandler<undefined.DatagramSocket, undefined.DatagramSocketMessageReceivedEventArgs>): void;
    removeEventListener(
        type: "messagereceived",
        listener: undefined.TypedEventHandler<undefined.DatagramSocket, undefined.DatagramSocketMessageReceivedEventArgs>): void;

    /**
     * Gets the output stream to write to the remote host. 
     */
    outputStream: undefined.IOutputStream;

    /**
     * Transfers ownership of the DatagramSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
     * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
     */
    transferOwnership(socketId: string): void;

    /**
     * Transfers ownership of the DatagramSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
     * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
     * @param data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
     */
    transferOwnership(socketId: string, data: undefined.SocketActivityContext): void;

    /**
     * Transfers ownership of the DatagramSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
     * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
     * @param data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
     * @param keepAliveTime How long the socket brokering service should monitor the socket for activity.
     */
    transferOwnership(
        socketId: string,
        data: undefined.SocketActivityContext,
        keepAliveTime: number): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides socket control data on a DatagramSocket object. 
 */
declare class DatagramSocketControl {

    /**
     * Gets or sets a Boolean value that specifies whether the DatagramSocket allows IP datagrams for UDP to be fragmented. 
     */
    dontFragment: boolean;

    /**
     * Gets or sets the size, in bytes, of the buffer used for receiving data on the DatagramSocket object. 
     */
    inboundBufferSizeInBytes: number;

    /**
     * Gets or sets a Boolean value that specifies whether the DatagramSocket is able to coexist with other Win32 or WinRT multicast sockets bound to the same address/port. 
     */
    multicastOnly: boolean;

    /**
     * Gets or sets the hop limit on an outbound packet sent to a unicast IP address by the DatagramSocket object. 
     */
    outboundUnicastHopLimit: number;

    /**
     * Gets or sets the quality of service on a DatagramSocket object. 
     */
    qualityOfService: undefined.SocketQualityOfService
}


/**
 * Provides socket information on a DatagramSocket object. 
 */
declare class DatagramSocketInformation {

    /**
     * The local IP address associated with a DatagramSocket object. 
     */
    localAddress: undefined.HostName;

    /**
     * The local service name or UDP port number associated with a DatagramSocket . 
     */
    localPort: string;

    /**
     * The IP address of the remote network destination associated with a DatagramSocket object. 
     */
    remoteAddress: undefined.HostName;

    /**
     * The UDP port number of the remote network destination associated with a DatagramSocket object. 
     */
    remotePort: string
}


/**
 * Provides data for a MessageReceived event on a DatagramSocket . 
 */
declare class DatagramSocketMessageReceivedEventArgs {

    /**
     * Gets a DataReader object to read incoming data received from the remote network destination on a DatagramSocket object.
     * @return  A DataReader object to read incoming data received from the remote network destination on a DatagramSocket object.
     */
    getDataReader(): undefined.DataReader;

    /**
     * Gets an IInputStream object that represents a sequential stream of bytes to be read as a message from the remote network destination on a DatagramSocket object.
     * @return  An IInputStream object that represents a sequential stream of bytes to be read as a message.
     */
    getDataStream(): undefined.IInputStream;

    /**
     * Gets the local IP address associated with a DatagramSocket when a message was received. 
     */
    localAddress: undefined.HostName;

    /**
     * Gets the IP address of the remote sender of the datagram on the DatagramSocket when a message is received. 
     */
    remoteAddress: undefined.HostName;

    /**
     * Gets the UDP port number of the remote sender of the datagram received on the DatagramSocket . 
     */
    remotePort: string
}


/**
 * Supports network communication that allows reading and writing whole messages using a WebSocket. 
 */
declare class MessageWebSocket {

    /**
     * Creates a new MessageWebSocket object. 
     */
    constructor(): this;

    /**
     * Closes the MessageWebSocket object and sends an empty close frame to the server. 
     */
    close(): void;

    /**
     * Closes the MessageWebSocket object and indicates a reason for the closure.
     * @param code Status code indicating the reason for closure.
     * @param reason Optional UTF-8-encoded data with additional information about the closure.
     */
    close(code: number, reason: string): void;

    /**
     * Starts an asynchronous operation to connect to a remote network destination on a MessageWebSocket object.
     * @param uri An absolute Uri for the server to connect to.
     * @return  An asynchronous connect operation on a MessageWebSocket object.
     */
    connectAsync(uri: undefined.Uri): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets socket control data on a MessageWebSocket object. 
     */
    control: undefined.MessageWebSocketControl;

    /**
     * Gets socket information on a MessageWebSocket object. 
     */
    information: undefined.MessageWebSocketInformation;

    /**
     * Occurs when a close frame is received on the MessageWebSocket object as part of the close handshake. 
     */
    onclosed: undefined.TypedEventHandler<undefined.IWebSocket, undefined.WebSocketClosedEventArgs>;
    addEventListener(
        type: "closed",
        listener: undefined.TypedEventHandler<undefined.IWebSocket, undefined.WebSocketClosedEventArgs>): void;
    removeEventListener(
        type: "closed",
        listener: undefined.TypedEventHandler<undefined.IWebSocket, undefined.WebSocketClosedEventArgs>): void;

    /**
     * An event that indicates that a message was received on the MessageWebSocket object. 
     */
    onmessagereceived: undefined.TypedEventHandler<undefined.MessageWebSocket, undefined.MessageWebSocketMessageReceivedEventArgs>;
    addEventListener(
        type: "messagereceived",
        listener: undefined.TypedEventHandler<undefined.MessageWebSocket, undefined.MessageWebSocketMessageReceivedEventArgs>): void;
    removeEventListener(
        type: "messagereceived",
        listener: undefined.TypedEventHandler<undefined.MessageWebSocket, undefined.MessageWebSocketMessageReceivedEventArgs>): void;

    /**
     * Gets the output stream to write to the remote network destination on a MessageWebSocket object. 
     */
    outputStream: undefined.IOutputStream;

    /**
     * Adds an HTTP request header to the HTTP request message used in the WebSocket protocol handshake by the MessageWebSocket object.
     * @param headerName The name of the request header.
     * @param headerValue The value of the request header.
     */
    setRequestHeader(headerName: string, headerValue: string): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides socket control data on a MessageWebSocket . 
 */
declare class MessageWebSocketControl {

    /**
     * The maximum message size, in bytes, for a WebSocket message to be configured on the MessageWebSocket object. 
     */
    maxMessageSize: number;

    /**
     * The WebSocket message type to be configured on a MessageWebSocket object for write operations. 
     */
    messageType: undefined.SocketMessageType;

    /**
     * The size, in bytes, of the send buffer to be used for sending data on a MessageWebSocket object. 
     */
    outboundBufferSizeInBytes: number;

    /**
     * The credential to use to authenticate to the proxy server through HTTP header authentication using a MessageWebSocket object. 
     */
    proxyCredential: undefined.PasswordCredential;

    /**
     * The credential to use to authenticate to the WebSocket server through HTTP header authentication using a MessageWebSocket object. 
     */
    serverCredential: undefined.PasswordCredential;

    /**
     * Gets a collection that can be used to add a list of supported sub-protocols that will be advertised to the server during the connect handshake. 
     */
    supportedProtocols: undefined.IVector<string >
}


/**
 * Provides socket information on a MessageWebSocket . 
 */
declare class MessageWebSocketInformation {

    /**
     * Gets bandwidth information for network data transfer on a MessageWebSocket object. 
     */
    bandwidthStatistics: undefined.BandwidthStatistics;

    /**
     * Gets the IP address associated with a MessageWebSocket object. 
     */
    localAddress: undefined.HostName;

    /**
     * Gets the WebSocket sub-protocol negotiated with the server during WebSocket handshake on a MessageWebSocket object. 
     */
    protocol: string
}


/**
 * Provides data for a message received event on a MessageWebSocket . 
 */
declare class MessageWebSocketMessageReceivedEventArgs {

    /**
     * Gets a DataReader object to read incoming data received from the remote network destination on a MessageWebSocket .
     * @return  A DataReader object to read incoming data received from the remote network destination on a MessageWebSocket .
     */
    getDataReader(): undefined.DataReader;

    /**
     * Gets an IInputStream object (a message represented as a sequential stream of bytes) from the remote network destination on a MessageWebSocket object.
     * @return  A message represented as a sequential stream of bytes.
     */
    getDataStream(): undefined.IInputStream;

    /**
     * Gets the type of the message received by a MessageWebSocket object. 
     */
    messageType: undefined.SocketMessageType
}


/**
 * The context associated with a socket while transferring ownership of the socket between an app and the socket brokering service. 
 */
declare class SocketActivityContext {

    /**
     * Constructs a new SocketActivityContext object with given context data.
     * @param data Context data to be used when the socket broker notifies the app of socket activity.
     */
    constructor(data: undefined.IBuffer): this;

    /**
     * Get the serialized data to associate the app context to a transferred socket. 
     */
    data: undefined.IBuffer
}


/**
 * Provides information on the transferred socket from the Socket Broker. 
 */
declare class SocketActivityInformation {

    /**
     * Gets a list of all the sockets transferred to the socket brokering service by this app. 
     */
    allSockets: undefined.IMapView<string, undefined.SocketActivityInformation>;

    /**
     * Get the context associated while transferring ownership of the socket. 
     */
    context: undefined.SocketActivityContext;

    /**
     * Based on the socket type, the app can reclaim the ownership of the appropriate DatagramSocket . 
     */
    datagramSocket: undefined.DatagramSocket;

    /**
     * A unique string for this app used to identify the transferred socket. This is passed by the app while transferring the socket ownership to the service. 
     */
    id: string;

    /**
     * Gets a SocketActivityKind enumeration value that identifies socket kind. 
     */
    socketKind: undefined.SocketActivityKind;

    /**
     * Based on the socket type, the app can reclaim the ownership of the appropriate StreamSocket . 
     */
    streamSocket: undefined.StreamSocket;

    /**
     * Based on the socket type, the app can reclaim the ownership of the appropriate StreamSocketListener . 
     */
    streamSocketListener: undefined.StreamSocketListener;

    /**
     * The background task ID used while transferring ownership of the socket. 
     */
    taskId: string
}


/**
 * A object instantiated by the background broker infrastructure and used by an app to retrieve details when a SocketActivityTrigger occurs. 
 */
declare class SocketActivityTriggerDetails {

    /**
     * Get the reason the SocketActivityTrigger occurred. 
     */
    reason: undefined.SocketActivityTriggerReason;

    /**
     * Get the SocketActivityInformation object for socket that caused the SocketActivityTrigger to occur. 
     */
    socketInformation: undefined.SocketActivityInformation
}


/**
 * Provides socket error status for operations on a DatagramSocket , StreamSocket , or StreamSocketListener . 
 */
declare class SocketError {

    /**
     * Gets a SocketErrorStatus value based on an error encountered by a socket operation.
     * @param hresult The error encountered by a socket operation represented as an HRESULT.
     * @return  The socket error status value for a socket operation.
     */
    getStatus(hresult: number): undefined.SocketErrorStatus
}


/**
 * Supports network communication using a stream socket over TCP or Bluetooth RFCOMM in Windows Store apps. 
 */
declare class StreamSocket {

    /**
     * Creates a new StreamSocket object. 
     */
    constructor(): this;

    /**
     * Cancels pending reads and writes over a StreamSocket object.
     * @return  An asynchronous cancel operation on a StreamSocket object.
     */
    cancelIOAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Closes the StreamSocket object. 
     */
    close(): void;

    /**
     * Starts an asynchronous operation on a StreamSocket object to connect to a remote network destination specified by a remote hostname and a remote service name.
     * @param remoteHostName The hostname or IP address of the remote network destination. For Bluetooth RFCOMM, this is a MAC address.
     * @param remoteServiceName The service name or TCP port number of the remote network destination. For Bluetooth RFCOMM, this is the Bluetooth address.
     * @return  An asynchronous connect operation on a StreamSocket object.
     */
    connectAsync(
        remoteHostName: undefined.HostName,
        remoteServiceName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts an asynchronous operation on a StreamSocket object to connect to a remote destination specified by a remote hostname, a remote service name, and a SocketProtectionLevel .
     * @param remoteHostName The hostname or IP address of the remote network destination. For Bluetooth RFCOMM, this is a MAC address.
     * @param remoteServiceName The service name or TCP port number of the remote network destination. For Bluetooth RFCOMM, this is the Bluetooth address.
     * @param protectionLevel The protection level that represents the integrity and encryption for the StreamSocket object.
     * @return  An asynchronous connect operation on a StreamSocket object.
     */
    connectAsync(
        remoteHostName: undefined.HostName,
        remoteServiceName: string,
        protectionLevel: undefined.SocketProtectionLevel): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts an asynchronous operation on a StreamSocket object to connect to a remote network destination specified as an EndpointPair object and a SocketProtectionLevel enumeration. This method is not callable from JavaScript.
     * @param endpointPair An EndpointPair object that specifies local hostname or IP address, local service name or TCP port, the remote hostname or remote IP address, and the remote service name or remote TCP port for the remote network destination.
     * @param protectionLevel The protection level that represents the integrity and encryption for a StreamSocket object.
     * @return  An asynchronous connect operation on a StreamSocket object.
     */
    connectAsync(
        endpointPair: undefined.EndpointPair,
        protectionLevel: undefined.SocketProtectionLevel): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts an asynchronous operation on a StreamSocket object to connect to a remote network destination specified as an EndpointPair object.
     * @param endpointPair An EndpointPair object that specifies the local hostname or IP address, the local service name or TCP port, the remote hostname or remote IP address, and the remote service name or remote TCP port for the remote network destination.
     * @return  An asynchronous connect operation on a StreamSocket object.
     */
    connectAsync(endpointPair: undefined.EndpointPair): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts an asynchronous operation on a StreamSocket object on a specified local network adapter to connect to a remote destination specified by a remote hostname, a remote service name, and a SocketProtectionLevel .
     * @param remoteHostName The hostname or IP address of the remote network destination. For Bluetooth RFCOMM, this is a MAC address.
     * @param remoteServiceName The service name or TCP port number of the remote network destination. For Bluetooth RFCOMM, this is the Bluetooth address.
     * @param protectionLevel The protection level that represents the integrity and encryption for the StreamSocket object.
     * @param adapter The local network adapter to use for the connect operation on the StreamSocket object.
     * @return  An asynchronous connect operation on a StreamSocket object.
     */
    connectAsync(
        remoteHostName: undefined.HostName,
        remoteServiceName: string,
        protectionLevel: undefined.SocketProtectionLevel,
        adapter: undefined.NetworkAdapter): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets socket control data on a StreamSocket object. 
     */
    control: undefined.StreamSocketControl;

    /**
     * Enables your app's background task to be triggered by the socket broker when traffic for this StreamSocket arrives while the app is not active.
     * @param taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this StreamSocket .
     */
    enableTransferOwnership(taskId: string): void;

    /**
     * Enables or disables the ability of your app's background task to be triggered by the socket broker when traffic for this StreamSocket arrives while the system is in connected standby.
     * @param taskId The IBackgroundTaskRegistration.TaskId of the background task being enabled or disabled.
     * @param connectedStandbyAction Specifies whether to enable or disable the activation of the background task when traffic arrives.
     */
    enableTransferOwnership(
        taskId: string,
        connectedStandbyAction: undefined.SocketActivityConnectedStandbyAction): void;

    /**
     * Gets socket information on a StreamSocket object. 
     */
    information: undefined.StreamSocketInformation;

    /**
     * Gets the input stream to read from the remote destination on a StreamSocket object. 
     */
    inputStream: undefined.IInputStream;

    /**
     * Gets the output stream to write to the remote host on a StreamSocket object. 
     */
    outputStream: undefined.IOutputStream;

    /**
     * Transfers ownership of the StreamSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
     * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
     */
    transferOwnership(socketId: string): void;

    /**
     * Transfers ownership of the StreamSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity. Specifies a new SocketActivityContext for the socket.
     * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
     * @param data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
     */
    transferOwnership(socketId: string, data: undefined.SocketActivityContext): void;

    /**
     * Transfers ownership of the StreamSocket to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity. Specifies a new SocketActivityContext and a keep alive time for the socket.
     * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
     * @param data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
     * @param keepAliveTime How long the socket brokering service should monitor the socket for activity.
     */
    transferOwnership(
        socketId: string,
        data: undefined.SocketActivityContext,
        keepAliveTime: number): void;

    /**
     * Starts an asynchronous operation to upgrade a connected socket to use SSL on a StreamSocket object.
     * @param protectionLevel The protection level that represents the integrity and encryption on the StreamSocket object.
     * @param validationHostName The hostname of the remote network destination that is used for validation when upgrading to SSL.
     * @return  An asynchronous operation to upgrade to use SSL on a StreamSocket object.
     */
    upgradeToSslAsync(
        protectionLevel: undefined.SocketProtectionLevel,
        validationHostName: undefined.HostName): undefined.IPromiseWithIAsyncAction
}


/**
 * Provides socket control data on a StreamSocket object. 
 */
declare class StreamSocketControl {

    /**
     * Gets or sets the client SSL/TLS certificate that will be sent to the server if the server requests a client certificate. 
     */
    clientCertificate: undefined.Certificate;

    /**
     * Get a vector of SSL server errors to ignore when making an SSL connection with a StreamSocket . 
     */
    ignorableServerCertificateErrors: undefined.IVector<undefined.ChainValidationResult>;

    /**
     * A value that indicates whether keep-alive packets are sent to the remote destination on a StreamSocket object. 
     */
    keepAlive: boolean;

    /**
     * A value that indicates whether the Nagle algorithm is used on a StreamSocket object. 
     */
    noDelay: boolean;

    /**
     * The size, in bytes, of the send buffer to be used for sending data on a StreamSocket object. 
     */
    outboundBufferSizeInBytes: number;

    /**
     * The hop limit on an outbound packet sent to a unicast IP address by the StreamSocket object. 
     */
    outboundUnicastHopLimit: number;

    /**
     * The quality of service on a StreamSocket object. 
     */
    qualityOfService: undefined.SocketQualityOfService;

    /**
     * A value that indicates whether, when multiple connection attempts are being made, the attempts are made in parallel or serially. 
     */
    serializeConnectionAttempts: boolean
}


/**
 * Provides socket information on a StreamSocket object. 
 */
declare class StreamSocketInformation {

    /**
     * Gets bandwidth information for network data transfer on a StreamSocket object. 
     */
    bandwidthStatistics: undefined.BandwidthStatistics;

    /**
     * Gets the local IP address associated with a StreamSocket object. 
     */
    localAddress: undefined.HostName;

    /**
     * Get the TCP port number associated with a StreamSocket . 
     */
    localPort: string;

    /**
     * Gets the protection level that represents the integrity and encryption set on a StreamSocket object. 
     */
    protectionLevel: undefined.SocketProtectionLevel;

    /**
     * Get the IP address or hostname of the remote network destination associated with a StreamSocket object. 
     */
    remoteAddress: undefined.HostName;

    /**
     * Get the hostname or IP address of the remote network destination associated with a StreamSocket object. 
     */
    remoteHostName: undefined.HostName;

    /**
     * Get the TCP port number or service name of the remote network destination associated with a StreamSocket object. 
     */
    remotePort: string;

    /**
     * Get the service name or TCP port number of the remote network destination associated with a StreamSocket object. 
     */
    remoteServiceName: string;

    /**
     * Gets round trip time information for a StreamSocket object. 
     */
    roundTripTimeStatistics: undefined.RoundTripTimeStatistics;

    /**
     * Gets the certificate from the server when making an SSL connection with a StreamSocket . 
     */
    serverCertificate: undefined.Certificate;

    /**
     * Gets the category of an error that occurred making an SSL connection with a StreamSocket . 
     */
    serverCertificateErrorSeverity: undefined.SocketSslErrorSeverity;

    /**
     * Gets the list of errors that occurred making an SSL connection with a StreamSocket . 
     */
    serverCertificateErrors: undefined.IVectorView<undefined.ChainValidationResult>;

    /**
     * Gets the intermediate certificates sent by the server during SSL negotiation when making an SSL connection with a StreamSocket . 
     */
    serverIntermediateCertificates: undefined.IVectorView<undefined.Certificate>;

    /**
     * Get a byte array that represents the private shared secret exchanged by proximity devices. 
     */
    sessionKey: undefined.IBuffer
}


/**
 * Supports listening for an incoming network connection using a TCP stream socket or Bluetooth RFCOMM. 
 */
declare class StreamSocketListener {

    /**
     * Creates a new StreamSocketListener object. 
     */
    constructor(): this;

    /**
     * Starts a bind operation on a StreamSocketListener to a local hostname and a local service name.
     * @param localHostName The local hostname or IP address on which to bind the StreamSocketListener object.
     * @param localServiceName The local service name or TCP port on which to bind the StreamSocketListener object.
     * @return  An asynchronous bind operation on a StreamSocketListener object.
     */
    bindEndpointAsync(
        localHostName: undefined.HostName,
        localServiceName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts a bind operation on a StreamSocketListener to a local service name.
     * @param localServiceName The local service name or TCP port on which to bind the StreamSocketListener object. For Bluetooth RFCOMM, this parameter is the Bluetooth Service ID.
     * @return  The asynchronous bind operation on a StreamSocketListener object.
     */
    bindServiceNameAsync(localServiceName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts a socket bind operation on a StreamSocketListener to a local service name on a specified network adapter with a specified SocketProtectionLevel to set on any bound sockets.
     * @param localServiceName The local service name or TCP port on which to bind the StreamSocketListener object. For Bluetooth RFCOMM, this parameter is the Bluetooth Service ID.
     * @param protectionLevel The protection level for encryption to set on any bound sockets.
     * @param adapter The network adapter on which to bind the StreamSocketListener object.
     * @return  The asynchronous bind operation on a StreamSocketListener object.
     */
    bindServiceNameAsync(
        localServiceName: string,
        protectionLevel: undefined.SocketProtectionLevel,
        adapter: undefined.NetworkAdapter): undefined.IPromiseWithIAsyncAction;

    /**
     * Starts a bind operation on a StreamSocketListener to a local service name with a specified SocketProtectionLevel to set on any bound sockets.
     * @param localServiceName The local service name or TCP port on which to bind the StreamSocketListener object. For Bluetooth RFCOMM, this parameter is the Bluetooth Service ID.
     * @param protectionLevel The protection level for encryption to set on any bound sockets.
     * @return  The asynchronous bind operation on a StreamSocketListener object.
     */
    bindServiceNameAsync(
        localServiceName: string,
        protectionLevel: undefined.SocketProtectionLevel): undefined.IPromiseWithIAsyncAction;

    /**
     * Cancels pending reads and writes over a StreamSocketListener object.
     * @return  An asynchronous cancel operation on a StreamSocketListener object.
     */
    cancelIOAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Closes the StreamSocketListener object. 
     */
    close(): void;

    /**
     * Gets socket control data on a StreamSocketListener object. 
     */
    control: undefined.StreamSocketListenerControl;

    /**
     * Enables your app's background task to be triggered by the socket broker when traffic for this StreamSocketListener arrives while the app is not active.
     * @param taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this StreamSocketListener .
     */
    enableTransferOwnership(taskId: string): void;

    /**
     * Enables your app's background task to be triggered by the socket broker when traffic for this StreamSocketListener arrives while the system is in connected standby.
     * @param taskId The IBackgroundTaskRegistration.TaskId of the background task that will be triggered by the socket broker when traffic arrives for this StreamSocketListener .
     * @param connectedStandbyAction Specifies whether to enable or disable the activation of the background task when traffic arrives.
     */
    enableTransferOwnership(
        taskId: string,
        connectedStandbyAction: undefined.SocketActivityConnectedStandbyAction): void;

    /**
     * Gets socket information for the StreamSocketListener object. 
     */
    information: undefined.StreamSocketListenerInformation;

    /**
     * An event that indicates that a connection was received on the StreamSocketListener object. 
     */
    onconnectionreceived: undefined.TypedEventHandler<undefined.StreamSocketListener, undefined.StreamSocketListenerConnectionReceivedEventArgs>;
    addEventListener(
        type: "connectionreceived",
        listener: undefined.TypedEventHandler<undefined.StreamSocketListener, undefined.StreamSocketListenerConnectionReceivedEventArgs>): void;
    removeEventListener(
        type: "connectionreceived",
        listener: undefined.TypedEventHandler<undefined.StreamSocketListener, undefined.StreamSocketListenerConnectionReceivedEventArgs>): void;

    /**
     * Transfers ownership of the StreamSocketListener to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
     * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
     */
    transferOwnership(socketId: string): void;

    /**
     * Transfers ownership of the StreamSocketListener to the socket brokering service, which monitors socket activity and notifies the app through a background task if there is any activity.
     * @param socketId A string the app uses to identify the transferred socket. The string should identify this socket uniquely within the app. When activity occurs on this socket, this string will be provided to the app to identify the socket.
     * @param data Use the SocketActivityContext to pass context information through the socket broker. When your app is notified by the broker of activity, this SocketActivityContext will be provided to your app to help establish the context in which you should handle the notification.
     */
    transferOwnership(socketId: string, data: undefined.SocketActivityContext): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for a ConnectionReceived event on a StreamSocketListener object. 
 */
declare class StreamSocketListenerConnectionReceivedEventArgs {

    /**
     * The StreamSocket object created when a connection is received by the StreamSocketListener object. 
     */
    socket: undefined.StreamSocket
}


/**
 * Provides socket control data on a StreamSocketListener object. 
 */
declare class StreamSocketListenerControl {

    /**
     * A value that indicates whether keep-alive packets should be sent on a StreamSocket object created when a connection is received by the StreamSocketListener object. 
     */
    keepAlive: boolean;

    /**
     * A value that indicates whether the Nagle algorithm is used on a StreamSocket object created when a connection is received by the StreamSocketListener object. 
     */
    noDelay: boolean;

    /**
     * The size, in bytes, of the send buffer to be used for sending data on a StreamSocket object created when a connection is received by the StreamSocketListener object. 
     */
    outboundBufferSizeInBytes: number;

    /**
     * The hop limit on an outbound packet sent to a unicast IP address by the StreamSocket object created when a connection is received by the StreamSocketListener object. 
     */
    outboundUnicastHopLimit: number;

    /**
     * The quality of service to be set on a StreamSocket object created when a connection is received by the StreamSocketListener object. 
     */
    qualityOfService: undefined.SocketQualityOfService
}


/**
 * Provides socket information on a StreamSocketListener object. 
 */
declare class StreamSocketListenerInformation {

    /**
     * Get the local TCP port number associated with a StreamSocketListener object. 
     */
    localPort: string
}


/**
 * Supports network communication that allows reading and writing streams using a WebSocket. 
 */
declare class StreamWebSocket {

    /**
     * Creates a new StreamWebSocket object. 
     */
    constructor(): this;

    /**
     * Closes the StreamWebSocket and sends an empty close frame to the server. 
     */
    close(): void;

    /**
     * Closes the StreamWebSocket and indicates a reason for the closure.
     * @param code Status code indicating the reason for closure.
     * @param reason Optional UTF-8-encoded data with additional information about the closure.
     */
    close(code: number, reason: string): void;

    /**
     * Starts an asynchronous operation to connect to a remote network destination on a StreamWebSocket object.
     * @param uri An absolute Uri for the server to connect to.
     * @return  An asynchronous connect operation on a StreamWebSocket object.
     */
    connectAsync(uri: undefined.Uri): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets socket control data on a StreamWebSocket object. 
     */
    control: undefined.StreamWebSocketControl;

    /**
     * Gets socket information on a StreamWebSocket object. 
     */
    information: undefined.StreamWebSocketInformation;

    /**
     * Gets the input stream to read from the remote destination on a StreamWebSocket object. 
     */
    inputStream: undefined.IInputStream;

    /**
     * Occurs when a close frame is received on the StreamWebSocket object as part of the close handshake. 
     */
    onclosed: undefined.TypedEventHandler<undefined.IWebSocket, undefined.WebSocketClosedEventArgs>;
    addEventListener(
        type: "closed",
        listener: undefined.TypedEventHandler<undefined.IWebSocket, undefined.WebSocketClosedEventArgs>): void;
    removeEventListener(
        type: "closed",
        listener: undefined.TypedEventHandler<undefined.IWebSocket, undefined.WebSocketClosedEventArgs>): void;

    /**
     * Gets the output stream to write to the remote network destination on a StreamWebSocket object. 
     */
    outputStream: undefined.IOutputStream;

    /**
     * Adds an HTTP request header to the HTTP request message used in the WebSocket protocol handshake by the StreamWebSocket object.
     * @param headerName The name of the request header.
     * @param headerValue The value of the request header.
     */
    setRequestHeader(headerName: string, headerValue: string): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides socket control data on a StreamWebSocket object. 
 */
declare class StreamWebSocketControl {

    /**
     * A value that indicates whether the Nagle algorithm is used on a StreamWebSocket object. 
     */
    noDelay: boolean;

    /**
     * The size, in bytes, of the send buffer to be used for sending data on a StreamWebSocket object. 
     */
    outboundBufferSizeInBytes: number;

    /**
     * The credential to use to authenticate to the proxy server through HTTP header authentication using a StreamWebSocket object. 
     */
    proxyCredential: undefined.PasswordCredential;

    /**
     * The credential to use to authenticate to the WebSocket server through HTTP header authentication using a StreamWebSocket object. 
     */
    serverCredential: undefined.PasswordCredential;

    /**
     * Gets a collection that can be used to add a list of supported sub-protocols that will be advertised to the server during the connect handshake. 
     */
    supportedProtocols: undefined.IVector<string >
}


/**
 * Provides socket information on a StreamWebSocket object. 
 */
declare class StreamWebSocketInformation {

    /**
     * Gets bandwidth information for network data transfer on a StreamWebSocket object. 
     */
    bandwidthStatistics: undefined.BandwidthStatistics;

    /**
     * Gets the IP address associated with a StreamWebSocket object. 
     */
    localAddress: undefined.HostName;

    /**
     * Gets the WebSocket sub-protocol negotiated with the server during WebSocket handshake on a StreamWebSocket object. 
     */
    protocol: string
}


/**
 * Provides data for a closed event on a MessageWebSocket , StreamWebSocket , or IWebSocket object. 
 */
declare class WebSocketClosedEventArgs {

    /**
     * Gets information about the reason that a WebSocket object was closed. 
     */
    code: number;

    /**
     * Gets additional details about the reason that a WebSocket object was closed. 
     */
    reason: string
}


/**
 * Provides socket error status on a MessageWebSocket or StreamWebSocket object. 
 */
declare class WebSocketError {

    /**
     * Gets a WebErrorStatus value based on an error encountered by a WebSocket operation.
     * @param hresult The error encountered by a WebSocket operation represented as an HRESULT.
     * @return  The socket error status value for a WebSocket operation.
     */
    getStatus(hresult: number): undefined.WebErrorStatus
}

declare interface Sockets$IWebSocket {
    close(): void
}


/**
 * Represents bandwidth information for network data transfer using a StreamSocket , StreamWebSocket , or MessageWebSocket object. 
 */
declare interface Sockets$BandwidthStatistics {}


/**
 * Represents round trip time information for a StreamSocket object. 
 */
declare interface Sockets$RoundTripTimeStatistics {}




/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class XboxLiveDeviceAddress {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param base64 This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    createFromSnapshotBase64(base64: string): undefined.XboxLiveDeviceAddress;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param buffer This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    createFromSnapshotBuffer(buffer: undefined.IBuffer): undefined.XboxLiveDeviceAddress;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param buffer This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    createFromSnapshotBytes(buffer: number[]): undefined.XboxLiveDeviceAddress;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getLocal(): undefined.XboxLiveDeviceAddress;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    maxSnapshotBytesSize: number;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param otherDeviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    compare(otherDeviceAddress: undefined.XboxLiveDeviceAddress): number;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getSnapshotAsBase64(): string;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getSnapshotAsBuffer(): undefined.IBuffer;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getSnapshotAsBytes(): {
        buffer: number[],
        bytesWritten: number
    };

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    isLocal: boolean;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    isValid: boolean;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    networkAccessKind: undefined.XboxLiveNetworkAccessKind;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    onsnapshotchanged: undefined.TypedEventHandler<undefined.XboxLiveDeviceAddress, any>;
    addEventListener(
        type: "snapshotchanged",
        listener: undefined.TypedEventHandler<undefined.XboxLiveDeviceAddress, any>): void;
    removeEventListener(
        type: "snapshotchanged",
        listener: undefined.TypedEventHandler<undefined.XboxLiveDeviceAddress, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class XboxLiveEndpointPair {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param localHostName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param localPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param remoteHostName This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param remotePort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    findEndpointPairByHostNamesAndPorts(
        localHostName: undefined.HostName,
        localPort: string,
        remoteHostName: undefined.HostName,
        remotePort: string): undefined.XboxLiveEndpointPair;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param localSocketAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param remoteSocketAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    findEndpointPairBySocketAddressBytes(
        localSocketAddress: number[],
        remoteSocketAddress: number[]): undefined.XboxLiveEndpointPair;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getLocalSocketAddressBytes(): number[];

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getRemoteSocketAddressBytes(): number[];

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    localHostName: undefined.HostName;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    localPort: string;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    onstatechanged: undefined.TypedEventHandler<undefined.XboxLiveEndpointPair, undefined.XboxLiveEndpointPairStateChangedEventArgs>;
    addEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.XboxLiveEndpointPair, undefined.XboxLiveEndpointPairStateChangedEventArgs>): void;
    removeEventListener(
        type: "statechanged",
        listener: undefined.TypedEventHandler<undefined.XboxLiveEndpointPair, undefined.XboxLiveEndpointPairStateChangedEventArgs>): void;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    remoteDeviceAddress: undefined.XboxLiveDeviceAddress;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    remoteHostName: undefined.HostName;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    remotePort: string;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    state: undefined.XboxLiveEndpointPairState;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    template: undefined.XboxLiveEndpointPairTemplate;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class XboxLiveEndpointPairCreationResult {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    deviceAddress: undefined.XboxLiveDeviceAddress;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    endpointPair: undefined.XboxLiveEndpointPair;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    isExistingPathEvaluation: boolean;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    status: undefined.XboxLiveEndpointPairCreationStatus
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class XboxLiveEndpointPairStateChangedEventArgs {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    newState: undefined.XboxLiveEndpointPairState;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    oldState: undefined.XboxLiveEndpointPairState
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class XboxLiveEndpointPairTemplate {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param name This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getTemplateByName(name: string): undefined.XboxLiveEndpointPairTemplate;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    templates: undefined.IVectorView<undefined.XboxLiveEndpointPairTemplate>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    acceptorBoundPortRangeLower: number;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    acceptorBoundPortRangeUpper: number;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param behaviors This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    createEndpointPairAsync(
        deviceAddress: undefined.XboxLiveDeviceAddress,
        behaviors: undefined.XboxLiveEndpointPairCreationBehaviors): undefined.IPromiseWithIAsyncOperation<undefined.XboxLiveEndpointPairCreationResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    createEndpointPairAsync(
        deviceAddress: undefined.XboxLiveDeviceAddress): undefined.IPromiseWithIAsyncOperation<undefined.XboxLiveEndpointPairCreationResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param initiatorPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param acceptorPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    createEndpointPairForPortsAsync(
        deviceAddress: undefined.XboxLiveDeviceAddress,
        initiatorPort: string,
        acceptorPort: string): undefined.IPromiseWithIAsyncOperation<undefined.XboxLiveEndpointPairCreationResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param initiatorPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param acceptorPort This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param behaviors This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    createEndpointPairForPortsAsync(
        deviceAddress: undefined.XboxLiveDeviceAddress,
        initiatorPort: string,
        acceptorPort: string,
        behaviors: undefined.XboxLiveEndpointPairCreationBehaviors): undefined.IPromiseWithIAsyncOperation<undefined.XboxLiveEndpointPairCreationResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    endpointPairs: undefined.IVectorView<undefined.XboxLiveEndpointPair>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    initiatorBoundPortRangeLower: number;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    initiatorBoundPortRangeUpper: number;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    name: string;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    oninboundendpointpaircreated: undefined.TypedEventHandler<undefined.XboxLiveEndpointPairTemplate, undefined.XboxLiveInboundEndpointPairCreatedEventArgs>;
    addEventListener(
        type: "inboundendpointpaircreated",
        listener: undefined.TypedEventHandler<undefined.XboxLiveEndpointPairTemplate, undefined.XboxLiveInboundEndpointPairCreatedEventArgs>): void;
    removeEventListener(
        type: "inboundendpointpaircreated",
        listener: undefined.TypedEventHandler<undefined.XboxLiveEndpointPairTemplate, undefined.XboxLiveInboundEndpointPairCreatedEventArgs>): void;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    socketKind: undefined.XboxLiveSocketKind;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class XboxLiveInboundEndpointPairCreatedEventArgs {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    endpointPair: undefined.XboxLiveEndpointPair
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class XboxLiveQualityOfServiceMeasurement {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    clearPrivatePayload(): void;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    isSystemInboundBandwidthConstrained: boolean;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    isSystemOutboundBandwidthConstrained: boolean;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    maxPrivatePayloadSize: number;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    maxSimultaneousProbeConnections: number;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param payload This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    publishPrivatePayloadBytes(payload: number[]): void;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    publishedPrivatePayload: undefined.IBuffer;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    constructor(): this;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    deviceAddresses: undefined.IVector<undefined.XboxLiveDeviceAddress>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param metric This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getMetricResult(
        deviceAddress: undefined.XboxLiveDeviceAddress,
        metric: undefined.XboxLiveQualityOfServiceMetric): undefined.XboxLiveQualityOfServiceMetricResult;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getMetricResultsForDevice(
        deviceAddress: undefined.XboxLiveDeviceAddress): undefined.IVectorView<undefined.XboxLiveQualityOfServiceMetricResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param metric This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getMetricResultsForMetric(
        metric: undefined.XboxLiveQualityOfServiceMetric): undefined.IVectorView<undefined.XboxLiveQualityOfServiceMetricResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @param deviceAddress This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    getPrivatePayloadResult(
        deviceAddress: undefined.XboxLiveDeviceAddress): undefined.XboxLiveQualityOfServicePrivatePayloadResult;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     * @return  This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime.
     */
    measureAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    metricResults: undefined.IVectorView<undefined.XboxLiveQualityOfServiceMetricResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    metrics: undefined.IVector<undefined.XboxLiveQualityOfServiceMetric>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    numberOfProbesToAttempt: number;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    numberOfResultsPending: number;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    privatePayloadResults: undefined.IVectorView<undefined.XboxLiveQualityOfServicePrivatePayloadResult>;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    shouldRequestPrivatePayloads: boolean;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    timeoutInMilliseconds: number
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class XboxLiveQualityOfServiceMetricResult {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    deviceAddress: undefined.XboxLiveDeviceAddress;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    metric: undefined.XboxLiveQualityOfServiceMetric;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    status: undefined.XboxLiveQualityOfServiceMeasurementStatus;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    value: number
}


/**
 * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
 */
declare class XboxLiveQualityOfServicePrivatePayloadResult {

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    deviceAddress: undefined.XboxLiveDeviceAddress;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    status: undefined.XboxLiveQualityOfServiceMeasurementStatus;

    /**
     * This API is not available to all apps. Unless your developer account is specially provisioned by Microsoft, calls to these APIs will fail at runtime. 
     */
    value: undefined.IBuffer
}

declare class HeadPose {
    forwardDirection: any;
    position: any;
    upDirection: any
}

declare class PerceptionTimestamp {
    predictionAmount: any;
    targetTime: any
}

declare class PerceptionTimestampHelper {
    fromHistoricalTargetTime: any
}

declare class SpatialAnchor {
    tryCreateRelativeTo: any;
    addEventListener: any;
    coordinateSystem: any;
    onrawcoordinatesystemadjusted: any;
    rawCoordinateSystem: any;
    removeEventListener: any
}

declare class SpatialAnchorManager {
    requestStoreAsync: any
}

declare class SpatialAnchorRawCoordinateSystemAdjustedEventArgs {
    oldRawCoordinateSystemToNewRawCoordinateSystemTransform: any
}

declare class SpatialAnchorStore {
    clear: any;
    getAllSavedAnchors: any;
    remove: any;
    trySave: any
}

declare class SpatialAnchorTransferManager {
    requestAccessAsync: any;
    tryExportAnchorsAsync: any;
    tryImportAnchorsAsync: any
}

declare class SpatialBoundingVolume {
    fromBox: any;
    fromFrustum: any;
    fromOrientedBox: any;
    fromSphere: any
}

declare class SpatialCoordinateSystem {
    tryGetTransformTo: any
}

declare
var unavailable: any;

declare
var orientationOnly: any;

declare
var positionalTrackingActivating: any;

declare
var positionalTrackingActive: any;

declare
var positionalTrackingInhibited: any;

declare class SpatialLocation {
    absoluteAngularAcceleration: any;
    absoluteAngularVelocity: any;
    absoluteLinearAcceleration: any;
    absoluteLinearVelocity: any;
    orientation: any;
    position: any
}

declare class SpatialLocator {
    getDefault: any;
    addEventListener: any;
    createAttachedFrameOfReferenceAtCurrentHeading: any;
    createStationaryFrameOfReferenceAtCurrentLocation: any;
    locatability: any;
    onlocatabilitychanged: any;
    onpositionaltrackingdeactivating: any;
    removeEventListener: any;
    tryLocateAtTimestamp: any
}

declare class SpatialLocatorAttachedFrameOfReference {
    adjustHeading: any;
    getStationaryCoordinateSystemAtTimestamp: any;
    relativeOrientation: any;
    relativePosition: any;
    tryGetRelativeHeadingAtTimestamp: any
}

declare class SpatialLocatorPositionalTrackingDeactivatingEventArgs {
    canceled: any
}

declare
var unspecified: any;

declare
var allowed: any;

declare
var deniedByUser: any;

declare
var deniedBySystem: any;

declare class SpatialStationaryFrameOfReference {
    coordinateSystem: any
}

declare class SpatialSurfaceInfo {
    id: any;
    tryComputeLatestMeshAsync: any;
    tryGetBounds: any;
    updateTime: any
}

declare class SpatialSurfaceMesh {
    coordinateSystem: any;
    surfaceInfo: any;
    triangleIndices: any;
    vertexNormals: any;
    vertexPositionScale: any;
    vertexPositions: any
}

declare class SpatialSurfaceMeshBuffer {
    data: any;
    elementCount: any;
    format: any;
    stride: any
}

declare class SpatialSurfaceMeshOptions {
    supportedTriangleIndexFormats: any;
    supportedVertexNormalFormats: any;
    supportedVertexPositionFormats: any;
    includeVertexNormals: any;
    triangleIndexFormat: any;
    vertexNormalFormat: any;
    vertexPositionFormat: any
}

declare class SpatialSurfaceObserver {
    requestAccessAsync: any;
    addEventListener: any;
    getObservedSurfaces: any;
    onobservedsurfaceschanged: any;
    removeEventListener: any;
    setBoundingVolume: any;
    setBoundingVolumes: any
}


/**
 * Provides an app with the ability to start the authentication request to get JavaScript Object Notation (JSON) tokens to use with your service or request tickets that can be used to get data that the user has consented to for your app using the Live Connect APIs. 
 */
declare class OnlineIdAuthenticator {

    /**
     * Creates an instance of the OnlineIdAuthenticator . 
     */
    constructor(): this;

    /**
     * Returns the ID of the application as a GUID. 
     */
    applicationId: string;

    /**
     * Starts the async authentication request with one OnlineIdServiceTicketRequest . If a user is signed into a Windows 8 system with a Microsoft account, this user will be used for the authentication request.
     * @param request A request object that provides the ability for an app to specify the service and policy used to authenticate a Live user to obtain identity properties and tickets.
     * @return  An object representing the authentication operation.
     */
    authenticateUserAsync(
        request: undefined.OnlineIdServiceTicketRequest): undefined.IPromiseWithOperation<any, undefined.UserAuthenticationOperation>;

    /**
     * Starts the async authentication request with multiple OnlineIdServiceTicketRequests and provides the ability to control the user experience by setting the CredentialPromptType to get the tickets. If a user is signed into a Windows 8 system with a Microsoft account, this user will be used for the authentication request.
     * @param requests A collection of requests.
     * @param credentialPromptType The type of credentials.
     * @return  An object representing the authentication operation.
     */
    authenticateUserAsync(
        requests: undefined.IIterable<undefined.OnlineIdServiceTicketRequest>,
        credentialPromptType: undefined.CredentialPromptType): undefined.IPromiseWithOperation<any, undefined.UserAuthenticationOperation>;

    /**
     * Returns the ID of a user who has been successfully authenticated for your app. 
     */
    authenticatedSafeCustomerId: string;

    /**
     * Indicates whether a user can sign out of the app, and whether to show the sign out link in the app. 
     */
    canSignOut: boolean;

    /**
     * Allows users to sign out of your app.
     * @return  An object that contains additional information about the why the user signed out.
     */
    signOutUserAsync(): undefined.IPromiseWithOperation<any, undefined.SignOutUserOperation >
}


/**
 * Contains the ticket that is obtained after the user authenticates to this app or has provided consent to access user data stored in Live. 
 */
declare class OnlineIdServiceTicket {

    /**
     * If there was an error in obtaining the ticket, then the error code is captured here. 
     */
    errorCode: number;

    /**
     * Represents the OnlineIdServiceTicketRequest for which the ticket was obtained. 
     */
    request: undefined.OnlineIdServiceTicketRequest;

    /**
     * The ticket. 
     */
    value: string
}


/**
 * Provides the ability for an app to specify the service and policy that is used to authenticate a Live user to obtain identity properties and tickets. 
 */
declare class OnlineIdServiceTicketRequest {

    /**
     * Creates an instance of the OnlineIdServiceTicketRequest class.
     * @param service The service for the request.
     * @param policy The policy for the request.
     */
    constructor(service: string, policy: string): this;

    /**
     * Creates an instance of the OnlineIdServiceTicketRequest class.
     * @param service The service for the request.
     */
    constructor(service: string): this;

    /**
     * The policy used to authenticate users. Supported values are JWT, which returns data using the JSON format. For apps that are requesting user consent to access stored in Live, app developer must pass a policy of DELEGATION. 
     */
    policy: string;

    /**
     * Identifies the service your app uses. The service name must match the DNS name you supplied when registering your app on http://go.microsoft.com/fwlink/p/?linkid=241860. Tickets are issued only for this service. For apps that are requesting user consent to access stored in Live, you must pass the offers to which your app needs access. The available list of offers can be found at our Scopes and Permissions page. The ticket can then be used with the Live Connect REST apis to access data that a user has consented to give to the app. Check out our REST APIs topic to learn more. Alternatively, the app can use the Live Connect SDK which will make these calls itself. 
     */
    service: string
}


/**
 * Allows users to sign out of your app. 
 */
declare class SignOutUserOperation {

    /**
     * Requests the cancellation of the operation. 
     */
    cancel(): void;

    /**
     * Requests that work associated with the operation should terminate. 
     */
    close(): void;

    /**
     * Gets or sets a handler that is called when the operation completes. 
     */
    completed: undefined.AsyncActionCompletedHandler;

    /**
     * Gets the error code should the operation fail. 
     */
    errorCode: Windows$WinRTError;

    /**
     * Returns the results of the operation. For this class, there are no results to return if the operation succeeds. 
     */
    getResults(): void;

    /**
     * Gets a unique identifier that represents the operation. 
     */
    id: number;

    /**
     * Gets the current status of the operation. 
     */
    status: undefined.AsyncStatus
}


/**
 * Asynchronously gets the user's identity and corresponding tickets and properties. 
 */
declare class UserAuthenticationOperation {

    /**
     * Requests the cancellation of the operation. 
     */
    cancel(): void;

    /**
     * Requests that work associated with the operation should terminate. 
     */
    close(): void;

    /**
     * Gets or sets a handler that's called when the operation completes. 
     */
    completed: undefined.AsyncOperationCompletedHandler<undefined.UserIdentity>;

    /**
     * Gets the error code should the operation fail. 
     */
    errorCode: Windows$WinRTError;

    /**
     * Returns a UserIdentity object that contains information about the user.
     * @return  An object containing information about the user's identity.
     */
    getResults(): undefined.UserIdentity;

    /**
     * Gets a unique identifier that represents the operation. 
     */
    id: number;

    /**
     * Gets the current status of the operation. 
     */
    status: undefined.AsyncStatus
}


/**
 * Contains the ID, tickets, and other information associated with a user. 
 */
declare class UserIdentity {

    /**
     * Contains the first name of the user. This value is available only to Microsoft application partners. 
     */
    firstName: string;

    /**
     * Gets the user's unique Microsoft account identifier. This value is available only to Microsoft application partners. 
     */
    id: string;

    /**
     * Indicates if the user is part of a beta program. This value is available only to Microsoft application partners. 
     */
    isBetaAccount: boolean;

    /**
     * Indicates if the user is on a PC that they have confirmed as their PC. This value is available only to Microsoft application partners. 
     */
    isConfirmedPC: boolean;

    /**
     * Contains the user's last name. This value is available only to Microsoft application partners. 
     */
    lastName: string;

    /**
     * Gets an obfuscated customer ID specific to the calling application. This ID allows your application to identify the user across sessions but cannot be used to share data between separate applications since each application will receive a distinct SafeCustomerId value for the same Microsoft account. 
     */
    safeCustomerId: string;

    /**
     * The sign in name of the user. This value is available only to Microsoft application partners. 
     */
    signInName: string;

    /**
     * Contains an array of tickets that identify the user. If your app uses the JWT policy, only one ticket is returned. This value is only available to Microsoft application partners. 
     */
    tickets: undefined.IVectorView<undefined.OnlineIdServiceTicket >
}


/**
 * Contains core methods for obtaining tokens from web account providers. 
 */
declare class WebAuthenticationCoreManager {

    /**
     * Finds a web account asynchronously.
     * @param provider The web account provider for the web account.
     * @param webAccountId The Id of the web account.
     * @return  When this method completes successfully, it returns the found web account.
     */
    findAccountAsync(
        provider: undefined.WebAccountProvider,
        webAccountId: string): undefined.IPromiseWithIAsyncOperation<undefined.WebAccount>;

    /**
     * Finds a web account provider asynchronously with one input.
     * @param webAccountProviderId The Id of the web account provider to find.
     * @return  When this method completes successfully, it returns the found web account provider.
     */
    findAccountProviderAsync(
        webAccountProviderId: string): undefined.IPromiseWithIAsyncOperation<undefined.WebAccountProvider>;

    /**
     * Finds a web account provider asynchronously with three inputs.
     * @param webAccountProviderId The Id of the web account provider to find.
     * @param authority The authority of the web account provider to find.
     * @param user The user associated with the web account provider to find.
     * @return  When this method completes successfully, it returns the found web account provider.
     */
    findAccountProviderAsync(
        webAccountProviderId: string,
        authority: string,
        user: undefined.User): undefined.IPromiseWithIAsyncOperation<undefined.WebAccountProvider>;

    /**
     * Finds a web account provider asynchronously with two inputs.
     * @param webAccountProviderId The Id of the web account provider to find.
     * @param authority The authority of the web account provider to find.
     * @return  When this method completes successfully, it returns the found web account provider.
     */
    findAccountProviderAsync(
        webAccountProviderId: string,
        authority: string): undefined.IPromiseWithIAsyncOperation<undefined.WebAccountProvider>;

    /**
     * Attempts to get a token without showing any UI using one input. The user will never be prompted to enter their credentials.
     * @param request The web token request.
     * @return  When this method completes successfully, it returns the result of the web token request.
     */
    getTokenSilentlyAsync(
        request: undefined.WebTokenRequest): undefined.IPromiseWithIAsyncOperation<undefined.WebTokenRequestResult>;

    /**
     * Attempts to get a token without showing any UI using two inputs. The user will never be prompted to enter their credentials.
     * @param request The web token request.
     * @param webAccount The web account.
     * @return  When this method completes successfully, it returns the result of the web token request.
     */
    getTokenSilentlyAsync(
        request: undefined.WebTokenRequest,
        webAccount: undefined.WebAccount): undefined.IPromiseWithIAsyncOperation<undefined.WebTokenRequestResult>;

    /**
     * Requests a token from a web account provider asynchronously. If needed, the user may be prompted to enter their credentials.
     * @param request The web token request.
     * @return  When this method completes successfully, it returns the results of the web token request.
     */
    requestTokenAsync(
        request: undefined.WebTokenRequest): undefined.IPromiseWithIAsyncOperation<undefined.WebTokenRequestResult>;

    /**
     * Requests a token from a web account provider asynchronously. If needed, the user may be prompted to enter their credentials.
     * @param request The web token request.
     * @param webAccount The web account for the request.
     * @return  When this method completes successfully, it returns the results of the web token request.
     */
    requestTokenAsync(
        request: undefined.WebTokenRequest,
        webAccount: undefined.WebAccount): undefined.IPromiseWithIAsyncOperation<undefined.WebTokenRequestResult >
}


/**
 * Represents an error from a web account provider. 
 */
declare class WebProviderError {

    /**
     * Initializes a new instance of the WebProviderError class.
     * @param errorCode The error code.
     * @param errorMessage The error message.
     */
    constructor(errorCode: number, errorMessage: string): this;

    /**
     * Gets the error code. 
     */
    errorCode: number;

    /**
     * Gets the error message. 
     */
    errorMessage: string;

    /**
     * Gets the error properties. 
     */
    properties: undefined.IMap<string, string >
}


/**
 * Represents a request to an online identity provider for an authentication token. 
 */
declare class WebTokenRequest {

    /**
     * Initializes a new instance of the WebTokenRequest class with two inputs.
     * @param provider The web account provider the request is for.
     * @param scope The scope of the request.
     */
    constructor(provider: undefined.WebAccountProvider, scope: string): this;

    /**
     * Initializes a new instance of the WebTokenRequest class with four inputs.
     * @param provider The web account provider the request is for.
     * @param scope The scope of the request.
     * @param clientId The client Id.
     * @param promptType The request prompt type.
     */
    constructor(provider: undefined.WebAccountProvider, scope: string, clientId: string, promptType: undefined.WebTokenRequestPromptType): this;

    /**
     * Initializes a new instance of the WebTokenRequest class with one inputs.
     * @param provider The web account provider the request is for.
     */
    constructor(provider: undefined.WebAccountProvider): this;

    /**
     * Initializes a new instance of the WebTokenRequest class with three inputs.
     * @param provider The web account provider the request is for.
     * @param scope The scope of the request.
     * @param clientId The client Id.
     */
    constructor(provider: undefined.WebAccountProvider, scope: string, clientId: string): this;
    appProperties: any;

    /**
     * Gets the Id of the client making the request. 
     */
    clientId: string;

    /**
     * Gets the prompt type of the request. 
     */
    promptType: undefined.WebTokenRequestPromptType;

    /**
     * Gets the properties of the request. 
     */
    properties: undefined.IMap<string, string>;

    /**
     * Gets the scope of the request. 
     */
    scope: string;

    /**
     * Gets the web account provider for the request. 
     */
    webAccountProvider: undefined.WebAccountProvider
}


/**
 * Represents the results of a web token request to an identity provider. 
 */
declare class WebTokenRequestResult {

    /**
     * Invalidates the current cached WebTokenRequestResult . Use this method if an access denied error is returned when trying to use a token.
     * @return  This method does not return an object or value.
     */
    invalidateCacheAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the response data from the web token provider. 
     */
    responseData: undefined.IVectorView<undefined.WebTokenResponse>;

    /**
     * Gets the error returned by the web provider, if any. 
     */
    responseError: undefined.WebProviderError;

    /**
     * Gets the status of the request. 
     */
    responseStatus: undefined.WebTokenRequestStatus
}


/**
 * Represents the response from a web account provider to a web token request. 
 */
declare class WebTokenResponse {

    /**
     * Initializes a new instance of the WebTokenResponse class. 
     */
    constructor(): this;

    /**
     * Initializes a new instance of the WebTokenResponse class with two inputs.
     * @param token The token.
     * @param webAccount The WebAccount .
     */
    constructor(token: string, webAccount: undefined.WebAccount): this;

    /**
     * Initializes a new instance of the WebTokenResponse class with three inputs.
     * @param token The token.
     * @param webAccount The WebAccount .
     * @param error The web provider error.
     */
    constructor(token: string, webAccount: undefined.WebAccount, error: undefined.WebProviderError): this;

    /**
     * Initializes a new instance of the WebTokenResponse class with one input.
     * @param token The token.
     */
    constructor(token: string): this;

    /**
     * Gets the properties of the response 
     */
    properties: undefined.IMap<string, string>;

    /**
     * Gets the error returned by the provider, if any. 
     */
    providerError: undefined.WebProviderError;

    /**
     * Gets the authentication token. 
     */
    token: string;

    /**
     * Gets the web account for the request. 
     */
    webAccount: undefined.WebAccount
}


/**
 * Represents the client view for a web account. Use this to control what information about an account from a provider is available to the client. 
 */
declare class WebAccountClientView {

    /**
     * Creates a new instance of the WebAccountClientView class.
     * @param viewType The client view type.
     * @param applicationCallbackUri The callback URI that indicates the completion of the operation.
     * @param accountPairwiseId The account pairwise Id.
     */
    constructor(viewType: undefined.WebAccountClientViewType, applicationCallbackUri: undefined.Uri, accountPairwiseId: string): this;

    /**
     * Creates a new instance of the WebAccountClientView class.
     * @param viewType The client view type.
     * @param applicationCallbackUri The callback URI that indicates the completion of the operation.
     */
    constructor(viewType: undefined.WebAccountClientViewType, applicationCallbackUri: undefined.Uri): this;

    /**
     * Gets the account pairwise Id. 
     */
    accountPairwiseId: string;

    /**
     * Gets the app callback Uri. 
     */
    applicationCallbackUri: undefined.Uri;

    /**
     * Gets the type of web account client view. 
     */
    type: undefined.WebAccountClientViewType
}


/**
 * Provides methods for managing web accounts. 
 */
declare class WebAccountManager {

    /**
     * Adds a new web account asynchronously with three inputs.
     * @param webAccountId The Id for the web account.
     * @param webAccountUserName The user name for the web account.
     * @param props Properties for the web account.
     * @return  When this method completes, it returns the new web account.
     */
    addWebAccountAsync(
        webAccountId: string,
        webAccountUserName: string,
        props: undefined.IMapView<string, string>): undefined.IPromiseWithIAsyncOperation<undefined.WebAccount>;

    /**
     * Adds a new web account asynchronously with four inputs.
     * @param webAccountId The Id for the web account.
     * @param webAccountUserName The user name for the web account.
     * @param props Properties for the web account.
     * @param scope The scope of the web account.
     * @return  When this method completes, it returns the new web account.
     */
    addWebAccountAsync(
        webAccountId: string,
        webAccountUserName: string,
        props: undefined.IMapView<string, string>,
        scope: undefined.WebAccountScope): undefined.IPromiseWithIAsyncOperation<undefined.WebAccount>;

    /**
     * Clears the view for a web account.
     * @param webAccount The web account to clear the view for.
     * @param applicationCallbackUri The callback Uri that indicates the completion of the operation. The broker matches this Uri against every Uri that it is about to navigate to. The broker never navigates to this Uri, instead the broker returns the control back to the application when the user clicks a link or a web server redirection is made.
     * @return  This method does not return a value.
     */
    clearViewAsync(
        webAccount: undefined.WebAccount,
        applicationCallbackUri: undefined.Uri): undefined.IPromiseWithIAsyncAction;

    /**
     * Clears a web account picture asynchronously.
     * @param webAccount The web account to clear the picture from.
     * @return  This method does not return a value.
     */
    clearWebAccountPictureAsync(webAccount: undefined.WebAccount): undefined.IPromiseWithIAsyncAction;

    /**
     * Deletes a web account asynchronously.
     * @param webAccount The WebAccount to delete.
     * @return  This method does not return a value.
     */
    deleteWebAccountAsync(webAccount: undefined.WebAccount): undefined.IPromiseWithIAsyncAction;

    /**
     * Finds all provider web accounts asynchronously.
     * @return  When this method completes, it returns all provider web accounts.
     */
    findAllProviderWebAccountsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the scope of the web account.
     * @param webAccount The web account to get scope for.
     * @return  The scope of the web account.
     */
    getScope(webAccount: undefined.WebAccount): undefined.WebAccountScope;

    /**
     * Gets the views for a web account asynchronously.
     * @param webAccount The web account to get views for.
     * @return  When this method completes, it returns the views for the web account.
     */
    getViewsAsync(
        webAccount: undefined.WebAccount): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Pulls cookies asynchronously. Use this to enable single sign-on in an app after a user has entered their credentials into a web browser.
     * @param uriString The Uri to pull cookies from.
     * @param callerPFN The caller's package family name.
     * @return  This method does not return a value.
     */
    pullCookiesAsync(uriString: string, callerPFN: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Pushes cookies asynchronously. Use this to enable single sign-on for a web account in a browser after the user has entered their credentials into the app.
     * @param uri The Uri to push the cookies to.
     * @param cookies The cookies to push.
     * @return  This method does not return a value.
     */
    pushCookiesAsync(
        uri: undefined.Uri,
        cookies: undefined.IVectorView<undefined.HttpCookie>): undefined.IPromiseWithIAsyncAction;

    /**
     * Sets the scope of a web account asynchronously.
     * @param webAccount The web account to set scope for.
     * @param scope The scope to set.
     * @return  This method does not return a value.
     */
    setScopeAsync(
        webAccount: undefined.WebAccount,
        scope: undefined.WebAccountScope): undefined.IPromiseWithIAsyncAction;

    /**
     * Sets the view for a web account asynchronously.
     * @param webAccount The web account to set the view for.
     * @param view The view to set.
     * @return  This method does not return a value.
     */
    setViewAsync(
        webAccount: undefined.WebAccount,
        view: undefined.WebAccountClientView): undefined.IPromiseWithIAsyncAction;

    /**
     * Sets the picture of a web account asynchronously.
     * @param webAccount The web account to set the picture for.
     * @param webAccountPicture The picture to set.
     * @return  This method does not return a value.
     */
    setWebAccountPictureAsync(
        webAccount: undefined.WebAccount,
        webAccountPicture: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncAction;

    /**
     * Updates the properties of a web account asynchronously.
     * @param webAccount The web account to update.
     * @param webAccountUserName The username to update.
     * @param additionalProperties The properties to update.
     * @return  This method does not return a value.
     */
    updateWebAccountPropertiesAsync(
        webAccount: undefined.WebAccount,
        webAccountUserName: string,
        additionalProperties: undefined.IMapView<string, string>): undefined.IPromiseWithIAsyncAction
}


/**
 * Represents an add account operation. 
 */
declare class WebAccountProviderAddAccountOperation {

    /**
     * Gets the kind of web account provider operation. 
     */
    kind: undefined.WebAccountProviderOperationKind;

    /**
     * Informs the activating app that the operation completed successfully. 
     */
    reportCompleted(): void
}


/**
 * Represents a delete account operation. 
 */
declare class WebAccountProviderDeleteAccountOperation {

    /**
     * Gets the kind of web account provider operation. 
     */
    kind: undefined.WebAccountProviderOperationKind;

    /**
     * Informs the activating app that the operation completed successfully. 
     */
    reportCompleted(): void;

    /**
     * Informs the activating app that the operation encountered an error.
     * @param value The type of error encountered.
     */
    reportError(value: undefined.WebProviderError): void;

    /**
     * Gets the web account to delete. 
     */
    webAccount: undefined.WebAccount
}


/**
 * Represents a get token silently operation. 
 */
declare class WebAccountProviderGetTokenSilentOperation {

    /**
     * Gets or sets the cache expiration time. 
     */
    cacheExpirationTime: Date;

    /**
     * Gets the kind of web account provider operation. 
     */
    kind: undefined.WebAccountProviderOperationKind;

    /**
     * Gets the web provider token request. 
     */
    providerRequest: undefined.WebProviderTokenRequest;

    /**
     * Gets the web provider token responses. 
     */
    providerResponses: undefined.IVector<undefined.WebProviderTokenResponse>;

    /**
     * Informs the activating app that the operation completed successfully. 
     */
    reportCompleted(): void;

    /**
     * Informs the activating app that the operation encountered an error.
     * @param value The type of error encountered.
     */
    reportError(value: undefined.WebProviderError): void;

    /**
     * Informs the activating app that user interaction is required to continue the operation. 
     */
    reportUserInteractionRequired(): void;

    /**
     * Informs the activating app that an error has occurred and user interaction is required to continue the operation.
     * @param value The error that has occurred.
     */
    reportUserInteractionRequired(value: undefined.WebProviderError): void
}


/**
 * Represents a manage account operation. 
 */
declare class WebAccountProviderManageAccountOperation {

    /**
     * Gets the kind of web provider operation. 
     */
    kind: undefined.WebAccountProviderOperationKind;

    /**
     * Informs the activating application that the operation completed successfully. 
     */
    reportCompleted(): void;

    /**
     * Gets the web account to manage. 
     */
    webAccount: undefined.WebAccount
}


/**
 * Represents a request token operation. 
 */
declare class WebAccountProviderRequestTokenOperation {

    /**
     * Gets or sets the cache expiration time. 
     */
    cacheExpirationTime: Date;

    /**
     * Gets the kind of web account provider operation. 
     */
    kind: undefined.WebAccountProviderOperationKind;

    /**
     * Gets the web provider token request. 
     */
    providerRequest: undefined.WebProviderTokenRequest;

    /**
     * Gets the web provider token responses. 
     */
    providerResponses: undefined.IVector<undefined.WebProviderTokenResponse>;

    /**
     * Informs the activating app that the operation completed successfully. 
     */
    reportCompleted(): void;

    /**
     * Informs the activating app that the operation encountered an error.
     * @param value The type of error encountered.
     */
    reportError(value: undefined.WebProviderError): void;

    /**
     * Informs the activating app that the user cancelled the operation. 
     */
    reportUserCanceled(): void
}


/**
 * Represents a retrieve cookies operation made by a web account provider. 
 */
declare class WebAccountProviderRetrieveCookiesOperation {

    /**
     * Gets the app callback Uri. 
     */
    applicationCallbackUri: undefined.Uri;

    /**
     * Gets the context of the retrieve cookies operation. 
     */
    context: undefined.Uri;

    /**
     * Gets the cookies. 
     */
    cookies: undefined.IVector<undefined.HttpCookie>;

    /**
     * Gets the kind of web account provider operation. 
     */
    kind: undefined.WebAccountProviderOperationKind;

    /**
     * Informs the activating app that the operation completed successfully. 
     */
    reportCompleted(): void;

    /**
     * Informs the activating app that the operation encountered an error.
     * @param value The type of error encountered.
     */
    reportError(value: undefined.WebProviderError): void;

    /**
     * Gets or sets the Uri to retrieve cookies from. 
     */
    uri: undefined.Uri
}


/**
 * Represents a sign out account operation made by a web account provider. 
 */
declare class WebAccountProviderSignOutAccountOperation {

    /**
     * Gets the app callback Uri. 
     */
    applicationCallbackUri: undefined.Uri;

    /**
     * Gets the client Id. 
     */
    clientId: string;

    /**
     * Gets the kind of web account provider operation. 
     */
    kind: undefined.WebAccountProviderOperationKind;

    /**
     * Informs the activating app that the operation completed successfully. 
     */
    reportCompleted(): void;

    /**
     * Informs the activating app that the operation encountered an error.
     * @param value The type of error encountered.
     */
    reportError(value: undefined.WebProviderError): void;

    /**
     * Gets the web account to sign out. 
     */
    webAccount: undefined.WebAccount
}


/**
 * Provides information about a web account provider trigger. 
 */
declare class WebAccountProviderTriggerDetails {

    /**
     * Gets the web account provider operation. 
     */
    operation: undefined.IWebAccountProviderOperation
}


/**
 * Represents a request for a token from a client to a provider. 
 */
declare class WebProviderTokenRequest {

    /**
     * Gets the app callback Uri. 
     */
    applicationCallbackUri: undefined.Uri;

    /**
     * Gets the web token request made by the client. 
     */
    clientRequest: undefined.WebTokenRequest;

    /**
     * Gets a token binding key for the app asynchronously.
     * @param keyType The type of key to get.
     * @param target The target Uri.
     * @return  When this method completes, it returns a cryptographic key.
     */
    getApplicationTokenBindingKeyAsync(
        keyType: undefined.TokenBindingKeyType,
        target: undefined.Uri): undefined.IPromiseWithIAsyncOperation<undefined.CryptographicKey>;

    /**
     * Gets the web account selection options. 
     */
    webAccountSelectionOptions: undefined.WebAccountSelectionOptions;

    /**
     * Gets the web accounts for the request. 
     */
    webAccounts: undefined.IVectorView<undefined.WebAccount >
}


/**
 * Represents a web provider token response. 
 */
declare class WebProviderTokenResponse {

    /**
     * Creates a new instance of the WebProviderTokenResponse class.
     * @param webTokenResponse The web token response from the client.
     */
    constructor(webTokenResponse: undefined.WebTokenResponse): this;

    /**
     * Gets the response from the provider to the client. 
     */
    clientResponse: undefined.WebTokenResponse
}


/**
 * Defines properties for web account provider operations. 
 */
declare interface Provider$IWebAccountProviderOperation {

    /**
     * Gets the kind of web account provider operation. 
     */
    kind: undefined.WebAccountProviderOperationKind
}


/**
 * Starts the authentication operation. You can call the methods of this class multiple times in a single application or across multiple applications at the same time. 
 */
declare class WebAuthenticationBroker {

    /**
     * Starts the authentication operation with two inputs.
     * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
     * @param callbackUri The callback URI that indicates the completion of the web authentication. The broker matches this URI against every URI that it is about to navigate to. The broker never navigates to this URI, instead the broker returns the control back to the application when the user clicks a link or a web server redirection is made.
     */
    authenticateAndContinue(requestUri: undefined.Uri, callbackUri: undefined.Uri): void;

    /**
     * Starts the authentication operation with one input.
     * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
     */
    authenticateAndContinue(requestUri: undefined.Uri): void;

    /**
     * Starts the authentication operation with four inputs.
     * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
     * @param callbackUri The callback URI that indicates the completion of the web authentication. The broker matches this URI against every URI that it is about to navigate to. The broker never navigates to this URI, instead the broker returns the control back to the application when the user clicks a link or a web server redirection is made.
     * @param continuationData Continuation data to be passed as part of the authentication operation.
     * @param options The options for the authentication operation.
     */
    authenticateAndContinue(
        requestUri: undefined.Uri,
        callbackUri: undefined.Uri,
        continuationData: undefined.ValueSet,
        options: undefined.WebAuthenticationOptions): void;

    /**
     * Starts the asynchronous authentication operation with three inputs. You can call this method multiple times in a single application or across multiple applications at the same time.
     * @param options The options for the authentication operation.
     * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
     * @param callbackUri The callback URI that indicates the completion of the web authentication. The broker matches this URI against every URI that it is about to navigate to. The broker never navigates to this URI, instead the broker returns the control back to the application when the user clicks a link or a web server redirection is made.
     * @return  The way to query the status and get the results of the authentication operation. If you are getting an invalid parameter error, the most common cause is that you are not using HTTPS for the requestUri parameter.
     */
    authenticateAsync(
        options: undefined.WebAuthenticationOptions,
        requestUri: undefined.Uri,
        callbackUri: undefined.Uri): undefined.IPromiseWithIAsyncOperation<undefined.WebAuthenticationResult>;

    /**
     * Starts the asynchronous authentication operation with two inputs. You can call this method multiple times in a single application or across multiple applications at the same time.
     * @param options The options for the authentication operation.
     * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
     * @return  The way to query the status and get the results of the authentication operation. If you are getting an invalid parameter error, the most common cause is that you are not using HTTPS for the requestUri parameter.
     */
    authenticateAsync(
        options: undefined.WebAuthenticationOptions,
        requestUri: undefined.Uri): undefined.IPromiseWithIAsyncOperation<undefined.WebAuthenticationResult>;

    /**
     * Starts the asynchronous authentication operation silently (no UI will be shown) with two inputs. You can call this method multiple times in a single application or across multiple applications at the same time.
     * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
     * @param options The options for the authentication operation.
     * @return  The way to query the status and get the results of the authentication operation. If you are getting an invalid parameter error, the most common cause is that you are not using HTTPS for the requestUri parameter.
     */
    authenticateSilentlyAsync(
        requestUri: undefined.Uri,
        options: undefined.WebAuthenticationOptions): undefined.IPromiseWithIAsyncOperation<undefined.WebAuthenticationResult>;

    /**
     * Starts the asynchronous authentication operation silently (no UI will be shown) with one input. You can call this method multiple times in a single application or across multiple applications at the same time.
     * @param requestUri The starting URI of the web service. This URI must be a secure address of https://.
     * @return  The way to query the status and get the results of the authentication operation. If you are getting an invalid parameter error, the most common cause is that you are not using HTTPS for the requestUri parameter.
     */
    authenticateSilentlyAsync(
        requestUri: undefined.Uri): undefined.IPromiseWithIAsyncOperation<undefined.WebAuthenticationResult>;

    /**
     * Gets the current application callback URI.
     * @return  The URI of the current application.
     */
    getCurrentApplicationCallbackUri(): undefined.Uri
}


/**
 * Indicates the result of the authentication operation. 
 */
declare class WebAuthenticationResult {

    /**
     * Contains the protocol data when the operation successfully completes. 
     */
    responseData: string;

    /**
     * Returns the HTTP error code when ResponseStatus is equal to WebAuthenticationStatus.ErrorHttp . This is only available if there is an error. 
     */
    responseErrorDetail: number;

    /**
     * Contains the status of the asynchronous operation when it completes. 
     */
    responseStatus: undefined.WebAuthenticationStatus
}


/**
 * Represents a key credential, an RSA, 2048-bit, asymmetric key that represents a user's identity for an application. 
 */
declare class KeyCredential {

    /**
     * Gets an attestation for a key credential. Call this method after provisioning a key credential for the current user and application.
     * @return  When this method completes, it returns a key credential attestation result.
     */
    getAttestationAsync(): undefined.IPromiseWithIAsyncOperation<undefined.KeyCredentialAttestationResult>;

    /**
     * Gets the name of the key credential. 
     */
    name: string;

    /**
     * Prompts the user to cryptographcally sign data using their key credential.
     * @param data The data to cryptographically sign.
     * @return  When this method completes, it returns a key credential operation result.
     */
    requestSignAsync(
        data: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.KeyCredentialOperationResult>;

    /**
     * Gets the public portion of the asymmetric KeyCredential .
     * @return  The public portion of the asymmetric key credential.
     */
    retrievePublicKey(): undefined.IBuffer;

    /**
     * Gets the public portion of the asymmetric KeyCredential .
     * @param blobType The blob type of the public key to retrieve.
     * @return  The public portion of the asymmetric key credential.
     */
    retrievePublicKey(blobType: undefined.CryptographicPublicKeyBlobType): undefined.IBuffer
}


/**
 * Represents the results of the KeyCredential.GetAttestationAsync method. 
 */
declare class KeyCredentialAttestationResult {

    /**
     * Gets the attestation information for the KeyCredential. 
     */
    attestationBuffer: undefined.IBuffer;

    /**
     * Gets the chain of certificates used to verify the attestation. 
     */
    certificateChainBuffer: undefined.IBuffer;

    /**
     * Gets the status of the key credential attestation. 
     */
    status: undefined.KeyCredentialAttestationStatus
}


/**
 * Contains methods for basic management of key credentials. 
 */
declare class KeyCredentialManager {

    /**
     * Deletes a previously provisioned user identity key for the current user and application.
     * @param name The name of the key to delete.
     * @return  This method does not return a value.
     */
    deleteAsync(name: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Determines if the current device and user is capable of provisioning a key credential.
     * @return  When this method completes, it returns true if the current device and user is capable of provisioning a key credential. Otherwise, it returns false.
     */
    isSupportedAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Retrieves a key credential for the current user and application.
     * @param name The name of the key credential to open.
     * @return  When this method completes, it returns the results of the key credential retrieval.
     */
    openAsync(
        name: string): undefined.IPromiseWithIAsyncOperation<undefined.KeyCredentialRetrievalResult>;

    /**
     * Renews an attestation for a key credential.
     * @return  This method does not return a value.
     */
    renewAttestationAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Creates a new key credential for the current user and application.
     * @param name The name of the key credential to create.
     * @param option Options for the creation operation.
     * @return  When this method completes, it returns the results of the key credential creation.
     */
    requestCreateAsync(
        name: string,
        option: undefined.KeyCredentialCreationOption): undefined.IPromiseWithIAsyncOperation<undefined.KeyCredentialRetrievalResult >
}


/**
 * Represents the result of a key credential operation. 
 */
declare class KeyCredentialOperationResult {

    /**
     * Gets the result of the key credential operation. 
     */
    result: undefined.IBuffer;

    /**
     * Gets the status of the key credential. 
     */
    status: undefined.KeyCredentialStatus
}


/**
 * Represents the result of a key credential retrieval. 
 */
declare class KeyCredentialRetrievalResult {

    /**
     * Gets the key credential. 
     */
    credential: undefined.KeyCredential;

    /**
     * Gets the status of the key credential. 
     */
    status: undefined.KeyCredentialStatus
}


/**
 * Represents the password credential store. 
 */
declare class PasswordCredential {

    /**
     * Creates and initializes a new instance of the PasswordCredential object that contains the provided credential data.
     * @param resource The resource for which the credentials are used.
     * @param userName The user name that must be present in the credentials.
     * @param password The password for the created credentials.
     */
    constructor(resource: string, userName: string, password: string): this;

    /**
     * Creates and initializes a new, empty instance of the PasswordCredential object. 
     */
    constructor(): this;

    /**
     * Gets or sets the password string of the credential. 
     */
    password: string;

    /**
     * This API is intended for internal use only should not be used in your code. 
     */
    properties: undefined.IPropertySet;

    /**
     * Gets or sets the resource of the credential. 
     */
    resource: string;

    /**
     * Populates the password for the credential. After the operation returns successfully, you can get the password from the Password property. 
     */
    retrievePassword(): void;

    /**
     * Gets or sets the user name of the credential. 
     */
    userName: string
}


/**
 * Represents the password credential property store. This class and its members are reserved for internal use and are not intended to be used in your code. 
 */
declare class PasswordCredentialPropertyStore {

    /**
     * This method is reserved for internal use and is not intended to be used in your code. 
     */
    constructor(): this;

    /**
     * This method is reserved for internal use and is not intended to be used in your code. 
     */
    clear(): void;

    /**
     * This method is reserved for internal use and is not intended to be used in your code.
     */
    first(): any;

    /**
     * This method is reserved for internal use and is not intended to be used in your code.
     */
    getView(): any;

    /**
     * This method is reserved for internal use and is not intended to be used in your code.
     * @param key Reserved.
     */
    hasKey(key: string): any;

    /**
     * This method is reserved for internal use and is not intended to be used in your code.
     * @param key Reserved.
     * @param value Reserved.
     */
    insert(key: string, value: any): any;

    /**
     * This method is reserved for internal use and is not intended to be used in your code.
     * @param key Reserved.
     */
    lookup(key: string): any;

    /**
     * This method is reserved for internal use and is not intended to be used in your code. 
     */
    onmapchanged: undefined.MapChangedEventHandler<string, any>;
    addEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, any>): void;
    removeEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, any>): void;

    /**
     * This method is reserved for internal use and is not intended to be used in your code.
     * @param key Reserved.
     */
    remove(key: string): void;

    /**
     * This method is reserved for internal use and is not intended to be used in your code. 
     */
    size: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a Credential Locker of credentials. The contents of the locker are specific to the app or service. Apps and services don't have access to credentials associated with other apps or services. 
 */
declare class PasswordVault {

    /**
     * Creates and initializes a new instance of the PasswordVault object. 
     */
    constructor(): this;

    /**
     * Adds a credential to the Credential Locker.
     * @param credential The credential to be added.
     */
    add(credential: undefined.PasswordCredential): void;

    /**
     * Searches the Credential Locker for credentials matching the resource specified.
     * @param resource The resource to be searched for.
     * @return  When this method returns, contains an IVectorView of credential objects that match the search criteria.
     */
    findAllByResource(resource: string): undefined.IVectorView<undefined.PasswordCredential>;

    /**
     * Searches the Credential Locker for credentials that match the user name specified.
     * @param userName The user name to be searched for.
     * @return  When this method returns, contains an IVectorView of credential objects that match the search criteria.
     */
    findAllByUserName(userName: string): undefined.IVectorView<undefined.PasswordCredential>;

    /**
     * Removes a credential from the Credential Locker.
     * @param credential The credential to be removed.
     */
    remove(credential: undefined.PasswordCredential): void;

    /**
     * Reads a credential from the Credential Locker.
     * @param resource The resource for which the credential is used.
     * @param userName The user name that must be present in the credential.
     * @return  The returned credential that contains all the data.
     */
    retrieve(resource: string, userName: string): undefined.PasswordCredential;

    /**
     * Retrieves all of the credentials stored in the Credential Locker.
     * @return  When this method returns, contains an IVectorView output of credential objects that match the search criteria. This output is a snapshot and not dynamic. If the results are used for updating or deleting credentials, those changes won't be reflected in the previous output.
     */
    retrieveAll(): undefined.IVectorView<undefined.PasswordCredential >
}


/**
 * Creates an asynchronous object that displays a dialog box of credentials to the user and collects the user's response. 
 */
declare class CredentialPicker {

    /**
     * Constructor used to initiate asynchronous prompting operations using three inputs.
     * @param targetName The target name to display.
     * @param message The message to display in the dialog box.
     * @param caption The caption to display in the dialog box.
     * @return  The credential and options from the user.
     */
    pickAsync(
        targetName: string,
        message: string,
        caption: string): undefined.IPromiseWithIAsyncOperation<undefined.CredentialPickerResults>;

    /**
     * Constructor used to initiate asynchronous prompting operations using two inputs.
     * @param targetName The target name to display.
     * @param message The message to display in the dialog box.
     * @return  The credential and options from the user.
     */
    pickAsync(
        targetName: string,
        message: string): undefined.IPromiseWithIAsyncOperation<undefined.CredentialPickerResults>;

    /**
     * Displays a dialog box to the user and collects credentials from the user.
     * @param options The options on displaying and collecting the credential box.
     * @return  The credential and options from the user.
     */
    pickAsync(
        options: undefined.CredentialPickerOptions): undefined.IPromiseWithIAsyncOperation<undefined.CredentialPickerResults >
}


/**
 * Controls the appearance and behavior of a credential prompt. 
 */
declare class CredentialPickerOptions {

    /**
     * Creates and initializes a new, empty instance of the CredentialPickerOptions object. 
     */
    constructor(): this;

    /**
     * Gets or sets the option of whether the dialog box is displayed. 
     */
    alwaysDisplayDialog: boolean;

    /**
     * Gets or sets the authentication protocol. 
     */
    authenticationProtocol: undefined.AuthenticationProtocol;

    /**
     * Gets or sets whether the caller wants to save the credentials. 
     */
    callerSavesCredential: boolean;

    /**
     * Gets or sets the caption text that is displayed to the user. 
     */
    caption: string;

    /**
     * Gets or sets the option on saving credentials. 
     */
    credentialSaveOption: undefined.CredentialSaveOption;

    /**
     * Gets or sets whether the authentication protocol is custom rather than a standard authentication protocol. 
     */
    customAuthenticationProtocol: string;

    /**
     * Gets or sets the error code. 
     */
    errorCode: number;

    /**
     * Gets or sets the body of text that displays to the user. 
     */
    message: string;

    /**
     * Gets or sets whether to fill dialog box fields with previous credentials. 
     */
    previousCredential: undefined.IBuffer;

    /**
     * Gets or sets the name of the target computer. 
     */
    targetName: string
}


/**
 * Describes the results of the dialog box operation. 
 */
declare class CredentialPickerResults {

    /**
     * Gets the opaque credential. 
     */
    credential: undefined.IBuffer;

    /**
     * Gets the domain name portion of the unpacked credential. 
     */
    credentialDomainName: string;

    /**
     * Gets the password portion of the unpacked credential. 
     */
    credentialPassword: string;

    /**
     * Gets the state of the "Save Credentials" check box. 
     */
    credentialSaveOption: undefined.CredentialSaveOption;

    /**
     * Gets the status of the credential save operation. 
     */
    credentialSaved: boolean;

    /**
     * Gets the user name of the unpacked credential. 
     */
    credentialUserName: string;

    /**
     * Gets the value of the error code. 
     */
    errorCode: number
}


/**
 * Checks for availability of a biometric (fingerprint) verifier device and performs a biometric verification. 
 */
declare class UserConsentVerifier {

    /**
     * Checks to see whether a biometric (fingerprint) verifier device is available.
     * @return  A UserConsentVerifierAvailability value that describes the result of the availability check operation.
     */
    checkAvailabilityAsync(): undefined.IPromiseWithIAsyncOperation<undefined.UserConsentVerifierAvailability>;

    /**
     * Performs a fingerprint (biometric) verification.
     * @param message A message to display to the user for this biometric verification request.
     * @return  A UserConsentVerificationResult value that describes the result of the biometric verification.
     */
    requestVerificationAsync(
        message: string): undefined.IPromiseWithIAsyncOperation<undefined.UserConsentVerificationResult >
}


/**
 * Identifies an account from a web account provider. 
 */
declare class WebAccount {

    /**
     * Creates an instance of the WebAccount class.
     * @param webAccountProvider The web account provider associated with the web account.
     * @param userName The user name of the web account.
     * @param state The state of the web account.
     */
    constructor(webAccountProvider: undefined.WebAccountProvider, userName: string, state: undefined.WebAccountState): this;

    /**
     * Gets the web account's picture asynchronously.
     * @param desizedSize The desired size of the web account picture.
     * @return  When this method completes, it returns the web account's picture.
     */
    getPictureAsync(
        desizedSize: undefined.WebAccountPictureSize): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStream>;

    /**
     * Gets the Id of the web account. 
     */
    id: string;

    /**
     * Gets the properties of the web account. 
     */
    properties: undefined.IMapView<string, string>;

    /**
     * Signs the web account out asynchronously. This clears all cached tokens associated with the account, and tells the provider to invalidate any tokens associated with the account for this app.
     * @param clientId The Id of the client.
     * @return  This method does not return a value.
     */
    signOutAsync(clientId: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Signs the web account out asynchronously. This clears all cached tokens associated with the account, and tells the provider to invalidate any tokens associated with the account for this app.
     * @return  This method does not return a value.
     */
    signOutAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the connected state of the web account. 
     */
    state: undefined.WebAccountState;

    /**
     * Gets the username for the web account. 
     */
    userName: string;

    /**
     * Gets the web authentication provider for the account. 
     */
    webAccountProvider: undefined.WebAccountProvider
}


/**
 * Represents a web account authentication provider. 
 */
declare class WebAccountProvider {

    /**
     * Creates an instance of the WebAccountProvider class.
     * @param id The web account provider id.
     * @param displayName The display name for the web account provider.
     * @param iconUri The Uri of the icon image to display for the web account provider.
     */
    constructor(id: string, displayName: string, iconUri: undefined.Uri): this;

    /**
     * Gets the authority of the web account provider. Use authority to disambiguate between a single provider with multiple identities (such as a Microsoft account versus Azure Active Directory). 
     */
    authority: string;

    /**
     * Gets the display name for the web account provider. 
     */
    displayName: string;

    /**
     * Gets the display purpose of the web account provider. 
     */
    displayPurpose: string;

    /**
     * Gets the Uri of the icon image to display for the web account provider. 
     */
    iconUri: undefined.Uri;

    /**
     * Gets the web account provider id. 
     */
    id: string;

    /**
     * Gets the user associated with the provider. 
     */
    user: undefined.User
}


/**
 * Represents a cryptography certificate. 
 */
declare class Certificate {

    /**
     * Create a new instance of the Certificate class using the specified certificate data.
     * @param certBlob The certificate data as an ASN.1 DER encoded certificate blob (.cer or .p7b).
     */
    constructor(certBlob: undefined.IBuffer): this;

    /**
     * Build a certificate chain for the specified certificates starting from the end entity certificate to the root using the specified chain building parameters.
     * @param certificates The intermediate certificates to use when building the certificate chain.
     * @param parameters The chain building paramaters to use when building the certificate chain.
     * @return  An asynchronous operation to retrieve the CertificateChain object that contains the entire certificate chain.
     */
    buildChainAsync(
        certificates: undefined.IIterable<undefined.Certificate>,
        parameters: undefined.ChainBuildingParameters): undefined.IPromiseWithIAsyncOperation<undefined.CertificateChain>;

    /**
     * Build a certificate chain for the specified certificates starting from the end entity certificate to the root.
     * @param certificates The intermediate certificates to use when building the certificate chain.
     * @return  An asynchronous operation to retrieve the CertificateChain object that contains the entire certificate chain.
     */
    buildChainAsync(
        certificates: undefined.IIterable<undefined.Certificate>): undefined.IPromiseWithIAsyncOperation<undefined.CertificateChain>;

    /**
     * Gets a collection of object identifiers (OIDs) for the enhanced key usage extension. 
     */
    enhancedKeyUsages: undefined.IVectorView<string>;

    /**
     * Gets or sets the friendly name for the certificate. 
     */
    friendlyName: string;

    /**
     * Gets the ASN.1 DER encoded certificate blob.
     * @return  The ASN.1 DER encoded certificate blob.
     */
    getCertificateBlob(): undefined.IBuffer;

    /**
     * Gets the hash value for the certificate for a specified algorithm.
     * @param hashAlgorithmName The hash algorithm to use for the hash value of the certificate. Only values of "SHA1" or "SHA256" are supported.
     * @return  The hash value of the certificate.
     */
    getHashValue(hashAlgorithmName: string): number[];

    /**
     * Gets the SHA1 hash value for the certificate.
     * @return  The SHA1 hash value for the certificate.
     */
    getHashValue(): number[];

    /**
     * Gets a value indicating whether the certificate has a private key. 
     */
    hasPrivateKey: boolean;

    /**
     * Gets whether the security device is bound. 
     */
    isSecurityDeviceBound: boolean;

    /**
     * Gets a value that indicates whether the private key associated with the certificate is strongly protected. 
     */
    isStronglyProtected: boolean;

    /**
     * Gets the name of the certificate issuer. 
     */
    issuer: string;

    /**
     * Gets the name of the cryptographic algorithm used to create the key. 
     */
    keyAlgorithmName: string;

    /**
     * Gets the key uses for the certificate. 
     */
    keyUsages: undefined.CertificateKeyUsages;

    /**
     * Gets the serial number of the certificate. 
     */
    serialNumber: number;

    /**
     * Gets the signature algorithm name. 
     */
    signatureAlgorithmName: string;

    /**
     * Gets the signature hash algorithm name. 
     */
    signatureHashAlgorithmName: string;

    /**
     * Gets the subject name of the certificate. 
     */
    subject: string;

    /**
     * Gets info on the subject alternative name. 
     */
    subjectAlternativeName: undefined.SubjectAlternativeNameInfo;

    /**
     * Gets the date and time after which the certificate is valid. 
     */
    validFrom: Date;

    /**
     * Gets the date and time after which the certificate is no longer valid. 
     */
    validTo: Date
}


/**
 * Represents a certificate chain used for signature verification. 
 */
declare class CertificateChain {

    /**
     * Gets the list of certificates from the certificate chain.
     * @param includeRoot True to include the root certificate in the results; otherwise false.
     * @return  The list of certificates from the certificate chain.
     */
    getCertificates(includeRoot: boolean): undefined.IVectorView<undefined.Certificate>;

    /**
     * Verifies whether or not the certificate chain is valid.
     * @return  The result of the certificate chain verification operation.
     */
    validate(): undefined.ChainValidationResult;

    /**
     * Verifies whether or not the certificate chain is valid using the specified validation parameters.
     * @param parameter The validation parameters to use when verifying the certificate chain.
     * @return  The result of the certificate chain verification operation.
     */
    validate(
        parameter: undefined.ChainValidationParameters): undefined.ChainValidationResult
}


/**
 * Represents a certificate enrollment manager. 
 */
declare class CertificateEnrollmentManager {

    /**
     * Asynchronously creates a PKCS #10 certificate request based on properties specified in a CertificateRequestProperties object.
     * @param request A CertificateRequestProperties object that contains the property values used to create the certificate request.
     * @return  This method returns a string that contains the base64 encoded PKCS #10 certificate request.
     */
    createRequestAsync(
        request: undefined.CertificateRequestProperties): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message.
     * @param pfxData Base64-encoded PFX message.
     * @param password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
     * @param exportable A value of the ExportOption enumeration that specifies whether the key can be exported.
     * @param keyProtectionLevel A value of the KeyProtectionLevel enumeration that specifies the strength of the key protection. The default is NoConsent.
     * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
     * @param friendlyName The display name of the enrolled certificate. This value overwrites the FriendlyName property inside the PFX message.
     * @return  This method does not return a value.
     */
    importPfxDataAsync(
        pfxData: string,
        password: string,
        exportable: undefined.ExportOption,
        keyProtectionLevel: undefined.KeyProtectionLevel,
        installOption: undefined.InstallOptions,
        friendlyName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using the specified key storage provider.
     * @param pfxData Base64-encoded PFX message.
     * @param password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
     * @param exportable A value of the ExportOption enumeration that specifies whether the key can be exported.
     * @param keyProtectionLevel A value of the KeyProtectionLevel enumeration that specifies the strength of the key protection. The default is NoConsent.
     * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
     * @param friendlyName The display name of the enrolled certificate. This value overwrites the FriendlyName property inside the PFX message.
     * @param keyStorageProvider The name of the key storage provider to use when importing the certificate.
     * @return  This method does not return a value.
     */
    importPfxDataAsync(
        pfxData: string,
        password: string,
        exportable: undefined.ExportOption,
        keyProtectionLevel: undefined.KeyProtectionLevel,
        installOption: undefined.InstallOptions,
        friendlyName: string,
        keyStorageProvider: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using import parameters.
     * @param pfxData Base64-encoded PFX message.
     * @param password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
     * @param pfxImportParameters The PFX import parameters.
     * @return  This method does not return a value.
     */
    importPfxDataAsync(
        pfxData: string,
        password: string,
        pfxImportParameters: undefined.PfxImportParameters): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously Installs a certificate chain into the app container on the local computer.
     * @param certificate The encoded certificate. The certificate is encoded by using Distinguished Encoding Rules (DER) as defined by the Abstract Syntax Notation One (ASN.1) standard.
     * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
     * @return  This method does not return a value.
     */
    installCertificateAsync(
        certificate: string,
        installOption: undefined.InstallOptions): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the associated UserCertificateEnrollmentManager . 
     */
    userCertificateEnrollmentManager: undefined.UserCertificateEnrollmentManager
}


/**
 * Represents the usages of a certificate key. 
 */
declare class CertificateKeyUsages {

    /**
     * Creates a new instance of the CertificateKeyUsages class. 
     */
    constructor(): this;

    /**
     * Gets or sets if the key is for cRLSign. 
     */
    crlSign: boolean;

    /**
     * Gets or sets if the key is for data encipherment. 
     */
    dataEncipherment: boolean;

    /**
     * Gets or sets if the key is for digital signature. 
     */
    digitalSignature: boolean;

    /**
     * Gets or sets if the key is for encipher only. 
     */
    encipherOnly: boolean;

    /**
     * Gets or sets if the key is for key agreement. 
     */
    keyAgreement: boolean;

    /**
     * Gets or sets if the key is for key certificate sign. 
     */
    keyCertificateSign: boolean;

    /**
     * Gets or sets if the key is for key encipherment. 
     */
    keyEncipherment: boolean;

    /**
     * Gets or sets if the key is for non-repudiation. 
     */
    nonRepudiation: boolean
}


/**
 * Represents parameters for a query for certificates from the certificate store for an app. 
 */
declare class CertificateQuery {

    /**
     * Creates a new instance of a certificate query. 
     */
    constructor(): this;

    /**
     * Gets a collection of object identifiers (OIDs) for the enhanced key usage extension to search for. 
     */
    enhancedKeyUsages: undefined.IVector<string>;

    /**
     * Gets or sets the certificate friendly name to search for. 
     */
    friendlyName: string;

    /**
     * Gets or sets a value that indicates whether only hardware certificates (SC or TPM) are to be returned from the query. 
     */
    hardwareOnly: boolean;

    /**
     * Gets or sets whether to include duplicates. 
     */
    includeDuplicates: boolean;

    /**
     * Gets or sets whether to include expired certificates. 
     */
    includeExpiredCertificates: boolean;

    /**
     * Gets or sets the name of the certificate issuer to search for. 
     */
    issuerName: string;

    /**
     * Gets or sets the store name. 
     */
    storeName: string;

    /**
     * Gets or sets a certificate thumbprint to search for. 
     */
    thumbprint: number
}


/**
 * Represents the properties of a certificate request. 
 */
declare class CertificateRequestProperties {

    /**
     * Creates and initializes a new instance of the CertificateRequestProperties . 
     */
    constructor(): this;

    /**
     * Gets or sets the CA exchange certificate that is used to encrypt a key attestation certificate request. 
     */
    attestationCredentialCertificate: undefined.Certificate;

    /**
     * Gets or sets the container name. 
     */
    containerName: string;

    /**
     * Gets or sets the prefix of the container name. 
     */
    containerNamePrefix: string;

    /**
     * Gets or sets the name of the elliptic curve. 
     */
    curveName: string;

    /**
     * Gets or sets the parameters of the elliptic curve. 
     */
    curveParameters: number;

    /**
     * Gets or sets a value that specifies whether the private key created for the request can be exported. 
     */
    exportable: undefined.ExportOption;

    /**
     * Gets or sets the display name of the enrolled certificate. 
     */
    friendlyName: string;

    /**
     * Gets or sets the hash algorithm used when creating the certificate request signature. 
     */
    hashAlgorithmName: string;

    /**
     * Gets or sets the public key algorithm. 
     */
    keyAlgorithmName: string;

    /**
     * Gets or sets the level of strong key protection. 
     */
    keyProtectionLevel: undefined.KeyProtectionLevel;

    /**
     * Gets or sets the size, in bits, of the private key to be generated. 
     */
    keySize: number;

    /**
     * Gets or sets the name of the key storage provider (KSP) that will be used to generate the private key. 
     */
    keyStorageProviderName: string;

    /**
     * Gets or sets the operation that can be performed by the private key created for this certificate request. The default value is Signing. 
     */
    keyUsages: undefined.EnrollKeyUsages;

    /**
     * Gets or sets the certificate used to sign the certificate request. 
     */
    signingCertificate: undefined.Certificate;

    /**
     * Gets or sets the name of the smart card reader used to create the certificate request. 
     */
    smartcardReaderName: string;

    /**
     * Gets or sets the subject name. 
     */
    subject: string;

    /**
     * Gets or sets whether to use the existing key. 
     */
    useExistingKey: boolean
}


/**
 * Represents a certificate store for an app. 
 */
declare class CertificateStore {

    /**
     * Adds a certificate to the certificate store.
     * @param certificate The certificate to add to the certificate store.
     */
    add(certificate: undefined.Certificate): void;

    /**
     * Deletes a certificate from the certificate store.
     * @param certificate The certificate to delete from the certificate store.
     */
    delete(certificate: undefined.Certificate): void;

    /**
     * Gets the name of the certificate store. 
     */
    name: string
}


/**
 * Represents a collection of certificate stores. 
 */
declare class CertificateStores {

    /**
     * Get all certificates from the certificate stores that match the specified query parameters.
     * @param query The certificate values to search for.
     * @return  An asynchronous operation to retrieve the list of certificates.
     */
    findAllAsync(
        query: undefined.CertificateQuery): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Get all certificates from the certificate stores.
     * @return  An asynchronous operation to retrieve the list of certificates.
     */
    findAllAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets a certificate store from the collection of certificate stores by name.
     * @param storeName The name of the certificate store to return. The storeName parameter value cannot be "MY".
     * @return  The requested certificate store.
     */
    getStoreByName(storeName: string): undefined.CertificateStore;

    /**
     * Gets the certificate store of intermediate certification authorities for an app. 
     */
    intermediateCertificationAuthorities: undefined.CertificateStore;

    /**
     * Gets the certificate store of trusted root certificates for an app. 
     */
    trustedRootCertificationAuthorities: undefined.CertificateStore
}


/**
 * Represents parameters to use when building a certificate chain. 
 */
declare class ChainBuildingParameters {

    /**
     * Creates a new instance of the ChainBuildingParameters class. 
     */
    constructor(): this;

    /**
     * Gets or sets a value that indicates whether Authority Information Access (AIA) is enabled. 
     */
    authorityInformationAccessEnabled: boolean;

    /**
     * Gets or sets a value indicating that the current time is to be used for the validation timestamp. 
     */
    currentTimeValidationEnabled: boolean;

    /**
     * Gets a collection of object identifiers (OIDs) for the enhanced key usage extension. 
     */
    enhancedKeyUsages: undefined.IVector<string>;

    /**
     * Gets the list of root certificates that will be trusted. 
     */
    exclusiveTrustRoots: undefined.IVector<undefined.Certificate>;

    /**
     * Gets or sets a value indicating whether to request new URLs to use for chain building and revocation checking or to use cached URLs. 
     */
    networkRetrievalEnabled: boolean;

    /**
     * Gets or sets a value indicating whether revocation checking is enabled. 
     */
    revocationCheckEnabled: boolean;

    /**
     * Gets or sets the time stamp used to determine whether the certificate chain was time valid. 
     */
    validationTimestamp: Date
}


/**
 * Represents values to use when verifying a certificate chain. 
 */
declare class ChainValidationParameters {

    /**
     * Creates a new instance of the ChainValidationParameters class. 
     */
    constructor(): this;

    /**
     * Gets or sets the certificate chain policy to use when verifying the certificate chain. 
     */
    certificateChainPolicy: undefined.CertificateChainPolicy;

    /**
     * Gets or sets the server DNS name to use for SSL policy. 
     */
    serverDnsName: undefined.HostName
}


/**
 * Represents a signature attached to a signed CMS message. 
 */
declare class CmsAttachedSignature {

    /**
     * Signs the specified input data using the specified signer information and creates an attached signed CMS message.
     * @param data The input data to be signed.
     * @param signers The signer information used to compute the signature.
     * @param certificates The list of certificates to build the chain for the signer certificates.
     * @return  An asynchronous operation to retrieve the attached signed CMS message.
     */
    generateSignatureAsync(
        data: undefined.IBuffer,
        signers: undefined.IIterable<undefined.CmsSignerInfo>,
        certificates: undefined.IIterable<undefined.Certificate>): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Creates a new instance of the CmsAttachedSignature class for the specified signed CMS message.
     * @param inputBlob A signed CMS message blob.
     */
    constructor(inputBlob: undefined.IBuffer): this;

    /**
     * Gets the list of certificates that are used for chain building for the signer certificate. 
     */
    certificates: undefined.IVectorView<undefined.Certificate>;

    /**
     * Gets the content of the signed CMS message. 
     */
    content: number;

    /**
     * Gets the list of signers that are used for creating or verifying the signature. 
     */
    signers: undefined.IVectorView<undefined.CmsSignerInfo>;

    /**
     * Verifies the signature contained in the signed CMS message.
     * @return  The result of the signature verification operation.
     */
    verifySignature(): undefined.SignatureValidationResult
}


/**
 * Represents a detached signature for a signed CMS message. 
 */
declare class CmsDetachedSignature {

    /**
     * Signs the specified input data using the specified signer information and creates a detached signed CMS message.
     * @param data The input data to be signed.
     * @param signers The signer information used to compute the signature.
     * @param certificates The list of certificates to build the chain for the signer certificates.
     * @return  An asynchronous operation to retrieve the detached signed CMS message.
     */
    generateSignatureAsync(
        data: undefined.IInputStream,
        signers: undefined.IIterable<undefined.CmsSignerInfo>,
        certificates: undefined.IIterable<undefined.Certificate>): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Creates a new instance of the CmsDetachedSignature class for the specified signed CMS message.
     * @param inputBlob A signed CMS message blob.
     */
    constructor(inputBlob: undefined.IBuffer): this;

    /**
     * Gets the list of certificates that are used for chain building for the signer certificate. 
     */
    certificates: undefined.IVectorView<undefined.Certificate>;

    /**
     * Gets the list of signers that are used for creating or verifying the signature. 
     */
    signers: undefined.IVectorView<undefined.CmsSignerInfo>;

    /**
     * Verifies a signed CMS message against the original streaming input.
     * @param data The original input stream for the signed CMS message.
     * @return  An asynchronous operation to retrieve the result of the signature validation operation.
     */
    verifySignatureAsync(
        data: undefined.IInputStream): undefined.IPromiseWithIAsyncOperation<undefined.SignatureValidationResult >
}


/**
 * Represents signer information for a signed CMS message which contains a set of properties. 
 */
declare class CmsSignerInfo {

    /**
     * Creates a new instance of the CmsSignerInfo class. 
     */
    constructor(): this;

    /**
     * Gets or sets the signer certificate that is used to sign the message. 
     */
    certificate: undefined.Certificate;

    /**
     * Gets or sets the hash algorithm that is used to sign the CMS message. 
     */
    hashAlgorithmName: string;

    /**
     * Gets the RFC3161 unauthenticated timestamp information. 
     */
    timestampInfo: undefined.CmsTimestampInfo
}


/**
 * Represents an RFC3161 unauthenticated timestamp attribute in a signed CMS message. 
 */
declare class CmsTimestampInfo {

    /**
     * Gets the list of certificates that is used for chain building for the signing certificate. 
     */
    certificates: undefined.IVectorView<undefined.Certificate>;

    /**
     * Gets the certificate that is used to sign the timestamp. 
     */
    signingCertificate: undefined.Certificate;

    /**
     * Gets the date and time of the timestamp. 
     */
    timestamp: Date
}


/**
 * Defines several commonly used public key algorithm names. You can use this class in the KeyAlgorithmName property on the CertificateRequestProperties class. 
 */
declare class KeyAlgorithmNames {

    /**
     * Returns "DSA" as the key algorithm name. 
     */
    dsa: string;

    /**
     * Returns "ECDH" as the key algorithm name. 
     */
    ecdh: string;

    /**
     * Returns "ECDH256" as the key algorithm name. 
     */
    ecdh256: string;

    /**
     * Returns "ECDH384" as the key algorithm name. 
     */
    ecdh384: string;

    /**
     * Returns "ECDH521" as the key algorithm name. 
     */
    ecdh521: string;

    /**
     * Returns "ECDSA" as the key algorithm name. 
     */
    ecdsa: string;

    /**
     * Returns "ECDSA256" as the key algorithm name. 
     */
    ecdsa256: string;

    /**
     * Returns "ECDSA384" as the key algorithm name. 
     */
    ecdsa384: string;

    /**
     * Returns "ECDSA521" as the key algorithm name. 
     */
    ecdsa521: string;

    /**
     * Returns "RSA" as the key algorithm name. 
     */
    rsa: string
}


/**
 * Provides access to key attestation methods. 
 */
declare class KeyAttestationHelper {

    /**
     * Decrypts a TPM key attestation credential.
     * @param credential The TPM key attestation credential to decrypt.
     * @return  When this method completes, it returns the decrypted TPM key attestation credential.
     */
    decryptTpmAttestationCredentialAsync(credential: string): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Decrypts a TPM key attestation credential.
     * @param credential The TPM key attestation credential to decrypt.
     * @param containerName The container name of the credential.
     * @return  When this method completes, it returns the decrypted TPM key attestation credential.
     */
    decryptTpmAttestationCredentialAsync(
        credential: string,
        containerName: string): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Gets the credential ID from a TPM key attestation credential.
     * @param credential The TPM key attestation credential to get the credential ID from.
     * @return  The credential ID from the TPM key attestation credential.
     */
    getTpmAttestationCredentialId(credential: string): string
}


/**
 * Defines several commonly used key storage provider names. You can use this class in the KeyStorageProviderName property on the CertificateRequestProperties class. 
 */
declare class KeyStorageProviderNames {

    /**
     * Returns "Microsoft Passport Key Storage Provider" as the provider name. 
     */
    passportKeyStorageProvider: string;

    /**
     * Returns "Microsoft Platform Crypyto Key Storage Provider" as the provider name. 
     */
    platformKeyStorageProvider: string;

    /**
     * Returns "Microsoft Smart Card Key Storage Provider" as the provider name. 
     */
    smartcardKeyStorageProvider: string;

    /**
     * Returns "Microsoft Software Key Storage Provider" as the provider name. 
     */
    softwareKeyStorageProvider: string
}


/**
 * Represents PFX import parameters. 
 */
declare class PfxImportParameters {

    /**
     * Creates a new instance of the PfxImportParameters class. 
     */
    constructor(): this;

    /**
     * Gets or sets the container name prefix. 
     */
    containerNamePrefix: string;

    /**
     * Gets or sets the export option. 
     */
    exportable: undefined.ExportOption;

    /**
     * Gets or sets the friendly name. 
     */
    friendlyName: string;

    /**
     * Gets or sets the install options. 
     */
    installOptions: undefined.InstallOptions;

    /**
     * Gets or sets the key protection level. 
     */
    keyProtectionLevel: undefined.KeyProtectionLevel;

    /**
     * Gets or sets the key storage provider name. 
     */
    keyStorageProviderName: string;

    /**
     * Gets or sets the reader name. 
     */
    readerName: string
}


/**
 * Provides info about a subject alternative name. 
 */
declare class SubjectAlternativeNameInfo {

    /**
     * Creates a new instance of the SubjectAlternativeNameInfo class. 
     */
    constructor(): this;

    /**
     * Gets the distinguished name. 
     */
    distinguishedName: undefined.IVectorView<string>;

    /**
     * Gets the DNS name. 
     */
    dnsName: undefined.IVectorView<string>;

    /**
     * Gets the email name. 
     */
    emailName: undefined.IVectorView<string>;

    /**
     * Gets the IP address. 
     */
    ipAddress: undefined.IVectorView<string>;

    /**
     * Gets the principal name. 
     */
    principalName: undefined.IVectorView<string>;

    /**
     * Gets the URL. 
     */
    url: undefined.IVectorView<string >
}


/**
 * Provides access to certificate creation, import, and enrollment methods. 
 */
declare class UserCertificateEnrollmentManager {

    /**
     * Asynchronously creates a PKCS #10 certificate request based on properties specified in a CertificateRequestProperties object.
     * @param request A CertificateRequestProperties object that contains the property values used to create the certificate request.
     * @return  An asynchronous operation to retrieve the base64 encoded PKCS #10 certificate request.
     */
    createRequestAsync(
        request: undefined.CertificateRequestProperties): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Asynchronously imports a user certificate from a Personal Information Exchange (PFX) message.
     * @param pfxData Base64-encoded PFX message.
     * @param password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
     * @param exportable A value of the ExportOption enumeration that specifies whether the key can be exported.
     * @param keyProtectionLevel A value of the KeyProtectionLevel enumeration that specifies the strength of the key protection. The default is NoConsent.
     * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
     * @param friendlyName The display name of the enrolled certificate. This value overwrites the FriendlyName property inside the PFX message.
     * @return  This method does not return a value.
     */
    importPfxDataAsync(
        pfxData: string,
        password: string,
        exportable: undefined.ExportOption,
        keyProtectionLevel: undefined.KeyProtectionLevel,
        installOption: undefined.InstallOptions,
        friendlyName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using the specified key storage provider.
     * @param pfxData Base64-encoded PFX message.
     * @param password The password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
     * @param exportable A value of the ExportOption enumeration that specifies whether the key can be exported.
     * @param keyProtectionLevel A value of the KeyProtectionLevel enumeration that specifies the strength of the key protection. The default is NoConsent.
     * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
     * @param friendlyName The display name of the enrolled certificate. This value overwrites the FriendlyName property inside the PFX message.
     * @param keyStorageProvider The name of the key storage provider to use when importing the certificate.
     * @return  This method does not return a value.
     */
    importPfxDataAsync(
        pfxData: string,
        password: string,
        exportable: undefined.ExportOption,
        keyProtectionLevel: undefined.KeyProtectionLevel,
        installOption: undefined.InstallOptions,
        friendlyName: string,
        keyStorageProvider: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously imports a certificate from a Personal Information Exchange (PFX) message using the specified import parameters.
     * @param pfxData Base64-encoded PFX message.
     * @param password he password used to decrypt and verify the PFX packet. The password must be exactly the same as the password that was used to encrypt the packet.
     * @param pfxImportParameters The import parameters.
     * @return  This method does not return a value.
     */
    importPfxDataAsync(
        pfxData: string,
        password: string,
        pfxImportParameters: undefined.PfxImportParameters): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously installs a certificate chain into the app container on the local computer.
     * @param certificate The encoded certificate. The certificate is encoded by using Distinguished Encoding Rules (DER) as defined by the Abstract Syntax Notation One (ASN.1) standard.
     * @param installOption An InstallOptions enumeration value that specifies the certificate installation option.
     * @return  This method does not return a value.
     */
    installCertificateAsync(
        certificate: string,
        installOption: undefined.InstallOptions): undefined.IPromiseWithIAsyncAction
}


/**
 * Contains static properties that enable you to retrieve algorithm names that can be used in the OpenAlgorithm method of the AsymmetricKeyAlgorithmProvider class. 
 */
declare class AsymmetricAlgorithmNames {

    /**
     * Retrieves a string that contains "DSA_SHA1". 
     */
    dsaSha1: string;

    /**
     * Retrieves a string that contains "DSA_SHA256". 
     */
    dsaSha256: string;

    /**
     * Retrieves a string that contains "ECDSA_P256_SHA256". 
     */
    ecdsaP256Sha256: string;

    /**
     * Retrieves a string that contains "ECDSA_P384_SHA384". 
     */
    ecdsaP384Sha384: string;

    /**
     * Retrieves a string that contains "ECDSA_P521_SHA512". 
     */
    ecdsaP521Sha512: string;

    /**
     * Retrieves a string that contains "ECDSA_SHA256". 
     */
    ecdsaSha256: string;

    /**
     * Retrieves a string that contains "ECDSA_SHA384". 
     */
    ecdsaSha384: string;

    /**
     * Retrieves a string that contains "ECDSA_SHA512". 
     */
    ecdsaSha512: string;

    /**
     * Retrieves a string that contains "RSA_OAEP_SHA1". 
     */
    rsaOaepSha1: string;

    /**
     * Retrieves a string that contains "RSA_OAEP_SHA256". 
     */
    rsaOaepSha256: string;

    /**
     * Retrieves a string that contains "RSA_OAEP_SHA384". 
     */
    rsaOaepSha384: string;

    /**
     * Retrieves a string that contains "RSA_OAEP_SHA512". 
     */
    rsaOaepSha512: string;

    /**
     * Retrieves a string that contains "RSA_PKCS1". 
     */
    rsaPkcs1: string;

    /**
     * Retrieves a string that contains "RSASIGN_PKCS1_SHA1". 
     */
    rsaSignPkcs1Sha1: string;

    /**
     * Retrieves a string that contains "RSASIGN_PKCS1_SHA256". 
     */
    rsaSignPkcs1Sha256: string;

    /**
     * Retrieves a string that contains "RSASIGN_PKCS1_SHA384". 
     */
    rsaSignPkcs1Sha384: string;

    /**
     * Retrieves a string that contains "RSASIGN_PSS_SHA512". 
     */
    rsaSignPkcs1Sha512: string;

    /**
     * Retrieves a string that contains "RSASIGN_PSS_SHA1". 
     */
    rsaSignPssSha1: string;

    /**
     * Retrieves a string that contains "RSASIGN_PSS_SHA256". 
     */
    rsaSignPssSha256: string;

    /**
     * Retrieves a string that contains "RSASIGN_PSS_SHA384". 
     */
    rsaSignPssSha384: string;

    /**
     * Retrieves a string that contains "RSASIGN_PSS_SHA512". 
     */
    rsaSignPssSha512: string
}


/**
 * Represents a provider of asymmetric (public) key algorithms. For more information, see Cryptographic keys. 
 */
declare class AsymmetricKeyAlgorithmProvider {

    /**
     * Creates an instance of the AsymmetricKeyAlgorithmProvider class and opens the specified algorithm for use.
     * @param algorithm Algorithm name.
     * @return  Represents a public key algorithm provider.
     */
    openAlgorithm(algorithm: string): undefined.AsymmetricKeyAlgorithmProvider;

    /**
     * Gets the name of the open asymmetric algorithm. 
     */
    algorithmName: string;

    /**
     * Creates a public/private key pair.
     * @param keySize Size, in bits, of the key. Typical key sizes are 512, 1024, 2048, or 4096 bits.
     * @return  Represents the asymmetric key pair.
     */
    createKeyPair(keySize: number): undefined.CryptographicKey;

    /**
     * Creates a public/private key pair using a curve name.
     * @param curveName The name of the curve.
     * @return  Represents the asymmetric key pair.
     */
    createKeyPairWithCurveName(curveName: string): undefined.CryptographicKey;

    /**
     * Creates a public/private key pair using curve parameters.
     * @param parameters The curve parameters.
     * @return  Represents the asymmetric key pair.
     */
    createKeyPairWithCurveParameters(parameters: number[]): undefined.CryptographicKey;

    /**
     * Imports a public/private key pair from a buffer.
     * @param keyBlob Buffer that contains the key pair to import.
     * @return  Represents the imported key pair.
     */
    importKeyPair(keyBlob: undefined.IBuffer): undefined.CryptographicKey;

    /**
     * Imports a public/private key pair from a buffer in the specified format.
     * @param keyBlob Buffer that contains the key pair to import.
     * @param BlobType A CryptographicPrivateKeyBlobType enumeration value that specifies information about the private key contained in the keyBlob buffer. The default value is Pkcs8RawPrivateKeyInfo.
     * @return  Represents the imported key pair.
     */
    importKeyPair(
        keyBlob: undefined.IBuffer,
        BlobType: undefined.CryptographicPrivateKeyBlobType): undefined.CryptographicKey;

    /**
     * Imports a public key into a buffer.
     * @param keyBlob Buffer that contains the key to import.
     * @return  Represents the imported key.
     */
    importPublicKey(keyBlob: undefined.IBuffer): undefined.CryptographicKey;

    /**
     * Imports a public key into a buffer for a specified format.
     * @param keyBlob Buffer that contains the key to import.
     * @param BlobType A CryptographicPublicKeyBlobType enumeration value that specifies the format of the public key contained in the keyBlob buffer. The default value is X509SubjectPublicKeyInfo.
     * @return  Represents the imported key.
     */
    importPublicKey(
        keyBlob: undefined.IBuffer,
        BlobType: undefined.CryptographicPublicKeyBlobType): undefined.CryptographicKey
}


/**
 * Encrypts, decrypts, and signs content, and verifies digital signatures. 
 */
declare class CryptographicEngine {

    /**
     * Decrypts content that was previously encrypted by using a symmetric or asymmetric algorithm.
     * @param key Cryptographic key to use for decryption. This can be an asymmetric or a symmetric key. For more information, see AsymmetricKeyAlgorithmProvider and SymmetricKeyAlgorithmProvider .
     * @param data Buffer that contains the encrypted data.
     * @param iv Buffer that contains the initialization vector. If an initialization vector (IV) was used to encrypt the data, you must use the same IV to decrypt the data. For more information, see Encrypt .
     * @return  Decrypted data.
     */
    decrypt(
        key: undefined.CryptographicKey,
        data: undefined.IBuffer,
        iv: undefined.IBuffer): undefined.IBuffer;

    /**
     * Decrypts and authenticates data. For more information and a complete code sample, see EncryptedAndAuthenticatedData .
     * @param key Symmetric key to use.
     * @param data Data to be decrypted and authenticated.
     * @param nonce Nonce to be used. This must be the same nonce used by the EncryptAndAuthenticate method.
     * @param authenticationTag Authentication tag.
     * @param authenticatedData Authenticated data. This can be Null.
     * @return  A buffer that contains the decrypted data.
     */
    decryptAndAuthenticate(
        key: undefined.CryptographicKey,
        data: undefined.IBuffer,
        nonce: undefined.IBuffer,
        authenticationTag: undefined.IBuffer,
        authenticatedData: undefined.IBuffer): undefined.IBuffer;

    /**
     * Decrypts the encrypted input data using the supplied key.
     * @param key The key to use to decrypt the encrypted input data.
     * @param data The encrypted data to decrypt.
     * @param iv The initial vector for a symmetric key. For an asymmetric key, set this value to null.
     * @return  The decrypted data.
     */
    decryptAsync(
        key: undefined.CryptographicKey,
        data: undefined.IBuffer,
        iv: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Derives a key from another key by using a key derivation function. For more information, see the KeyDerivationAlgorithmProvider and KeyDerivationParameters classes.
     * @param key The symmetric or secret key used for derivation.
     * @param parameters Derivation parameters. The parameters vary depending on the type of KDF algorithm used.
     * @param desiredKeySize Requested size, in bytes, of the derived key.
     * @return  Buffer that contains the derived key.
     */
    deriveKeyMaterial(
        key: undefined.CryptographicKey,
        parameters: undefined.KeyDerivationParameters,
        desiredKeySize: number): undefined.IBuffer;

    /**
     * Encrypts data by using a symmetric or asymmetric algorithm.
     * @param key Cryptographic key to use for encryption. This can be an asymmetric or a symmetric key. For more information, see AsymmetricKeyAlgorithmProvider and SymmetricKeyAlgorithmProvider .
     * @param data Data to encrypt.
     * @param iv Buffer that contains the initialization vector. This can be null for a symmetric algorithm and should always be null for an asymmetric algorithm. If an initialization vector (IV) was used to encrypt the data, you must use the same IV to decrypt the data. You can use the GenerateRandom method to create an IV that contains random data. Other IVs, such as nonce-generated vectors, require custom implementation. For more information, see Cryptographic keys.
     * @return  Encrypted data.
     */
    encrypt(
        key: undefined.CryptographicKey,
        data: undefined.IBuffer,
        iv: undefined.IBuffer): undefined.IBuffer;

    /**
     * Performs authenticated encryption.
     * @param key Symmetric key to use for encryption.
     * @param data Data to be encrypted and authenticated.
     * @param nonce Nonce to be used. A nonce is a variable that has minimal chance of repeating. For example, you can use a random value that is newly generated for each use, a time stamp, a sequence number, or some combination of these. The Microsoft GCM implementation requires a 12-byte nonce. The CCM implementation requires a 7- to 13- byte nonce.
     * @param authenticatedData Authenticated data. This can be Null.
     * @return  The encrypted and authenticated data.
     */
    encryptAndAuthenticate(
        key: undefined.CryptographicKey,
        data: undefined.IBuffer,
        nonce: undefined.IBuffer,
        authenticatedData: undefined.IBuffer): undefined.EncryptedAndAuthenticatedData;

    /**
     * Signs digital content. For more information, see MACs, hashes, and signatures.
     * @param key Key used for signing.
     * @param data Data to be signed.
     * @return  The data's signature.
     */
    sign(key: undefined.CryptographicKey, data: undefined.IBuffer): undefined.IBuffer;

    /**
     * Computes a hash for the supplied input data, and then signs the computed hash using the specified key.
     * @param key The key to use to compute and sign the hash.
     * @param data The raw input data to sign. The data is not hashed.
     * @return  An asynchronous operation to retrieve the hashed and signed data.
     */
    signAsync(
        key: undefined.CryptographicKey,
        data: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Signs the hashed input data using the specified key.
     * @param key The key to use to sign the hash. This key must be an asymmetric key obtained from a PersistedKeyProvider or AsymmetricKeyAlgorithmProvider .
     * @param data The input data to sign. The data is a hashed value which can be obtained through incremental hash.
     * @return  The signed data.
     */
    signHashedData(key: undefined.CryptographicKey, data: undefined.IBuffer): undefined.IBuffer;

    /**
     * Signs the hashed input data using the specified key.
     * @param key The key to use to sign the hash. This key must be an asymmetric key obtained from a PersistedKeyProvider or AsymmetricKeyAlgorithmProvider .
     * @param data The input data to sign. The data is a hashed value which can be obtained through incremental hash.
     * @return  An asynchronous operation to retrieve the signed data.
     */
    signHashedDataAsync(
        key: undefined.CryptographicKey,
        data: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Verifies a message signature.
     * @param key Key used for verification. This must be the same key previously used to sign the message.
     * @param data Message to be verified.
     * @param signature Signature previously computed over the message to be verified.
     * @return  true if the message is verified.
     */
    verifySignature(
        key: undefined.CryptographicKey,
        data: undefined.IBuffer,
        signature: undefined.IBuffer): boolean;

    /**
     * Verifies the signature of the specified input data against a known signature.
     * @param key The key to use to retrieve the signature from the input data. This key must be an asymmetric key obtained from a PersistedKeyProvider or AsymmetricKeyAlgorithmProvider .
     * @param data The data to be verified. The data is a hashed value of raw data.
     * @param signature The known signature to use to verify the signature of the input data.
     * @return  True if the signature is verified; otherwise false.
     */
    verifySignatureWithHashInput(
        key: undefined.CryptographicKey,
        data: undefined.IBuffer,
        signature: undefined.IBuffer): boolean
}


/**
 * Represents a reusable hashing object and contains the result of a hashing operation. 
 */
declare class CryptographicHash {

    /**
     * Appends a binary encoded string to the data stored in the CryptographicHash object.
     * @param data Data to append.
     */
    append(data: undefined.IBuffer): void;

    /**
     * Gets hashed data from the CryptographicHash object and resets the object.
     * @return  Hashed data.
     */
    getValueAndReset(): undefined.IBuffer
}


/**
 * Represents a symmetric key or an asymmetric key pair. 
 */
declare class CryptographicKey {

    /**
     * Exports the key pair to a buffer.
     * @return  Buffer that contains the key pair.
     */
    export (): undefined.IBuffer;

    /**
     * Exports the key pair to a buffer given a specified format.
     * @param BlobType A CryptographicPrivateKeyBlobType enumeration value that specifies the format of the key in the buffer. The default value is Pkcs8RawPrivateKeyInfo.
     * @return  Buffer that contains the key pair.
     */
    export (BlobType: undefined.CryptographicPrivateKeyBlobType): undefined.IBuffer;

    /**
     * Exports a public key to a buffer.
     * @return  Buffer that contains the public key.
     */
    exportPublicKey(): undefined.IBuffer;

    /**
     * Exports a public key to a buffer given a specified format.
     * @param BlobType A CryptographicPublicKeyBlobType enumeration value that specifies the format of the key in the buffer. The default value is X509SubjectPublicKeyInfo.
     * @return  Buffer that contains the public key.
     */
    exportPublicKey(BlobType: undefined.CryptographicPublicKeyBlobType): undefined.IBuffer;

    /**
     * Gets the size, in bits, of the key. 
     */
    keySize: number
}


/**
 * Contains static properties that enable you to retrieve supported elliptic curve cryptography (ECC) algorithm names. 
 */
declare class EccCurveNames {

    /**
     * Gets an array of strings that represents all the curves registered on the local computer. This includes curves that were registered by the local administrator. 
     */
    allEccCurveNames: undefined.IVectorView<string>;

    /**
     * Retrieves a string that contains "BRAINPOOLP160R1". 
     */
    brainpoolP160r1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP160T1". 
     */
    brainpoolP160t1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP192R1". 
     */
    brainpoolP192r1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP192T1". 
     */
    brainpoolP192t1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP224R1". 
     */
    brainpoolP224r1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP224T1". 
     */
    brainpoolP224t1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP256R1". 
     */
    brainpoolP256r1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP256T1". 
     */
    brainpoolP256t1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP320R1". 
     */
    brainpoolP320r1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP320T1". 
     */
    brainpoolP320t1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP384R1". 
     */
    brainpoolP384r1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP384T1". 
     */
    brainpoolP384t1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP512R1". 
     */
    brainpoolP512r1: string;

    /**
     * Retrieves a string that contains "BRAINPOOLP512T1". 
     */
    brainpoolP512t1: string;

    /**
     * Retrieves a string that contains "CURVE25519". 
     */
    curve25519: string;

    /**
     * Retrieves a string that contains "EC192WAPI". 
     */
    ec192wapi: string;

    /**
     * Retrieves a string that contains "NISTP192". 
     */
    nistP192: string;

    /**
     * Retrieves a string that contains "NISTP224". 
     */
    nistP224: string;

    /**
     * Retrieves a string that contains "NISTP256". 
     */
    nistP256: string;

    /**
     * Retrieves a string that contains "NISTP384". 
     */
    nistP384: string;

    /**
     * Retrieves a string that contains "NISTP521". 
     */
    nistP521: string;

    /**
     * Retrieves a string that contains "NUMSP256T1". 
     */
    numsP256t1: string;

    /**
     * Retrieves a string that contains "NUMSP384T1". 
     */
    numsP384t1: string;

    /**
     * Retrieves a string that contains "NUMSP512T1". 
     */
    numsP512t1: string;

    /**
     * Retrieves a string that contains "SECP160K1". 
     */
    secP160k1: string;

    /**
     * Retrieves a string that contains "SECP160R1". 
     */
    secP160r1: string;

    /**
     * Retrieves a string that contains "SECP160R2". 
     */
    secP160r2: string;

    /**
     * Retrieves a string that contains "SECP192K1". 
     */
    secP192k1: string;

    /**
     * Retrieves a string that contains "SECP192R1". 
     */
    secP192r1: string;

    /**
     * Retrieves a string that contains "SECP224K1". 
     */
    secP224k1: string;

    /**
     * Retrieves a string that contains "SECP224R1". 
     */
    secP224r1: string;

    /**
     * Retrieves a string that contains "SecP256k1". 
     */
    secP256k1: string;

    /**
     * Retrieves a string that contains "SecP256r1". 
     */
    secP256r1: string;

    /**
     * Retrieves a string that contains "SecP384r1". 
     */
    secP384r1: string;

    /**
     * Retrieves a string that contains "SecP521r1". 
     */
    secP521r1: string;

    /**
     * Retrieves a string that contains "WTLS12". 
     */
    wtls12: string;

    /**
     * Retrieves a string that contains "WTLS7". 
     */
    wtls7: string;

    /**
     * Retrieves a string that contains "WTLS9". 
     */
    wtls9: string;

    /**
     * Retrieves a string that contains "X962P192v1". 
     */
    x962P192v1: string;

    /**
     * Retrieves a string that contains "X962P192v2". 
     */
    x962P192v2: string;

    /**
     * Retrieves a string that contains "X962P192v3". 
     */
    x962P192v3: string;

    /**
     * Retrieves a string that contains "X962P239v1". 
     */
    x962P239v1: string;

    /**
     * Retrieves a string that contains "X962P239v2". 
     */
    x962P239v2: string;

    /**
     * Retrieves a string that contains "X962P239v3". 
     */
    x962P239v3: string;

    /**
     * Retrieves a string that contains "X962P256v1". 
     */
    x962P256v1: string
}


/**
 * Contains data that can be retrieved from encrypted and authenticated data. Authenticated encryption algorithms are opened by using the SymmetricKeyAlgorithmProvider class. 
 */
declare class EncryptedAndAuthenticatedData {

    /**
     * Gets the authentication tag. 
     */
    authenticationTag: undefined.IBuffer;

    /**
     * Gets the encrypted data. 
     */
    encryptedData: undefined.IBuffer
}


/**
 * Contains static properties that enable you to retrieve algorithm names that can be used in the OpenAlgorithm method of the HashAlgorithmProvider class. 
 */
declare class HashAlgorithmNames {

    /**
     * Retrieves a string that contains "MD5". 
     */
    md5: string;

    /**
     * Retrieves a string that contains "SHA1". 
     */
    sha1: string;

    /**
     * Retrieves a string that contains "SHA256". 
     */
    sha256: string;

    /**
     * Retrieves a string that contains "SHA384". 
     */
    sha384: string;

    /**
     * Retrieves a string that contains "SHA512". 
     */
    sha512: string
}


/**
 * Represents a cryptographic hash provider. For more information about hashes, see MACs, hashes, and signatures. 
 */
declare class HashAlgorithmProvider {

    /**
     * Creates a HashAlgorithmProvider object and opens the specified algorithm for use.
     * @param algorithm Algorithm name.
     * @return  Represents a provider that implements hash algorithms.
     */
    openAlgorithm(algorithm: string): undefined.HashAlgorithmProvider;

    /**
     * Gets the name of the open hash algorithm. 
     */
    algorithmName: string;

    /**
     * Creates a reusable CryptographicHash object.
     * @return  Reusable hash object.
     */
    createHash(): undefined.CryptographicHash;

    /**
     * Hashes binary data.
     * @param data Data to be hashed.
     * @return  Hashed data.
     */
    hashData(data: undefined.IBuffer): undefined.IBuffer;

    /**
     * Gets the length, in bytes, of the hash. 
     */
    hashLength: number
}


/**
 * Contains static properties that enable you to retrieve algorithm names that can be used in the OpenAlgorithm method of the KeyDerivationAlgorithmProvider class. 
 */
declare class KeyDerivationAlgorithmNames {

    /**
     * Retrieves a string that contains "CAPI_KDF_MD5". 
     */
    capiKdfMd5: string;

    /**
     * Retrieves a string that contains "CAPI_KDF_SHA1". 
     */
    capiKdfSha1: string;

    /**
     * Retrieves a string that contains "CAPI_KDF_SHA256". 
     */
    capiKdfSha256: string;

    /**
     * Retrieves a string that contains "CAPI_KDF_SHA384". 
     */
    capiKdfSha384: string;

    /**
     * Retrieves a string that contains "CAPI_KDF_SHA512". 
     */
    capiKdfSha512: string;

    /**
     * Retrieves a string that contains "PBKDF2_MD5". 
     */
    pbkdf2Md5: string;

    /**
     * Retrieves a string that contains "PBKDF2_SHA1". 
     */
    pbkdf2Sha1: string;

    /**
     * Retrieves a string that contains "PBKDF2_SHA256". 
     */
    pbkdf2Sha256: string;

    /**
     * Retrieves a string that contains "PBKDF2_SHA384". 
     */
    pbkdf2Sha384: string;

    /**
     * Retrieves a string that contains "PBKDF2_SHA512". 
     */
    pbkdf2Sha512: string;

    /**
     * Retrieves a string that contains "SP800_108_CTR_HMAC_MD5". 
     */
    sp800108CtrHmacMd5: string;

    /**
     * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA1". 
     */
    sp800108CtrHmacSha1: string;

    /**
     * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA256". 
     */
    sp800108CtrHmacSha256: string;

    /**
     * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA384". 
     */
    sp800108CtrHmacSha384: string;

    /**
     * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA512". 
     */
    sp800108CtrHmacSha512: string;

    /**
     * Retrieves a string that contains "SP800_56A_CONCAT_MD5". 
     */
    sp80056aConcatMd5: string;

    /**
     * Retrieves a string that contains "SP800_56A_CONCAT_SHA1". 
     */
    sp80056aConcatSha1: string;

    /**
     * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA256". 
     */
    sp80056aConcatSha256: string;

    /**
     * Retrieves a string that contains "SP800_108_CTR_HMAC_SHA384". 
     */
    sp80056aConcatSha384: string;

    /**
     * Retrieves a string that contains "SP800_56A_CONCAT_SHA512". 
     */
    sp80056aConcatSha512: string
}


/**
 * Represents a key derivation algorithm provider. 
 */
declare class KeyDerivationAlgorithmProvider {

    /**
     * Creates an instance of the KeyDerivationAlgorithmProvider class and opens the specified algorithm for use.
     * @param algorithm Represents a KDF algorithm provider.
     * @return  The algorithm provider.
     */
    openAlgorithm(algorithm: string): undefined.KeyDerivationAlgorithmProvider;

    /**
     * Gets the name of the open key derivation function (KDF) algorithm. 
     */
    algorithmName: string;

    /**
     * Creates a KDF key.
     * @param keyMaterial Data used to create the key.
     * @return  Represents the KDF key.
     */
    createKey(keyMaterial: undefined.IBuffer): undefined.CryptographicKey
}


/**
 * Represents parameters used when deriving a key. 
 */
declare class KeyDerivationParameters {

    /**
     * Creates a KeyDerivationParameters object for use in the target algorithm.
     * @param capi1KdfTargetAlgorithm The target algorithm.
     * @return  Refers to the parameters used during key derivation.
     */
    buildForCapi1Kdf(
        capi1KdfTargetAlgorithm: undefined.Capi1KdfTargetAlgorithm): undefined.KeyDerivationParameters;

    /**
     * Creates a KeyDerivationParameters object for use in the password-based key derivation function 2 (PBKDF2).
     * @param pbkdf2Salt The salt, a random or pseudorandom value to be combined with the password in multiple iterations. A salt is used to increase entropy above what can be obtained from using a password alone.
     * @param iterationCount Number of iterations to be used to derive a key.
     * @return  Refers to the parameters used during key derivation.
     */
    buildForPbkdf2(
        pbkdf2Salt: undefined.IBuffer,
        iterationCount: number): undefined.KeyDerivationParameters;

    /**
     * Creates a KeyDerivationParameters object for use in a counter mode, hash-based message authentication code (HMAC) key derivation function.
     * @param label Buffer that specifies the purpose for the derived keying material.
     * @param context Buffer that specifies information related to the derived keying material. For example, the context can identify the parties who are deriving the keying material and, optionally, a nonce known by the parties.
     * @return  Refers to the parameters used during key derivation.
     */
    buildForSP800108(
        label: undefined.IBuffer,
        context: undefined.IBuffer): undefined.KeyDerivationParameters;

    /**
     * Creates a KeyDerivationParameters object for use in the SP800-56A key derivation function.
     * @param algorithmId Specifies the intended purpose of the derived key.
     * @param partyUInfo Contains public information contributed by the initiator.
     * @param partyVInfo Contains public information contributed by the responder.
     * @param suppPubInfo Contains public information known to both initiator and responder.
     * @param suppPrivInfo Contains private information known to both initiator and responder, such as a shared secret.
     * @return  Refers to the parameters used during key derivation.
     */
    buildForSP80056a(
        algorithmId: undefined.IBuffer,
        partyUInfo: undefined.IBuffer,
        partyVInfo: undefined.IBuffer,
        suppPubInfo: undefined.IBuffer,
        suppPrivInfo: undefined.IBuffer): undefined.KeyDerivationParameters;

    /**
     * Gets or sets the Capi1KdfTargetAlgorithm . 
     */
    capi1KdfTargetAlgorithm: undefined.Capi1KdfTargetAlgorithm;

    /**
     * Retrieves the number of iterations used to derive the key. For more information, see BuildForPbkdf2 . 
     */
    iterationCount: number;

    /**
     * Gets or sets the parameters used by the key derivation algorithm. 
     */
    kdfGenericBinary: undefined.IBuffer
}


/**
 * Contains static properties that enable you to retrieve algorithm names that can be used in the OpenAlgorithm method of the MacAlgorithmProvider class. 
 */
declare class MacAlgorithmNames {

    /**
     * Retrieves a string that contains "AES_CMAC". 
     */
    aesCmac: string;

    /**
     * Retrieves a string that contains "HMAC_MD5". 
     */
    hmacMd5: string;

    /**
     * Retrieves a string that contains "HMAC_SHA1". 
     */
    hmacSha1: string;

    /**
     * Retrieves a string that contains "HMAC_SHA256". 
     */
    hmacSha256: string;

    /**
     * Retrieves a string that contains "HMAC_SHA384". 
     */
    hmacSha384: string;

    /**
     * Retrieves a string that contains "HMAC_SHA512". 
     */
    hmacSha512: string
}


/**
 * Represents a message authentication code (MAC). A MAC uses symmetric key cryptography to prevent message tampering. For more information, see MACs, hashes, and signatures. 
 */
declare class MacAlgorithmProvider {

    /**
     * Creates a MacAlgorithmProvider object and opens the specified algorithm for use.
     * @param algorithm Algorithm name.
     * @return  Represents a provider that implements MAC algorithms.
     */
    openAlgorithm(algorithm: string): undefined.MacAlgorithmProvider;

    /**
     * Gets the name of the open MAC algorithm. 
     */
    algorithmName: string;

    /**
     * Creates a CryptographicHash object that supports incremental hash operations.
     * @param keyMaterial Random data used to help generate the hash. You can call the GenerateRandom method to create the random data.
     * @return  A CryptographicHash object that supports incremental hash operations.
     */
    createHash(keyMaterial: undefined.IBuffer): undefined.CryptographicHash;

    /**
     * Creates a symmetric key that can be used to create the MAC value.
     * @param keyMaterial Random data used to help generate the key. You can call the GenerateRandom method to create the random data.
     * @return  Symmetric key.
     */
    createKey(keyMaterial: undefined.IBuffer): undefined.CryptographicKey;

    /**
     * Gets the length, in bytes, of the message authentication code. 
     */
    macLength: number
}


/**
 * Retrieves a persisted key from a Certificate object. 
 */
declare class PersistedKeyProvider {

    /**
     * Opens the persisted private key from the specified Certificate object.
     * @param certificate The certificate that is associated with the private key.
     * @param hashAlgorithmName The hash algorithm for signature operations. For encryption, the hash algorithm is ignored.
     * @param padding The padding mode for asymmetric algorithm signature or encryption operations.
     * @return  An asynchronous operation for retrieving a private key from the supplied Certificate object.
     */
    openKeyPairFromCertificateAsync(
        certificate: undefined.Certificate,
        hashAlgorithmName: string,
        padding: undefined.CryptographicPadding): undefined.IPromiseWithIAsyncOperation<undefined.CryptographicKey>;

    /**
     * Opens the persisted public key from the specified Certificate object.
     * @param certificate The certificate that contains the public key.
     * @param hashAlgorithmName The has algorithm for signature operations.
     * @param padding The padding mode for asymmetric algorithm signature or encryption operations.
     * @return  The public key retrieved from the supplied Certificate object.
     */
    openPublicKeyFromCertificate(
        certificate: undefined.Certificate,
        hashAlgorithmName: string,
        padding: undefined.CryptographicPadding): undefined.CryptographicKey
}


/**
 * Contains static properties that enable you to retrieve algorithm names that can be used in the OpenAlgorithm method of the SymmetricKeyAlgorithmProvider class. 
 */
declare class SymmetricAlgorithmNames {

    /**
     * Retrieves a string that contains "AES_CBC". 
     */
    aesCbc: string;

    /**
     * Retrieves a string that contains "AES_CBC_PKCS7". 
     */
    aesCbcPkcs7: string;

    /**
     * Retrieves a string that contains "AES_CCM". 
     */
    aesCcm: string;

    /**
     * Retrieves a string that contains "AES_ECB". 
     */
    aesEcb: string;

    /**
     * Retrieves a string that contains "AES_ECB_PKCS7". 
     */
    aesEcbPkcs7: string;

    /**
     * Retrieves a string that contains "AES_CCM". 
     */
    aesGcm: string;

    /**
     * Retrieves a string that contains "DES_CBC". 
     */
    desCbc: string;

    /**
     * Retrieves a string that contains "DES_CBC_PKCS7". 
     */
    desCbcPkcs7: string;

    /**
     * Retrieves a string that contains "DES_ECB". 
     */
    desEcb: string;

    /**
     * Retrieves a string that contains "DES_ECB_PKCS7". 
     */
    desEcbPkcs7: string;

    /**
     * Retrieves a string that contains "RC2_CBC". 
     */
    rc2Cbc: string;

    /**
     * Retrieves a string that contains "RC2_CBC_PKCS7". 
     */
    rc2CbcPkcs7: string;

    /**
     * Retrieves a string that contains "RC2_ECB". 
     */
    rc2Ecb: string;

    /**
     * Retrieves a string that contains "RC2_ECB_PKCS7". 
     */
    rc2EcbPkcs7: string;

    /**
     * Retrieves a string that contains "RC4". 
     */
    rc4: string;

    /**
     * Retrieves a string that contains "3DES_CBC". 
     */
    tripleDesCbc: string;

    /**
     * Retrieves a string that contains "3DES_CBC_PKCS7". 
     */
    tripleDesCbcPkcs7: string;

    /**
     * Retrieves a string that contains "3DES_ECB". 
     */
    tripleDesEcb: string;

    /**
     * Retrieves a string that contains "3DES_ECB_PKCS7". 
     */
    tripleDesEcbPkcs7: string
}


/**
 * Represents a provider of symmetric key algorithms. For more information, see Cryptographic keys. 
 */
declare class SymmetricKeyAlgorithmProvider {

    /**
     * Creates an instance of the SymmetricKeyAlgorithmProvider class and opens the specified algorithm for use.
     * @param algorithm Algorithm name.
     * @return  Represents a symmetric key algorithm provider.
     */
    openAlgorithm(algorithm: string): undefined.SymmetricKeyAlgorithmProvider;

    /**
     * Gets the name of the open symmetric algorithm. 
     */
    algorithmName: string;

    /**
     * Gets the size, in bytes, of the cipher block for the open algorithm. 
     */
    blockLength: number;

    /**
     * Creates a symmetric key.
     * @param keyMaterial Data used to generate the key. You can call the GenerateRandom method to create random key material.
     * @return  Symmetric key.
     */
    createSymmetricKey(keyMaterial: undefined.IBuffer): undefined.CryptographicKey
}


/**
 * Contains static methods that implement data management functionality common to cryptographic operations. 
 */
declare class CryptographicBuffer {

    /**
     * Compares two IBuffer objects.
     * @param object1 Buffer to be used for comparison.
     * @param object2 Buffer to be used for comparison.
     * @return  True specifies that the buffers are equal. Two buffers are equal if each code point in one matches the corresponding code point in the other.
     */
    compare(object1: undefined.IBuffer, object2: undefined.IBuffer): boolean;

    /**
     * Converts a buffer to an encoded string.
     * @param encoding Encoding format.
     * @param buffer Data to be encoded.
     * @return  A string that contains the encoded data.
     */
    convertBinaryToString(encoding: undefined.BinaryStringEncoding, buffer: undefined.IBuffer): string;

    /**
     * Converts a string to an encoded buffer.
     * @param value String to be encoded.
     * @param encoding Encoding format.
     * @return  Encoded buffer.
     */
    convertStringToBinary(value: string, encoding: undefined.BinaryStringEncoding): undefined.IBuffer;

    /**
     * Copies a buffer to an array of bytes.
     * @param buffer Input buffer.
     * @return  An array of bytes that contains the values copied from the input buffer. You must declare the array before calling this method and pass it by using the ref keyword. If the buffer for the input parameter is empty, then the value parameter will be returned as NULL.
     */
    copyToByteArray(buffer: undefined.IBuffer): number[];

    /**
     * Creates a buffer from an input byte array.
     * @param value An array of bytes used to create the buffer.
     * @return  Output buffer.
     */
    createFromByteArray(value: number[]): undefined.IBuffer;

    /**
     * Decodes a string that has been base64 encoded.
     * @param value Base64 encoded input string.
     * @return  Output buffer that contains the decoded string.
     */
    decodeFromBase64String(value: string): undefined.IBuffer;

    /**
     * Decodes a string that has been hexadecimal encoded.
     * @param value Encoded input string.
     * @return  Output buffer that contains the decoded string.
     */
    decodeFromHexString(value: string): undefined.IBuffer;

    /**
     * Encodes a buffer to a base64 string.
     * @param buffer Input buffer.
     * @return  Base64-encoded output string.
     */
    encodeToBase64String(buffer: undefined.IBuffer): string;

    /**
     * Encodes a buffer to a hexadecimal string.
     * @param buffer Input buffer.
     * @return  Hexadecimal encoded output string.
     */
    encodeToHexString(buffer: undefined.IBuffer): string;

    /**
     * Creates a buffer that contains random data.
     * @param length Length, in bytes, of the buffer to create.
     * @return  Output buffer that contains the random data.
     */
    generateRandom(length: number): undefined.IBuffer;

    /**
     * Creates a random number.
     * @return  Integer that contains the random data.
     */
    generateRandomNumber(): number
}


/**
 * Represents a cryptographic provider that can be used to asynchronously encrypt and decrypt static data or a data stream. 
 */
declare class DataProtectionProvider {

    /**
     * Constructor used for encryption operations. Use this constructor before calling the ProtectAsync or ProtectStreamAsync methods.
     * @param protectionDescriptor Contains the protection descriptor that determines the entity to which the data will be encrypted. For more information, see Remarks.
     */
    constructor(protectionDescriptor: string): this;

    /**
     * Constructor used for decryption operations. Use this constructor before calling the UnprotectAsync or UnprotectStreamAsync methods. 
     */
    constructor(): this;

    /**
     * Asynchronously protects static data.
     * @param data Data to protect.
     * @return  Represents an asynchronous operation.
     */
    protectAsync(
        data: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Asynchronously protects a data stream.
     * @param src Stream to be protected.
     * @param dest Protected stream.
     * @return  Represents an asynchronous action.
     */
    protectStreamAsync(
        src: undefined.IInputStream,
        dest: undefined.IOutputStream): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously decrypts static data.
     * @param data Data to decrypt.
     * @return  Represents an asynchronous operation.
     */
    unprotectAsync(
        data: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Asynchronously decrypts a data stream.
     * @param src Stream to decrypt.
     * @param dest Decrypted stream.
     * @return  Represents an asynchronous action.
     */
    unprotectStreamAsync(
        src: undefined.IInputStream,
        dest: undefined.IOutputStream): undefined.IPromiseWithIAsyncAction
}


/**
 * Contains information about the result from protecting or unprotecting an enterprise protected buffer. 
 */
declare class BufferProtectUnprotectResult {

    /**
     * Gets the enterprise protected buffer that has been protected or unprotected. 
     */
    buffer: undefined.IBuffer;

    /**
     * Gets the DataProtectionInfo object concerning the enterprise protected buffer that has been protected or unprotected. 
     */
    protectionInfo: undefined.DataProtectionInfo
}


/**
 * Contains information about an enterprise protected buffer or stream. 
 */
declare class DataProtectionInfo {

    /**
     * The enterprise identity of the enterprise protected buffer or stream. 
     */
    identity: string;

    /**
     * The protection status of the enterprise protected buffer or stream. 
     */
    status: undefined.DataProtectionStatus
}


/**
 * Provides access to operations that manage buffers and streams that are protected to an enterprise identity. 
 */
declare class DataProtectionManager {

    /**
     * Get the status of an enterprise protected buffer.
     * @param protectedData The buffer for which protection status is being queried.
     * @return  When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the buffer.
     */
    getProtectionInfoAsync(
        protectedData: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.DataProtectionInfo>;

    /**
     * Get the status of an enterprise protected stream.
     * @param protectedStream The stream for which protection status is being queried.
     * @return  When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the stream.
     */
    getStreamProtectionInfoAsync(
        protectedStream: undefined.IInputStream): undefined.IPromiseWithIAsyncOperation<undefined.DataProtectionInfo>;

    /**
     * Protect the data in a buffer to an enterprise identity.
     * @param data The buffer to be protected.
     * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
     * @return  When the call to this method completes successfully, it returns a BufferProtectUnprotectResult object that contains the status of the newly protected buffer.
     */
    protectAsync(
        data: undefined.IBuffer,
        identity: string): undefined.IPromiseWithIAsyncOperation<undefined.BufferProtectUnprotectResult>;

    /**
     * Protect a stream of data to an enterprise identity.
     * @param unprotectedStream The input, unprotected stream.
     * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
     * @param protectedStream The output, protected stream.
     * @return  When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the protected stream.
     */
    protectStreamAsync(
        unprotectedStream: undefined.IInputStream,
        identity: string,
        protectedStream: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperation<undefined.DataProtectionInfo>;

    /**
     * Removes the protection to an enterprise identity from a buffer.
     * @param data The buffer to be unprotected.
     * @return  When the call to this method completes successfully, it returns a BufferProtectUnprotectResult object that contains the status of the unprotected buffer.
     */
    unprotectAsync(
        data: undefined.IBuffer): undefined.IPromiseWithIAsyncOperation<undefined.BufferProtectUnprotectResult>;

    /**
     * Removes the protection to an enterprise identity from a stream of data.
     * @param protectedStream The input, protected stream.
     * @param unprotectedStream The output, unprotected stream.
     * @return  When the call to this method completes successfully, it returns a DataProtectionInfo object that contains the status of the unprotected stream.
     */
    unprotectStreamAsync(
        protectedStream: undefined.IInputStream,
        unprotectedStream: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperation<undefined.DataProtectionInfo >
}


/**
 * Contains information about an enterprise protected file. 
 */
declare class FileProtectionInfo {

    /**
     * The enterprise identity of the enterprise protected file. 
     */
    identity: string;

    /**
     * Specifies if the protection of the enterprise protected file can be roamed to other devices. 
     */
    isRoamable: boolean;

    /**
     * The protection status of the enterprise protected file. 
     */
    status: undefined.FileProtectionStatus
}


/**
 * Provides access to operations that manage files that are protected to an enterprise identity. 
 */
declare class FileProtectionManager {

    /**
     * Replicate the file protection of one file onto another file.
     * @param source The source file, from which file protection is being copied.
     * @param target The target file, to which file protection is being copied.
     * @return  When the call to this method completes successfully, it returns true if the file protection was copied, or false if there was an error.
     */
    copyProtectionAsync(
        source: undefined.IStorageItem,
        target: undefined.IStorageItem): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Create an enterprise-protected file.
     * @param parentFolder The folder into which to create the enterprise protected file.
     * @param desiredName The desired name of the new enterprise protected file.
     * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
     * @param collisionOption A CreationCollisionOption value that specifies what to do if desiredName already exists.
     * @return  When the call to this method completes successfully, it returns a ProtectedFileCreateResult object representing the newly created protected file.
     */
    createProtectedAndOpenAsync(
        parentFolder: undefined.IStorageFolder,
        desiredName: string,
        identity: string,
        collisionOption: undefined.CreationCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.ProtectedFileCreateResult>;

    /**
     * Get the status of an enterprise-protected file.
     * @param source The file or folder for which protection status is being queried.
     * @return  When the call to this method completes successfully, it returns a FileProtectionInfo object that contains the status of the file.
     */
    getProtectionInfoAsync(
        source: undefined.IStorageItem): undefined.IPromiseWithIAsyncOperation<undefined.FileProtectionInfo>;
    isContainerAsync: any;

    /**
     * Create an enterprise-protected file, and load it from a container file.
     * @param containerFile The enterprise protected file to be created and loaded.
     * @return  When the call to this method completes successfully, it returns a ProtectedContainerImportResult object representing the newly created protected file.
     */
    loadFileFromContainerAsync(
        containerFile: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.ProtectedContainerImportResult>;

    /**
     * Create an enterprise-protected file in a specified storage item (such as a folder), and load it from a container file.
     * @param containerFile The enterprise protected file to be created and loaded.
     * @param target The storage item into which to create the enterprise protected file.
     * @return  When the call to this method completes successfully, it returns a ProtectedContainerImportResult object representing the newly created protected file.
     */
    loadFileFromContainerAsync(
        containerFile: undefined.IStorageFile,
        target: undefined.IStorageItem): undefined.IPromiseWithIAsyncOperation<undefined.ProtectedContainerImportResult>;

    /**
     * Create an enterprise-protected file in a specified storage item (such as a folder), and load it from a container file.
     * @param containerFile The enterprise protected file to be created and loaded.
     * @param target The storage item into which to create the enterprise protected file.
     * @param collisionOption The enum value that determines how Windows responds if the created file has the same name as an existing item in the container's location.
     * @return  When the call to this method completes successfully, it returns a ProtectedContainerImportResult object representing the newly created protected file.
     */
    loadFileFromContainerAsync(
        containerFile: undefined.IStorageFile,
        target: undefined.IStorageItem,
        collisionOption: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.ProtectedContainerImportResult>;

    /**
     * Protect the data in a file to an enterprise identity. The app can then use standard APIs to read or write from the file.
     * @param target The file to be protected.
     * @param identity The enterprise identity. This is an email address or domain that is managed. Use ProtectionPolicyManager.IsIdentityManaged to confirm that an email address or domain is managed before using the identity to protect a file.
     * @return  When the call to this method completes successfully, it returns a FileProtectionInfo object that contains the status of the newly protected file.
     */
    protectAsync(
        target: undefined.IStorageItem,
        identity: string): undefined.IPromiseWithIAsyncOperation<undefined.FileProtectionInfo>;

    /**
     * Save an enterprise-protected file as a containerized version.
     * @param protectedFile The protected source file being copied.
     * @return  When the call to this method completes successfully, it returns a ProtectedContainerExportResult object representing the newly created container file.
     */
    saveFileAsContainerAsync(
        protectedFile: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.ProtectedContainerExportResult>;

    /**
     * Save an enterprise-protected file as a containerized version, and share it with a specified list of user identities.
     * @param protectedFile The protected source file being copied.
     * @param sharedWithIdentities A collection of strings representing the user identities to share the containerized file with. For example, email recipients.
     * @return  When the call to this method completes successfully, it returns a ProtectedContainerExportResult object representing the newly created container file.
     */
    saveFileAsContainerAsync(
        protectedFile: undefined.IStorageFile,
        sharedWithIdentities: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.ProtectedContainerExportResult >
}


/**
 * Provides access to Selective Wipe operations. 
 */
declare class FileRevocationManager {

    /**
     * Copy the selective wipe protection state of a file or folder to a new file or folder.
     * @param sourceStorageItem The source item to copy the selective wipe protection status from.
     * @param targetStorageItem The target item to copy the selective wipe protection status to.
     * @return  True if the copy operation was successful; otherwise false.
     */
    copyProtectionAsync(
        sourceStorageItem: undefined.IStorageItem,
        targetStorageItem: undefined.IStorageItem): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets the selective wipe protection status for a file or folder.
     * @param storageItem The file or folder to get the selective wipe protection status for.
     * @return  An aysnchronous operation that retrieves the selective wipe protection status for the storageItem.
     */
    getStatusAsync(
        storageItem: undefined.IStorageItem): undefined.IPromiseWithIAsyncOperation<undefined.FileProtectionStatus>;

    /**
     * Protects a file or folder for selective wipe.
     * @param storageItem The file or folder to protect for selective wipe.
     * @param enterpriseIdentity The enterprise id that the file or folder is protected for. The enterpriseIdentity value must be formatted as an Internationalized Domain Name (IDN) and cannot contain spaces. For example, contoso.com.
     * @return  An asynchronous operation that retrieves the selective wipe protection status for the storageItem.
     */
    protectAsync(
        storageItem: undefined.IStorageItem,
        enterpriseIdentity: string): undefined.IPromiseWithIAsyncOperation<undefined.FileProtectionStatus>;

    /**
     * Revokes all files and folders protected for selective wipe for a specified enterprise id.
     * @param enterpriseIdentity Revoke all files and folders protected by selective wipe for this enterprise id. The enterpriseIdentity value must be formatted as an Internationalized Domain Name (IDN) and cannot contain spaces. For example, contoso.com.
     */
    revoke(enterpriseIdentity: string): void
}


/**
 * Provides data when content protection is resumed. 
 */
declare class ProtectedAccessResumedEventArgs {

    /**
     * Contains the enterprise identities for which content protection is being resumed. 
     */
    identities: undefined.IVectorView<string >
}


/**
 * Provides data when content protection is being suspended. 
 */
declare class ProtectedAccessSuspendingEventArgs {

    /**
     * DateTime at which content protection will be suspended. The app can subtract DateTime.Now from this value to determine how much time there is to perform any processing before the suspension occurs. 
     */
    deadline: Date;

    /**
     * Gets the Deferral object that manages the protection suspension. The app must call Deferral.Complete before it returns from the event handler.
     * @return  The Deferral object.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Contains the enterprise identities for which content protection is being suspended. 
     */
    identities: undefined.IVectorView<string >
}


/**
 * Represents the result of an enterprise protected file that has been exported to a container file. 
 */
declare class ProtectedContainerExportResult {

    /**
     * The container file that has been exported from an enterprise protected file. 
     */
    file: undefined.StorageFile;

    /**
     * The protection status after an enterprise protected file has been exported to a container file. 
     */
    status: undefined.ProtectedImportExportStatus
}


/**
 * Represents the result of an enterprise protected file that has been imported from a container file. 
 */
declare class ProtectedContainerImportResult {

    /**
     * The enterprise protected file that has been loaded from a container file. 
     */
    file: undefined.StorageFile;

    /**
     * The protection status after an enterprise protected file has been imported from a container file. 
     */
    status: undefined.ProtectedImportExportStatus
}


/**
 * Provides data when content protection has been revoked. 
 */
declare class ProtectedContentRevokedEventArgs {

    /**
     * Contains the enterprise identities for which content protection has been revoked. 
     */
    identities: undefined.IVectorView<string >
}


/**
 * Contains information about a newly created enterprise protected file. 
 */
declare class ProtectedFileCreateResult {

    /**
     * The newly created enterprise protected file. 
     */
    file: undefined.StorageFile;

    /**
     * Information about the enterprise protected file. 
     */
    protectionInfo: undefined.FileProtectionInfo;

    /**
     * The stream random access to the newly created enterprise protected file. 
     */
    stream: undefined.IRandomAccessStream
}


/**
 * Manages enterprise-protection policy on protected content. 
 */
declare class ProtectionPolicyManager {

    /**
     * Request if access to enterprise-protected content is available to an identity.
     * @param sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to check if an email address or domain is managed.
     * @param targetIdentity The enterprise identity you want to check has access to the protected content.
     * @return  A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the query.
     */
    checkAccess(
        sourceIdentity: string,
        targetIdentity: string): undefined.ProtectionPolicyEvaluationResult;

    /**
     * Perform enterprise-protection policy evaluation for a data transfer between your app and a specific target app.
     * @param sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to check if an email address or domain is managed.
     * @param appPackageFamilyName The package family name of the app you want to check has access to the protected content.
     * @return  A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the query.
     */
    checkAccessForApp(
        sourceIdentity: string,
        appPackageFamilyName: string): undefined.ProtectionPolicyEvaluationResult;

    /**
     * Clear UI policy enforcement for an enterprise identity. The app calls this method before it displays non-enterprise-protected content. 
     */
    clearProcessUIPolicy(): void;

    /**
     * Creates a ThreadNetworkContext protected to an enterprise identity. The creation of the context tags all network connections made thereafter on the current thread with the identity, and allows access to enterprise resources that are access controlled by the enterprise's policy.
     * @param identity The enterprise identity. This is an email address or domain that is managed. This may be returned from GetPrimaryManagedIdentityForNetworkEndpoint ; otherwise your app should use IsIdentityManaged to confirm that an email address or domain is managed.
     * @return  The protected network context. The app must call ThreadNetworkContext.Close after access to the resource is completed.
     */
    createCurrentThreadNetworkContext(identity: string): undefined.ThreadNetworkContext;

    /**
     * You can use this method to determine the current enterprise data protection (EDP) enforcement level. EDP enforcement level is one aspect of mobile device management (MDM) policy configuration.
     * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
     * @return  A value of the EnforcementLevel enumeration.
     */
    getEnforcementLevel(identity: string): undefined.EnforcementLevel;

    /**
     * Returns the ProtectionPolicyManager object associated with the current app window.
     * @return  The ProtectionPolicyManager object associated with the current app window.
     */
    getForCurrentView(): undefined.ProtectionPolicyManager;

    /**
     * Returns the enterprise identity of a network resource if the resource is on an enterprise-policy-managed endpoint.
     * @param endpointHost The host name or IP address of the network resource.
     * @return  The enterprise identity.
     */
    getPrimaryManagedIdentityForNetworkEndpointAsync(
        endpointHost: undefined.HostName): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Use this method to check whether access to protected data has been revoked since a specified date and time, or is still accessible.
     * @param identity The enterprise identity protecting the data. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
     * @param since The date and time from which point forward you want to include in the check.
     * @return  true if access has been revoked since the specified date and time, otherwise false.
     */
    hasContentBeenRevokedSince(identity: string, since: Date): boolean;

    /**
     * Determines if an enterprise entity is managed by an enterprise policy.
     * @param identity The enterprise identity. This is an email address or domain.
     * @return  true if the enterprise identity is managed, or false if it is not.
     */
    isIdentityManaged(identity: string): boolean;

    /**
     * Use this property to determine whether enterprise data protection (EDP) is enabled on the device. 
     */
    isProtectionEnabled: boolean;

    /**
     * Use this property to determine the value of the ProtectionUnderLockConfigRequired enterprise data protection (EDP) policy.
     * @param identity The enterprise identity you want to check has ProtectionUnderLockConfigRequired policy set.
     * @return  true if ProtectionUnderLockConfigRequired policy is set for the identity, otherwise false.
     */
    isProtectionUnderLockRequired(identity: string): boolean;

    /**
     * Use this property to determine whether decryption of files protected by enterprise data protection (EDP) is allowed.
     * @param identity The enterprise identity you want to check has access to the protected content.
     * @return  true if decryption of files protected by EDP is allowed, otherwise false.
     */
    isUserDecryptionAllowed(identity: string): boolean;

    /**
     * An event that is raised in response to changes in enterprise data protection (EDP) policy managed by the Policy CSP. 
     */
    onpolicychanged: undefined.EventHandler<any>;
    addEventListener(type: "policychanged", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "policychanged", listener: undefined.EventHandler<any>): void;

    /**
     * Event with which the app registers to receive notification that protection has been resumed. 
     */
    onprotectedaccessresumed: undefined.EventHandler<any>;
    addEventListener(type: "protectedaccessresumed", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "protectedaccessresumed", listener: undefined.EventHandler<any>): void;

    /**
     * Event with which the app registers to receive notification that protection is to be suspended. 
     */
    onprotectedaccesssuspending: undefined.EventHandler<any>;
    addEventListener(type: "protectedaccesssuspending", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "protectedaccesssuspending", listener: undefined.EventHandler<any>): void;

    /**
     * Event with which the app registers to receive notification that protection is to be revoked. When the app receives this event, it should determine from ProtectedContentRevokedEventArgs.Identities which enterprise entities have had protection revoked, and call RevokeContent as well as delete any metadata associated with the identity. 
     */
    onprotectedcontentrevoked: undefined.EventHandler<any>;
    addEventListener(type: "protectedcontentrevoked", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "protectedcontentrevoked", listener: undefined.EventHandler<any>): void;

    /**
     * Request access to enterprise protected content for an identity.
     * @param sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
     * @param targetIdentity The target enterprise identity to which the content is protected.
     * @return  A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the request.
     */
    requestAccessAsync(
        sourceIdentity: string,
        targetIdentity: string): undefined.IPromiseWithIAsyncOperation<undefined.ProtectionPolicyEvaluationResult>;

    /**
     * Request access to enterprise-protected content for a specific target app.
     * @param sourceIdentity The source enterprise identity of the app. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
     * @param appPackageFamilyName The package family name of the app you want to check has access to the protected content.
     * @return  A value of the ProtectionPolicyEvaluationResult enumeration that is the result of the query.
     */
    requestAccessForAppAsync(
        sourceIdentity: string,
        appPackageFamilyName: string): undefined.IPromiseWithIAsyncOperation<undefined.ProtectionPolicyEvaluationResult>;

    /**
     * Revoke the keys required to access all content protected to the specified enterprise identity.
     * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
     */
    revokeContent(identity: string): void;

    /**
     * Enables UI policy enforcement for an enterprise identity. When an app is about to display a protected file (such as a PDF) or resource (buffer or stream) on its UI, it must enable UI policy enforcement based on the identity the file is protected to. A call to TryApplyProcessUIPolicy ensures that the OS knows about the current context of the app.
     * @param identity The enterprise identity. This is an email address or domain that is managed. Your app should use IsIdentityManaged to confirm that an email address or domain is managed.
     * @return  true if the identity is being managed by an enterprise policy, or false if it is not.
     */
    tryApplyProcessUIPolicy(identity: string): boolean;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void;

    /**
     * Gets or sets the enterprise identity. 
     */
    identity: string
}


/**
 * A protected network context for an enterprise identity. The creation of the context tags all network connections made thereafter on the current thread with the identity, and allows access to enterprise resources that are access controlled by the enterprise's policy. 
 */
declare class ThreadNetworkContext {

    /**
     * Closes the protected network context. The app must call Close after access to the protected resource is completed. 
     */
    close(): void
}


/**
 * Provides the app the ability to retrieve device information from the local device. 
 */
declare class EasClientDeviceInformation {

    /**
     * Creates an instance of an object that allows the caller app to retrieve device information from the local device. 
     */
    constructor(): this;

    /**
     * Returns the friendly name of the local device. 
     */
    friendlyName: string;

    /**
     * Returns the identifier of the local device. 
     */
    id: string;

    /**
     * Returns the operating system of the local device. 
     */
    operatingSystem: string;

    /**
     * Returns the system firmware version of the local device. 
     */
    systemFirmwareVersion: string;

    /**
     * Returns the system hardware version of the local device. 
     */
    systemHardwareVersion: string;

    /**
     * Returns the system manufacturer of the local device. Use this only if the SystemSku is empty. 
     */
    systemManufacturer: string;

    /**
     * Returns the system product name of the local device. 
     */
    systemProductName: string;

    /**
     * Returns the system SKU of the local device. 
     */
    systemSku: string
}


/**
 * Modern mail apps evaluate and apply the EAS security policies. An EasClientSecurityPolicy object is constructed by the caller app to set policies received from the Exchange server or application. 
 */
declare class EasClientSecurityPolicy {

    /**
     * Creates an instance of an object that allows the caller app to set policies received from the Exchange server for evaluation or application. 
     */
    constructor(): this;

    /**
     * Applies the EAS policies in asynchronous mode once the user consents. ApplyAsync is called by a Windows Store app for mail any time the app wants to make the local computer compliant.
     * @return  Returns the evaluation of the callback results, in asynchronous mode, back to the calling app.
     */
    applyAsync(): undefined.IPromiseWithIAsyncOperation<undefined.EasComplianceResults>;

    /**
     * Evaluates the EAS policies. CheckCompliance is called by a Windows Store app for mail any time the app wants to evaluate whether the local computer is compliant to the given EAS policies. Because this call doesn't involve any UI interactions, it is a synchronous call.
     * @return  Returns the results of the compliance check, in synchronous mode.
     */
    checkCompliance(): undefined.EasComplianceResults;

    /**
     * Gets or sets the ability to prevent convenience logons. DisallowConvenienceLogon is not defined in MS-ASPROV. It is mapped from MS-ASPROV AllowSimplePassword with respect to the Windows password policies. 
     */
    disallowConvenienceLogon: boolean;

    /**
     * Gets or sets the maximum length of time the computer can remain inactive before it is locked. The MS-ASPROV name is MaxInactivityTimeDeviceLock. 
     */
    maxInactivityTimeLock: number;

    /**
     * Gets or sets the maximum number of failed password attempts for logging on. The MS-ASPROV name is MaxDevicePasswordFailedAttempts. 
     */
    maxPasswordFailedAttempts: number;

    /**
     * Gets or sets the minimum number of complex characters that are required for a password. The MS-ASPROV name is MinDevicePasswordComplexCharacters. 
     */
    minPasswordComplexCharacters: number;

    /**
     * Gets or set the minimum length of password allowed. The MS-ASPROV name is MinPasswordLength. 
     */
    minPasswordLength: number;

    /**
     * Gets or set the length of time that a password is valid. The MS-ASPROV name is DevicePasswordExpiration. 
     */
    passwordExpiration: number;

    /**
     * Gets or set the password information previously used. The MS-ASPROV name is DevicePasswordHistory. 
     */
    passwordHistory: number;

    /**
     * Gets or sets whether encryption is required. The MS-ASPROV name is RequireDeviceEncryption. 
     */
    requireEncryption: boolean
}


/**
 * Provides the mail app with the results of the evaluation of the EAS security policies. Every policy being evaluated returns an enumerated value indicating the evaluation results against the policy. The evaluations results are encapsulated in the EasComplianceResults object for the caller app to retrieve. 
 */
declare class EasComplianceResults {

    /**
     * Returns the result of whether the computer is compliant with the EAS policies. 
     */
    compliant: boolean;

    /**
     * Returns the result of whether convenience logons are disallowed. 
     */
    disallowConvenienceLogonResult: undefined.EasDisallowConvenienceLogonResult;

    /**
     * Gets the type of the Exchange ActiveSync encryption provider. 
     */
    encryptionProviderType: undefined.EasEncryptionProviderType;

    /**
     * Returns the result of the maximum time of inactivity allowed before the computer is locked. 
     */
    maxInactivityTimeLockResult: undefined.EasMaxInactivityTimeLockResult;

    /**
     * Returns the result of the maximum number of failed password attempts allowed. 
     */
    maxPasswordFailedAttemptsResult: undefined.EasMaxPasswordFailedAttemptsResult;

    /**
     * Returns the result of the minimum number of complex password characters required. 
     */
    minPasswordComplexCharactersResult: undefined.EasMinPasswordComplexCharactersResult;

    /**
     * Returns the result of the minimum length of the password required. 
     */
    minPasswordLengthResult: undefined.EasMinPasswordLengthResult;

    /**
     * Returns the result of whether the password is expired. 
     */
    passwordExpirationResult: undefined.EasPasswordExpirationResult;

    /**
     * Returns the result of the history of passwords. 
     */
    passwordHistoryResult: undefined.EasPasswordHistoryResult;

    /**
     * Returns the result of whether encryption is required. 
     */
    requireEncryptionResult: undefined.EasRequireEncryptionResult
}






/**
 * A list of the entries that are in your app's most recently used list (MRU) (obtained from the static StorageApplicationPermissions.MostRecentlyUsedList property) and in your app's future-access list (obtained from the static StorageApplicationPermissions.FutureAccessList property). 
 */
declare class AccessListEntryView mixins Array<undefined.AccessListEntry>{

    /**
     * Retrieves the first storage item from the access list or most recently used (MRU) list.
     * @return  The first item.
     */
    first(): undefined.IIterator<undefined.AccessListEntry>;

    /**
     * Retrieves the storage item at the specified index in the access list or most recently used (MRU) list.
     * @param index The zero-based index of the storage item to retrieve.
     * @return  The storage item.
     */
    getAt(index: number): undefined.AccessListEntry;

    /**
     * Retrieves the storage items that start at the specified index in the access list or most recently used (MRU) list.
     * @param startIndex The zero-based index of the start of the items in the collection to retrieve.
     */
    getMany(startIndex: number): {
        items: undefined.AccessListEntry,
        returnValue: number
    };

    /**
     * Retrieves the index of the specified storage item in the access list or most recently used (MRU) list.
     * @param value The storage item.
     */
    indexOf(value: undefined.AccessListEntry): {
        index: number,
        returnValue: boolean
    };

    /**
     * Gets the number of storage items in the access list or most recently used (MRU) list. 
     */
    size: number;
    indexOf(
        value: undefined.AccessListEntry,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.AccessListEntry, fromIndex?: number): number
}


/**
 * Provides data about an ItemRemoved event. 
 */
declare class ItemRemovedEventArgs {

    /**
     * Gets information about the StorageFile or StorageFolder that was removed from the StorageItemMostRecentlyUsedList . 
     */
    removedEntry: undefined.AccessListEntry
}


/**
 * Provides static properties for you to get your app's most recently used list (MRU) (use StorageApplicationPermissions.MostRecentlyUsedList ) and future-access list (use StorageApplicationPermissions.FutureAccessList . 
 */
declare class StorageApplicationPermissions {

    /**
     * Gets an object that represents a list that an app maintains so that the app can store files and/or locations (like folders) and easily access these items in the future. 
     */
    futureAccessList: undefined.StorageItemAccessList;

    /**
     * Gets an object that represents a list that an app can use to track the files and/or locations (like folders) that the app has accessed most recently. 
     */
    mostRecentlyUsedList: undefined.StorageItemMostRecentlyUsedList
}


/**
 * Represents your app's future-access list (obtained from the static StorageApplicationPermissions.FutureAccessList property). By picking files and folders, your user grants your app permission to access items that might not be accessible otherwise. If you add these items to your future-access list then you'll retain that permission when your app wants to access those items again later. Items are stored in the future-access list as StorageFile and StorageFolder objects. 
 */
declare class StorageItemAccessList {

    /**
     * Adds a new storage item and accompanying metadata to the access list.
     * @param file The storage item to add.
     * @param metadata Optional metadata to associate with the storage item.
     * @return  A token that the app can use later to retrieve the storage item.
     */
    add(file: undefined.IStorageItem, metadata: string): string;

    /**
     * Adds a new storage item to the access list.
     * @param file The storage item to add.
     * @return  A token that the app can use later to retrieve the storage item.
     */
    add(file: undefined.IStorageItem): string;

    /**
     * Adds a new storage item and accompanying metadata to the access list, or replaces the specified item if it already exists in the list.
     * @param token A token that the app can use later to retrieve this storage item.
     * @param file The storage item to add or replace.
     * @param metadata Optional metadata to associate with the storage item.
     */
    addOrReplace(token: string, file: undefined.IStorageItem, metadata: string): void;

    /**
     * Adds a new storage item to the access list, or replaces the specified item if it already exists in the list.
     * @param token The token associated with the new storage item. If the access list already contains a storage item that has this token, the new item replaces the existing one.
     * @param file The storage item to add or replace.
     */
    addOrReplace(token: string, file: undefined.IStorageItem): void;

    /**
     * Determines whether the app has access to the specified storage item in the access list.
     * @param file The storage item to check for access.
     * @return  True if the app can access the storage item; otherwise false.
     */
    checkAccess(file: undefined.IStorageItem): boolean;

    /**
     * Removes all storage items from the access list. 
     */
    clear(): void;

    /**
     * Determines whether the access list contains the specified storage item.
     * @param token The token of the storage item to look for.
     * @return  True if the access list contains the specified storage item; false otherwise.
     */
    containsItem(token: string): boolean;

    /**
     * Gets an object for retrieving storage items from the access list. 
     */
    entries: undefined.AccessListEntryView;

    /**
     * Retrieves the specified StorageFile from the list.
     * @param token The token of the StorageFile to retrieve.
     * @return  When this method completes successfully, it returns the StorageFile that is associated with the specified token.
     */
    getFileAsync(token: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Retrieves the StorageFile from the list using the specified options.
     * @param token The token of the StorageFile to retrieve.
     * @param options The enum value that describes the behavior to use when the app accesses the item.
     * @return  When this method completes successfully, it returns the StorageFile that is associated with the specified token.
     */
    getFileAsync(
        token: string,
        options: undefined.AccessCacheOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Retrieves the specified StorageFolder from the list using the specified options.
     * @param token The token of the StorageFolder to retrieve.
     * @param options The enum value that describes the behavior to use when the app accesses the item.
     * @return  When this method completes successfully, it returns the StorageFolder that is associated with the specified token.
     */
    getFolderAsync(
        token: string,
        options: undefined.AccessCacheOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Retrieves the specified StorageFolder from the list.
     * @param token The token of the StorageFolder to retrieve.
     * @return  When this method completes successfully, it returns the StorageFolder that is associated with the specified token.
     */
    getFolderAsync(token: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Retrieves the specified item (like a file or folder) from the most recently used (MRU) list.
     * @param token The token of the item to retrieve.
     * @return  When this method completes successfully, it returns the item (type IStorageItem ) that is associated with the specified token.
     */
    getItemAsync(token: string): undefined.IPromiseWithIAsyncOperation<undefined.IStorageItem>;

    /**
     * Retrieves the specified item (like a file or folder) from the list using the specified options.
     * @param token The token of the item to retrieve.
     * @param options The enum value that describes the behavior to use when the app accesses the item.
     * @return  When this method completes successfully, it returns the item (type IStorageItem ) that is associated with the specified token.
     */
    getItemAsync(
        token: string,
        options: undefined.AccessCacheOptions): undefined.IPromiseWithIAsyncOperation<undefined.IStorageItem>;

    /**
     * Gets the maximum number of storage items that the access list can contain. 
     */
    maximumItemsAllowed: number;

    /**
     * Removes the specified storage item from the access list.
     * @param token The token of the storage item to remove.
     */
    remove(token: string): void
}


/**
 * Represents your app's most recently used list (MRU) (obtained from the static StorageApplicationPermissions.MostRecentlyUsedList property). You use your MRU to track items (files and/or folders) that the user has accessed most recently. Items are stored in the MRU as StorageFile and StorageFolder objects. 
 */
declare class StorageItemMostRecentlyUsedList {

    /**
     * Adds a new storage item and accompanying metadata to the most recently used (MRU) list.
     * @param file The storage item to add.
     * @param metadata Optional metadata to associate with the storage item.
     * @return  A token that the app can use later to retrieve the storage item.
     */
    add(file: undefined.IStorageItem, metadata: string): string;

    /**
     * Adds a new storage item to the most recently used (MRU) list.
     * @param file The storage item to add.
     * @return  A token that the app can use later to retrieve the storage item.
     */
    add(file: undefined.IStorageItem): string;

    /**
     * Adds a new storage item and accompanying metadata to the most recently used (MRU) list, specifying the extent of its visibility in the list.
     * @param file The storage item to add.
     * @param metadata Optional metadata to associate with the storage item.
     * @param visibility The extent of the visibility of the storage item in the list.
     * @return  A token that the app can use later to retrieve the storage item.
     */
    add(
        file: undefined.IStorageItem,
        metadata: string,
        visibility: undefined.RecentStorageItemVisibility): string;

    /**
     * Adds a new storage item to the most recently used (MRU) list, or replaces the specified item if it already exists in the list.
     * @param token The token associated with the new storage item. If the access list already contains a storage item that has this token, the new item replaces the existing one.
     * @param file The storage item to add or replace.
     */
    addOrReplace(token: string, file: undefined.IStorageItem): void;

    /**
     * Adds a new storage item and accompanying metadata to the most recently used (MRU) list, or replaces the specified item if it already exists in the list.
     * @param token The token associated with the new storage item. If the access list already contains a storage item that has this token, the new item replaces the existing one.
     * @param file The storage item to add or replace.
     * @param metadata Optional metadata to associate with the storage item.
     */
    addOrReplace(token: string, file: undefined.IStorageItem, metadata: string): void;

    /**
     * Adds a new storage item and accompanying metadata to the most recently used (MRU) list, or replaces the specified item if it already exists in the list. Also specifies the extent of its visibility in the list.
     * @param token The token associated with the new storage item. If the access list already contains a storage item that has this token, the new item replaces the existing one.
     * @param file The storage item to add or replace.
     * @param metadata Optional metadata to associate with the storage item.
     * @param visibility The extent of the visibility of the storage item in the list.
     */
    addOrReplace(
        token: string,
        file: undefined.IStorageItem,
        metadata: string,
        visibility: undefined.RecentStorageItemVisibility): void;

    /**
     * Determines whether the app has access to the specified storage item in the most recently used (MRU) list.
     * @param file The storage item to check for access.
     * @return  True if the app can access the storage item; otherwise false.
     */
    checkAccess(file: undefined.IStorageItem): boolean;

    /**
     * Removes all storage items from the most recently used (MRU) list. 
     */
    clear(): void;

    /**
     * Determines whether the most recently used (MRU) list contains the specified storage item.
     * @param token The token of the storage item to look for.
     * @return  True if the MRU list contains the specified storage item; false otherwise.
     */
    containsItem(token: string): boolean;

    /**
     * Gets an object for retrieving storage items from the most recently used (MRU) list. 
     */
    entries: undefined.AccessListEntryView;

    /**
     * Retrieves the specified storageFile from the most recently used (MRU) list using the specified options.
     * @param token The token of the storageFile to retrieve.
     * @param options The enum value that describes the behavior to use when the app accesses the item.
     * @return  When this method completes successfully, it returns the storageFile that is associated with the specified token.
     */
    getFileAsync(
        token: string,
        options: undefined.AccessCacheOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Retrieves the specified storageFile from the most recently used (MRU) list.
     * @param token The token of the storageFile to retrieve.
     * @return  When this method completes successfully, it returns the storageFile that is associated with the specified token.
     */
    getFileAsync(token: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Retrieves the specified StorageFolder from the most recently used (MRU) list.
     * @param token The token of the StorageFolder to retrieve.
     * @return  When this method completes successfully, it returns the StorageFolder that is associated with the specified token.
     */
    getFolderAsync(token: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Retrieves the specified StorageFolder from the most recently used (MRU) list using the specified options.
     * @param token The token of the StorageFolder to retrieve.
     * @param options The enum value that describes the behavior to use when the app accesses the item.
     * @return  When this method completes successfully, it returns the StorageFolder that is associated with the specified token.
     */
    getFolderAsync(
        token: string,
        options: undefined.AccessCacheOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Retrieves the specified item (like a file or folder) from the most recently used (MRU) list using the specified options.
     * @param token The token of the item to retrieve.
     * @param options The enum value that describes the behavior to use when the app accesses the item.
     * @return  When this method completes successfully, it returns the item (type IStorageItem ) that is associated with the specified token.
     */
    getItemAsync(
        token: string,
        options: undefined.AccessCacheOptions): undefined.IPromiseWithIAsyncOperation<undefined.IStorageItem>;

    /**
     * Retrieves the specified item (like a file or folder) from the most recently used (MRU) list.
     * @param token The token of the item to retrieve.
     * @return  When this method completes successfully, it returns the item (type IStorageItem ) that is associated with the specified token.
     */
    getItemAsync(token: string): undefined.IPromiseWithIAsyncOperation<undefined.IStorageItem>;

    /**
     * Gets the maximum number of storage items that the most recently used (MRU) list can contain. 
     */
    maximumItemsAllowed: number;

    /**
     * Fires when a storage item is removed from the most recently used (MRU) list. 
     */
    onitemremoved: undefined.TypedEventHandler<undefined.StorageItemMostRecentlyUsedList, undefined.ItemRemovedEventArgs>;
    addEventListener(
        type: "itemremoved",
        listener: undefined.TypedEventHandler<undefined.StorageItemMostRecentlyUsedList, undefined.ItemRemovedEventArgs>): void;
    removeEventListener(
        type: "itemremoved",
        listener: undefined.TypedEventHandler<undefined.StorageItemMostRecentlyUsedList, undefined.ItemRemovedEventArgs>): void;

    /**
     * Removes the specified storage item from the most recently used (MRU) list.
     * @param token The token of the storage item to remove.
     */
    remove(token: string): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a list entry that contains the identifier and metadata for a StorageFile or StorageFolder object in a list. 
 */
declare interface AccessCache$AccessListEntry {

    /**
     * Optional app-specified metadata associated with the StorageFile or StorageFolder in the list. 
     */
    metadata: string,

        /**
         * The identifier of the StorageFile or StorageFolder in the list. 
         */
        token: string
}


/**
 * Provides access to the application data store. Application data consists of files and settings that are either local, roaming, or temporary. 
 */
declare class ApplicationData {

    /**
     * Provides access to the app data store associated with the app's app package. 
     */
    current: undefined.ApplicationData;

    /**
     * Static method that returns the ApplicationData for a User .
     * @param user The User for which the ApplicationData is returned.
     * @return  When this method completes, it returns the requested ApplicationData object.
     */
    getForUserAsync(
        user: undefined.User): undefined.IPromiseWithIAsyncOperation<undefined.ApplicationData>;

    /**
     * Removes all application data from the local, roaming, and temporary app data stores.
     * @return  An object that is used to manage the asynchronous clear operation.
     */
    clearAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Removes all application data from the specified app data store.
     * @param locality One of the enumeration values.
     * @return  An object that is used to manage the asynchronous clear operation.
     */
    clearAsync(
        locality: undefined.ApplicationDataLocality): undefined.IPromiseWithIAsyncAction;

    /**
     * Clears the files and subfolders from the specified subfolder of the shared storage folder for the publisher of the current app.
     * @param folderName The subfolder of the shared storage folder for the publisher of the current app from which to clear the files and subfolders.
     * @return  Represents an asynchronous action that does not return a result and does not have progress notifications. You can use this value to get the results of the operation, or to specify a method to run when the operation completes - for example, to repopulate the shared storage folder with new data.
     */
    clearPublisherCacheFolderAsync(folderName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the specified subfolder of the shared storage folder for the publisher of the current app.
     * @param folderName The subfolder to get from the shared storage folder for the publisher of the current app.
     * @return  The specified subfolder.
     */
    getPublisherCacheFolder(folderName: string): undefined.StorageFolder;

    /**
     * Gets the folder in the local app data store where you can save files that are not included in backup and restore. 
     */
    localCacheFolder: undefined.StorageFolder;

    /**
     * Gets the root folder in the local app data store. 
     */
    localFolder: undefined.StorageFolder;

    /**
     * Gets the application settings container in the local app data store. 
     */
    localSettings: undefined.ApplicationDataContainer;

    /**
     * Occurs when roaming application data is synchronized. 
     */
    ondatachanged: undefined.TypedEventHandler<undefined.ApplicationData, any>;
    addEventListener(
        type: "datachanged",
        listener: undefined.TypedEventHandler<undefined.ApplicationData, any>): void;
    removeEventListener(
        type: "datachanged",
        listener: undefined.TypedEventHandler<undefined.ApplicationData, any>): void;

    /**
     * Gets the root folder in the roaming app data store. 
     */
    roamingFolder: undefined.StorageFolder;

    /**
     * Gets the application settings container in the roaming app data store. 
     */
    roamingSettings: undefined.ApplicationDataContainer;

    /**
     * Gets the maximum size of the data that can be synchronized to the cloud from the roaming app data store. 
     */
    roamingStorageQuota: number;

    /**
     * Sets the version number of the application data in the app data store.
     * @param desiredVersion The new version number.
     * @param handler The set version event handler.
     * @return  An object that is used to manage the asynchronous set version operation.
     */
    setVersionAsync(
        desiredVersion: number,
        handler: undefined.ApplicationDataSetVersionHandler): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the root folder in the shared app data store. 
     */
    sharedLocalFolder: undefined.StorageFolder;

    /**
     * Sends a DataChanged | datachanged event to all registered event handlers. 
     */
    signalDataChanged(): void;

    /**
     * Gets the root folder in the temporary app data store. 
     */
    temporaryFolder: undefined.StorageFolder;

    /**
     * Gets the version number of the application data in the app data store. 
     */
    version: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents related app settings that must be serialized and deserialized atomically. 
 */
declare class ApplicationDataCompositeValue {

    /**
     * Creates and initializes a new, initially empty, instance of the object. 
     */
    constructor(): this;

    /**
     * Removes all application settings previously inserted into the composite value object, returning the object to its empty state. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to enumerate the settings in the composite value.
     * @return  The iterator.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Returns a read-only snapshot of the contents of the composite value.
     * @return  The view of the composite value.
     */
    getView(): undefined.IMapView<string, any>;

    /**
     * Determines whether there is an application setting with the specified key.
     * @param key The key.
     * @return  True if the key is found; otherwise false.
     */
    hasKey(key: string): boolean;

    /**
     * Creates or replaces an application setting.
     * @param key The key of the setting to insert or replace.
     * @param value The setting value.
     * @return  True if an item with the specified key is an existing item and was replaced; otherwise, false.
     */
    insert(key: string, value: any): boolean;

    /**
     * Retrieves the specified application setting.
     * @param key The key of the setting.
     * @return  The application setting.
     */
    lookup(key: string): any;

    /**
     * Occurs when the map changes. 
     */
    onmapchanged: undefined.MapChangedEventHandler<string, any>;
    addEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, any>): void;
    removeEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, any>): void;

    /**
     * Removes the value with the specified key.
     * @param key The key of the value to remove.
     */
    remove(key: string): void;

    /**
     * Removes a specific item from the ApplicationDataCompositeValue .
     * @param key The key of the item to remove.
     * @return  true if the item was removed, otherwise false.
     */
    remove(key: string): boolean;

    /**
     * Gets the number of related application settings. 
     */
    size: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents a container for app settings. The methods and properties of this class support creating, deleting, enumerating, and traversing the container hierarchy. 
 */
declare class ApplicationDataContainer {

    /**
     * Gets the child application settings containers of this application settings container. 
     */
    containers: undefined.IMapView<string, undefined.ApplicationDataContainer>;

    /**
     * Creates or opens the specified settings container in the current settings container.
     * @param name The name of the container.
     * @param disposition One of the enumeration values.
     * @return  The settings container.
     */
    createContainer(
        name: string,
        disposition: undefined.ApplicationDataCreateDisposition): undefined.ApplicationDataContainer;

    /**
     * Deletes the specified settings container, its subcontainers, and all application settings in the hierarchy.
     * @param name The name of the settings container.
     */
    deleteContainer(name: string): void;

    /**
     * Gets the type (local or roaming) of the app data store that is associated with the current settings container. 
     */
    locality: undefined.ApplicationDataLocality;

    /**
     * Gets the name of the current settings container. 
     */
    name: string;

    /**
     * Gets an object that represents the settings in this settings container. 
     */
    values: undefined.IPropertySet
}


/**
 * Provides access to the settings in a settings container. The ApplicationDataContainer.Values property returns an object that can be cast to this type. 
 */
declare class ApplicationDataContainerSettings {

    /**
     * Removes all related application settings. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to enumerate the settings in the settings container.
     * @return  The iterator.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Returns a read-only snapshot of the contents of the settings container.
     * @return  The view of the settings container.
     */
    getView(): undefined.IMapView<string, any>;

    /**
     * Determines whether there is an application setting with the specified key.
     * @param key The key.
     * @return  True if the key is found; otherwise false.
     */
    hasKey(key: string): boolean;

    /**
     * Inserts or replaces an application setting.
     * @param key The key of the setting to insert or replace.
     * @param value The setting value.
     * @return  True if an item with the specified key is an existing item and was replaced; otherwise, false.
     */
    insert(key: string, value: any): boolean;

    /**
     * Retrieves the specified application setting.
     * @param key The key of the setting.
     * @return  The application setting.
     */
    lookup(key: string): any;

    /**
     * Occurs when the map changes. 
     */
    onmapchanged: undefined.MapChangedEventHandler<string, any>;
    addEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, any>): void;
    removeEventListener(
        type: "mapchanged",
        listener: undefined.MapChangedEventHandler<string, any>): void;

    /**
     * Removes the specified application setting.
     * @param key The key of the setting.
     */
    remove(key: string): void;

    /**
     * Removes a specific item from the ApplicationDataContainerSettings .
     * @param key The key of the item to remove.
     * @return  true if the item was removed, otherwise false.
     */
    remove(key: string): boolean;

    /**
     * Gets the number of related application settings. 
     */
    size: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides synchronous access to the properties exposed off StorageFile and lets an app perform asynchronous file operations such as copy, delete, move, and rename. 
 */
declare class FileInformation {

    /**
     * Gets the attributes of a file. 
     */
    attributes: undefined.FileAttributes;

    /**
     * Gets an object that contains the basic properties information of the file. 
     */
    basicProperties: undefined.BasicProperties;

    /**
     * Gets a string that describes the contents of the file. 
     */
    contentType: string;

    /**
     * Replaces the specified StorageFile with a copy of the current file.
     * @param fileToReplace The StorageFile to be replaced.
     * @return  No object or value is returned when this method completes.
     */
    copyAndReplaceAsync(fileToReplace: undefined.IStorageFile): undefined.IPromiseWithIAsyncAction;

    /**
     * Creates a copy of the StorageFile , gives it the specified file name, and stores it in the specified StorageFolder .
     * @param destinationFolder The folder in which to store the copied file.
     * @param desiredNewName The name of the new copy.
     * @return  When this method completes successfully, it returns the copy as a StorageFile object.
     */
    copyAsync(
        destinationFolder: undefined.IStorageFolder,
        desiredNewName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates a copy of the StorageFile , gives it the specified file name, and stores it in the specified StorageFolder . The method also specifies what to do if a file with the same name already exists in the specified folder.
     * @param destinationFolder The folder in which to store the copied file.
     * @param desiredNewName The name of the new copy.
     * @param option A value that indicates what to do if the file name already exists in the destination folder.
     * @return  When this method completes successfully, it returns the copy as a StorageFile object.
     */
    copyAsync(
        destinationFolder: undefined.IStorageFolder,
        desiredNewName: string,
        option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates a copy of the StorageFile and stores it in the specified StorageFolder .
     * @param destinationFolder The folder in which to store the copied file.
     * @return  When this method completes successfully, it returns the copy as a StorageFile object.
     */
    copyAsync(
        destinationFolder: undefined.IStorageFolder): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Gets the date that the file was created. 
     */
    dateCreated: Date;

    /**
     * Deletes a file.
     * @return  No object or value is returned when this method completes.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Deletes a file, optionally moving the deleted file to the recycle bin.
     * @param option A value that specifies whether the deleted file is moved to the recycle bin.
     * @return  No object or value is returned when this method completes.
     */
    deleteAsync(option: undefined.StorageDeleteOption): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the user-friendly name of the StorageFile . 
     */
    displayName: string;

    /**
     * Gets the display type of the StorageFile . 
     */
    displayType: string;

    /**
     * Gets an object that provides access to the document properties of the StorageFile , such as the title, author name, and so on. 
     */
    documentProperties: undefined.DocumentProperties;

    /**
     * Gets the file type. 
     */
    fileType: string;

    /**
     * Gets the identifier that uniquely identifies the StorageFile relative to other items in the same folder. 
     */
    folderRelativeId: string;

    /**
     * Retrieves the basic properties of the StorageFile .
     * @return  When this method completes successfully, it returns a BasicProperties object.
     */
    getBasicPropertiesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.BasicProperties>;

    /**
     * Gets the parent folder of the current file.
     * @return  When this method completes, it returns the parent folder as a StorageFolder .
     */
    getParentAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Retrieves the thumbnail that is associated with the StorageFile .
     * @param mode The thumbnail mode to retrieve.
     * @return  When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Retrieves the thumbnail that is associated with the StorageFile , scaling it to the specified size.
     * @param mode The thumbnail mode to retrieve.
     * @param requestedSize The requested size in pixels of thumbnail to retrieve.
     * @return  When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Retrieves the thumbnail that is associated with the StorageFile , based on the specified options.
     * @param mode The thumbnail mode to retrieve.
     * @param requestedSize The requested size in pixels of thumbnail to retrieve.
     * @param options The thumbnail retrieval options.
     * @return  When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number,
        options: undefined.ThumbnailOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Gets the image properties of the StorageFile , such as the title, rating, date that the image was taken, and so on. 
     */
    imageProperties: undefined.ImageProperties;

    /**
     * Indicates if the current file has been downloaded or can be downloaded. 
     */
    isAvailable: boolean;

    /**
     * Indicates whether the current file is the same as the specified storage item.
     * @param item The IStorageItem object that represents a storage item to compare against.
     * @return  Returns true if the current storage item is the same as the specified storage item; otherwise false.
     */
    isEqual(item: undefined.IStorageItem): boolean;

    /**
     * Determines whether the loaded StorageFile is the specified type.
     * @param type The type of item to check against.
     * @return  True if the loaded StorageFile is the specified type; otherwise false.
     */
    isOfType(type: undefined.StorageItemTypes): boolean;

    /**
     * Moves the current StorageFile from its location and uses it to replace the specified StorageFile.
     * @param fileToReplace The StorageFile to be replaced.
     * @return  An object for managing the asynchronous move and replace operation.
     */
    moveAndReplaceAsync(fileToReplace: undefined.IStorageFile): undefined.IPromiseWithIAsyncAction;

    /**
     * Moves the StorageFile to the specified StorageFolder .
     * @param destinationFolder The destination folder.
     * @return  No object or value is returned when this method completes.
     */
    moveAsync(
        destinationFolder: undefined.IStorageFolder): undefined.IPromiseWithIAsyncAction;

    /**
     * Moves the StorageFile to the specified folder and gives it the specified file name. The method also specifies what to do if a file with the same name already exists in the specified folder.
     * @param destinationFolder The destination folder.
     * @param desiredNewName The new file name.
     * @param option A value that indicates what to do if the file name already exists in the destination folder.
     * @return  No object or value is returned when this method completes.
     */
    moveAsync(
        destinationFolder: undefined.IStorageFolder,
        desiredNewName: string,
        option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncAction;

    /**
     * Moves the StorageFile to the specified folder, and gives the file the specified file name.
     * @param destinationFolder The destination folder.
     * @param desiredNewName The new file name.
     * @return  No object or value is returned when this method completes.
     */
    moveAsync(
        destinationFolder: undefined.IStorageFolder,
        desiredNewName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the music properties associated with the StorageFile , such as the album name, artist name, bit rate, and so on. 
     */
    musicProperties: undefined.MusicProperties;

    /**
     * Gets the name of the StorageFile . 
     */
    name: string;

    /**
     * Occurs when one or more of the StorageFile 's properties is updated. 
     */
    onpropertiesupdated: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>;
    addEventListener(
        type: "propertiesupdated",
        listener: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>): void;
    removeEventListener(
        type: "propertiesupdated",
        listener: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>): void;

    /**
     * Fires when the StorageFile 's thumbnail is updated or a better quality thumbnail is available. 
     */
    onthumbnailupdated: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>;
    addEventListener(
        type: "thumbnailupdated",
        listener: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>): void;
    removeEventListener(
        type: "thumbnailupdated",
        listener: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>): void;

    /**
     * Opens a random-access stream with the specified options over the specified file.
     * @param accessMode One of the enumeration values that specifies the type of access to allow.
     * @return  When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
     */
    openAsync(
        accessMode: undefined.FileAccessMode): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStream>;

    /**
     * Opens a random-access stream with the specified options over the specified file.
     * @param accessMode One of the enumeration values that specifies the type of access to allow.
     * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
     * @return  When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
     */
    openAsync(
        accessMode: undefined.FileAccessMode,
        options: undefined.StorageOpenOptions): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStream>;

    /**
     * Opens a read-only, random-access stream over the StorageFile .
     * @return  When this method completes successfully, it returns a read-only, random-access stream (type IRandomAccessStreamWithContentType ).
     */
    openReadAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStreamWithContentType>;

    /**
     * Opens a read-only, sequential-access stream over the StorageFile .
     * @return  When this method completes successfully, it returns a read-only, sequential-access stream (type IInputStream ).
     */
    openSequentialReadAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IInputStream>;

    /**
     * Opens a random-access stream to the file that can be used for transacted-write operations.
     * @return  When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
     */
    openTransactedWriteAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageStreamTransaction>;

    /**
     * Opens a random-access stream to the file that can be used for transacted-write operations with the specified options.
     * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
     * @return  When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
     */
    openTransactedWriteAsync(
        options: undefined.StorageOpenOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageStreamTransaction>;

    /**
     * Gets the path of the StorageFile . 
     */
    path: string;

    /**
     * Gets an object for retrieving the properties of the StorageFile . 
     */
    properties: undefined.StorageItemContentProperties;

    /**
     * Gets the StorageProvider object that contains info about the service that stores the current file. 
     */
    provider: undefined.StorageProvider;

    /**
     * Renames the StorageFile .
     * @param desiredName The new name.
     * @return  No object or value is returned when this method completes.
     */
    renameAsync(desiredName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Renames the StorageFile , and specifies what to do if a file with the same name already exists in the current folder.
     * @param desiredName The new name.
     * @param option A value that indicates what to do if the file name already exists in the current folder.
     * @return  No object or value is returned when this method completes.
     */
    renameAsync(
        desiredName: string,
        option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the thumbnail associated with the StorageFile . 
     */
    thumbnail: undefined.StorageItemThumbnail;

    /**
     * Gets an object that provides access to the video properties of the StorageFile , such as the duration, rating, date released, and so on. 
     */
    videoProperties: undefined.VideoProperties;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Used to load information about files and folders from the results of a query and to bind these file system items to JavaScript ListView or XAML ListView and GridView controls. After information is loaded, an app can then access that information quickly using synchronous operations. 
 */
declare class FileInformationFactory {

    /**
     * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result, specifies the requested size and options for thumbnails that are retrieved for the objects, and indicates whether to delay loading information.
     * @param queryResult The result of a query of files and folders on the system.
     * @param mode A value that indicates the type of thumbnail view to retrieve for the StorageFile and StorageFolder .
     * @param requestedThumbnailSize The requested minimum size, in pixels, of the StorageFile and StorageFolder thumbnails.
     * @param thumbnailOptions The thumbnail retrieval options.
     * @param delayLoad True to delay loading information; otherwise false. By default, this option is false and delay loading is not used.
     */
    constructor(queryResult: undefined.IStorageQueryResultBase, mode: undefined.ThumbnailMode, requestedThumbnailSize: number, thumbnailOptions: undefined.ThumbnailOptions, delayLoad: boolean): this;

    /**
     * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result, and that specifies the requested size and options for thumbnails that are retrieved for the objects.
     * @param queryResult The result of a query of files and folders on the system.
     * @param mode A value that indicates the type of thumbnail view to retrieve for the StorageFile and StorageFolder .
     * @param requestedThumbnailSize The requested minimum size, in pixels, of the StorageFile and StorageFolder thumbnails.
     * @param thumbnailOptions The thumbnail retrieval options.
     */
    constructor(queryResult: undefined.IStorageQueryResultBase, mode: undefined.ThumbnailMode, requestedThumbnailSize: number, thumbnailOptions: undefined.ThumbnailOptions): this;

    /**
     * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result and that specifies the requested size for thumbnails that are retrieved for the objects.
     * @param queryResult The result of a query of files and folders on the system.
     * @param mode A value that indicates the type of thumbnail view to retrieve for the StorageFile and StorageFolder .
     * @param requestedThumbnailSize The requested minimum size, in pixels, of the StorageFile and StorageFolder thumbnails.
     */
    constructor(queryResult: undefined.IStorageQueryResultBase, mode: undefined.ThumbnailMode, requestedThumbnailSize: number): this;

    /**
     * Creates a new FileInformationFactory object that retrieves information about the StorageFile and StorageFolder objects in the specified query result.
     * @param queryResult The result of a query of files and folders on the system.
     * @param mode A value that indicates the type of thumbnail view to retrieve for the StorageFile and StorageFolder .
     */
    constructor(queryResult: undefined.IStorageQueryResultBase, mode: undefined.ThumbnailMode): this;

    /**
     * Retrieves a collection of FileInformation objects that contain information about a range of StorageFile objects in a collection.
     * @param startIndex The zero-based index of the first StorageFile in the range.
     * @param maxItemsToRetrieve The maximum number of StorageFile objects to retrieve information for.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of FileInformation objects.
     */
    getFilesAsync(
        startIndex: number,
        maxItemsToRetrieve: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a collection of FileInformation objects that contain information about all StorageFile objects in a collection.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of FileInformation objects.
     */
    getFilesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a collection of FolderInformation objects that contain information about a range of StorageFolder objects in a collection.
     * @param startIndex The zero-based index of the first StorageFolder in the range.
     * @param maxItemsToRetrieve The maximum number of StorageFolder objects to retrieve information for.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of FolderInformation objects.
     */
    getFoldersAsync(
        startIndex: number,
        maxItemsToRetrieve: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a collection of FolderInformation objects that contain information about all StorageFolder objects in a collection.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of FolderInformation objects.
     */
    getFoldersAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a collection of IStorageItemInformation objects that contain information about all the items in the collection.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of FileInformation and FolderInformation objects.
     */
    getItemsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a collection of IStorageItemInformation objects that contain information about a range of items in a collection.
     * @param startIndex The zero-based index of the first item in the range.
     * @param maxItemsToRetrieve The maximum number of items to retrieve information for.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of FileInformation and FolderInformation objects.
     */
    getItemsAsync(
        startIndex: number,
        maxItemsToRetrieve: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets a virtualized vector of IStorageItemInformation objects that can be bound to ListView or GridView controls in C#, C++, and VB.
     * @return  The virtualized vector of IStorageItemInformation objects.
     */
    getVirtualizedFilesVector(): any;

    /**
     * Gets a virtualized vector of IStorageItemInformation objects that can be bound to ListView or GridView controls in C#, C++, and VB.
     * @return  The virtualized vector of IStorageItemInformation objects.
     */
    getVirtualizedFoldersVector(): any;

    /**
     * Gets a virtualized vector of IStorageItemInformation objects that can be bound to ListView or GridView controls in C#, C++, and VB.
     * @return  The virtualized vector of IStorageItemInformation objects.
     */
    getVirtualizedItemsVector(): any
}


/**
 * Provides synchronous access to the properties exposed off StorageFolder and lets an app perform asynchronous management operations such as copy, delete, move, and rename. 
 */
declare class FolderInformation {

    /**
     * Retrieves a value that indicates whether the folder supports the specified search query options.
     * @param queryOptions The search query options to test.
     * @return  True if the folder supports the specified search query options; otherwise false.
     */
    areQueryOptionsSupported(queryOptions: undefined.QueryOptions): boolean;

    /**
     * Gets the attributes of a loaded folder. 
     */
    attributes: undefined.FileAttributes;

    /**
     * Gets an object that contains the basic properties information of the folder. 
     */
    basicProperties: undefined.BasicProperties;

    /**
     * Creates a new file in the current folder.
     * @param desiredName The name of the new file.
     * @return  When this method completes successfully, it returns a StorageFile that represents the new file.
     */
    createFileAsync(
        desiredName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates a new file in the current folder, and specifies what to do if a file with the same name already exists in the current folder.
     * @param desiredName The name of the new file.
     * @param options A value that indicates what to do if the file name already exists in the current folder.
     * @return  When this method completes successfully, it returns a StorageFile that represents the new file.
     */
    createFileAsync(
        desiredName: string,
        options: undefined.CreationCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates an object for performing filtered search queries for StorageFile in the current folder.
     * @return  An object for managing the search queries and accessing the results.
     */
    createFileQuery(): undefined.StorageFileQueryResult;

    /**
     * Creates an object for performing filtered search queries for StorageFile objects in the current folder. Search results are grouped based on the specified file attribute.
     * @param query A value that specifies the folder attribute to use to group the search results.
     * @return  An object for managing the search queries and accessing the results.
     */
    createFileQuery(query: undefined.CommonFileQuery): undefined.StorageFileQueryResult;

    /**
     * Creates an object used to perform filtered search queries for StorageFile objects in the folder. The object is initialized with the specified query options.
     * @param queryOptions The initial query options.
     * @return  An object for managing the search queries and accessing the results.
     */
    createFileQueryWithOptions(queryOptions: undefined.QueryOptions): undefined.StorageFileQueryResult;

    /**
     * Creates a new child folder of the current folder, and specifies what to do if a folder with the same name already exists in the current folder.
     * @param desiredName The name of the new folder.
     * @param options A value that indicates what to do if the child folder already exists in the current folder.
     * @return  When this method completes successfully, it returns a StorageFolder that represents the new file.
     */
    createFolderAsync(
        desiredName: string,
        options: undefined.CreationCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Creates a new child folder of the current folder.
     * @param desiredName The name of the new folder.
     * @return  When this method completes successfully, it returns a StorageFolder that represents the new file.
     */
    createFolderAsync(
        desiredName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Creates an object for performing filtered search queries for child StorageFolder objects of the current folder.
     * @return  An object for managing the search queries and accessing the results.
     */
    createFolderQuery(): undefined.StorageFolderQueryResult;

    /**
     * Creates an object for performing filtered search queries for child StorageFolder objects of the current folder. Search results are grouped based on the specified folder attribute.
     * @param query A value that specifies the folder attribute to use to group the search results.
     * @return  An object for managing the search queries and accessing the results.
     */
    createFolderQuery(query: undefined.CommonFolderQuery): undefined.StorageFolderQueryResult;

    /**
     * Creates an object used to perform filtered search queries for child StorageFolder objects of the current folder. The object is initialized with the specified query options.
     * @param queryOptions The initial query options.
     * @return  An object for managing the search queries and accessing the results.
     */
    createFolderQueryWithOptions(queryOptions: undefined.QueryOptions): undefined.StorageFolderQueryResult;

    /**
     * Creates an object used to perform filtered search queries for items in the folder.
     * @return  An object for managing the search queries and accessing the results.
     */
    createItemQuery(): undefined.StorageItemQueryResult;

    /**
     * Creates an object used to perform filtered search queries for items in the folder. The object is initialized with the specified query options.
     * @param queryOptions The initial query options.
     * @return  An object for managing the search queries and accessing the results.
     */
    createItemQueryWithOptions(queryOptions: undefined.QueryOptions): undefined.StorageItemQueryResult;

    /**
     * Gets the date that the folder was created. 
     */
    dateCreated: Date;

    /**
     * Deletes the current folder.
     * @return  No object or value is returned when this method completes.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Deletes the current folder, optionally moving the deleted folder to the recycle bin.
     * @param option A value that specifies whether to move the deleted folder to the recycle bin.
     * @return  No object or value is returned when this method completes.
     */
    deleteAsync(option: undefined.StorageDeleteOption): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the user-friendly name of the StorageFolder . 
     */
    displayName: string;

    /**
     * Gets the display type of the StorageFolder . 
     */
    displayType: string;

    /**
     * Gets the document properties of the StorageFolder . 
     */
    documentProperties: undefined.DocumentProperties;

    /**
     * Gets the identifier that uniquely identifies the StorageFolder relative to other items in the same folder. 
     */
    folderRelativeId: string;

    /**
     * Retrieves the basic properties of the StorageFolder object.
     * @return  When this method completes successfully, it returns a BasicProperties object.
     */
    getBasicPropertiesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.BasicProperties>;

    /**
     * Retrieves a file from the current folder.
     * @param name The name of the file to retrieve.
     * @return  When this method completes successfully, it returns a StorageFile .
     */
    getFileAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Retrieves all files from the current folder.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of StorageFile objects in the folder.
     */
    getFilesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves files from the current folder based on a common folder query.
     * @param query The common file query.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of StorageFile objects in the folder.
     */
    getFilesAsync(
        query: undefined.CommonFileQuery): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a range of files from the current folder based on a common file query.
     * @param query The common file query.
     * @param startIndex The zero-based index of the first file in the range.
     * @param maxItemsToRetrieve The maximum number of files to retrieve.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of StorageFile objects in the folder.
     */
    getFilesAsync(
        query: undefined.CommonFileQuery,
        startIndex: number,
        maxItemsToRetrieve: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves the specified child folder from the current folder.
     * @param name The name of the child folder to retrieve.
     * @return  When this method completes successfully, it returns a StorageFolder that represents the specified child folder.
     */
    getFolderAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Retrieves all child folders from the current folder.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of child folders. Each child folder in this list is represented by a StorageFolder object.
     */
    getFoldersAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a range of child folders from the current folder based on a common folder query.
     * @param query The common folder query.
     * @param startIndex The zero-based index of the first child folder in the range.
     * @param maxItemsToRetrieve The maximum number of child folders to retrieve.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of child folders. Each child folder in this list is represented by a StorageFolder object.
     */
    getFoldersAsync(
        query: undefined.CommonFolderQuery,
        startIndex: number,
        maxItemsToRetrieve: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves child folders from the current folder based on a common folder query.
     * @param query The common folder query.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of child folders. Each child folder in this list is represented by a StorageFolder object.
     */
    getFoldersAsync(
        query: undefined.CommonFolderQuery): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves the indexed state of the folder.
     * @return  When this method completes successfully, it returns an IndexedState enumeration value.
     */
    getIndexedStateAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IndexedState>;

    /**
     * Retrieves an item from the folder.
     * @param name The name of the item to retrieve.
     * @return  When this method completes successfully, it returns the item (type IStorageItem ).
     */
    getItemAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.IStorageItem>;

    /**
     * Retrieves all items from the current folder.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of items.
     */
    getItemsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a range of items from the current folder.
     * @param startIndex The zero-based index of the first item in the range.
     * @param maxItemsToRetrieve The maximum number of items to retrieve.
     * @return  When this method completes successfully, it returns the list (type IVectorView ) of items.
     */
    getItemsAsync(
        startIndex: number,
        maxItemsToRetrieve: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the parent folder of the current folder.
     * @return  When this method completes, it returns the parent folder as a StorageFolder .
     */
    getParentAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Retrieves the thumbnail that is associated with the StorageFolder , scaling it to the specified size.
     * @param mode The thumbnail mode to retrieve.
     * @param requestedSize The requested size in pixels of thumbnail to retrieve.
     * @return  When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Retrieves the thumbnail that is associated with the StorageFolder .
     * @param mode The thumbnail mode to retrieve.
     * @return  When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Retrieves the thumbnail that is associated with the StorageFolder , based on the specified options.
     * @param mode The thumbnail mode to retrieve.
     * @param requestedSize The requested size in pixels of thumbnail to retrieve.
     * @param options The thumbnail retrieval options.
     * @return  When this method completes successfully, it returns the thumbnail image as a StorageItemThumbnail object.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number,
        options: undefined.ThumbnailOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Gets the image properties of the StorageFolder . 
     */
    imageProperties: undefined.ImageProperties;

    /**
     * Retrieves a value that indicates whether the current folder supports the specified common file query.
     * @param query The common file query to test.
     * @return  True if the folder supports the specified common file query; otherwise false.
     */
    isCommonFileQuerySupported(query: undefined.CommonFileQuery): boolean;

    /**
     * Retrieves a value that indicates whether the current folder supports the specified common folder query.
     * @param query The common folder query to test.
     * @return  True if the folder supports the specified common folder query; otherwise false.
     */
    isCommonFolderQuerySupported(query: undefined.CommonFolderQuery): boolean;

    /**
     * Indicates whether the current folder is equal to the specified folder.
     * @param item The IStorageItem object that represents the folder to compare against.
     * @return  Returns true if the current folder is equal to the specified folder; otherwise false.
     */
    isEqual(item: undefined.IStorageItem): boolean;

    /**
     * Determines whether the loaded StorageFolder is the specified type.
     * @param type The type of item to check against.
     * @return  True if the loaded StorageFolder is the specified type; otherwise false.
     */
    isOfType(type: undefined.StorageItemTypes): boolean;

    /**
     * Gets the music properties associated with the StorageFolder . 
     */
    musicProperties: undefined.MusicProperties;

    /**
     * Gets the name of the StorageFolder . 
     */
    name: string;

    /**
     * Occurs when one or more of the StorageFolder 's properties is updated. 
     */
    onpropertiesupdated: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>;
    addEventListener(
        type: "propertiesupdated",
        listener: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>): void;
    removeEventListener(
        type: "propertiesupdated",
        listener: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>): void;

    /**
     * Fires when the StorageFolder 's thumbnail is updated or a better quality thumbnail is available. 
     */
    onthumbnailupdated: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>;
    addEventListener(
        type: "thumbnailupdated",
        listener: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>): void;
    removeEventListener(
        type: "thumbnailupdated",
        listener: undefined.TypedEventHandler<undefined.IStorageItemInformation, any>): void;

    /**
     * Gets the path of the StorageFolder . 
     */
    path: string;

    /**
     * Gets an object for retrieving the properties of the StorageFolder . 
     */
    properties: undefined.StorageItemContentProperties;

    /**
     * Gets the StorageProvider object that contains info about the service that stores the current folder. 
     */
    provider: undefined.StorageProvider;

    /**
     * Renames the StorageFolder .
     * @param desiredName The new name.
     * @return  No object or value is returned when this method completes.
     */
    renameAsync(desiredName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Renames the StorageFolder , and specifies what to do if a folder with the same name already exists.
     * @param desiredName The new name.
     * @param option A value that indicates what to do if a folder with desiredName already exists.
     * @return  No object or value is returned when this method completes.
     */
    renameAsync(
        desiredName: string,
        option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the thumbnail for the StorageFile . 
     */
    thumbnail: undefined.StorageItemThumbnail;

    /**
     * Try to get a specific file or sub-folder from the current folder using the name of the file or folder to get.
     * @param name The name (or path relative to the current folder) of the file or sub-folder to try to retrieve.
     * @return  When this method completes successfully, it returns the file or folder (type IStorageItem ).
     */
    tryGetItemAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.IStorageItem>;

    /**
     * Gets the video properties that are associated with the StorageFolder . 
     */
    videoProperties: undefined.VideoProperties;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides synchronous access to the properties of a file or folder in the file system. 
 */
declare interface BulkAccess$IStorageItemInformation {

    /**
     * Gets an object that contains the basic properties information of the item. 
     */
    basicProperties: undefined.BasicProperties,

        /**
         * Gets an object that provides access to the document properties of the item, such as the title, author name, and so on. 
         */
        documentProperties: undefined.DocumentProperties,

        /**
         * Gets an object that provides access to the image properties of the item, such as the title, rating, date that the image was taken, and so on. 
         */
        imageProperties: undefined.ImageProperties,

        /**
         * Gets an object that provides access to the music properties of the item, such as the album name, artist name, bit rate, and so on. 
         */
        musicProperties: undefined.MusicProperties,

        /**
         * Gets the thumbnail associated with the item. 
         */
        thumbnail: undefined.StorageItemThumbnail,

        /**
         * Gets an object that provides access to the video properties of the item, such as the duration, rating, date released, and so on. 
         */
        videoProperties: undefined.VideoProperties
}


/**
 * Lets apps manage real-time updates to files. 
 */
declare class CachedFileManager {

    /**
     * Initiates updates for the specified file. This method contacts the app that provided the file to perform the updates.
     * @param file The file to update.
     * @return  When this method completes, it returns a FileUpdateStatus enum value that describes the status of the updates to the file.
     */
    completeUpdatesAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.FileUpdateStatus>;

    /**
     * Lets apps defer real-time updates for a specified file.
     * @param file The file to defer updates for.
     */
    deferUpdates(file: undefined.IStorageFile): void
}


/**
 * A compressor takes information written to a stream and compresses it using a compression algorithm. 
 */
declare class Compressor {

    /**
     * Creates an instance of a compressor.
     * @param underlyingStream The stream of compressed information to be written by the compressor.
     */
    constructor(underlyingStream: undefined.IOutputStream): this;

    /**
     * Creates an instance of a compressor.
     * @param underlyingStream The stream of compressed information to be written by the compressor.
     * @param algorithm The compression algorithm used by the compressor to write underlyingStream.
     * @param blockSize Size in bytes of the intermediate buffer used by the compression algorithm. A value of 0 specifies that the compression algorithm will use its default block size. Valid non-zero values for this parameter are 32Kb to 64Mb.
     */
    constructor(underlyingStream: undefined.IOutputStream, algorithm: undefined.CompressAlgorithm, blockSize: number): this;

    /**
     * Closes a Compressor object and synchronously discards any information in buffers. This will close the underlying stream as well unless the Compressor.Detach method has been used to detach the stream from the object. Subsequent calls on a closed object, except for Compressor.Close, will fail. 
     */
    close(): void;

    /**
     * Detaches the underlying stream from the Compressor object so that the object can be closed using the Compressor.Close method without also closing the underlying stream.
     * @return  The stream of information.
     */
    detachStream(): undefined.IOutputStream;

    /**
     * Finishes writing the compression stream.
     * @return  The asynchronous operation.
     */
    finishAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Flushes the compression stream asynchronously.
     * @return  The asynchronous operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Writes information to the compression stream asynchronously.
     * @param buffer The buffer that contains the information to be written to the stream.
     * @return  The asynchronous operation.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * A decompressor takes a stream compressed by a compressor and decompresses it. 
 */
declare class Decompressor {

    /**
     * This method creates an instance of a decompressor.
     * @param underlyingStream The stream of compressed information to be read and decompressed by the decompressor.
     */
    constructor(underlyingStream: undefined.IInputStream): this;

    /**
     * Closes a Decompressor object and synchronously discards any information in buffers. This will close the underlying stream as well unless the Decompressor.Detach method has been used to detach the stream from the object. Subsequent calls on a closed object, except Decompressor.Close, will fail. 
     */
    close(): void;

    /**
     * Detaches the underlying stream from the Decompressor object so that the object can be closed using the Decompressor.Close method without also closing the underlying stream.
     * @return  The stream of information.
     */
    detachStream(): undefined.IInputStream;

    /**
     * Reads from the compression stream asynchronously.
     * @param buffer The buffer that contains the information to be read from the stream.
     * @param count The number of bytes to read.
     * @param options Read options
     * @return  The asynchronous operation.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number >
}


/**
 * Creates files and folders inside the Downloads folder. 
 */
declare class DownloadsFolder {

    /**
     * Creates a new file inside the Downloads folder.
     * @param desiredName The desired name of the file to create.
     * @return  When this method completes, it returns the new file as a StorageFile object.
     */
    createFileAsync(
        desiredName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates a new file in the Downloads folder, and specifies what to do if a file with the same name already exists in the Downloads folder.
     * @param desiredName The desired name of the file to create.
     * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing file in the current folder.
     * @return  When this method completes, it returns the new file as a StorageFile object.
     */
    createFileAsync(
        desiredName: string,
        option: undefined.CreationCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates a new file inside the Downloads folder of a specific User .
     * @param user The User for which the file is created.
     * @param desiredName The desired name of the file to create.
     * @return  When this method completes, it returns the new file as a StorageFile object.
     */
    createFileForUserAsync(
        user: undefined.User,
        desiredName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates a new file in the Downloads folder of a specific User , and specifies what to do if a file with the same name already exists in the Downloads folder.
     * @param user The User for which the file is created.
     * @param desiredName The desired name of the file to create.
     * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing file in the current folder.
     * @return  When this method completes, it returns the new file as a StorageFile object.
     */
    createFileForUserAsync(
        user: undefined.User,
        desiredName: string,
        option: undefined.CreationCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates a new subfolder in the Downloads folder.
     * @param desiredName The desired name of the subfolder to create.
     * @return  When this method completes, it returns the new subfolder as a StorageFolder .
     */
    createFolderAsync(
        desiredName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Creates a new subfolder in the Downloads folder, and specifies what to do if a subfolder with the same name already exists in the Downloads folder.
     * @param desiredName The desired name of the subfolder to create.
     * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing subfolder in the Downloads folder.
     * @return  When this method completes, it returns the new subfolder as a StorageFolder .
     */
    createFolderAsync(
        desiredName: string,
        option: undefined.CreationCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Creates a new subfolder inside the Downloads folder of a specific User .
     * @param user The User for which the folder is created.
     * @param desiredName The desired name of the subfolder to create.
     * @return  When this method completes, it returns the new subfolder as a StorageFolder .
     */
    createFolderForUserAsync(
        user: undefined.User,
        desiredName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Creates a new subfolder in the Downloads folder of a specific User , and specifies what to do if a subfolder with the same name already exists in the Downloads folder.
     * @param user The User for which the folder is created.
     * @param desiredName The desired name of the subfolder to create.
     * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing subfolder in the Downloads folder.
     * @return  When this method completes, it returns the new subfolder as a StorageFolder .
     */
    createFolderForUserAsync(
        user: undefined.User,
        desiredName: string,
        option: undefined.CreationCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder >
}


/**
 * Provides helper methods for reading and writing files that are represented by objects of type IStorageFile . 
 */
declare class FileIO {

    /**
     * Appends lines of text to the specified file.
     * @param file The file that the lines are appended to.
     * @param lines The list of text strings to append as lines.
     * @return  No object or value is returned when this method completes.
     */
    appendLinesAsync(
        file: undefined.IStorageFile,
        lines: undefined.IIterable<string>): undefined.IPromiseWithIAsyncAction;

    /**
     * Appends lines of text to the specified file using the specified character encoding.
     * @param file The file that the lines are appended to.
     * @param lines The list of text strings to append as lines.
     * @param encoding The character encoding of the file.
     * @return  No object or value is returned when this method completes.
     */
    appendLinesAsync(
        file: undefined.IStorageFile,
        lines: undefined.IIterable<string>,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncAction;

    /**
     * Appends text to the specified file.
     * @param file The file that the text is appended to.
     * @param contents The text to append.
     * @return  No object or value is returned when this method completes.
     */
    appendTextAsync(
        file: undefined.IStorageFile,
        contents: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Appends text to the specified file using the specified character encoding.
     * @param file The file that the text is appended to.
     * @param contents The text to append.
     * @param encoding The character encoding of the file.
     * @return  No object or value is returned when this method completes.
     */
    appendTextAsync(
        file: undefined.IStorageFile,
        contents: string,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncAction;

    /**
     * Reads the contents of the specified file and returns a buffer.
     * @param file The file to read.
     * @return  When this method completes, it returns an object (type IBuffer ) that represents the contents of the file.
     */
    readBufferAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Reads the contents of the specified file and returns lines of text.
     * @param file The file to read.
     * @return  When this method completes successfully, it returns the contents of the file as a list (type IVector ) of lines of text. Each line of text in the list is represented by a String object.
     */
    readLinesAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.IVector<any >> ;

    /**
     * Reads the contents of the specified file using the specified character encoding and returns lines of text.
     * @param file The file to read.
     * @param encoding The character encoding to use.
     * @return  When this method completes successfully, it returns the contents of the file as a list (type IVector ) of lines of text. Each line of text in the list is represented by a String object.
     */
    readLinesAsync(
        file: undefined.IStorageFile,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncOperation<undefined.IVector<any >> ;

    /**
     * Reads the contents of the specified file and returns text.
     * @param file The file to read.
     * @return  When this method completes successfully, it returns the contents of the file as a text string.
     */
    readTextAsync(file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Reads the contents of the specified file using the specified character encoding and returns text.
     * @param file The file to read.
     * @param encoding The character encoding to use.
     * @return  When this method completes successfully, it returns the contents of the file as a text string.
     */
    readTextAsync(
        file: undefined.IStorageFile,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Writes data from a buffer to the specified file.
     * @param file The file that the buffer of data is written to.
     * @param buffer The buffer that contains the data to write.
     * @return  No object or value is returned when this method completes.
     */
    writeBufferAsync(
        file: undefined.IStorageFile,
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncAction;

    /**
     * Writes an array of bytes of data to the specified file.
     * @param file The file that the byte is written to.
     * @param buffer The array of bytes to write.
     * @return  No object or value is returned when this method completes.
     */
    writeBytesAsync(
        file: undefined.IStorageFile,
        buffer: number[]): undefined.IPromiseWithIAsyncAction;

    /**
     * Writes lines of text to the specified file.
     * @param file The file that the lines are written to.
     * @param lines The list of text strings to write as lines.
     * @return  No object or value is returned when this method completes.
     */
    writeLinesAsync(
        file: undefined.IStorageFile,
        lines: undefined.IIterable<string>): undefined.IPromiseWithIAsyncAction;

    /**
     * Writes lines of text to the specified file using the specified character encoding.
     * @param file The file that the lines are written to.
     * @param lines The list of text strings to write as lines.
     * @param encoding The character encoding of the file.
     * @return  No object or value is returned when this method completes.
     */
    writeLinesAsync(
        file: undefined.IStorageFile,
        lines: undefined.IIterable<string>,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncAction;

    /**
     * Writes text to the specified file.
     * @param file The file that the text is written to.
     * @param contents The text to write.
     * @return  No object or value is returned when this method completes.
     */
    writeTextAsync(
        file: undefined.IStorageFile,
        contents: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Writes text to the specified file using the specified character encoding.
     * @param file The file that the text is written to.
     * @param contents The text to write.
     * @param encoding The character encoding of the file.
     * @return  No object or value is returned when this method completes.
     */
    writeTextAsync(
        file: undefined.IStorageFile,
        contents: string,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncAction
}


/**
 * Provides access to the basic properties, like the size of the item or the date the item was last modified, of the item (like a file or folder). 
 */
declare class BasicProperties {

    /**
     * Gets the timestamp of the last time the file was modified. 
     */
    dateModified: Date;

    /**
     * Gets the most relevant date for the item. 
     */
    itemDate: Date;

    /**
     * Retrieves the specified properties associated with the item.
     * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
     * @return  When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
     */
    retrievePropertiesAsync(
        propertiesToRetrieve: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.IMap<any, any >> ;

    /**
     * Saves the specified properties and values associated with the item.
     * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(
        propertiesToSave: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncAction;

    /**
     * Saves all properties associated with the item.
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the size of the file. 
     */
    size: number
}


/**
 * Provides access to the document-related properties of an item (like a file or folder). 
 */
declare class DocumentProperties {

    /**
     * Gets the collection of the document's authors. 
     */
    author: undefined.IVector<string>;

    /**
     * Gets or sets the comments associated with the document. 
     */
    comment: string;

    /**
     * Gets the collection of keywords associated with the document. 
     */
    keywords: undefined.IVector<string>;

    /**
     * Retrieves the specified properties associated with the item.
     * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
     * @return  An object for managing the asynchronous property retrieval operation.
     */
    retrievePropertiesAsync(
        propertiesToRetrieve: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.IMap<any, any >> ;

    /**
     * Saves the specified properties and values associated with the item.
     * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(
        propertiesToSave: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncAction;

    /**
     * Saves all properties associated with the item.
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets the title of the document. 
     */
    title: string
}


/**
 * Provides methods for setting and retrieving geographic metadata for a file. 
 */
declare class GeotagHelper {

    /**
     * Asynchronously retrieves a Geopoint representing the geographic metadata of a file, if present.
     * @param file The file from which the geographic metadata is retrieved.
     * @return  An asynchronous operation that returns a Geopoint on successful completion.
     */
    getGeotagAsync(
        file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.Geopoint>;

    /**
     * Asynchronously sets the geographic metadata of a file from the provided Geopoint .
     * @param file The file into which the geographic metadata is set.
     * @param geopoint The Geopoint representing the geographic metadata to be set.
     * @return  An asynchronous action.
     */
    setGeotagAsync(
        file: undefined.IStorageFile,
        geopoint: undefined.Geopoint): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously sets the geographic metadata of a file to the device's current location using the provided Geolocator object.
     * @param file The file into which the geographic metadata is set.
     * @param geolocator The Geolocator object that will be used to determine the device's current location.
     * @return  An asychronous action.
     */
    setGeotagFromGeolocatorAsync(
        file: undefined.IStorageFile,
        geolocator: undefined.Geolocator): undefined.IPromiseWithIAsyncAction
}


/**
 * Provides access to the image-related properties of an item (like a file or folder). 
 */
declare class ImageProperties {

    /**
     * Gets or sets the manufacturer of the camera that took the photo. 
     */
    cameraManufacturer: string;

    /**
     * Gets or sets the model of the camera that took the photo. 
     */
    cameraModel: string;

    /**
     * Gets or sets the date when the image was taken. 
     */
    dateTaken: Date;

    /**
     * Gets the height of the image. 
     */
    height: number;

    /**
     * Gets the collection of keywords associated with the image. 
     */
    keywords: undefined.IVector<string>;

    /**
     * Gets the latitude coordinate where the photo was taken. 
     */
    latitude: number;

    /**
     * Gets the longitude coordinate where the photo was taken. 
     */
    longitude: number;

    /**
     * Gets the Exchangeable Image File (EXIF) orientation flag of the photo. 
     */
    orientation: undefined.PhotoOrientation;

    /**
     * Gets the names of people who are tagged in the photo. 
     */
    peopleNames: undefined.IVectorView<string>;

    /**
     * Gets or sets the rating associated with an image file. 
     */
    rating: number;

    /**
     * Retrieves the specified properties associated with the item.
     * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
     * @return  When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
     */
    retrievePropertiesAsync(
        propertiesToRetrieve: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.IMap<any, any >> ;

    /**
     * Saves the specified properties and values associated with the item.
     * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(
        propertiesToSave: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncAction;

    /**
     * Saves all properties associated with the item.
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets the title of the image. 
     */
    title: string;

    /**
     * Gets the width of the image. 
     */
    width: number
}


/**
 * Provides access to the music-related properties of an item (like a file or folder). 
 */
declare class MusicProperties {

    /**
     * Gets or sets the name of the album that contains the song. 
     */
    album: string;

    /**
     * Gets or sets the name of the album artist of the song. 
     */
    albumArtist: string;

    /**
     * Gets the artists that contributed to the song. 
     */
    artist: string;

    /**
     * Gets the bit rate of the song file. 
     */
    bitrate: number;

    /**
     * Gets the composers of the song. 
     */
    composers: undefined.IVector<string>;

    /**
     * Gets the conductors of the song. 
     */
    conductors: undefined.IVector<string>;

    /**
     * Gets the duration of the song in milliseconds. 
     */
    duration: number;

    /**
     * Gets the names of music genres that the song belongs to. 
     */
    genre: undefined.IVector<string>;

    /**
     * Gets the producers of the song. 
     */
    producers: undefined.IVector<string>;

    /**
     * Gets or sets the publisher of the song. 
     */
    publisher: string;

    /**
     * Gets or sets the rating associated with a music file. 
     */
    rating: number;

    /**
     * Retrieves the specified properties associated with the item.
     * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
     * @return  When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
     */
    retrievePropertiesAsync(
        propertiesToRetrieve: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.IMap<any, any >> ;

    /**
     * Saves the specified properties and values associated with the item.
     * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(
        propertiesToSave: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncAction;

    /**
     * Saves all properties associated with the item.
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets the subtitle of the song. 
     */
    subtitle: string;

    /**
     * Gets or sets the title of the song 
     */
    title: string;

    /**
     * Gets or sets the track number of the song on the song's album. 
     */
    trackNumber: number;

    /**
     * Gets the songwriters. 
     */
    writers: undefined.IVector<string>;

    /**
     * Gets or sets the year that the song was released. 
     */
    year: number
}


/**
 * Provides access to the content-related properties of an item (like a file or folder). 
 */
declare class StorageItemContentProperties {

    /**
     * Retrieves the document properties of the item (like a file of folder).
     * @return  When this method completes successfully, it returns a documentProperties object.
     */
    getDocumentPropertiesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.DocumentProperties>;

    /**
     * Retrieves the image properties of the item (like a file of folder).
     * @return  When this method completes successfully, it returns an imageProperties object.
     */
    getImagePropertiesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.ImageProperties>;

    /**
     * Retrieves the music properties of the item (like a file of folder).
     * @return  When this method completes successfully, it returns a musicProperties object.
     */
    getMusicPropertiesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.MusicProperties>;

    /**
     * Retrieves the video properties of the item (like a file of folder).
     * @return  When this method completes successfully, it returns a videoProperties object.
     */
    getVideoPropertiesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.VideoProperties>;

    /**
     * Retrieves the specified properties associated with the item.
     * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
     * @return  When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs. The return value of properties can be null.
     */
    retrievePropertiesAsync(
        propertiesToRetrieve: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.IMap<any, any >> ;

    /**
     * Saves all properties associated with the item.
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Saves the specified properties and values associated with the item.
     * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(
        propertiesToSave: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncAction
}


/**
 * Represents the thumbnail image associated with a system resource (like a file or folder). 
 */
declare class StorageItemThumbnail {

    /**
     * Gets a value that indicates whether the thumbnail stream can be read from. 
     */
    canRead: boolean;

    /**
     * Gets a value that indicates whether the thumbnail stream can be written to. 
     */
    canWrite: boolean;

    /**
     * Creates a new stream over the thumbnail that is represented by the current storageItemThumbnail object.
     * @return  The new thumbnail stream. The initial, internal position of the stream is 0.
     */
    cloneStream(): undefined.IRandomAccessStream;

    /**
     * Releases system resources that are exposed by a Windows Runtime object. 
     */
    close(): void;

    /**
     * Gets the MIME content type of the thumbnail image. 
     */
    contentType: string;

    /**
     * Flushes data asynchronously in a sequential stream.
     * @return  The stream flush operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Retrieves the thumbnail image data as an undecoded stream.
     * @param position The position in the storage item to start reading thumbnail image data.
     * @return  An object for reading the thumbnail image data.
     */
    getInputStreamAt(position: number): undefined.IInputStream;

    /**
     * Retrieves an output stream object for writing thumbnail image data to a storage item.
     * @param position The position in the storage item to start writing thumbnail image data.
     * @return  The output stream.
     */
    getOutputStreamAt(position: number): undefined.IOutputStream;

    /**
     * Gets the original (not scaled) height of the thumbnail image. 
     */
    originalHeight: number;

    /**
     * Gets the original (not scaled) width of the thumbnail image. 
     */
    originalWidth: number;

    /**
     * Gets the byte offset of the thumbnail stream. 
     */
    position: number;

    /**
     * Returns an asynchronous byte reader object.
     * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
     * @param count The number of bytes to read that is less than or equal to the Capacity value.
     * @param options Specifies the type of the asynchronous read operation.
     * @return  The asynchronous operation.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Gets a value that indicates whether the thumbnail image returned was a cached version with a smaller size. 
     */
    returnedSmallerCachedSize: boolean;

    /**
     * Sets the offset of the thumbnail stream to the specified value.
     * @param position The number of bytes from the start of the thumbnail stream where the position of the thumbnail stream is set.
     */
    seek(position: number): void;

    /**
     * Gets or sets the size of the thumbnail image. 
     */
    size: number;

    /**
     * Gets a value that indicates if the thumbnail is an icon or an image. 
     */
    type: undefined.ThumbnailType;

    /**
     * Writes data asynchronously in a sequential stream.
     * @param buffer The buffer into which the asynchronous writer operation writes.
     * @return  The byte writer operation.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides access to the video-related properties of an item (like a file or folder). 
 */
declare class VideoProperties {

    /**
     * Gets the sum audio and video bitrate of the video. 
     */
    bitrate: number;

    /**
     * Gets the directors of the video. 
     */
    directors: undefined.IVector<string>;

    /**
     * Gets the duration of the video. 
     */
    duration: number;

    /**
     * Gets the height of the video. 
     */
    height: number;

    /**
     * Gets the collection of keywords associated with the video. 
     */
    keywords: undefined.IVector<string>;

    /**
     * Gets the latitude coordinate where the video was shot. 
     */
    latitude: number;

    /**
     * Gets the longitude coordinate where the video was shot. 
     */
    longitude: number;

    /**
     * Gets a VideoOrientation value that indicates how the video should be rotated to display it correctly. 
     */
    orientation: undefined.VideoOrientation;

    /**
     * Gets the producers of the video. 
     */
    producers: undefined.IVector<string>;

    /**
     * Gets or sets the publisher of the video. 
     */
    publisher: string;

    /**
     * Gets or sets the rating associated with a video file. 
     */
    rating: number;

    /**
     * Retrieves the specified properties associated with the item.
     * @param propertiesToRetrieve A collection that contains the names of the properties to retrieve.
     * @return  When this method completes successfully, it returns a collection (type IMap ) that contains the specified properties and values as key-value pairs.
     */
    retrievePropertiesAsync(
        propertiesToRetrieve: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.IMap<any, any >> ;

    /**
     * Saves the specified properties and values associated with the item.
     * @param propertiesToSave A collection that contains the names and values of the properties to save as key-value pairs (type IKeyValuePair ).
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(
        propertiesToSave: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): undefined.IPromiseWithIAsyncAction;

    /**
     * Saves all properties associated with the item.
     * @return  No object or value is returned when this method completes.
     */
    savePropertiesAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets the subtitle of the video. 
     */
    subtitle: string;

    /**
     * Gets or sets the title of the video. 
     */
    title: string;

    /**
     * Gets the width of the video. 
     */
    width: number;

    /**
     * Gets the script writers for the video. 
     */
    writers: undefined.IVector<string>;

    /**
     * Gets or sets the year that the video was shot or released. 
     */
    year: number
}


/**
 * Provides access to common locations that contain user content. This includes content from a user's local libraries (such as Documents, Pictures, Music, and Videos), HomeGroup, removable devices, and media server devices. 
 */
declare class KnownFolders {

    /**
     * Gets the App Captures folder. 
     */
    appCaptures: undefined.StorageFolder;

    /**
     * Gets the Camera Roll folder. 
     */
    cameraRoll: undefined.StorageFolder;

    /**
     * Gets the Documents library. The Documents library is not intended for general use. 
     */
    documentsLibrary: undefined.StorageFolder;

    /**
     * Static method that returns a specified known folder for a User .
     * @param user The User for which the folder is returned.
     * @param folderId The ID of the folder to be returned.
     * @return  When this method completes, it returns the requested StorageFolder object.
     */
    getFolderForUserAsync(
        user: undefined.User,
        folderId: undefined.KnownFolderId): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Gets the HomeGroup folder. 
     */
    homeGroup: undefined.StorageFolder;

    /**
     * Gets the folder of media server (DLNA) devices. 
     */
    mediaServerDevices: undefined.StorageFolder;

    /**
     * Gets the Music library. 
     */
    musicLibrary: undefined.StorageFolder;

    /**
     * Gets the Objects 3D folder. 
     */
    objects3D: undefined.StorageFolder;

    /**
     * Gets the Pictures library. 
     */
    picturesLibrary: undefined.StorageFolder;

    /**
     * Gets the play lists folder. 
     */
    playlists: undefined.StorageFolder;

    /**
     * Gets the recorded calls folder. 
     */
    recordedCalls: undefined.StorageFolder;

    /**
     * Gets the removable devices folder. 
     */
    removableDevices: undefined.StorageFolder;

    /**
     * Gets the Saved Pictures folder. 
     */
    savedPictures: undefined.StorageFolder;

    /**
     * Gets the Videos library. 
     */
    videosLibrary: undefined.StorageFolder
}


/**
 * Provides helper methods for reading and writing a file using the absolute path or URI of the file. 
 */
declare class PathIO {

    /**
     * Appends lines of text to the file at the specified path or URI using the specified character encoding.
     * @param absolutePath The path of the file that the lines are appended to.
     * @param lines The list of text strings to append as lines.
     * @param encoding The character encoding of the file.
     * @return  No object or value is returned when this method completes.
     */
    appendLinesAsync(
        absolutePath: string,
        lines: undefined.IIterable<string>,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncAction;

    /**
     * Appends lines of text to the file at the specified path or URI.
     * @param absolutePath The path or URI of the file that the lines are appended to.
     * @param lines The list of text strings to append as lines.
     * @return  No object or value is returned when this method completes.
     */
    appendLinesAsync(
        absolutePath: string,
        lines: undefined.IIterable<string>): undefined.IPromiseWithIAsyncAction;

    /**
     * Appends text to the file at the specified path or URI using the specified character encoding.
     * @param absolutePath The path of the file that the text is appended to.
     * @param contents The text to append.
     * @param encoding The character encoding of the file.
     * @return  No object or value is returned when this method completes.
     */
    appendTextAsync(
        absolutePath: string,
        contents: string,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncAction;

    /**
     * Appends text to the file at the specified path or URI.
     * @param absolutePath The path of the file that the text is appended to.
     * @param contents The text to append.
     * @return  No object or value is returned when this method completes.
     */
    appendTextAsync(absolutePath: string, contents: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Reads the contents of the file at the specified path or URI and returns a buffer.
     * @param absolutePath The path of the file to read.
     * @return  When this method completes, it returns an object (type IBuffer ) that represents the contents of the file.
     */
    readBufferAsync(absolutePath: string): undefined.IPromiseWithIAsyncOperation<undefined.IBuffer>;

    /**
     * Reads the contents of the file at the specified path or URI and returns lines of text.
     * @param absolutePath The path of the file to read.
     * @return  When this method completes successfully, it returns the contents of the file as a list (type IVector ) of lines of text. Each line of text in the list is represented by a String object.
     */
    readLinesAsync(
        absolutePath: string): undefined.IPromiseWithIAsyncOperation<undefined.IVector<any >> ;

    /**
     * Reads the contents of the file at the specified path or URI using the specified character encoding and returns lines of text.
     * @param absolutePath The path of the file to read.
     * @param encoding The character encoding of the file.
     * @return  When this method completes successfully, it returns the contents of the file as a list (type IVector ) of lines of text. Each line of text in the list is represented by a String object.
     */
    readLinesAsync(
        absolutePath: string,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncOperation<undefined.IVector<any >> ;

    /**
     * Reads the contents of the file at the specified path or URI and returns text.
     * @param absolutePath The path of the file to read.
     * @return  When this method completes successfully, it returns the contents of the file as a text string.
     */
    readTextAsync(absolutePath: string): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Reads the contents of the file at the specified path or URI using the specified character encoding and returns text.
     * @param absolutePath The path of the file to read.
     * @param encoding The character encoding of the file.
     * @return  When this method completes successfully, it returns the contents of the file as a text string.
     */
    readTextAsync(
        absolutePath: string,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Writes data from a buffer to the file at the specified path or URI.
     * @param absolutePath The path of the file that the data is written to.
     * @param buffer The buffer that contains the data to write.
     * @return  No object or value is returned when this method completes.
     */
    writeBufferAsync(
        absolutePath: string,
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncAction;

    /**
     * Writes a single byte of data to the file at the specified path or URI.
     * @param absolutePath The path of the file that the byte is written to.
     * @param buffer An array of bytes to write.
     * @return  No object or value is returned when this method completes.
     */
    writeBytesAsync(absolutePath: string, buffer: number[]): undefined.IPromiseWithIAsyncAction;

    /**
     * Writes lines of text to the file at the specified path or URI using the specified character encoding.
     * @param absolutePath The path of the file that the lines are appended to.
     * @param lines The list of text strings to append as lines.
     * @param encoding The character encoding of the file.
     * @return  No object or value is returned when this method completes.
     */
    writeLinesAsync(
        absolutePath: string,
        lines: undefined.IIterable<string>,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncAction;

    /**
     * Writes lines of text to the file at the specified path or URI.
     * @param absolutePath The path of the file that the lines are written to.
     * @param lines The list of text strings to append as lines.
     * @return  No object or value is returned when this method completes.
     */
    writeLinesAsync(
        absolutePath: string,
        lines: undefined.IIterable<string>): undefined.IPromiseWithIAsyncAction;

    /**
     * Writes text to the file at the specified path or URI.
     * @param absolutePath The path of the file that the text is written to.
     * @param contents The text to write.
     * @return  No object or value is returned when this method completes.
     */
    writeTextAsync(absolutePath: string, contents: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Writes text to the file at the specified path or URI using the specified character encoding.
     * @param absolutePath The path of the file that the text is written to.
     * @param contents The text to write.
     * @param encoding The character encoding of the file.
     * @return  No object or value is returned when this method completes.
     */
    writeTextAsync(
        absolutePath: string,
        contents: string,
        encoding: undefined.UnicodeEncoding): undefined.IPromiseWithIAsyncAction
}


/**
 * Represents a random-access collection of file name extensions. 
 */
declare class FileExtensionVector mixins Array<string>{

    /**
     * Appends a file name extension to the end of the collection.
     * @param value The file name extension to append.
     */
    append(value: string): void;

    /**
     * Removes all file name extensions from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator that iterates through the file name extensions in the collection.
     * @return  The iterator.
     */
    first(): undefined.IIterator<string>;

    /**
     * Retrieves the file name extension at the specified index in the collection.
     * @param index The zero-based index of the file name extension to retrieve.
     * @return  The file name extension at the specified index.
     */
    getAt(index: number): string;

    /**
     * Retrieves the file name extensions that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the file name extensions in the collection to retrieve.
     */
    getMany(startIndex: number): {
        items: string[],
        returnValue: number
    };

    /**
     * Retrieves an immutable view of the collection of file name extensions.
     * @return  The view of the collection.
     */
    getView(): undefined.IVectorView<string>;

    /**
     * Retrieves the index of a specified file name extension in the collection.
     * @param value The file name extension to find in the collection.
     */
    indexOf(value: string): {
        index: number,
        returnValue: boolean
    };

    /**
     * Inserts a file name extension into a collection at a specified index.
     * @param index Zero-based index of the location at which to insert the file name extension.
     * @param value The file name extension to insert.
     */
    insertAt(index: number, value: string): void;

    /**
     * Removes the file name extension at the specified index in the collection.
     * @param index The zero-based index of the file name extension to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last file name extension from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all file name extensions in the collection with the specified file name extensions.
     * @param items The collection of file name extensions to put in the vector.
     */
    replaceAll(items: string[]): void;

    /**
     * Sets the file name extension at the specified index of the collection.
     * @param index The zero-based index of the location at which to set the file name extension.
     * @param value The file name extension.
     */
    setAt(index: number, value: string): void;

    /**
     * Gets the number of file name extensions in the collection. 
     */
    size: number;
    indexOf(value: string, ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: string, fromIndex?: number): number
}


/**
 * Represents a UI element that lets the user choose and open files. 
 */
declare class FileOpenPicker {
    resumePickSingleFileAsync: any;

    /**
     * Creates a new instance of a FileOpenPicker . 
     */
    constructor(): this;

    /**
     * Gets or sets the label text of the file open picker's commit button. 
     */
    commitButtonText: string;

    /**
     * Gets a set of values to be populated by the app before PickSingleFileAndContinue or PickMultipleFilesAndContinue operation that deactivates the app in order to provide context when the app is activated. (Windows Phone Store apps) 
     */
    continuationData: undefined.ValueSet;

    /**
     * Gets the collection of file types that the file open picker displays. 
     */
    fileTypeFilter: undefined.IVector<string>;

    /**
     * Shows the file picker so that the user can pick multiple files, deactivating and the app and reactivating it when the operation is complete. (Windows Phone Store apps) 
     */
    pickMultipleFilesAndContinue(): void;

    /**
     * Shows the file picker so that the user can pick multiple files. (Windows Store apps)
     * @return  When the call to this method completes successfully, it returns a filePickerSelectedFilesArray object that contains all the files that were picked by the user. Picked files in this array are represented by storageFile objects.
     */
    pickMultipleFilesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Shows the file picker so that the user can pick one file, potentially deactivating the app and reactivating it when the operation is complete. (Windows Phone Store apps) 
     */
    pickSingleFileAndContinue(): void;

    /**
     * Shows the file picker so that the user can pick one file.
     * @return  When the call to this method completes successfully, it returns a StorageFile object that represents the file that the user picked.
     */
    pickSingleFileAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Shows the file picker so that the user can pick one file.
     * @param pickerOperationId This argument is ignored and has no effect.
     * @return  When the call to this method completes successfully, it returns a StorageFile object that represents the file that the user picked.
     */
    pickSingleFileAsync(
        pickerOperationId: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Gets or sets the settings identifier associated with the state of the file open picker. 
     */
    settingsIdentifier: string;

    /**
     * Gets or sets the initial location where the file open picker looks for files to present to the user. 
     */
    suggestedStartLocation: undefined.PickerLocationId;

    /**
     * Gets or sets the view mode that the file open picker uses to display items. 
     */
    viewMode: undefined.PickerViewMode
}


/**
 * Represents a collection of display names mapped to the associated file types (extensions). Each element in this collection maps a display name to a corresponding collection of file name extensions. The key is a single string, the value is a list/vector of strings representing one or more extension choices. 
 */
declare class FilePickerFileTypesOrderedMap {

    /**
     * Removes all display names and associated file name extensions from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator that iterates through the display names and associated file types in the collection.
     * @return  The iterator.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Returns an immutable view of the collection of display names and associated file types.
     * @return  The view of the collection.
     */
    getView(): undefined.IMapView<string, undefined.IVector<string >> ;

    /**
     * Determines whether the mapped collection of display names and associated file types contains the specified key.
     * @param key The key.
     * @return  True if the key is found; otherwise, false.
     */
    hasKey(key: string): boolean;

    /**
     * Inserts or replaces an item in the mapped collection of display names and associated file types.
     * @param key The key associated with the item to insert.
     * @param value The item to insert.
     * @return  true if an item with the specified key is an existing item and was replaced; otherwise false.
     */
    insert(key: string, value: undefined.IVector<string>): boolean;

    /**
     * Returns the item at the specified key in the mapped collection of display names and associated file types.
     * @param key The key to use to locate the item.
     * @return  The item associated with the specified key.
     */
    lookup(key: string): undefined.IVector<string>;

    /**
     * Removes an item from the mapped collection of display names and associated file types.
     * @param key The key associated with the item to remove.
     */
    remove(key: string): void;

    /**
     * Gets the number of items in the mapped collection of display names and associated file types. 
     */
    size: number
}


/**
 * Represents a collection of storage files that the user has selected by using a file picker. 
 */
declare class FilePickerSelectedFilesArray mixins Array<undefined.StorageFile>{

    /**
     * Retrieves an iterator that iterates through the collection of StorageFile objects that represent selected files.
     * @return  The iterator.
     */
    first(): undefined.IIterator<undefined.StorageFile>;

    /**
     * Returns the StorageFile object at the specified index in the collection.
     * @param index The zero-based index of the object to retrieve.
     * @return  The object at the specified index.
     */
    getAt(index: number): undefined.StorageFile;

    /**
     * Retrieves the StorageFile objects that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the objects in the collection to return.
     */
    getMany(startIndex: number): {
        items: undefined.StorageFile,
        returnValue: number
    };

    /**
     * Retrieves the index of a specified StorageFile object in the collection.
     * @param value The object to find in the collection.
     */
    indexOf(value: undefined.StorageFile): {
        index: number,
        returnValue: boolean
    };

    /**
     * Gets the number of StorageFile objects in the collection. 
     */
    size: number;
    indexOf(
        value: undefined.StorageFile,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.StorageFile, fromIndex?: number): number
}


/**
 * Represents a file picker that lets the user choose the file name, extension, and storage location for a file. 
 */
declare class FileSavePicker {

    /**
     * Creates a new instance of a FileSavePicker . 
     */
    constructor(): this;

    /**
     * Gets or sets the label text of the commit button in the file picker UI. 
     */
    commitButtonText: string;

    /**
     * Gets a set of values to be populated by the app before a PickSaveFileAndContinue operation that deactivates the app in order to provide context when the app is activated. (Windows Phone Store apps) 
     */
    continuationData: undefined.ValueSet;

    /**
     * Gets or sets the default file name extension that the fileSavePicker gives to files to be saved. 
     */
    defaultFileExtension: string;

    /**
     * Gets or sets an ID that specifies the enterprise that owns the file. 
     */
    enterpriseId: string;

    /**
     * Gets the collection of valid file types that the user can choose to assign to a file. 
     */
    fileTypeChoices: undefined.IMap<string, undefined.IVector<string >> ;

    /**
     * Shows the file picker so that the user can save a file, deactivating and the app and reactivating it when the operation is complete. (Windows Phone Store apps) 
     */
    pickSaveFileAndContinue(): void;

    /**
     * Shows the file picker so that the user can save a file and set the file name, extension, and location of the file to be saved. (Windows Store apps)
     * @return  When the call to this method completes successfully, it returns a storageFile object that was created to represent the saved file. The file name, extension, and location of this storageFile match those specified by the user, but the file has no content.
     */
    pickSaveFileAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Gets or sets the settings identifier associated with the current FileSavePicker instance. 
     */
    settingsIdentifier: string;

    /**
     * Gets or sets the file name that the file save picker suggests to the user. 
     */
    suggestedFileName: string;

    /**
     * Gets or sets the storageFile that the file picker suggests to the user for saving a file. 
     */
    suggestedSaveFile: undefined.StorageFile;

    /**
     * Gets or sets the location that the file save picker suggests to the user as the location to save a file. 
     */
    suggestedStartLocation: undefined.PickerLocationId
}


/**
 * Represents a UI element that lets the user choose folders. 
 */
declare class FolderPicker {

    /**
     * Creates a new instance of a FolderPicker . 
     */
    constructor(): this;

    /**
     * Gets or sets the label text of the folder picker's commit button. 
     */
    commitButtonText: string;

    /**
     * Gets a set of values to be populated by the app before a PickFolderAndContinue operation that deactivates the app in order to provide context when the app is activated. (Windows Phone Store apps) 
     */
    continuationData: undefined.ValueSet;

    /**
     * Gets the collection of file types that the folder picker displays. 
     */
    fileTypeFilter: undefined.IVector<string>;

    /**
     * Shows the file picker so that the user can pick a folder, deactivating and the app and reactivating it when the operation is complete. (Windows Phone Store apps) 
     */
    pickFolderAndContinue(): void;

    /**
     * Shows the folderPicker object so that the user can pick a folder. (Windows Store apps)
     * @return  When the call to this method completes successfully, it returns a storageFolder object that represents the folder that the user picked.
     */
    pickSingleFolderAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Gets or sets the settings identifier associated with the with the current FolderPicker instance. 
     */
    settingsIdentifier: string;

    /**
     * Gets or sets the initial location where the folder picker looks for folders to present to the user. 
     */
    suggestedStartLocation: undefined.PickerLocationId;

    /**
     * Gets or sets the view mode that the folder picker uses to display items. 
     */
    viewMode: undefined.PickerViewMode
}


/**
 * Used to interact with the file picker if your app provides files with the File Open Picker contract. 
 */
declare class FileOpenPickerUI {

    /**
     * Adds the specified file to the list of files that the user has chosen.
     * @param id A unique identifier of the file to add.
     * @param file The file to add to the list of files that the user has chosen.
     * @return  The enumeration value that indicates the result of this addFile method.
     */
    addFile(id: string, file: undefined.IStorageFile): undefined.AddFileResult;

    /**
     * Gets a list of file types (extensions) that the user can choose. 
     */
    allowedFileTypes: undefined.IVectorView<string>;

    /**
     * Indicates whether the specified file can be added to the list of files the user has chosen.
     * @param file The file to test.
     * @return  True if the file can be added to the file picker UI; otherwise false.
     */
    canAddFile(file: undefined.IStorageFile): boolean;

    /**
     * Determines whether the specified file is in the list of files that the user has chosen.
     * @param id The identifier of the file.
     * @return  True if the file is in the basket; otherwise false.
     */
    containsFile(id: string): boolean;

    /**
     * Fires when the user closes the file picker. 
     */
    onclosing: undefined.TypedEventHandler<undefined.FileOpenPickerUI, undefined.PickerClosingEventArgs>;
    addEventListener(
        type: "closing",
        listener: undefined.TypedEventHandler<undefined.FileOpenPickerUI, undefined.PickerClosingEventArgs>): void;
    removeEventListener(
        type: "closing",
        listener: undefined.TypedEventHandler<undefined.FileOpenPickerUI, undefined.PickerClosingEventArgs>): void;

    /**
     * Fires when the user removes a file from the list of files that the user has chosen if that file was added by the app that is providing files. 
     */
    onfileremoved: undefined.TypedEventHandler<undefined.FileOpenPickerUI, undefined.FileRemovedEventArgs>;
    addEventListener(
        type: "fileremoved",
        listener: undefined.TypedEventHandler<undefined.FileOpenPickerUI, undefined.FileRemovedEventArgs>): void;
    removeEventListener(
        type: "fileremoved",
        listener: undefined.TypedEventHandler<undefined.FileOpenPickerUI, undefined.FileRemovedEventArgs>): void;

    /**
     * Removes the specified file from the list of files the user has chosen.
     * @param id The identifier of the file to remove.
     */
    removeFile(id: string): void;

    /**
     * Gets an enumeration value that indicates whether the file picker currently limits selection to single files, or if multiple files can be selected. 
     */
    selectionMode: undefined.FileSelectionMode;

    /**
     * Gets an identifier for the current context of the file picker. 
     */
    settingsIdentifier: string;

    /**
     * Gets or sets a title to display in the file picker UI that identifies the location that the file picker is displaying to the user. 
     */
    title: string;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides information about a fileremoved event. 
 */
declare class FileRemovedEventArgs {

    /**
     * Gets the identifier of the file that the user removed from the list of chosen files in the file picker. This identifier was set by the providing app when it added the files to the list of chosen files. 
     */
    id: string
}


/**
 * Used to interact with the file picker when your app provides a save location with the File Save Picker contract. 
 */
declare class FileSavePickerUI {

    /**
     * Gets a list of file types (extensions) that can be saved to the app that is providing the save location. 
     */
    allowedFileTypes: undefined.IVectorView<string>;

    /**
     * Gets the full file name of the file to save, including the file type extension. The file name and extension are specified by the user. 
     */
    fileName: string;

    /**
     * Fired when the user changes the file name in the file name text box or changes the extension in the file type drop-down menu. 
     */
    onfilenamechanged: undefined.TypedEventHandler<undefined.FileSavePickerUI, any>;
    addEventListener(
        type: "filenamechanged",
        listener: undefined.TypedEventHandler<undefined.FileSavePickerUI, any>): void;
    removeEventListener(
        type: "filenamechanged",
        listener: undefined.TypedEventHandler<undefined.FileSavePickerUI, any>): void;

    /**
     * Fires when the user commits a file to be saved in the file picker. 
     */
    ontargetfilerequested: undefined.TypedEventHandler<undefined.FileSavePickerUI, undefined.TargetFileRequestedEventArgs>;
    addEventListener(
        type: "targetfilerequested",
        listener: undefined.TypedEventHandler<undefined.FileSavePickerUI, undefined.TargetFileRequestedEventArgs>): void;
    removeEventListener(
        type: "targetfilerequested",
        listener: undefined.TypedEventHandler<undefined.FileSavePickerUI, undefined.TargetFileRequestedEventArgs>): void;

    /**
     * Gets an identifier for the current context of the file picker. 
     */
    settingsIdentifier: string;

    /**
     * Gets or sets a title to display in the file picker UI that identifies the location that the file picker is displaying to the user. 
     */
    title: string;

    /**
     * Tries to set the file name and extension in the file picker UI.
     * @param value The file name and extension that are used to update the file name text box and file type drop-down menu in the file picker UI.
     * @return  The enumeration value that indicates whether the file name and extension were updated in the file picker UI.
     */
    trySetFileName(value: string): undefined.SetFileNameResult;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Use by an app that provides files to indicate asynchronously that the app is finished responding to a closing event. 
 */
declare class PickerClosingDeferral {

    /**
     * Signals that the app providing files has finished responding to a closing event. 
     */
    complete(): void
}


/**
 * Provides information about a closing event. 
 */
declare class PickerClosingEventArgs {

    /**
     * Gets a pickerClosingOperation object that is used to respond to a closing event. 
     */
    closingOperation: undefined.PickerClosingOperation;

    /**
     * Gets a value that indicates whether the file picker is closing because the user cancelled it. 
     */
    isCanceled: boolean
}


/**
 * Lets an app that provides files get the deadline for responding to a closing event and get a deferral so the app can respond to the event asynchronously. 
 */
declare class PickerClosingOperation {

    /**
     * Gets a dateTime object that indicates when the system will shut down the app that is providing files through the file picker without further notice. 
     */
    deadline: Date;

    /**
     * Gets a pickerClosingDeferral that the app providing files through the file picker can use to respond asynchronously to a closing event.
     * @return  The pickerClosingDeferral that the app providing files through the file picker can use to respond asynchronously to a closing event.
     */
    getDeferral(): undefined.PickerClosingDeferral
}


/**
 * Lets an app that provides a save location specify the storageFile that represents the file to save and get a deferral so the app can respond asynchronously to a targetFileRequested event. 
 */
declare class TargetFileRequest {

    /**
     * Gets a targetFileRequestDeferral that the app providing the save location can use to respond asynchronously to a targetfilerequested event.
     * @return  The targetFileRequestDeferral that the providing app can use asynchronously to indicate that it is finished responding to a targetfilerequested event.
     */
    getDeferral(): undefined.TargetFileRequestDeferral;

    /**
     * Gets or sets the IStorageFile object that is provided to represent the file to save by the app that is providing the save location. 
     */
    targetFile: undefined.IStorageFile
}


/**
 * Used by an app that provides a save location to indicate asynchronously that the app is finished responding to a targetfilerequested event. 
 */
declare class TargetFileRequestDeferral {

    /**
     * Signals that the app providing the save location finished responding to a targetfilerequested event. 
     */
    complete(): void
}


/**
 * Provides information about a targetfilerequested event. 
 */
declare class TargetFileRequestedEventArgs {

    /**
     * Gets a targetFileRequest object that is used to respond to a targetfilerequested event. 
     */
    request: undefined.TargetFileRequest
}


/**
 * Manages files so that they can be updated in real-time by an app that participates in the Cached File Updater contract. 
 */
declare class CachedFileUpdater {

    /**
     * Configures update policies for a local file.
     * @param file The local file.
     * @param contentId A unique identifier for the local file.
     * @param readMode A value that specifies whether Windows will request updates before the local file is read by other apps.
     * @param writeMode A value that specifies whether other apps can write to the local file and, if so, whether Windows will request updates after the local file is written.
     * @param options A value that specifies additional circumstances and behaviors for when Windows requests updates.
     */
    setUpdateInformation(
        file: undefined.IStorageFile,
        contentId: string,
        readMode: undefined.ReadActivationMode,
        writeMode: undefined.WriteActivationMode,
        options: undefined.CachedFileOptions): void
}


/**
 * Used to interact with the file picker if your app provides file updates through the Cached File Updater contract. 
 */
declare class CachedFileUpdaterUI {

    /**
     * Gets an object used to complete a file update request asynchronously.
     * @return  The object that the app uses to indicate, asynchronously, that it has finished responding to a FileUpdateRequested event and that the Request is complete.
     */
    getDeferral(): undefined.FileUpdateRequestDeferral;

    /**
     * Fires when the Windows requests a file update. This event fires once for each requested update. 
     */
    onfileupdaterequested: undefined.TypedEventHandler<undefined.CachedFileUpdaterUI, undefined.FileUpdateRequestedEventArgs>;
    addEventListener(
        type: "fileupdaterequested",
        listener: undefined.TypedEventHandler<undefined.CachedFileUpdaterUI, undefined.FileUpdateRequestedEventArgs>): void;
    removeEventListener(
        type: "fileupdaterequested",
        listener: undefined.TypedEventHandler<undefined.CachedFileUpdaterUI, undefined.FileUpdateRequestedEventArgs>): void;

    /**
     * Fires when the calling app needs to display the file picker letterbox UI that is represented by the CachedFileUpdaterUI object. 
     */
    onuirequested: undefined.TypedEventHandler<undefined.CachedFileUpdaterUI, any>;
    addEventListener(
        type: "uirequested",
        listener: undefined.TypedEventHandler<undefined.CachedFileUpdaterUI, any>): void;
    removeEventListener(
        type: "uirequested",
        listener: undefined.TypedEventHandler<undefined.CachedFileUpdaterUI, any>): void;

    /**
     * Gets or sets the title to display in the top-left the file picker UI. The title identifies the location or context of the app's page (which is hosted in the file picker UI) for the user. 
     */
    title: string;

    /**
     * Gets an enum value that indicates the status of the file picker UI. 
     */
    uiStatus: undefined.UIStatus;

    /**
     * Gets the file update request currently being processed by the cached file updater. 
     */
    updateRequest: undefined.FileUpdateRequest;

    /**
     * Gets a value that indicates which version of the file needs to be updated: the local version or the version in the app's repository. 
     */
    updateTarget: undefined.CachedFileTarget;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides information about a requested file update so that the app can complete the request. 
 */
declare class FileUpdateRequest {

    /**
     * Gets the unique identifier used to associate the local version of a file with the corresponding remote version. 
     */
    contentId: string;

    /**
     * Gets a StorageFile object that represents the locally cached copy of the file to update. 
     */
    file: undefined.StorageFile;

    /**
     * Gets an object used to complete an update asynchronously.
     * @return  The object that the app uses to indicate, asynchronously, that it has finished responding to a FileUpdateRequested event and that the Request is complete.
     */
    getDeferral(): undefined.FileUpdateRequestDeferral;

    /**
     * Gets or sets the status of the update. This property is set in response to a FileUpdateRequested event. 
     */
    status: undefined.FileUpdateStatus;

    /**
     * Provide a new version of the local file to represent the remote file.
     * @param value The new version of the local file that will represent remote file.
     */
    updateLocalFile(value: undefined.IStorageFile): void;

    /**
     * Gets or sets a message to the user indicating that user input is needed to complete the FileUpdateRequest . 
     */
    userInputNeededMessage: string
}


/**
 * Use to complete an update asynchronously. 
 */
declare class FileUpdateRequestDeferral {

    /**
     * Signals that the response to a FileUpdateRequested event is finished. 
     */
    complete(): void
}


/**
 * Provides information about a FileUpdateRequested event. 
 */
declare class FileUpdateRequestedEventArgs {

    /**
     * Gets the details of the requested file update. 
     */
    request: undefined.FileUpdateRequest
}


/**
 * Enables Windows Store apps to place content properties in the system index. 
 */
declare class ContentIndexer {

    /**
     * Gets the per-app index with the specified name or creates a new one, if necessary.
     * @param indexName The index name.
     * @return  The index.
     */
    getIndexer(indexName: string): undefined.ContentIndexer;

    /**
     * Gets an existing per-app index or creates a new one, if necessary.
     * @return  The index.
     */
    getIndexer(): undefined.ContentIndexer;

    /**
     * Adds app-defined items with properties and content to the system index.
     * @param indexableContent The content properties to index.
     */
    addAsync(indexableContent: undefined.IIndexableContent): any;

    /**
     * Builds a query with the specified search filter, sort order, and identifies which properties to retrieve.
     * @param searchFilter The AQS filter.
     * @param propertiesToRetrieve The properties to retrieve, specified by their Windows canonical property names.
     * @param sortOrder The sort order for the filtered results.
     * @return  The query.
     */
    createQuery(
        searchFilter: string,
        propertiesToRetrieve: undefined.IIterable<string>,
        sortOrder: undefined.IIterable<undefined.SortEntry>): undefined.ContentIndexerQuery;

    /**
     * Builds a query with the specified search filter, sort order, filter language, and identifies which properties to retrieve.
     * @param searchFilter The AQS filter to apply.
     * @param propertiesToRetrieve The properties to retrieve, specified by their Windows canonical property names.
     * @param sortOrder The sort order for the filtered results.
     * @param searchFilterLanguage The language that's used to parse AQS, specified as a BCP-47 language tag.
     * @return  The query.
     */
    createQuery(
        searchFilter: string,
        propertiesToRetrieve: undefined.IIterable<string>,
        sortOrder: undefined.IIterable<undefined.SortEntry>,
        searchFilterLanguage: string): undefined.ContentIndexerQuery;

    /**
     * Builds a query with the specified search filter and identifies which properties to retrieve.
     * @param searchFilter The AQS filter to apply.
     * @param propertiesToRetrieve The properties to retrieve, specified by their Windows canonical property names.
     * @return  The query.
     */
    createQuery(
        searchFilter: string,
        propertiesToRetrieve: undefined.IIterable<string>): undefined.ContentIndexerQuery;

    /**
     * Removes all app-defined items from the ContentIndexer .
     */
    deleteAllAsync(): any;

    /**
     * Removes the specified app-defined item from the ContentIndexer .
     * @param contentId The identifier of the item to remove.
     */
    deleteAsync(contentId: string): any;

    /**
     * Removes the specified app-defined items from the ContentIndexer .
     * @param contentIds The identifier of the item to remove.
     */
    deleteMultipleAsync(contentIds: undefined.IIterable<string>): any;

    /**
     * Gets content properties based on the given content identifier.
     * @param contentId The identifier for the content properties.
     * @param propertiesToRetrieve The retrieved properties, based on contentId.
     * @return  When this method completes, it returns the retrieved properties as a map of key-value pairs.
     */
    retrievePropertiesAsync(
        contentId: string,
        propertiesToRetrieve: undefined.IIterable<string>): undefined.IPromiseWithIAsyncOperation<undefined.IMapView<any, any >> ;

    /**
     * Gets the version of the ContentIndexer . 
     */
    revision: number;

    /**
     * Updates app content and properties in the ContentIndexer .
     * @param indexableContent The content properties to update.
     */
    updateAsync(indexableContent: undefined.IIndexableContent): any
}


/**
 * Represents a query for content properties in the ContentIndexer . 
 */
declare class ContentIndexerQuery {

    /**
     * Runs the query on the app's indexed content properties and returns the specified number of items from the specified start index in the results collection.
     * @param startIndex The index of the first item to get from the results collection.
     * @param maxItems The maximum number of items to get.
     * @return  When this method completes, it returns the query results, represented as a collection of IndexableContent instances.
     */
    getAsync(
        startIndex: number,
        maxItems: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Runs the query on the app's indexed content properties.
     * @return  When this method completes, it returns the query results, represented as a collection of IIndexableContent instances.
     */
    getAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the number of items in the search results.
     * @return  When this method completes, it returns the number of items in the search results.
     */
    getCountAsync(): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Retrieves a collection of property sets for an app, where the property sets are key-value pairs.
     * @return  When this method completes, it returns the query results as a collection of PropertyValue instances.
     */
    getPropertiesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Runs the query on the app's indexed content properties and returns the specified number of properties from the specified start index in the results collection.
     * @param startIndex The index of the first item to get from the results collection.
     * @param maxItems The maximum number of items to get.
     * @return  When this method completes, it returns the query results as a collection of PropertyValue instances.
     */
    getPropertiesAsync(
        startIndex: number,
        maxItems: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the StorageFolder representation of the app-provided items in the ContentIndexer query. 
     */
    queryFolder: undefined.StorageFolder
}


/**
 * Represents app content and properties that can be added to the ContentIndexer . 
 */
declare class IndexableContent {

    /**
     * Initializes a new instance of the IndexableContent class. 
     */
    constructor(): this;

    /**
     * Gets or sets the identifier for the content properties in the IndexableContent object. Changes to the actual representation of the item in the index can be made using the ContentIndexer class. 
     */
    id: string;

    /**
     * Gets the content properties. 
     */
    properties: undefined.IMap<string, any>;

    /**
     * Gets or sets a Stream that provides full-text content. Changes to the actual representation of the item in the index can be made using the ContentIndexer class. 
     */
    stream: undefined.IRandomAccessStream;

    /**
     * Specifies the type of content in the Stream . 
     */
    streamContentType: string
}


/**
 * Specifies the parameters of a search query for enumerating the contents of storage folders. 
 */
declare class QueryOptions {

    /**
     * Creates an instance of the QueryOptions class for enumerating files and initializes it with values provided by the specified CommonFileQuery and an optional file type filter that determines which files to include in query results.
     * @param query An enumeration value that specifies the search parameters to use to query files.
     * @param fileTypeFilter An array of file types to be included in the query results. To include all file types, supply null or an array containing a single entry of "*".
     */
    constructor(query: undefined.CommonFileQuery, fileTypeFilter: undefined.IIterable<string>): this;

    /**
     * Creates an instance of the QueryOptions class for enumerating subfolders and initializes it with values based on the specified CommonFolderQuery .
     * @param query An enumeration value that specifies how to group the contents of the folder where the query is created into subfolders to enumerate. The subfolders that are retrieved using a CommonFolderQuery can be actual file system folders or virtual folders that represent groups of files (which are determined by the CommonFolderQuery value). For example, the CommonFolderQuery.GroupByArtist uses the Artist of the files in the folder (and its subfolders) to group files, creating one virtual folder (or file group) for each artist.
     */
    constructor(query: undefined.CommonFolderQuery): this;

    /**
     * Creates an instance of the QueryOptions class for enumerating storage items, and initializes it with the following default settings: QueryOptions.FolderDepth gets FolderDepth.Shallow and QueryOptions.IndexerOption gets IndexerOption.DoNotUseIndexer . 
     */
    constructor(): this;

    /**
     * Gets or sets an application-defined Advanced Query Syntax (AQS) string for filtering files by keywords or properties. This property is combined with the UserSearchFilter to create the query's search filter. 
     */
    applicationSearchFilter: string;

    /**
     * Gets the unit of time used to group files into folders if the QueryOptions object was created with a CommonFolderQuery based on date. For example, if CommonFolderQuery.GroupByYear is used to create a QueryOptions object, the value of this property is DateStackOption.Year . 
     */
    dateStackOption: undefined.DateStackOption;

    /**
     * Gets a list of file name extensions used to filter the search results. If the list is empty, the results include all file types. 
     */
    fileTypeFilter: undefined.IVector<string>;

    /**
     * Indicates whether the search query should produce a shallow view of the folder contents or a deep recursive view of all files and subfolder. 
     */
    folderDepth: undefined.FolderDepth;

    /**
     * Gets the name of the property used to group query results if the QueryOptions object was created using a CommonFolderQuery . For example, if CommonFolderQuery.GroupByYear is used to create a QueryOptions object, the value of this property is System.ItemDate . 
     */
    groupPropertyName: string;

    /**
     * Gets or sets a value that specifies whether the system index or the file system is used to retrieve query results. The indexer can retrieve results faster but is not available in all file locations. 
     */
    indexerOption: undefined.IndexerOption;

    /**
     * Gets or sets the Internet Engineering Task Force (IETF) language tag (BCP47 standard) that identifies the language associated with the query. This determines the language-specific algorithm used by the system to break the query into individual search tokens. 
     */
    language: string;

    /**
     * Initializes the current instance of the QueryOptions class with search parameters specified by a string that was created by the SaveToString method.
     * @param value A string retrieved by a previous call to SaveToString .
     */
    loadFromString(value: string): void;

    /**
     * Converts the values of a QueryOptions object to a string that can be used to initialize the values of a QueryOptions object by calling LoadFromString .
     * @return  A string representing the serialized settings of a QueryOptions instance.
     */
    saveToString(): string;

    /**
     * Specifies properties that the system should load in advance for all items in the query result set while the query is being executed (instead of retrieving them on a case-by-case basis). If many properties are specified, the query might take longer to execute, but subsequent property retrieval on query results will be faster.
     * @param options A value that specifies the set of properties to retrieve in advance.
     * @param propertiesToRetrieve A custom list of properties to retrieve in advance as an array of property names. Use the system property names to specify properties, for example "System.Copyright" and "System.Image.ColorSpace".
     */
    setPropertyPrefetch(
        options: undefined.PropertyPrefetchOptions,
        propertiesToRetrieve: undefined.IIterable<string>): void;

    /**
     * Specifies the type and size of thumbnails that the system should start loading immediately when items are accessed (instead of retrieving them on a case-by-case basis). This uses more resources but makes thumbnail retrieval on query results faster.
     * @param mode The enumeration value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to return a thumbnail image that can be scaled to the requested size without reducing the quality of the image.
     * @param options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
     */
    setThumbnailPrefetch(
        mode: undefined.ThumbnailMode,
        requestedSize: number,
        options: undefined.ThumbnailOptions): void;

    /**
     * Gets the list of SortEntry structures that specify how to sort content (like files and subfolders) in query results. Use this list to customize how query results are sorted. 
     */
    sortOrder: undefined.IVector<undefined.SortEntry>;

    /**
     * Gets the filter for storage provider identifiers. 
     */
    storageProviderIdFilter: undefined.IVector<string>;

    /**
     * Gets or sets a user-defined Advanced Query Syntax (AQS) string for filtering files by keywords or properties. This property is combined with the ApplicationSearchFilter to create the query's search filter. 
     */
    userSearchFilter: string
}


/**
 * Provides access to the sorting criteria of the query results as a collection of SortEntry objects. 
 */
declare class SortEntryVector mixins Array<undefined.SortEntry>{

    /**
     * Appends a sort entry to the end of the collection.
     * @param value The sort entry to append to the collection.
     */
    append(value: undefined.SortEntry): void;

    /**
     * Removes all sort entries from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator that iterates through the sort entries in the collection.
     * @return  The iterator.
     */
    first(): undefined.IIterator<undefined.SortEntry>;

    /**
     * Retrieves the sort entry at the specified index in the collection.
     * @param index The zero-based index of the sort entry to retrieve.
     * @return  The sort entry at the specified index.
     */
    getAt(index: number): undefined.SortEntry;

    /**
     * Retrieves the sort entries that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the sort entries in the collection to retrieve.
     */
    getMany(startIndex: number): {
        items: undefined.SortEntry,
        returnValue: number
    };

    /**
     * Retrieves an immutable view of the collection of sort entries.
     * @return  The view of the collection.
     */
    getView(): undefined.IVectorView<undefined.SortEntry>;

    /**
     * Retrieves the index of a specified sort entry in the collection.
     * @param value The sort entry to find in the collection.
     */
    indexOf(value: undefined.SortEntry): {
        index: number,
        returnValue: boolean
    };

    /**
     * Inserts a sort entry into the collection at a specified index.
     * @param index The zero-based index of the location to insert the sort entry.
     * @param value The sort entry to insert.
     */
    insertAt(index: number, value: undefined.SortEntry): void;

    /**
     * Removes the sort entry at the specified index in the collection.
     * @param index The zero-based index of the sort entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last sort entry from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all sort entries in the collection with the specified sort entries.
     * @param items The collection of sort entries to put in the vector.
     */
    replaceAll(items: undefined.SortEntry): void;

    /**
     * Sets the sort entry at the specified index of the collection.
     * @param index The zero-based index of the location at which to set the sort entry.
     * @param value The sort entry.
     */
    setAt(index: number, value: undefined.SortEntry): void;

    /**
     * Gets the number of sort entries in the collection. 
     */
    size: number;
    indexOf(
        value: undefined.SortEntry,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.SortEntry, fromIndex?: number): number
}


/**
 * Provides access to the results of a query of the files in the location that is represented by a storageFolder object. You can use storageFileQueryResult to enumerate the files in that storageFolder location. 
 */
declare class StorageFileQueryResult {

    /**
     * Modifies query results based on new QueryOptions .
     * @param newQueryOptions The new query options.
     */
    applyNewQueryOptions(newQueryOptions: undefined.QueryOptions): void;

    /**
     * Retrieves the index of the file from the query results that most closely matches the specified property value (or file, if used with FileActivatedEventArgs.NeighboringFilesQuery ). The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
     * @param value The property value to match when searching the query results. The property to that is used to match this value is the property in the first SortEntry of the QueryOptions.SortOrder list.
     * @return  When this method completes successfully, it returns the index of the matched file in the query results or the index of the file in the FileActivatedEventArgs.NeighboringFilesQuery . In the latter case, the file is expected to be sourced from FileActivatedEventArgs.Files .
     */
    findStartIndexAsync(value: any): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Gets the folder that was queried to create the StorageFileQueryResult object. This folder represents the scope of the query. 
     */
    folder: undefined.StorageFolder;

    /**
     * Retrieves the query options used to determine query results.
     * @return  The query options.
     */
    getCurrentQueryOptions(): undefined.QueryOptions;

    /**
     * Retrieves a list of all the files in the query result set.
     * @return  When this method completes successfully, it returns a list (type IVectorView ) of files that are represented by storageFile objects.
     */
    getFilesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a list of files in a specified range.
     * @param startIndex The zero-based index of the first file to retrieve. This parameter is 0 by default.
     * @param maxNumberOfItems The maximum number of files to retrieve. Use -1 to retrieve all files. If the range contains fewer files than the max number, all files in the range are returned.
     * @return  When this method completes successfully, it returns a list (type IVectorView ) of files that are represented by storageFile objects.
     */
    getFilesAsync(
        startIndex: number,
        maxNumberOfItems: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves the number of files in the set of query results.
     * @return  When this method completes successfully, it returns the number of files in the location that match the query.
     */
    getItemCountAsync(): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Gets matching file properties with corresponding text ranges.
     * @param file The file to query for properties.
     * @return  The matched properties and corresponding text ranges.
     */
    getMatchingPropertiesWithRanges(
        file: undefined.StorageFile): undefined.IMap<string, undefined.IVectorView<any >> ;

    /**
     * Fires when a file is added to, deleted from, or modified in the folder being queried. This event only fires after GetFilesAsync has been called at least once. 
     */
    oncontentschanged: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>;
    addEventListener(
        type: "contentschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;
    removeEventListener(
        type: "contentschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;

    /**
     * Fires when the query options change. 
     */
    onoptionschanged: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>;
    addEventListener(
        type: "optionschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;
    removeEventListener(
        type: "optionschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides access to the results of a query that lists the folder (or file groups) in the folder being queried (which is represented by a storageFolder ). You can use a storageFolderQueryResult to enumerate folders or file groups in that folder. 
 */
declare class StorageFolderQueryResult {

    /**
     * Modifies query results based on new QueryOptions .
     * @param newQueryOptions The new query options.
     */
    applyNewQueryOptions(newQueryOptions: undefined.QueryOptions): void;

    /**
     * Retrieves the index of the folder from the query results that most closely matches the specified property value. The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
     * @param value The property value to match when searching the query results. The property to that is used to match this value is the property in the first SortEntry of the QueryOptions.SortOrder list.
     * @return  When this method completes successfully it returns the index of the matched folder in the query results.
     */
    findStartIndexAsync(value: any): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Gets the folder originally used to create the StorageFolderQueryResult object. This folder represents the scope of the query. 
     */
    folder: undefined.StorageFolder;

    /**
     * Retrieves the query options used to determine query results.
     * @return  The query options.
     */
    getCurrentQueryOptions(): undefined.QueryOptions;

    /**
     * Retrieves folders (or file groups) in a specified range.
     * @param startIndex The zero-based index of the first folder to retrieve. This parameter defaults to 0.
     * @param maxNumberOfItems The maximum number of folders or file groups to retrieve. Use -1 to retrieve all folders. If the range contains fewer folders than the max number, all folders in the range are returned.
     * @return  When this method completes successfully, it returns a list (type IVectorView ) of folders or file groups that are represented by storageFolder objects.
     */
    getFoldersAsync(
        startIndex: number,
        maxNumberOfItems: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a list of all the folders (or file groups) in the result set.
     * @return  When this method completes successfully, it returns a list (type IVectorView ) of folders or file groups that are represented by storageFolder objects. Each of these folder or file group can also be enumerated to retrieve its contents.
     */
    getFoldersAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves the number of folders (or file groups) in the set of query results.
     * @return  When this method completes successfully, it returns the number of folders or file groups in the location that match the query.
     */
    getItemCountAsync(): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Fires when a file is added to, deleted from, or modified in the folder being queried. This event only fires after GetFilesAsync has been called at least once. 
     */
    oncontentschanged: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>;
    addEventListener(
        type: "contentschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;
    removeEventListener(
        type: "contentschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;

    /**
     * Fires when the query options change. 
     */
    onoptionschanged: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>;
    addEventListener(
        type: "optionschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;
    removeEventListener(
        type: "optionschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides access to the results of a query that lists all items including files and folders (or file groups) in the folder being queried (which is represented by a storageFolder ). You can use storageItemQueryResult to enumerate the files and folders in that storageFolder . 
 */
declare class StorageItemQueryResult {

    /**
     * Modifies query results based on new QueryOptions .
     * @param newQueryOptions The new query options.
     */
    applyNewQueryOptions(newQueryOptions: undefined.QueryOptions): void;

    /**
     * Retrieves the index of the item from the query results that most closely matches the specified property value. The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
     * @param value The property value to match when searching the query results. The property to that is used to match this value is the property in the first SortEntry of the QueryOptions.SortOrder list.
     * @return  When this method completes successfully it returns the index of the matched item in the query results.
     */
    findStartIndexAsync(value: any): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Gets the folder originally used to create the StorageItemQueryResult object. This folder represents the scope of the query. 
     */
    folder: undefined.StorageFolder;

    /**
     * Retrieves the query options used to determine query results.
     * @return  The query options.
     */
    getCurrentQueryOptions(): undefined.QueryOptions;

    /**
     * Retrieves the number of items in the set of query results.
     * @return  When this method completes successfully, it returns the number of items in the location that match the query.
     */
    getItemCountAsync(): undefined.IPromiseWithIAsyncOperation<number>;

    /**
     * Retrieves a list of all the items (files and folders) in the query results set.
     * @return  When this method completes successfully, it returns a list (type IVectorView ) of items. Each item is the IStorageItem type and represents a file, folder, or file group.
     */
    getItemsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a list of items (files and folders) in a specified range.
     * @param startIndex The zero-based index of the first item to retrieve. This parameter defaults to 0.
     * @param maxNumberOfItems The maximum number of items to retrieve. Use -1 to retrieve all items. If the range contains fewer items than the max number, all items in the range are returned.
     * @return  When this method completes successfully, it returns a list (type IVectorView ) of items. Each item is the IStorageItem type and represents a file, folder, or file group.
     */
    getItemsAsync(
        startIndex: number,
        maxNumberOfItems: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Fires when an item is added to, deleted from, or modified in the folder being queried. This event only fires after GetItemsAsync has been called at least once. 
     */
    oncontentschanged: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>;
    addEventListener(
        type: "contentschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;
    removeEventListener(
        type: "contentschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;

    /**
     * Fires when the query options change. 
     */
    onoptionschanged: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>;
    addEventListener(
        type: "optionschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;
    removeEventListener(
        type: "optionschanged",
        listener: undefined.TypedEventHandler<undefined.IStorageQueryResultBase, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Details about a change to storage library content. 
 */
declare class StorageLibraryContentChangedTriggerDetails {

    /**
     * Query for the creation/modified changes since a previous such query.
     * @param lastQueryTime The time the previous query was made.
     * @return  The query result.
     */
    createModifiedSinceQuery(lastQueryTime: Date): undefined.StorageItemQueryResult;

    /**
     * Gets the StorageFolder that has been changed. 
     */
    folder: undefined.StorageFolder
}


/**
 * Specifies the language of a property, as a BCP-47 language code. 
 */
declare class ValueAndLanguage {

    /**
     * Initializes a new instance of the ValueAndLanguage class. 
     */
    constructor(): this;

    /**
     * Gets or sets the language of the property value, specified as a BCP-47 language code. 
     */
    language: string;

    /**
     * Gets or sets the property value for the current ValueAndLanguage . 
     */
    value: any
}


/**
 * Provides methods to access to and manage query results. 
 */
declare interface Search$IStorageQueryResultBase {

    /**
     * Applies new query options to the results retrieved by the StorageFileQueryResult , StorageFolderQueryResult , or StorageItemQueryResult object.
     * @param newQueryOptions The new query options.
     */
    applyNewQueryOptions(newQueryOptions: undefined.QueryOptions): void,

        /**
         * Retrieves the index of the file from the query results that most closely matches the specified property value. The property that is matched is determined by the first SortEntry of the QueryOptions.SortOrder list.
         * @param value The property value to match when searching the query results.
         * @return  When this method completes successfully it returns the index of the matched item in the query results.
         */
        findStartIndexAsync(value: any): undefined.IPromiseWithIAsyncOperation<number>,

        /**
         * Retrieves the query options used to create a StorageFileQueryResult , StorageFolderQueryResult , or StorageItemQueryResult object.
         * @return  The query options.
         */
        getCurrentQueryOptions(): undefined.QueryOptions,

        /**
         * Retrieves the number of items that match the query that created a StorageFileQueryResult , StorageFolderQueryResult , or StorageItemQueryResult object.
         * @return  When this method completes successfully, it returns the number of items that match the query.
         */
        getItemCountAsync(): undefined.IPromiseWithIAsyncOperation<number>,

        /**
         * Gets the folder originally used to create a StorageFileQueryResult , StorageFolderQueryResult , or StorageItemQueryResult object. This folder represents the scope of the query. 
         */
        folder: undefined.StorageFolder
}


/**
 * Represents app content and properties that can be added to the ContentIndexer . 
 */
declare interface Search$IIndexableContent {

    /**
     * Gets or sets the identifier for the content properties in the IIndexableContent object. Changes to the actual representation of the item in the index can be made using the ContentIndexer class. 
     */
    id: string,

        /**
         * Gets the content properties. 
         */
        properties: undefined.IMap<string, any>,

        /**
         * Gets or sets a stream that provides full-text content. Changes to the actual representation of the item in the index can be made using the ContentIndexer class. 
         */
        stream: undefined.IRandomAccessStream,

        /**
         * Specifies the type of content in the Stream . 
         */
        streamContentType: string
}


/**
 * An entry in the SortOrder list the specifies a property and ordering that is used to sort query results. 
 */
declare interface Search$SortEntry {

    /**
     * True to sort content in the query results in ascending order based on the property name, or false to sort content in descending order. 
     */
    ascendingOrder: boolean,

        /**
         * The name of the property to use for sorting, like System.Author. The property must be registered on the system. 
         */
        propertyName: string
}


/**
 * Manages a delayed set version operation. 
 */
declare class SetVersionDeferral {

    /**
     * Notifies the system that the app has set the version of the application data in its app data store. 
     */
    complete(): void
}


/**
 * Provides data when an app sets the version of the application data in its app data store. 
 */
declare class SetVersionRequest {

    /**
     * Gets the current version. 
     */
    currentVersion: number;

    /**
     * Gets the requested version. 
     */
    desiredVersion: number;

    /**
     * Requests that the set version request be delayed.
     * @return  The set version deferral.
     */
    getDeferral(): undefined.SetVersionDeferral
}


/**
 * Represents a file. Provides information about the file and its content, and ways to manipulate them. 
 */
declare class StorageFile {

    /**
     * Creates a StorageFile to represent the specified stream of data. This method lets the app produce the data on-demand by specifying a function to be invoked when the StorageFile that represents the stream is first accessed.
     * @param displayNameWithExtension The user-friendly name of the StorageFile to create, including a file type extension.
     * @param dataRequested The function that should be invoked when the StorageFile that is returned is first accessed. This function should produce the data stream represented by the returned StorageFile and lets the app produce data on-demand instead of writing the contents of the file at creation time.
     * @param thumbnail The thumbnail image for the StorageFile to create.
     * @return  When this method completes, it returns a StorageFile object that represents the new stream of data.
     */
    createStreamedFileAsync(
        displayNameWithExtension: string,
        dataRequested: undefined.StreamedFileDataRequestedHandler,
        thumbnail: undefined.IRandomAccessStreamReference): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates a StorageFile to represent a stream of data from the specified URI resource. This method lets the app download the data on-demand when the StorageFile that represents the stream is first accessed.
     * @param displayNameWithExtension The user-friendly name of the StorageFile to create, including a file type extension.
     * @param uri The URI of the resource used to create the StorageFile .
     * @param thumbnail The thumbnail image for the StorageFile to create.
     * @return  When this method completes, it returns a StorageFile object that represents the URI resource.
     */
    createStreamedFileFromUriAsync(
        displayNameWithExtension: string,
        uri: undefined.Uri,
        thumbnail: undefined.IRandomAccessStreamReference): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Gets a StorageFile object to represent the specified URI app resource. For examples of sample URIs see How to load file resources.
     * @param uri The URI of the app resource to get a StorageFile to represent.
     * @return  When this method completes, it returns a StorageFile object that represents the URI resource.
     */
    getFileFromApplicationUriAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Gets a StorageFile object to represent the file at the specified path.
     * @param path The path of the file to get a StorageFile to represent.
     * @return  When this method completes, it returns the file as a StorageFile .
     */
    getFileFromPathAsync(path: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Replaces the contents of the file referred to by the specified IStorageFile object with a new data stream. This method lets the app produce the data on-demand by specifying a function to be invoked when the StorageFile that represents the stream is first accessed.
     * @param fileToReplace The file (type IStorageFile ) that the new data stream should be written to.
     * @param dataRequested The function that should be invoked when the StorageFile that is returned is first accessed. This function should produce the data stream represented by the returned StorageFile and lets the app produce data on-demand instead of writing the contents of the file at creation time.
     * @param thumbnail The thumbnail image for the StorageFile to create.
     * @return  When this method completes, it returns a StorageFile object that represents the new data stream. Subsequently, this StorageFile object should be used to access file content instead of the file (type IStorageFile ) that was specified to be replace.
     */
    replaceWithStreamedFileAsync(
        fileToReplace: undefined.IStorageFile,
        dataRequested: undefined.StreamedFileDataRequestedHandler,
        thumbnail: undefined.IRandomAccessStreamReference): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Replaces the contents of the file referred to by the specified IStorageFile object with a new data stream of the specified URI. This method lets the app download the data on-demand when the StorageFile that represents the stream is first accessed.
     * @param fileToReplace The file that the created StorageFile will provide a stream of.
     * @param uri The URI of the resource used to create the StorageFile .
     * @param thumbnail The thumbnail image for the StorageFile to create.
     * @return  When this method completes, it returns a StorageFile object that represents the streamed file. Subsequently, this StorageFile object should be used to access file content instead of the file (type IStorageFile ) that was specified to be replace.
     */
    replaceWithStreamedFileFromUriAsync(
        fileToReplace: undefined.IStorageFile,
        uri: undefined.Uri,
        thumbnail: undefined.IRandomAccessStreamReference): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Gets the attributes of a file. 
     */
    attributes: undefined.FileAttributes;

    /**
     * Gets the MIME type of the contents of the file. 
     */
    contentType: string;

    /**
     * Replaces the specified file with a copy of the current file.
     * @param fileToReplace The file to replace.
     * @return  No object or value is returned when this method completes.
     */
    copyAndReplaceAsync(fileToReplace: undefined.IStorageFile): undefined.IPromiseWithIAsyncAction;

    /**
     * Creates a copy of the file in the specified folder and renames the copy. This method also specifies what to do if a file with the same name already exists in the destination folder.
     * @param destinationFolder The destination folder where the copy of the file is created.
     * @param desiredNewName The new name for the copy of the file created in the destinationFolder.
     * @param option One of the enumeration values that determines how to handle the collision if a file with the specified desiredNewName already exists in the destination folder.
     * @return  When this method completes, it returns a StorageFile that represents the copy of the file created in the destinationFolder.
     */
    copyAsync(
        destinationFolder: undefined.IStorageFolder,
        desiredNewName: string,
        option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates a copy of the file in the specified folder and renames the copy.
     * @param destinationFolder The destination folder where the copy of the file is created.
     * @param desiredNewName The new name for the copy of the file created in the destinationFolder.
     * @return  When this method completes, it returns a StorageFile that represents the copy of the file created in the destinationFolder.
     */
    copyAsync(
        destinationFolder: undefined.IStorageFolder,
        desiredNewName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates a copy of the file in the specified folder.
     * @param destinationFolder The destination folder where the copy of the file is created.
     * @return  When this method completes, it returns a StorageFile that represents the copy of the file created in the destinationFolder.
     */
    copyAsync(
        destinationFolder: undefined.IStorageFolder): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Gets the date and time when the current file was created. 
     */
    dateCreated: Date;

    /**
     * Deletes the current file, optionally deleting the item permanently.
     * @param option A value that indicates whether to delete the item permanently.
     * @return  No object or value is returned by this method when it completes.
     */
    deleteAsync(option: undefined.StorageDeleteOption): undefined.IPromiseWithIAsyncAction;

    /**
     * Deletes the current file.
     * @return  No object or value is returned by this method when it completes.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets a user-friendly name for the file. 
     */
    displayName: string;

    /**
     * Gets a user-friendly description of the type of the file. 
     */
    displayType: string;

    /**
     * Gets the type (file name extension) of the file. 
     */
    fileType: string;

    /**
     * Gets an identifier for the file. This ID is unique for the query result or StorageFolder that contains the file and can be used to distinguish between items that have the same name. 
     */
    folderRelativeId: string;

    /**
     * Gets the basic properties of the current file.
     * @return  When this method completes successfully, it returns the basic properties of the current file as a BasicProperties object.
     */
    getBasicPropertiesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.BasicProperties>;

    /**
     * Gets the parent folder of the current file.
     * @return  When this method completes, it returns the parent folder as a StorageFolder .
     */
    getParentAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail, the requested size, and the specified options
     * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
     * @param options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
     */
    getScaledImageAsThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number,
        options: undefined.ThumbnailOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail and the requested size.
     * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
     */
    getScaledImageAsThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail.
     * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
     */
    getScaledImageAsThumbnailAsync(
        mode: undefined.ThumbnailMode): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Retrieves an adjusted thumbnail image for the file, determined by the purpose of the thumbnail.
     * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the file.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Retrieves an adjusted thumbnail image for the file, determined by the purpose of the thumbnail and the requested size.
     * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the file.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Retrieves an adjusted thumbnail image for the file, determined by the purpose of the thumbnail, the requested size, and the specified options.
     * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
     * @param options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the file.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number,
        options: undefined.ThumbnailOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Indicates if the file is local, is cached locally, or can be downloaded. 
     */
    isAvailable: boolean;

    /**
     * Indicates whether the current file is equal to the specified file.
     * @param item The IStorageItem object that represents a file to compare against.
     * @return  Returns true if the current file is equal to the specified file; otherwise false.
     */
    isEqual(item: undefined.IStorageItem): boolean;

    /**
     * Determines whether the current StorageFile matches the specified StorageItemTypes value.
     * @param type The value to match against.
     * @return  True if the StorageFile matches the specified value; otherwise false.
     */
    isOfType(type: undefined.StorageItemTypes): boolean;

    /**
     * Moves the current file to the location of the specified file and replaces the specified file in that location.
     * @param fileToReplace The file to replace.
     * @return  No object or value is returned by this method.
     */
    moveAndReplaceAsync(fileToReplace: undefined.IStorageFile): undefined.IPromiseWithIAsyncAction;

    /**
     * Moves the current file to the specified folder.
     * @param destinationFolder The destination folder where the file is moved.
     * @return  No object or value is returned by this method.
     */
    moveAsync(
        destinationFolder: undefined.IStorageFolder): undefined.IPromiseWithIAsyncAction;

    /**
     * Moves the current file to the specified folder and renames the file according to the desired name.
     * @param destinationFolder The destination folder where the file is moved.
     * @param desiredNewName The desired name of the file after it is moved.
     * @return  No object or value is returned by this method.
     */
    moveAsync(
        destinationFolder: undefined.IStorageFolder,
        desiredNewName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Moves the current file to the specified folder and renames the file according to the desired name. This method also specifies what to do if a file with the same name already exists in the specified folder.
     * @param destinationFolder The destination folder where the file is moved.
     * @param desiredNewName The desired name of the file after it is moved.
     * @param option An enum value that determines how Windows responds if the desiredNewName is the same as the name of an existing file in the destination folder.
     * @return  No object or value is returned by this method.
     */
    moveAsync(
        destinationFolder: undefined.IStorageFolder,
        desiredNewName: string,
        option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the name of the file including the file name extension. 
     */
    name: string;

    /**
     * Opens a random-access stream with the specified options over the specified file.
     * @param accessMode One of the enumeration values that specifies the type of access to allow.
     * @return  When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
     */
    openAsync(
        accessMode: undefined.FileAccessMode): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStream>;

    /**
     * Opens a random-access stream with the specified options over the specified file.
     * @param accessMode One of the enumeration values that specifies the type of access to allow.
     * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
     * @return  When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
     */
    openAsync(
        accessMode: undefined.FileAccessMode,
        options: undefined.StorageOpenOptions): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStream>;

    /**
     * Opens a random-access stream over the current file for reading file contents.
     * @return  When this method completes, it returns the random-access stream (type IRandomAccessStreamWithContentType ).
     */
    openReadAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStreamWithContentType>;

    /**
     * Opens a sequential-access stream over the current file for reading file contents.
     * @return  When this method completes, it returns the sequential-access stream (type IInputStream ).
     */
    openSequentialReadAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IInputStream>;

    /**
     * Opens a random-access stream to the file that can be used for transacted-write operations.
     * @return  When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
     */
    openTransactedWriteAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageStreamTransaction>;

    /**
     * Opens a random-access stream to the file that can be used for transacted-write operations with the specified options.
     * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
     * @return  When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
     */
    openTransactedWriteAsync(
        options: undefined.StorageOpenOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageStreamTransaction>;

    /**
     * Gets the full file-system path of the current file, if the file has a path. 
     */
    path: string;

    /**
     * Gets an object that provides access to the content-related properties of the file. 
     */
    properties: undefined.StorageItemContentProperties;

    /**
     * Gets the StorageProvider object that contains info about the service that stores the current file. 
     */
    provider: undefined.StorageProvider;

    /**
     * Renames the current file.
     * @param desiredName The desired, new name of the current item.
     * @return  No object or value is returned by this method when it completes.
     */
    renameAsync(desiredName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Renames the current file. This method also specifies what to do if an existing item in the current file's location has the same name.
     * @param desiredName The desired, new name of the current file.
     * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing item in the current file's location.
     * @return  No object or value is returned by this method when it completes.
     */
    renameAsync(
        desiredName: string,
        option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncAction
}


/**
 * Manages folders and their contents and provides information about them. 
 */
declare class StorageFolder {

    /**
     * Gets the folder that has the specified absolute path in the file system.
     * @param path The absolute path in the file system (not the Uri) of the folder to get.
     * @return  When this method completes successfully, it returns a StorageFolder that represents the specified folder.
     */
    getFolderFromPathAsync(path: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Indicates whether the current folder supports the specified QueryOptions .
     * @param queryOptions The QueryOptions to check.
     * @return  True if the folder or file group supports the specified QueryOptions ; otherwise false.
     */
    areQueryOptionsSupported(queryOptions: undefined.QueryOptions): boolean;

    /**
     * Gets the attributes of the current folder. 
     */
    attributes: undefined.FileAttributes;

    /**
     * Creates a new file in the current folder. This method also specifies what to do if a file with the same name already exists in the current folder.
     * @param desiredName The name of the new file to create in the current folder.
     * @param options One of the enumeration values that determines how to handle the collision if a file with the specified desiredName already exists in the current folder.
     * @return  When this method completes, it returns a StorageFile that represents the new file.
     */
    createFileAsync(
        desiredName: string,
        options: undefined.CreationCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Creates a new file with the specified name in the current folder.
     * @param desiredName The name of the new file to create in the current folder.
     * @return  When this method completes, it returns a StorageFile that represents the new file.
     */
    createFileAsync(
        desiredName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Gets a query result object that contains the files in the current folder.
     * @return  A query result object. Call the GetFilesAsync method of the query result to get the flat list of files. This method returns a list of type IReadOnlyList< StorageFile >. Each file is represented by an item of type StorageFile.
     */
    createFileQuery(): undefined.StorageFileQueryResult;

    /**
     * Gets a query result object that contains the files in the current folder. Also gets the files from the subfolders of the current folder when the value of the query argument is something other than CommonFileQuery.DefaultQuery . Files are sorted based on the specified CommonFileQuery.
     * @param query One of the enumeration values that specifies how to sort the files and determines whether the query is shallow or deep.
     * @return  A query result object. Call the GetFilesAsync method of the query result to get the flat list of files, sorted as specified by query. This method returns a list of type IReadOnlyList< StorageFile >. Each file is represented by an item of type StorageFile.
     */
    createFileQuery(query: undefined.CommonFileQuery): undefined.StorageFileQueryResult;

    /**
     * Gets a query result object that contains the files in the current folder and, optionally, in the subfolders of the current folder. The results are based on the specified QueryOptions .
     * @param queryOptions The criteria that are applied to the query.
     * @return  A query result object that contains the files in the current folder and, optionally, in the subfolders of the current folder, filtered and sorted based on the specified QueryOptions . Call the GetFilesAsync method of the query result to get the flat list of files, sorted as specified by queryOptions. This method returns a list of type IReadOnlyList< StorageFile >. Each file is represented by an item of type StorageFile.
     */
    createFileQueryWithOptions(queryOptions: undefined.QueryOptions): undefined.StorageFileQueryResult;

    /**
     * Creates a new subfolder with the specified name in the current folder.
     * @param desiredName The name of the new subfolder to create in the current folder.
     * @return  When this method completes, it returns a StorageFolder that represents the new subfolder.
     */
    createFolderAsync(
        desiredName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Creates a new subfolder with the specified name in the current folder. This method also specifies what to do if a subfolder with the same name already exists in the current folder.
     * @param desiredName The name of the new subfolder to create in the current folder.
     * @param options One of the enumeration values that determines how to handle the collision if a subfolder with the specified desiredName already exists in the current folder.
     * @return  When this method completes, it returns a StorageFolder that represents the new subfolder.
     */
    createFolderAsync(
        desiredName: string,
        options: undefined.CreationCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Gets a query result object that contains the subfolders in the current folder.
     * @return  A query result object. Call the GetFoldersAsync method of the query result to get the subfolders in the current folder. This method returns a list of type IReadOnlyList< StorageFolder >. Each file or folder is represented by an item of type StorageFolder.
     */
    createFolderQuery(): undefined.StorageFolderQueryResult;

    /**
     * Gets a query result object that contains the subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , gets a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. Files are grouped into folders based on the specified value from the CommonFolderQuery enumeration.
     * @param query One of the enumeration values that specifies how to group the files into folders and determines whether the query is shallow or deep.
     * @return  A query result object. Call the GetFoldersAsync method of the query result to get the subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , the query result object contains a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. (Files from the current folder are not included.) The files are grouped as specified by query. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
     */
    createFolderQuery(query: undefined.CommonFolderQuery): undefined.StorageFolderQueryResult;

    /**
     * Gets a query result object that contains the subfolders in the current folder and, optionally, nested subfolders. The results are based on the specified QueryOptions .
     * @param queryOptions The criteria that are applied to the query.
     * @return  A query result object. Call the GetFoldersAsync method of the query result to get the subfolders in the current folder. If you provided a CommonFolderQuery value other than CommonFolderQuery.DefaultQuery when you instantiated the QueryOptions , the query result object contains a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. (Files from the current folder are not included.) The files are grouped as specified by queryOptions. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
     */
    createFolderQueryWithOptions(queryOptions: undefined.QueryOptions): undefined.StorageFolderQueryResult;

    /**
     * Gets a query result object that contains the files and subfolders in the current folder.
     * @return  A query result object. Call the GetItemsAsync method of the query result to get the files and subfolders in the current folder. This method returns a list of type IReadOnlyList< IStorageItem >. Each file or folder is represented by an item of type IStorageItem.
     */
    createItemQuery(): undefined.StorageItemQueryResult;

    /**
     * Gets a query result object that contains the files and subfolders in the current folder and, optionally, in the subfolders of the current folder. The results are based on the specified QueryOptions .
     * @param queryOptions The criteria that are applied to the query.
     * @return  A query result object. Call the GetItemsAsync method of the query result to get the files and subfolders in the current folder and, optionally, in the subfolders of the current folder, filtered and sorted based on the specified QueryOptions . This method returns a list of type IReadOnlyList< IStorageItem >. Each file or folder is represented by an item of type IStorageItem.
     */
    createItemQueryWithOptions(queryOptions: undefined.QueryOptions): undefined.StorageItemQueryResult;

    /**
     * Gets the date and time that the current folder was created. 
     */
    dateCreated: Date;

    /**
     * Deletes the current folder. This method also specifies whether to delete the folder permanently.
     * @param option One of the enumeration values that specifies whether to delete the folder permanently.
     * @return  No object or value is returned by this method when it completes.
     */
    deleteAsync(option: undefined.StorageDeleteOption): undefined.IPromiseWithIAsyncAction;

    /**
     * Deletes the current folder.
     * @return  No object or value is returned by this method when it completes.
     */
    deleteAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the user-friendly name of the current folder. 
     */
    displayName: string;

    /**
     * Gets the user-friendly description of the type of the folder; for example, JPEG image. 
     */
    displayType: string;

    /**
     * Gets an identifier for the current folder. This ID is unique for the query result or StorageFolder that contains the current folder or file group, and can be used to distinguish between items that have the same name. 
     */
    folderRelativeId: string;

    /**
     * Gets the basic properties of the current folder or file group.
     * @return  When this method completes successfully, it returns the basic properties of the current folder or file group as a BasicProperties object.
     */
    getBasicPropertiesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.BasicProperties>;

    /**
     * Gets the file with the specified name from the current folder.
     * @param name The name (or path relative to the current folder) of the file to get.
     * @return  When this method completes successfully, it returns a StorageFile that represents the specified file.
     */
    getFileAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>;

    /**
     * Gets the files in the current folder. Also gets the files from the subfolders of the current folder when the value of the query argument is something other than CommonFileQuery.DefaultQuery . Files are sorted based on the specified value from the CommonFileQuery enumeration.
     * @param query One of the enumeration values that specifies how to sort the files and determines whether the query is shallow or deep.
     * @return  When this method completes successfully, it returns a flat list of files, sorted as specified by query. The list is of type IReadOnlyList< StorageFile >. Each file in the list is represented by a StorageFile object.
     */
    getFilesAsync(
        query: undefined.CommonFileQuery): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the files in the current folder.
     * @return  When this method completes successfully, it returns a list of the files in the current folder. The list is of type IReadOnlyList< StorageFile >. Each file in the list is represented by a StorageFile object.
     */
    getFilesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets an index-based range of files from the list of all files in the current folder. Also gets the files from the subfolders of the current folder when the value of the query argument is something other than CommonFileQuery.DefaultQuery . Files are sorted based on the specified value from the CommonFileQuery enumeration.
     * @param query One of the enumeration values that specifies how to sort the files and determines whether the query is shallow or deep.
     * @param startIndex The zero-based index of the first file in the range to retrieve.
     * @param maxItemsToRetrieve The maximum number of files to retrieve.
     * @return  When this method completes successfully, it returns a flat list of files sorted as specified by query. The list is of type IReadOnlyList< StorageFile >. Each file in the list is represented by a StorageFile object.
     */
    getFilesAsync(
        query: undefined.CommonFileQuery,
        startIndex: number,
        maxItemsToRetrieve: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the subfolder with the specified name from the current folder.
     * @param name The name (or path relative to the current folder) of the subfolder to get.
     * @return  When this method completes successfully, it returns a StorageFolder that represents the specified subfolder.
     */
    getFolderAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Gets the subfolders in the current folder.
     * @return  When this method completes successfully, it returns a list of the subfolders in the current folder. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
     */
    getFoldersAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , gets a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. Files are grouped into folders based on the specified value from the CommonFolderQuery enumeration.
     * @param query One of the enumeration values that specifies how to group the files into folders and determines whether the query is shallow or deep.
     * @return  When this method completes successfully, it returns a list of subfolders. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , this method returns a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. (Files from the current folder are not included.) The files are grouped as specified by query. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
     */
    getFoldersAsync(
        query: undefined.CommonFolderQuery): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets an index-based range of folders from the list of all subfolders in the current folder. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , gets a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. Files are grouped into folders based on the specified value from the CommonFolderQuery enumeration.
     * @param query One of the enumeration values that specifies how to group the files into folders and determines whether the query is shallow or deep.
     * @param startIndex The zero-based index of the first folder in the range to retrieve.
     * @param maxItemsToRetrieve The maximum number of folders to retrieve.
     * @return  When this method completes successfully, it returns a list of subfolders. When the value of the query argument is something other than CommonFolderQuery.DefaultQuery , this method returns a list of virtual folders that represent containers for groups of files in the subfolders of the current folder. (Files from the current folder are not included.) The files are grouped as specified by query. The list is of type IReadOnlyList< StorageFolder >. Each folder in the list is represented by a StorageFolder object.
     */
    getFoldersAsync(
        query: undefined.CommonFolderQuery,
        startIndex: number,
        maxItemsToRetrieve: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the indexed state of the current folder.
     * @return  When this method completes successfully, it returns an IndexedState enum value that describes the state of the folder.
     */
    getIndexedStateAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IndexedState>;

    /**
     * Gets the file or folder with the specified name from the current folder.
     * @param name The name (or path relative to the current folder) of the file or folder to get.
     * @return  When this method completes successfully, it returns an IStorageItem that represents the specified file or folder.
     */
    getItemAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.IStorageItem>;

    /**
     * Gets the files and subfolders in the current folder.
     * @return  When this method completes successfully, it returns a list of the files and folders in the current folder. The list is of type IReadOnlyList< IStorageItem >. Each item in the list is represented by an IStorageItem object.
     */
    getItemsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets an index-based range of files and folders from the list of all files and subfolders in the current folder.
     * @param startIndex The zero-based index of the first item in the range to get.
     * @param maxItemsToRetrieve The maximum number of items to get.
     * @return  When this method completes successfully, it returns a list of the files and subfolders in the current folder. The list is of type IReadOnlyList< IStorageItem >. Each item in the list is represented by an IStorageItem object.
     */
    getItemsAsync(
        startIndex: number,
        maxItemsToRetrieve: number): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets the parent folder of the current folder.
     * @return  When this method completes, it returns the parent folder as a StorageFolder .
     */
    getParentAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail, the requested size, and the specified options
     * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
     * @param options The enum value that describes the desired behavior to use to retrieve the thumbnail image. The specified behavior might affect the size and/or quality of the image and how quickly the thumbnail image is retrieved.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
     */
    getScaledImageAsThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number,
        options: undefined.ThumbnailOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail and the requested size.
     * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. Windows uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
     */
    getScaledImageAsThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Gets a scaled image as a thumbnail, determined by the purpose of the thumbnail.
     * @param mode The enum value that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image or null if there is no thumbnail image associated with the item.
     */
    getScaledImageAsThumbnailAsync(
        mode: undefined.ThumbnailMode): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Gets a thumbnail image for the current folder, sized for the specified purpose of the thumbnail and adjusted to the requested size with the specified options.
     * @param mode A value from the enumeration that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. This method uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
     * @param options A value from the enumeration that specifies how to retrieve and size the image. The default value, UseCurrentScale, is suitable for most apps.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image, or null if there is no thumbnail image associated with the folder.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number,
        options: undefined.ThumbnailOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Gets a thumbnail image for the current folder, sized for the specified purpose of the thumbnail and adjusted to the requested size.
     * @param mode A value from the enumeration that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @param requestedSize The requested size, in pixels, of the longest edge of the thumbnail. This method uses the requestedSize as a guide and tries to scale the thumbnail image without reducing the quality of the image.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image, or null if there is no thumbnail image associated with the folder.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode,
        requestedSize: number): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Gets a thumbnail image for the current folder, sized for the specified purpose of the thumbnail.
     * @param mode A value from the enumeration that describes the purpose of the thumbnail and determines how the thumbnail image is adjusted.
     * @return  When this method completes successfully, it returns a StorageItemThumbnail that represents the thumbnail image, or null if there is no thumbnail image associated with the folder.
     */
    getThumbnailAsync(
        mode: undefined.ThumbnailMode): undefined.IPromiseWithIAsyncOperation<undefined.StorageItemThumbnail>;

    /**
     * Indicates whether the current folder supports the specified CommonFileQuery .
     * @param query The value to test.
     * @return  True if the folder supports the specified CommonFileQuery ; otherwise, false.
     */
    isCommonFileQuerySupported(query: undefined.CommonFileQuery): boolean;

    /**
     * Indicates whether the current folder supports the specified CommonFolderQuery .
     * @param query The value to test.
     * @return  True if the folder supports the specified CommonFolderQuery ; otherwise, false.
     */
    isCommonFolderQuerySupported(query: undefined.CommonFolderQuery): boolean;

    /**
     * Indicates whether the current folder is equal to the specified folder.
     * @param item The IStorageItem object that represents the folder to compare against.
     * @return  Returns true if the current folder is equal to the specified folder; otherwise false.
     */
    isEqual(item: undefined.IStorageItem): boolean;

    /**
     * Indicates whether the current StorageFolder matches the specified StorageItemTypes value.
     * @param type The enum value that determines the object type to match against.
     * @return  True if the StorageFolder matches the specified StorageItemTypes value; otherwise false.
     */
    isOfType(type: undefined.StorageItemTypes): boolean;

    /**
     * Gets the name of the current folder. 
     */
    name: string;

    /**
     * Gets the full path of the current folder in the file system, if the path is available. 
     */
    path: string;

    /**
     * Gets an object that provides access to the content-related properties of the current folder. 
     */
    properties: undefined.StorageItemContentProperties;

    /**
     * Gets the StorageProvider object that contains info about the service that stores the current folder. 
     */
    provider: undefined.StorageProvider;

    /**
     * Renames the current folder.
     * @param desiredName The desired, new name for the current folder.
     * @return  No object or value is returned by this method when it completes.
     */
    renameAsync(desiredName: string): undefined.IPromiseWithIAsyncAction;

    /**
     * Renames the current folder and specifies what to do if a folder with the same name already exists.
     * @param desiredName The desired, new name for the current folder.
     * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing item in the current folder's location.
     * @return  No object or value is returned by this method when it completes.
     */
    renameAsync(
        desiredName: string,
        option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncAction;

    /**
     * Tries to get the file or folder with the specified name from the current folder. Returns null instead of raising an exception if the specified file or folder is not found.
     * @param name The name (or path relative to the current folder) of the file or folder to get.
     * @return  When this method completes successfully, it returns an IStorageItem that represents the specified file or folder. If the specified file or folder is not found, this method returns null instead of raising an exception.
     */
    tryGetItemAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.IStorageItem >
}


/**
 * Lets you add and remove folders from a library like Music or Videos and lets you get a list of folders included in the library. 
 */
declare class StorageLibrary {

    /**
     * Gets the specified library.
     * @param libraryId A KnownLibraryId value that identifies the library to retrieve, like Music or Videos.
     * @return  When this method completes successfully, it returns the library (type StorageLibrary ).
     */
    getLibraryAsync(
        libraryId: undefined.KnownLibraryId): undefined.IPromiseWithIAsyncOperation<undefined.StorageLibrary>;

    /**
     * Gets the specified library for a User .
     * @param user The User for which the library is retrieved.
     * @param libraryId A KnownLibraryId value that identifies the library to retrieve, like Music or Videos.
     * @return  When this method completes successfully, it returns the library (type StorageLibrary ).
     */
    getLibraryForUserAsync(
        user: undefined.User,
        libraryId: undefined.KnownLibraryId): undefined.IPromiseWithIAsyncOperation<undefined.StorageLibrary>;

    /**
     * Gets the folders in the current library. 
     */
    folders: undefined.IObservableVector<undefined.StorageFolder>;

    /**
     * Occurs when the list of folders in the current library changes. 
     */
    ondefinitionchanged: undefined.TypedEventHandler<undefined.StorageLibrary, any>;
    addEventListener(
        type: "definitionchanged",
        listener: undefined.TypedEventHandler<undefined.StorageLibrary, any>): void;
    removeEventListener(
        type: "definitionchanged",
        listener: undefined.TypedEventHandler<undefined.StorageLibrary, any>): void;

    /**
     * Prompts the user to select a folder, and then adds the folder to the library.
     * @return  When this method completes, it returns the folder that the user picked and added as a StorageFolder . If the user cancels the operation and doesn't pick a folder, the method returns null.
     */
    requestAddFolderAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>;

    /**
     * Prompts the user to confirm removal of the specified folder from the current library, and then removes the folder.
     * @param folder The folder to remove.
     * @return  Returns true if the folder was removed; otherwise false.
     */
    requestRemoveFolderAsync(
        folder: undefined.StorageFolder): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Get the default save folder for the current library. 
     */
    saveFolder: undefined.StorageFolder;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains info about the service that stores files and folders. Files and folders may be stored either by the local file system or by a remote service like Microsoft OneDrive. 
 */
declare class StorageProvider {

    /**
     * Gets a user-friendly name for the current provider of files and folders. 
     */
    displayName: string;

    /**
     * Gets an identifier for the current provider of files and folders. 
     */
    id: string
}


/**
 * Represents a write transaction for a random-access stream. 
 */
declare class StorageStreamTransaction {

    /**
     * Releases system resources that are exposed by the stream, indicating that the data request is complete. 
     */
    close(): void;

    /**
     * Save the stream to the underlying file.
     * @return  No object or value is returned by this method.
     */
    commitAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets the random-access stream used in the transaction. 
     */
    stream: undefined.IRandomAccessStream
}


/**
 * Represents a sequential-access output stream that indicates a request for the data stream of a StorageFile that was created by calling CreateStreamedFileAsync or ReplaceWithStreamedFileAsync . 
 */
declare class StreamedFileDataRequest {

    /**
     * Releases system resources that are exposed by the current stream indicating that the data request is complete. 
     */
    close(): void;

    /**
     * Indicates that the data can't be streamed and releases system resources that are exposed by the current stream indicating that the data request is complete.
     * @param failureMode The enum value that indicates why the data stream can't be accessed.
     */
    failAndClose(failureMode: undefined.StreamedFileFailureMode): void;

    /**
     * Flushes the data in the current stream.
     * @return  When this method completes, it returns true if the data was flushed successfully or false if the flush operation failed.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Writes data from a buffer to the current stream.
     * @param buffer The buffer that contains the data to write.
     * @return  When this method completes, it returns the number of bytes (type UInt32 ) that were written to the stream. If the app specifies a function to monitor progress, that function receives the number of bytes (type UInt32) written so far.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides a default implementation of the IBuffer interface and its related interfaces. 
 */
declare class Buffer {

    /**
     * Creates a new buffer containing a copy of a specified buffer.
     * @param input The buffer to be copied.
     * @return  The newly created copy.
     */
    createCopyFromMemoryBuffer(input: undefined.IMemoryBuffer): undefined.Buffer;

    /**
     * Creates a MemoryBuffer from an existing IBuffer .
     * @param input The input IBuffer .
     * @return  The newly created MemoryBuffer .
     */
    createMemoryBufferOverIBuffer(input: undefined.IBuffer): undefined.MemoryBuffer;

    /**
     * Initializes a new instance of the Buffer class with the specified capacity.
     * @param capacity The maximum number of bytes that the buffer can hold.
     */
    constructor(capacity: number): this;
    byteLength: any;

    /**
     * Gets the maximum number of bytes that the buffer can hold. 
     */
    capacity: number;

    /**
     * Gets the number of bytes currently in use in the buffer. 
     */
    length: number
}


/**
 * Reads data from an input stream. 
 */
declare class DataReader {

    /**
     * Creates a new instance of the data reader with data from the specified buffer.
     * @param buffer The buffer.
     * @return  The data reader.
     */
    fromBuffer(buffer: undefined.IBuffer): undefined.DataReader;

    /**
     * Creates and initializes a new instance of the data reader.
     * @param inputStream The input stream.
     */
    constructor(inputStream: undefined.IInputStream): this;

    /**
     * Gets or sets the byte order of the data in the input stream. 
     */
    byteOrder: undefined.ByteOrder;

    /**
     * Closes the current stream and releases system resources. 
     */
    close(): void;

    /**
     * Detaches the buffer that is associated with the data reader.
     * @return  The detached buffer.
     */
    detachBuffer(): undefined.IBuffer;

    /**
     * Detaches the stream that is associated with the data reader.
     * @return  The detached stream.
     */
    detachStream(): undefined.IInputStream;

    /**
     * Gets or sets the read options for the input stream. 
     */
    inputStreamOptions: undefined.InputStreamOptions;

    /**
     * Loads data from the input stream.
     * @param count The count of bytes to load into the intermediate buffer.
     * @return  The asynchronous load data request.
     */
    loadAsync(
        count: number): undefined.IPromiseWithOperation<any, undefined.DataReaderLoadOperation>;

    /**
     * Reads a Boolean value from the input stream.
     * @return  The value.
     */
    readBoolean(): boolean;

    /**
     * Reads a buffer from the input stream.
     * @param length The length of the buffer, in bytes.
     * @return  The buffer.
     */
    readBuffer(length: number): undefined.IBuffer;

    /**
     * Reads a byte value from the input stream.
     * @return  The value.
     */
    readByte(): number;

    /**
     * Reads an array of byte values from the input stream.
     * @return  The array that receives the byte values.
     */
    readBytes(): number[];

    /**
     * Reads a date and time value from the input stream.
     * @return  The value.
     */
    readDateTime(): Date;

    /**
     * Reads a floating-point value from the input stream.
     * @return  The value.
     */
    readDouble(): number;

    /**
     * Reads a GUID value from the input stream.
     * @return  The value.
     */
    readGuid(): string;

    /**
     * Reads a 16-bit integer value from the input stream.
     * @return  The value.
     */
    readInt16(): number;

    /**
     * Reads a 32-bit integer value from the input stream.
     * @return  The value.
     */
    readInt32(): number;

    /**
     * Reads a 64-bit integer value from the input stream.
     * @return  The value.
     */
    readInt64(): number;

    /**
     * Reads a floating-point value from the input stream.
     * @return  The value.
     */
    readSingle(): number;

    /**
     * Reads a string value from the input stream.
     * @param codeUnitCount The length of the string.
     * @return  The value.
     */
    readString(codeUnitCount: number): string;

    /**
     * Reads a time-interval value from the input stream.
     * @return  The value.
     */
    readTimeSpan(): number;

    /**
     * Reads a 16-bit unsigned integer from the input stream.
     * @return  The value.
     */
    readUInt16(): number;

    /**
     * Reads a 32-bit unsigned integer from the input stream.
     * @return  The value.
     */
    readUInt32(): number;

    /**
     * Reads a 64-bit unsigned integer from the input stream.
     * @return  The value.
     */
    readUInt64(): number;

    /**
     * Gets the size of the buffer that has not been read. 
     */
    unconsumedBufferLength: number;

    /**
     * Gets or sets the Unicode character encoding for the input stream. 
     */
    unicodeEncoding: undefined.UnicodeEncoding
}


/**
 * Loads data from an input stream. 
 */
declare class DataReaderLoadOperation {

    /**
     * Requests the cancellation of the data load operation. 
     */
    cancel(): void;

    /**
     * Requests that work associated with the data load operation should stop. 
     */
    close(): void;

    /**
     * Gets or sets the handler to call when the data load operation is complete. 
     */
    completed: undefined.AsyncOperationCompletedHandler<number>;

    /**
     * Gets the error code for the data load operation if it fails. 
     */
    errorCode: Windows$WinRTError;

    /**
     * Returns the result of the data load operation.
     * @return  The result of the operation.
     */
    getResults(): number;

    /**
     * Gets a unique identifier that represents the data load operation. 
     */
    id: number;

    /**
     * Gets the current status of the data load operation. 
     */
    status: undefined.AsyncStatus
}


/**
 * Writes data to an output stream. 
 */
declare class DataWriter {

    /**
     * Creates and initializes a new instance of the data writer. 
     */
    constructor(): this;

    /**
     * Creates and initializes a new instance of the data writer to an output stream.
     * @param outputStream The new output stream instance.
     */
    constructor(outputStream: undefined.IOutputStream): this;

    /**
     * Gets or sets the byte order of the data in the output stream. 
     */
    byteOrder: undefined.ByteOrder;

    /**
     * Closes the current stream and releases system resources. 
     */
    close(): void;

    /**
     * Detaches the buffer that is associated with the data writer.
     * @return  The detached buffer.
     */
    detachBuffer(): undefined.IBuffer;

    /**
     * Detaches the stream that is associated with the data writer.
     * @return  The detached stream.
     */
    detachStream(): undefined.IOutputStream;

    /**
     * Flushes data asynchronously.
     * @return  The stream flush operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets the size of a string.
     * @param value The string.
     * @return  The size of the string, in bytes.
     */
    measureString(value: string): number;

    /**
     * Commits data in the buffer to a backing store.
     * @return  The asynchronous store data operation.
     */
    storeAsync(): undefined.IPromiseWithOperation<any, undefined.DataWriterStoreOperation>;

    /**
     * Gets or sets the Unicode character encoding for the output stream. 
     */
    unicodeEncoding: undefined.UnicodeEncoding;

    /**
     * Gets the size of the buffer that has not been used. 
     */
    unstoredBufferLength: number;

    /**
     * Writes a Boolean value to the output stream.
     * @param value The value.
     */
    writeBoolean(value: boolean): void;

    /**
     * Writes the specified bytes from a buffer to the output stream.
     * @param buffer The buffer.
     * @param start The starting byte.
     * @param count The number of bytes to write.
     */
    writeBuffer(buffer: undefined.IBuffer, start: number, count: number): void;

    /**
     * Writes the contents of the specified buffer to the output stream.
     * @param buffer The buffer.
     */
    writeBuffer(buffer: undefined.IBuffer): void;

    /**
     * Writes a byte value to the output stream.
     * @param value The value.
     */
    writeByte(value: number): void;

    /**
     * Writes an array of byte values to the output stream.
     * @param value The array of values.
     */
    writeBytes(value: number[]): void;

    /**
     * Writes a date and time value to the output stream.
     * @param value The value.
     */
    writeDateTime(value: Date): void;

    /**
     * Writes a floating-point value to the output stream.
     * @param value The value.
     */
    writeDouble(value: number): void;

    /**
     * Writes a GUID value to the output stream.
     * @param value The value.
     */
    writeGuid(value: string): void;

    /**
     * Writes a 16-bit integer value to the output stream.
     * @param value The value.
     */
    writeInt16(value: number): void;

    /**
     * Writes a 32-bit integer value to the output stream.
     * @param value The value.
     */
    writeInt32(value: number): void;

    /**
     * Writes a 64-bit integer value to the output stream.
     * @param value The value.
     */
    writeInt64(value: number): void;

    /**
     * Writes a floating-point value to the output stream.
     * @param value The value.
     */
    writeSingle(value: number): void;

    /**
     * Writes a string value to the output stream.
     * @param value The value.
     * @return  The length of the string, in bytes.
     */
    writeString(value: string): number;

    /**
     * Writes a time-interval value to the output stream.
     * @param value The value.
     */
    writeTimeSpan(value: number): void;

    /**
     * Writes a 16-bit unsigned integer value to the output stream.
     * @param value The value.
     */
    writeUInt16(value: number): void;

    /**
     * Writes a 32-bit unsigned integer value to the output stream.
     * @param value The value.
     */
    writeUInt32(value: number): void;

    /**
     * Writes a 64-bit unsigned integer value to the output stream.
     * @param value The value.
     */
    writeUInt64(value: number): void
}


/**
 * Commits data in a buffer to a backing store. 
 */
declare class DataWriterStoreOperation {

    /**
     * Requests the cancellation of the data store operation. 
     */
    cancel(): void;

    /**
     * Requests that work associated with the data store operation should stop. 
     */
    close(): void;

    /**
     * Gets or sets the handler to call when the data store operation is complete. 
     */
    completed: undefined.AsyncOperationCompletedHandler<number>;

    /**
     * Gets the error code for the data store operation if it fails. 
     */
    errorCode: Windows$WinRTError;

    /**
     * Returns the result of the data store operation.
     * @return  The result of the operation.
     */
    getResults(): number;

    /**
     * Gets a unique identifier that represents the data store operation. 
     */
    id: number;

    /**
     * Gets the current status of the data store operation. 
     */
    status: undefined.AsyncStatus
}


/**
 * Reads data from a file. 
 */
declare class FileInputStream {

    /**
     * Closes the current stream and releases system resources. 
     */
    close(): void;

    /**
     * Returns an asynchronous byte reader object.
     * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
     * @param count The number of bytes to read that is less than or equal to the Capacity value.
     * @param options Specifies the type of the asynchronous read operation.
     * @return  The asynchronous operation.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number >
}


/**
 * Writes data to a file. 
 */
declare class FileOutputStream {

    /**
     * Closes the current stream and releases system resources. 
     */
    close(): void;

    /**
     * Flushes data asynchronously in a sequential stream.
     * @return  The stream flush operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Writes data asynchronously to a file.
     * @param buffer The buffer into which the asynchronous writer operation writes.
     * @return  The byte writer operation.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Supports reading and writing to a file at a specified position. 
 */
declare class FileRandomAccessStream {

    /**
     * Gets a value that indicates whether the stream can be read from. 
     */
    canRead: boolean;

    /**
     * Gets a value that indicates whether the file can be written to. 
     */
    canWrite: boolean;

    /**
     * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
     * @return  The new stream. The initial, internal position of the stream is 0.
     */
    cloneStream(): undefined.IRandomAccessStream;

    /**
     * Closes the current stream and releases system resources. 
     */
    close(): void;

    /**
     * Flushes data asynchronously in a sequential stream.
     * @return  The stream flush operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Returns an input stream at a specified location in a stream.
     * @param position The location in the stream at which to begin.
     * @return  The input stream.
     */
    getInputStreamAt(position: number): undefined.IInputStream;

    /**
     * Returns an output stream at a specified location in a stream.
     * @param position The location in the output stream at which to begin.
     * @return  The output stream.
     */
    getOutputStreamAt(position: number): undefined.IOutputStream;

    /**
     * Gets the byte offset of the stream. 
     */
    position: number;

    /**
     * Returns an asynchronous byte reader object.
     * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
     * @param count The number of bytes to read that is less than or equal to the Capacity value.
     * @param options Specifies the type of the asynchronous read operation.
     * @return  The asynchronous operation.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Sets the position of the stream to the specified value.
     * @param position The new position of the stream.
     */
    seek(position: number): void;

    /**
     * Gets or sets the size of the random access stream. 
     */
    size: number;

    /**
     * Writes data asynchronously to a file.
     * @param buffer The buffer into which the asynchronous writer operation writes.
     * @return  The byte writer operation.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides random access of data in input and output streams that are stored in memory instead of on disk. 
 */
declare class InMemoryRandomAccessStream {

    /**
     * Creates a new instance of the InMemoryRandomAccessStream class. 
     */
    constructor(): this;

    /**
     * Gets a value that indicates whether the stream can be read from. 
     */
    canRead: boolean;

    /**
     * Gets a value that indicates whether the stream can be written to. 
     */
    canWrite: boolean;

    /**
     * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
     * @return  The new stream. The initial, internal position of the stream is 0.
     */
    cloneStream(): undefined.IRandomAccessStream;

    /**
     * Closes the current stream and releases system resources. 
     */
    close(): void;

    /**
     * Flushes data asynchronously in a sequential stream.
     * @return  The stream flush operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Returns an input stream at a specified location in a stream.
     * @param position The location in the stream at which to begin.
     * @return  The input stream.
     */
    getInputStreamAt(position: number): undefined.IInputStream;

    /**
     * Returns an output stream at a specified location in a stream.
     * @param position The location in the output stream at which to begin.
     * @return  The output stream.
     */
    getOutputStreamAt(position: number): undefined.IOutputStream;

    /**
     * Gets the byte offset of the stream. 
     */
    position: number;

    /**
     * Returns an asynchronous byte reader object.
     * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
     * @param count The number of bytes to read that is less than or equal to the Capacity value.
     * @param options Specifies the type of the asynchronous read operation.
     * @return  The asynchronous operation.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Sets the position of the stream to the specified value.
     * @param position The new position of the stream.
     */
    seek(position: number): void;

    /**
     * Gets or sets the size of the random access stream. 
     */
    size: number;

    /**
     * Writes data asynchronously in a sequential stream.
     * @param buffer The buffer into which the asynchronous writer operation writes.
     * @return  The byte writer operation.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides a Windows Runtime input stream for an IStream base implementation. 
 */
declare class InputStreamOverStream {

    /**
     * Closes the current stream and releases system resources. 
     */
    close(): void;

    /**
     * Returns an asynchronous byte reader object.
     * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
     * @param count The number of bytes to read that is less than or equal to the Capacity value.
     * @param options Specifies the type of the asynchronous read operation.
     * @return  The asynchronous operation.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number >
}


/**
 * Provides a Windows Runtime output stream for an IStream base implementation. 
 */
declare class OutputStreamOverStream {

    /**
     * Closes the current stream and releases system resources. 
     */
    close(): void;

    /**
     * Flushes data asynchronously in a sequential stream.
     * @return  The stream flush operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Writes data asynchronously in a sequential stream.
     * @param buffer The buffer into which the asynchronous writer operation writes.
     * @return  The byte writer operation.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides random access of data in input and output streams. 
 */
declare class RandomAccessStream {

    /**
     * Copies a source stream to a destination stream and waits for the copy operation to complete.
     * @param source The stream to copy data from.
     * @param destination The stream to copy data to.
     * @return  The asynchronous operation.
     */
    copyAndCloseAsync(
        source: undefined.IInputStream,
        destination: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperationWithProgress<number, number>;

    /**
     * Copies the specified number of bytes from a source stream to a destination stream.
     * @param source The stream to copy data from.
     * @param destination The stream to copy data to.
     * @param bytesToCopy The number of bytes to copy.
     * @return  The asynchronous operation.
     */
    copyAsync(
        source: undefined.IInputStream,
        destination: undefined.IOutputStream,
        bytesToCopy: number): undefined.IPromiseWithIAsyncOperationWithProgress<number, number>;

    /**
     * Copies a source stream to a destination stream.
     * @param source The stream to copy data from.
     * @param destination The stream to copy data to.
     * @return  The asynchronous operation.
     */
    copyAsync(
        source: undefined.IInputStream,
        destination: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides a Windows Runtime random access stream for an IStream base implementation. 
 */
declare class RandomAccessStreamOverStream {

    /**
     * Gets a value that indicates whether the stream can be read from. 
     */
    canRead: boolean;

    /**
     * Gets a value that indicates whether the stream can be written to. 
     */
    canWrite: boolean;

    /**
     * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
     * @return  The new stream. The initial, internal position of the stream is 0.
     */
    cloneStream(): undefined.IRandomAccessStream;

    /**
     * Closes the current stream and releases system resources. 
     */
    close(): void;

    /**
     * Flushes data asynchronously in a sequential stream.
     * @return  The stream flush operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Returns an input stream at a specified location in a stream.
     * @param position The location in the stream at which to begin.
     * @return  The input stream.
     */
    getInputStreamAt(position: number): undefined.IInputStream;

    /**
     * Returns an output stream at a specified location in a stream.
     * @param position The location in the output stream at which to begin.
     * @return  The output stream.
     */
    getOutputStreamAt(position: number): undefined.IOutputStream;

    /**
     * Gets the byte offset of the stream. 
     */
    position: number;

    /**
     * Returns an asynchronous byte reader object.
     * @param buffer The buffer into which the asynchronous read operation places the bytes that are read.
     * @param count The number of bytes to read that is less than or equal to the Capacity value.
     * @param options Specifies the type of the asynchronous read operation.
     * @return  The asynchronous operation.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Sets the position of the stream to the specified value.
     * @param position The new position of the stream.
     */
    seek(position: number): void;

    /**
     * Gets or sets the size of the random access stream. 
     */
    size: number;

    /**
     * Writes data asynchronously in a sequential stream.
     * @param buffer The buffer into which the asynchronous writer operation writes.
     * @return  The byte writer operation.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides random access of data in input and output streams for a file. 
 */
declare class RandomAccessStreamReference {

    /**
     * Creates a random access stream around a file.
     * @param file The file to create a stream around.
     * @return  The stream that encapsulates file.
     */
    createFromFile(file: undefined.IStorageFile): undefined.RandomAccessStreamReference;

    /**
     * Creates a random access stream around the specified stream.
     * @param stream The source stream.
     * @return  The random access stream that encapsulates stream.
     */
    createFromStream(stream: undefined.IRandomAccessStream): undefined.RandomAccessStreamReference;

    /**
     * Creates a random access stream around the specified URI.
     * @param uri The URI to create the stream around. The valid URI schemes are http, https, ms-appx, and ms-appdata.
     * @return  The random access stream that encapsulates uri.
     */
    createFromUri(uri: undefined.Uri): undefined.RandomAccessStreamReference;

    /**
     * Opens a stream for random access.
     * @return  The asynchronous operation.
     */
    openReadAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStreamWithContentType >
}


/**
 * Enables a Windows Runtime component to provide access to an encapsulated stream. 
 */
declare interface Streams$IRandomAccessStreamReference {

    /**
     * Opens a stream for random access.
     * @return  The asynchronous operation.
     */
    openReadAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStreamWithContentType >
}


/**
 * Supports random access of data in input and output streams for a specified data format. 
 */
declare type Streams$IRandomAccessStreamWithContentType = {} & & & & &



    /**
     * Supports random access of data in input and output streams. 
     */
    declare type Streams$IRandomAccessStream = {

        /**
         * Creates a new instance of a IRandomAccessStream over the same resource as the current stream.
         * @return  The new stream. The initial, internal position of the stream is 0.
         */
        cloneStream(): undefined.IRandomAccessStream,

        /**
         * Returns an input stream at a specified location in a stream.
         * @param position The location in the stream at which to begin.
         * @return  The input stream.
         */
        getInputStreamAt(position: number): undefined.IInputStream,

        /**
         * Returns an output stream at a specified location in a stream.
         * @param position The location in the output stream at which to begin.
         * @return  The output stream.
         */
        getOutputStreamAt(position: number): undefined.IOutputStream,

        /**
         * Sets the position of the stream to the specified value.
         * @param position The new position of the stream.
         */
        seek(position: number): void,

        /**
         * Gets a value that indicates whether the stream can be read from. 
         */
        canRead: boolean,

        /**
         * Gets a value that indicates whether the stream can be written to. 
         */
        canWrite: boolean,

        /**
         * Gets the byte offset of the stream. 
         */
        position: number,

        /**
         * Gets or sets the size of the random access stream. 
         */
        size: number
    } & & &



    /**
     * Represents a referenced array of bytes used by byte stream read and write interfaces. Buffer is the class implementation of this interface. 
     */
    declare interface Streams$IBuffer {

        /**
         * Gets the maximum number of bytes that the buffer can hold. 
         */
        capacity: number,

            /**
             * Gets the number of bytes currently in use in the buffer. 
             */
            length: number
    }


/**
 * Represents a sequential stream of bytes to be read. 
 */
declare type Streams$IInputStream = {

    /**
     * Reads data from the stream asynchronously.
     * @param buffer A buffer that may be used to return the bytes that are read. The return value contains the buffer that holds the results.
     * @param count The number of bytes to read that is less than or equal to the Capacity value.
     * @param options Specifies the type of the asynchronous read operation.
     * @return  The asynchronous operation.
     */
    readAsync(
        buffer: undefined.IBuffer,
        count: number,
        options: undefined.InputStreamOptions): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer,
    number >
}


/**
 * Represents a sequential stream of bytes to be written. 
 */
declare type Streams$IOutputStream = {

    /**
     * Flushes data asynchronously in a sequential stream.
     * @return  The stream flush operation.
     */
    flushAsync(): undefined.IPromiseWithIAsyncOperation<boolean>,

    /**
     * Writes data asynchronously in a sequential stream.
     * @param buffer A buffer that contains the data to be written.
     * @return  The byte writer operation.
     */
    writeAsync(
        buffer: undefined.IBuffer): undefined.IPromiseWithIAsyncOperationWithProgress<number,
    number >
}


/**
 * Characterizes the format of the data. 
 */
declare interface Streams$IContentTypeProvider {

    /**
     * Gets the format of the data. 
     */
    contentType: string
}


/**
 * Enables a Windows Runtime component to provide sequential read access to an encapsulated stream. 
 */
declare interface Streams$IInputStreamReference {

    /**
     * Opens a stream for sequential read access.
     * @return  The asynchronous operation.
     */
    openSequentialReadAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IInputStream >
}


/**
 * A helper object that provides indexing names for Windows audio file properties. 
 */
declare class SystemAudioProperties {

    /**
     * Gets the name of the System.Audio.EncodingBitrate property (one of the Windows audio file properties). 
     */
    encodingBitrate: string
}


/**
 * A helper object that provides indexing names for GPS file properties. 
 */
declare class SystemGPSProperties {

    /**
     * Gets the name of the System.GPS.LatitudeDecimal property (one of the GPS file properties). 
     */
    latitudeDecimal: string;

    /**
     * Gets the name of the System.GPS.LongitudeDecimal property (one of the GPS file properties). 
     */
    longitudeDecimal: string
}


/**
 * A helper object that provides indexing names for Windows image file properties. 
 */
declare class SystemImageProperties {

    /**
     * Gets the name of the System.Image.HorizontalSize property (one of the Windows image file properties). 
     */
    horizontalSize: string;

    /**
     * Gets the name of the System.Image.VerticalSize property (one of the Windows image file properties). 
     */
    verticalSize: string
}


/**
 * A helper object that provides indexing names for Windows media file properties. 
 */
declare class SystemMediaProperties {

    /**
     * Gets the name of the System.Media.Duration property (one of the Windows media file properties). 
     */
    duration: string;

    /**
     * Gets the name of the System.Media.Producer property (one of the Windows media file properties). 
     */
    producer: string;

    /**
     * Gets the name of the System.Media.Publisher property (one of the Windows media file properties). 
     */
    publisher: string;

    /**
     * Gets the name of the System.Media.SubTitle property (one of the Windows media file properties). 
     */
    subTitle: string;

    /**
     * Gets the name of the System.Media.Writer property (one of the Windows media file properties). 
     */
    writer: string;

    /**
     * Gets the name of the System.Media.Year property (one of the Windows media file properties). 
     */
    year: string
}


/**
 * A helper object that provides indexing names for Windows music file properties. 
 */
declare class SystemMusicProperties {

    /**
     * Gets the name of the System.Music.AlbumArtist property (one of the Windows music file properties). 
     */
    albumArtist: string;

    /**
     * Gets the name of the System.Music.AlbumTitle property (one of the Windows music file properties). 
     */
    albumTitle: string;

    /**
     * Gets the name of the System.Music.Artist property (one of the Windows music file properties). 
     */
    artist: string;

    /**
     * Gets the name of the System.Music.Composer property (one of the Windows music file properties). 
     */
    composer: string;

    /**
     * Gets the name of the System.Music.Conductor property (one of the Windows music file properties). 
     */
    conductor: string;

    /**
     * Gets the name of the System.Music.DisplayArtist property (one of the Windows music file properties). 
     */
    displayArtist: string;

    /**
     * Gets the name of the System.Music.Genre property (one of the Windows music file properties). 
     */
    genre: string;

    /**
     * Gets the name of the System.Music.TrackNumber property (one of the Windows music file properties). 
     */
    trackNumber: string
}


/**
 * A helper object that provides indexing names for Windows photo file properties. 
 */
declare class SystemPhotoProperties {

    /**
     * Gets the name of the System.Photo.CameraManufacturer property (one of the Windows photo file properties). 
     */
    cameraManufacturer: string;

    /**
     * Gets the name of the System.Photo.CameraModel property (one of the Windows photo file properties). 
     */
    cameraModel: string;

    /**
     * Gets the name of the System.Photo.DateTaken property (one of the Windows photo file properties). 
     */
    dateTaken: string;

    /**
     * Gets the name of the System.Photo.Orientation property (one of the Windows photo file properties). 
     */
    orientation: string;

    /**
     * Gets the name of the System.Photo.PeopleNames property (one of the Windows photo file properties). 
     */
    peopleNames: string
}


/**
 * Provides string values for indexing names of common Windows file properties such as System.Title , and also references helper objects that provide indexing names for properties of specific file types (for example video files). 
 */
declare class SystemProperties {

    /**
     * Gets an object that provides the indexing names of Windows file properties for System.Audio. 
     */
    audio: undefined.SystemAudioProperties;

    /**
     * Gets the name of the System.Author property (one of the Windows file properties). 
     */
    author: string;

    /**
     * Gets the name of the System.Comment property (one of the Windows file properties). 
     */
    comment: string;

    /**
     * Gets an object that provides the indexing names of Windows system file properties for System.GPS. 
     */
    gps: undefined.SystemGPSProperties;

    /**
     * Gets an object that provides the indexing names of Windows file properties for System.Image. 
     */
    image: undefined.SystemImageProperties;

    /**
     * Gets the name of the System.ItemNameDisplay property (one of the Windows file properties). 
     */
    itemNameDisplay: string;

    /**
     * Gets the name of the System.Keywords property (one of the Windows file properties). 
     */
    keywords: string;

    /**
     * Gets an object that provides the indexing names of system media file properties such as System.Duration . 
     */
    media: undefined.SystemMediaProperties;

    /**
     * Gets an object that provides the indexing names of Windows file properties for System.Music. 
     */
    music: undefined.SystemMusicProperties;

    /**
     * Gets an object that provides the indexing names of Windows file properties for System.Photo. 
     */
    photo: undefined.SystemPhotoProperties;

    /**
     * Gets the name of the System.Rating property (one of the Windows file properties). 
     */
    rating: string;

    /**
     * Gets the name of the System.Title property (one of the Windows file properties). 
     */
    title: string;

    /**
     * Gets an object that provides the indexing names of Windows file properties for System.Video. 
     */
    video: undefined.SystemVideoProperties
}


/**
 * A helper object that provides indexing names for video file properties. 
 */
declare class SystemVideoProperties {

    /**
     * Gets the name of the System.Video.Director property (one of the Windows video file properties). 
     */
    director: string;

    /**
     * Gets the name of the System.Video.FrameHeight property (one of the Windows video file properties). 
     */
    frameHeight: string;

    /**
     * Gets the name of the System.Video.FrameWidth property (one of the Windows video file properties). 
     */
    frameWidth: string;

    /**
     * Gets the name of the System.Video.Orientation property (one of the Windows video file properties). 
     */
    orientation: string;

    /**
     * Gets the name of the System.Video.TotalBitrate property (one of the Windows video file properties). 
     */
    totalBitrate: string
}


/**
 * Manipulates storage items (files and folders) and their contents, and provides information about them. 
 */
declare interface Storage$IStorageItem {

    /**
     * Deletes the current item, optionally deleting it permanently.
     * @param option A value that indicates whether to delete the item permanently.
     * @return  No object or value is returned by this method when it completes.
     */
    deleteAsync(option: undefined.StorageDeleteOption): undefined.IPromiseWithIAsyncAction,

        /**
         * Deletes the current item.
         * @return  No object or value is returned by this method when it completes.
         */
        deleteAsync(): undefined.IPromiseWithIAsyncAction,

        /**
         * Gets the basic properties of the current item (like a file or folder).
         * @return  When this method completes successfully, it returns the basic properties of the current item as a BasicProperties object.
         */
        getBasicPropertiesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.BasicProperties>,

        /**
         * Determines whether the current IStorageItem matches the specified StorageItemTypes value.
         * @param type The value to match against.
         * @return  True if the IStorageItem matches the specified value; otherwise false.
         */
        isOfType(type: undefined.StorageItemTypes): boolean,

        /**
         * Renames the current item. This method also specifies what to do if an existing item in the current item's location has the same name.
         * @param desiredName The desired, new name of the current item.
         * @param option The enum value that determines how Windows responds if the desiredName is the same as the name of an existing item in the current item's location.
         * @return  No object or value is returned by this method when it completes.
         */
        renameAsync(
            desiredName: string,
            option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncAction,

        /**
         * Renames the current item.
         * @param desiredName The desired, new name of the item.
         * @return  No object or value is returned by this method when it completes.
         */
        renameAsync(desiredName: string): undefined.IPromiseWithIAsyncAction,

        /**
         * Gets the attributes of a storage item. 
         */
        attributes: undefined.FileAttributes,

        /**
         * Gets the date and time when the current item was created. 
         */
        dateCreated: Date,

        /**
         * Gets the name of the item including the file name extension if there is one. 
         */
        name: string,

        /**
         * Gets the full file-system path of the item, if the item has a path. 
         */
        path: string,

        /**
         * Gets the parent folder of the current storage item.
         * @return  When this method completes, it returns the parent folder as a StorageFolder .
         */
        getParentAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>,

        /**
         * Indicates whether the current item is the same as the specified item.
         * @param item The IStorageItem object that represents a storage item to compare against.
         * @return  Returns true if the current storage item is the same as the specified storage item; otherwise false.
         */
        isEqual(item: undefined.IStorageItem): boolean
}


/**
 * Represents a file. Provides information about the file and its contents, and ways to manipulate them. 
 */
declare type Storage$IStorageFile = {

        /**
         * Replaces the specified file with a copy of the current file.
         * @param fileToReplace The file to replace.
         * @return  No object or value is returned when this method completes.
         */
        copyAndReplaceAsync(fileToReplace: undefined.IStorageFile): undefined.IPromiseWithIAsyncAction,

        /**
         * Creates a copy of the file in the specified folder, using the desired name. This method also specifies what to do if an existing file in the specified folder has the same name.
         * @param destinationFolder The destination folder where the copy is created.
         * @param desiredNewName The desired name of the copy.
         * @param option An enum value that determines how Windows responds if the desiredNewName is the same as the name of an existing file in the destination folder.
         * @return  When this method completes, it returns a StorageFile that represents the copy.
         */
        copyAsync(
            destinationFolder: undefined.IStorageFolder,
            desiredNewName: string,
            option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>,

        /**
         * Creates a copy of the file in the specified folder, using the desired name.
         * @param destinationFolder The destination folder where the copy is created.
         * @param desiredNewName The desired name of the copy.
         * @return  When this method completes, it returns a StorageFile that represents the copy.
         */
        copyAsync(
            destinationFolder: undefined.IStorageFolder,
            desiredNewName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>,

        /**
         * Creates a copy of the file in the specified folder.
         * @param destinationFolder The destination folder where the copy is created.
         * @return  When this method completes, it returns a StorageFile that represents the copy.
         */
        copyAsync(
            destinationFolder: undefined.IStorageFolder): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>,

        /**
         * Moves the current file to the location of the specified file and replaces the specified file in that location.
         * @param fileToReplace The file to replace.
         * @return  No object or value is returned by this method.
         */
        moveAndReplaceAsync(fileToReplace: undefined.IStorageFile): undefined.IPromiseWithIAsyncAction,

        /**
         * Moves the current file to the specified folder.
         * @param destinationFolder The destination folder where the file is moved.
         * @return  No object or value is returned by this method.
         */
        moveAsync(
            destinationFolder: undefined.IStorageFolder): undefined.IPromiseWithIAsyncAction,

        /**
         * Moves the current file to the specified folder and renames the file according to the desired name. This method also specifies what to do if a file with the same name already exists in the specified folder.
         * @param destinationFolder The destination folder where the file is moved.
         * @param desiredNewName The desired name of the file after it is moved.
         * @param option An enum value that determines how Windows responds if the desiredNewName is the same as the name of an existing file in the destination folder.
         * @return  No object or value is returned by this method.
         */
        moveAsync(
            destinationFolder: undefined.IStorageFolder,
            desiredNewName: string,
            option: undefined.NameCollisionOption): undefined.IPromiseWithIAsyncAction,

        /**
         * Moves the current file to the specified folder and renames the file according to the desired name.
         * @param destinationFolder The destination folder where the file is moved.
         * @param desiredNewName The desired name of the file after it is moved.
         * @return  No object or value is returned by this method.
         */
        moveAsync(
            destinationFolder: undefined.IStorageFolder,
            desiredNewName: string): undefined.IPromiseWithIAsyncAction,

        /**
         * Opens a random-access stream over the file.
         * @param accessMode The type of access to allow.
         * @return  When this method completes, it returns the random-access stream (type IRandomAccessStream ).
         */
        openAsync(
            accessMode: undefined.FileAccessMode): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStream>,

        /**
         * Opens a random-access stream over the file.
         * @param accessMode One of the enumeration values that specifies the type of access to allow.
         * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
         * @return  When this method completes, it returns an IRandomAccessStream that contains the requested random-access stream.
         */
        openAsync(
            accessMode: undefined.FileAccessMode,
            options: undefined.StorageOpenOptions): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStream>,

        /**
         * Opens a transacted, random-access stream for writing to the file.
         * @return  When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
         */
        openTransactedWriteAsync(): undefined.IPromiseWithIAsyncOperation<undefined.StorageStreamTransaction>,

        /**
         * Opens a random-access stream to the file that can be used for transacted-write operations with the specified options.
         * @param options A bitwise combination of the enumeration values that specify options for opening the stream.
         * @return  When this method completes, it returns a StorageStreamTransaction that contains the random-access stream and methods that can be used to complete transactions.
         */
        openTransactedWriteAsync(
            options: undefined.StorageOpenOptions): undefined.IPromiseWithIAsyncOperation<undefined.StorageStreamTransaction>,

        /**
         * Gets the MIME type of the contents of the file. 
         */
        contentType: string,

        /**
         * Gets the type (file name extension) of the file. 
         */
        fileType: string
    } & & &



    /**
     * Manipulates folders and their contents, and provides information about them. 
     */
    declare type Storage$IStorageFolder = {

        /**
         * Creates a new file in the current folder, and specifies what to do if a file with the same name already exists in the current folder.
         * @param desiredName The desired name of the file to create.
         * @param options The enum value that determines how Windows responds if the desiredName is the same as the name of an existing file in the current folder.
         * @return  When this method completes, it returns the new file as a StorageFile .
         */
        createFileAsync(
            desiredName: string,
            options: undefined.CreationCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>,

        /**
         * Creates a new file in the current folder.
         * @param desiredName The desired name of the file to create.
         * @return  When this method completes, it returns the new file as a StorageFile .
         */
        createFileAsync(
            desiredName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>,

        /**
         * Creates a new folder in the current folder.
         * @param desiredName The desired name of the folder to create.
         * @return  When this method completes, it returns the new folder as a StorageFolder .
         */
        createFolderAsync(
            desiredName: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>,

        /**
         * Creates a new folder in the current folder, and specifies what to do if a folder with the same name already exists in the current folder.
         * @param desiredName The desired name of the folder to create.
         * @param options The enum value that determines how Windows responds if the desiredName is the same as the name of an existing folder in the current folder.
         * @return  When this method completes, it returns the new folder as a StorageFolder .
         */
        createFolderAsync(
            desiredName: string,
            options: undefined.CreationCollisionOption): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>,

        /**
         * Gets the specified file from the current folder.
         * @param name The name (or path relative to the current folder) of the file to retrieve.
         * @return  When this method completes successfully, it returns a StorageFile that represents the file.
         */
        getFileAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFile>,

        /**
         * Gets the files from the current folder.
         * @return  When this method completes successfully, it returns a list of the files (type IVectorView ) in the folder. Each file in the list is represented by a StorageFile object.
         */
        getFilesAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ,

        /**
         * Gets the specified folder from the current folder.
         * @param name The name of the child folder to retrieve.
         * @return  When this method completes successfully, it returns a StorageFolder that represents the child folder.
         */
        getFolderAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.StorageFolder>,

        /**
         * Gets the folders in the current folder.
         * @return  When this method completes successfully, it returns a list of the files (type IVectorView ). Each folder in the list is represented by a StorageFolder .
         */
        getFoldersAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ,

        /**
         * Gets the specified item from the IStorageFolder .
         * @param name The name of the item to retrieve.
         * @return  When this method completes successfully, it returns the file or folder (type IStorageItem ).
         */
        getItemAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.IStorageItem>,

        /**
         * Gets the items from the current folder.
         * @return  When this method completes successfully, it returns a list of the files and folders (type IVectorView ). The files and folders in the list are represented by objects of type IStorageItem .
         */
        getItemsAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ,

        /**
         * Try to get a single file or sub-folder from the current folder by using the name of the item.
         * @param name The name (or path relative to the current folder) of the file or sub-folder to try to retrieve.
         * @return  When this method completes successfully, it returns the file or folder (type IStorageItem ).
         */
        tryGetItemAsync(name: string): undefined.IPromiseWithIAsyncOperation<undefined.IStorageItem >
    }


/**
 * Represents a method that handles the request to set the version of the application data in the application data store. 
 */
declare type Storage$ApplicationDataSetVersionHandler = (setVersionRequest: undefined.SetVersionRequest) => void;


/**
 * Represents the method that will stream data into a StorageFile when that file is first accessed. 
 */
declare type Storage$StreamedFileDataRequestedHandler = (stream: undefined.StreamedFileDataRequest) => void;


/**
 * Represents app memory usage at a single point in time. 
 */
declare class AppMemoryReport {

    /**
     * Gets the app's peak usage of private commit. 
     */
    peakPrivateCommitUsage: number;

    /**
     * Gets the app's usage of private commit. 
     */
    privateCommitUsage: number;

    /**
     * Gets the app's total cap for private plus shared commit. 
     */
    totalCommitLimit: number;

    /**
     * Gets the app's total usage of private plus shared commit. 
     */
    totalCommitUsage: number
}


/**
 * Provides data for the AppMemoryUsageLimitChanging event. 
 */
declare class AppMemoryUsageLimitChangingEventArgs {

    /**
     * Gets the new limit for how much total memory the app can use, in bytes. 
     */
    newLimit: number;

    /**
     * Gets the old limit for how much total memory the app can use, in bytes. 
     */
    oldLimit: number
}


/**
 * Provides access to data about the CPU usage of a process. 
 */
declare class ProcessCpuUsage {

    /**
     * Gets the ProcessCpuUsageReport for the process.
     * @return  The CPU usage report for the process.
     */
    getReport(): undefined.ProcessCpuUsageReport
}


/**
 * Provides data about the CPU usage of the process. 
 */
declare class ProcessCpuUsageReport {

    /**
     * Gets the amount of CPU kernel time consumed by the process. 
     */
    kernelTime: number;

    /**
     * Gets the amount of CPU user time consumed by the process. 
     */
    userTime: number
}


/**
 * Provides diagnostic information about a process, such as CPU usage, disk usage, memory usage and so on. 
 */
declare class ProcessDiagnosticInfo {

    /**
     * Gets the ProcessDiagnosticInfo for the currently running process.
     * @return  The ProcessDiagnosticInfo for the currently running process.
     */
    getForCurrentProcess(): undefined.ProcessDiagnosticInfo;

    /**
     * Gets a list of ProcessDiagnosticInfo objects for all running processes.
     * @return  A list of ProcessDiagnosticInfo objects for all running processes.
     */
    getForProcesses(): undefined.IVectorView<undefined.ProcessDiagnosticInfo>;

    /**
     * Gets the CPU time used by the process. 
     */
    cpuUsage: undefined.ProcessCpuUsage;

    /**
     * Gets the disk I/O usage of the process. 
     */
    diskUsage: undefined.ProcessDiskUsage;

    /**
     * Gets the name of the executable file for the process. 
     */
    executableFileName: string;

    /**
     * Get memory usage data for the process. 
     */
    memoryUsage: undefined.ProcessMemoryUsage;

    /**
     * Gets the ProcessDiagnosticInfo for the parent process. 
     */
    parent: undefined.ProcessDiagnosticInfo;

    /**
     * Gets the unique process ID. 
     */
    processId: number;

    /**
     * Gets the time the process was started. 
     */
    processStartTime: Date
}


/**
 * Provides access to data about the disk usage of a process. 
 */
declare class ProcessDiskUsage {

    /**
     * Gets the ProcessDiskUsageReport for the process.
     * @return  The ProcessDiskUsageReport for the process.
     */
    getReport(): undefined.ProcessDiskUsageReport
}


/**
 * Provides data about the disk usage of the process. 
 */
declare class ProcessDiskUsageReport {

    /**
     * Gets the number of bytes the process has read from disk. 
     */
    bytesReadCount: number;

    /**
     * Gets the number of bytes the process has written to disk. 
     */
    bytesWrittenCount: number;

    /**
     * Gets the number of bytes used by the process in disk operations that were not read or write operations. 
     */
    otherBytesCount: number;

    /**
     * Gets the number of disk operations performed by the process that were not read or write operations. 
     */
    otherOperationCount: number;

    /**
     * Gets the number of disk read operations performed by the process. 
     */
    readOperationCount: number;

    /**
     * Gets the number of disk write operations performed by the process. 
     */
    writeOperationCount: number
}


/**
 * Provides access to data about the memory usage of a process. 
 */
declare class ProcessMemoryUsage {

    /**
     * Gets the ProcessMemoryUsageReport for the process.
     * @return  The ProcessMemoryUsageReport for the process.
     */
    getReport(): undefined.ProcessMemoryUsageReport
}


/**
 * Provides data about the memory usage of the process. 
 */
declare class ProcessMemoryUsageReport {

    /**
     * Gets the amount of non-paged memory available to the process, in bytes. 
     */
    nonPagedPoolSizeInBytes: number;

    /**
     * Gets the number of memory page faults. 
     */
    pageFaultCount: number;

    /**
     * Gets the size of the memory page file in bytes. 
     */
    pageFileSizeInBytes: number;

    /**
     * Gets the amount of paged memory available to the process, in bytes. 
     */
    pagedPoolSizeInBytes: number;

    /**
     * Gets the maximum amount of non-paged memory used by the process, in bytes. 
     */
    peakNonPagedPoolSizeInBytes: number;

    /**
     * Gets the maximum size of the memory page file used by the process, in bytes. 
     */
    peakPageFileSizeInBytes: number;

    /**
     * Gets the maximum amount of paged memory used by the process, in bytes. 
     */
    peakPagedPoolSizeInBytes: number;

    /**
     * Gets the maximum amount of virtual memory used by the associated process. 
     */
    peakVirtualMemorySizeInBytes: number;

    /**
     * Gets the maximum amount of physical memory used by the associated process. 
     */
    peakWorkingSetSizeInBytes: number;

    /**
     * Gets the number of private memory pages allocated for the associated process. 
     */
    privatePageCount: number;

    /**
     * Gets the amount of the virtual memory allocated for the associated process. 
     */
    virtualMemorySizeInBytes: number;

    /**
     * Gets the amount of physical memory allocated for the associated process. 
     */
    workingSetSizeInBytes: number
}


/**
 * Represents a display request. 
 */
declare class DisplayRequest {

    /**
     * Creates an instance of the DisplayRequest class. 
     */
    constructor(): this;

    /**
     * Activates a display request. 
     */
    requestActive(): void;

    /**
     * Deactivates a display request. 
     */
    requestRelease(): void
}


/**
 * Specifies the options to use when launching File Explorer to display the contents of a specific folder by calling the LaunchFolderAsync(IStorageFolder, FolderLauncherOptions) method. 
 */
declare class FolderLauncherOptions {

    /**
     * Initializes a new instance of the FolderLauncherOptions class. 
     */
    constructor(): this;

    /**
     * Specifies how much space on the screen to leave for the calling app when launching File Explorer. The calling app can take up more or less space than File Explorer, or File Explorer can fill the entire screen. 
     */
    desiredRemainingView: undefined.ViewSizePreference;

    /**
     * Provides the list of items to select when File Explorer displays the contents of the specified folder. 
     */
    itemsToSelect: undefined.IVector<undefined.IStorageItem >
}


/**
 * Contains basic information about a user. 
 */
declare class KnownUserProperties {

    /**
     * Gets the user's account name. 
     */
    accountName: string;

    /**
     * Gets the user's display name. 
     */
    displayName: string;

    /**
     * Gets the user's domain name. 
     */
    domainName: string;

    /**
     * Gets the user's first name. 
     */
    firstName: string;

    /**
     * Gets the user's guest host. 
     */
    guestHost: string;

    /**
     * Gets the user's last name. 
     */
    lastName: string;

    /**
     * Gets the user's principal name. 
     */
    principalName: string;

    /**
     * Gets the user's provider name. 
     */
    providerName: string;

    /**
     * Gets the user's session initiation protocol Uri. 
     */
    sessionInitiationProtocolUri: string
}


/**
 * Represents the results of a Uri launch. 
 */
declare class LaunchUriResult {

    /**
     * Gets the result of the Uri launch. 
     */
    result: undefined.ValueSet;

    /**
     * Gets the status of the Uri launch. 
     */
    status: undefined.LaunchUriStatus
}


/**
 * Starts the default app associated with the specified file or URI. 
 */
declare class Launcher {

    /**
     * Enumerate the file handlers on the device.
     * @param extension The file extension that you want to find handlers for. For example, ".bat". Include the leading period '.'.
     * @return  A list of AppInfo s for each application that handles the specified file extension.
     */
    findFileHandlersAsync(
        extension: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<undefined.AppInfo >> ;

    /**
     * Enumerates the
     * @param scheme The scheme name that you find to find handlers for. For example, "ms-lens".
     * @return  A list of AppInfo s for each application that handles the specified scheme.
     */
    findUriSchemeHandlersAsync(
        scheme: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<undefined.AppInfo >> ;

    /**
     * Enumerate the scheme handlers on the device.
     * @param scheme The scheme name that you find to find handlers for. For example, "ms-lens".
     * @param launchQuerySupportType Filter the list of handlers by whether they can be launched for results or not.
     * @return  A list of AppInfo s for each application that handles the specified scheme.
     */
    findUriSchemeHandlersAsync(
        scheme: string,
        launchQuerySupportType: undefined.LaunchQuerySupportType): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<undefined.AppInfo >> ;

    /**
     * Starts the default app associated with the specified file.
     * @param file The file.
     * @return  The launch operation.
     */
    launchFileAsync(file: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Starts the default app associated with the specified file, using the specified options.
     * @param file The file.
     * @param options The launch options for the app.
     * @return  The launch operation.
     */
    launchFileAsync(
        file: undefined.IStorageFile,
        options: undefined.LauncherOptions): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Launches File Explorer with the specified options and displays the contents of the specified folder.
     * @param folder The folder to display in File Explorer.
     * @param options Options that specify the amount of screen space that File Explorer fills, and the list of items to select in the specified folder.
     * @return  The result of the operation.
     */
    launchFolderAsync(
        folder: undefined.IStorageFolder,
        options: undefined.FolderLauncherOptions): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Launches File Explorer and displays the contents of the specified folder.
     * @param folder The folder to display in File Explorer.
     * @return  The result of the operation.
     */
    launchFolderAsync(
        folder: undefined.IStorageFolder): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Starts the default app associated with the URI scheme name for the specified URI.
     * @param uri The URI.
     * @return  The launch operation.
     */
    launchUriAsync(uri: undefined.Uri): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Starts the default app associated with the URI scheme name or the one specified by the ContentType for the specified URI, using the specified options.
     * @param uri The URI.
     * @param options The launch options for the app.
     * @return  The launch operation.
     */
    launchUriAsync(
        uri: undefined.Uri,
        options: undefined.LauncherOptions): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Starts the default app associated with the URI scheme name for the specified URI, using the specified options and input data.
     * @param uri The URI.
     * @param options The launch options for the app.
     * @param inputData The input data for the app.
     * @return  The launch operation.
     */
    launchUriAsync(
        uri: undefined.Uri,
        options: undefined.LauncherOptions,
        inputData: undefined.ValueSet): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously starts the default app associated with the URI scheme name for the specified URI, using the specified options and input data.
     * @param uri The Uri to launch.
     * @param options The launch options.
     * @param inputData The data to send to the launched app.
     * @return  When this method completes, it returns the results of the launch.
     */
    launchUriForResultsAsync(
        uri: undefined.Uri,
        options: undefined.LauncherOptions,
        inputData: undefined.ValueSet): undefined.IPromiseWithIAsyncOperation<undefined.LaunchUriResult>;

    /**
     * Asynchronously starts the default app associated with the URI scheme name for the specified URI, using the specified options.
     * @param uri The Uri to launch.
     * @param options The launch options.
     * @return  When this method completes, it returns the results of the launch.
     */
    launchUriForResultsAsync(
        uri: undefined.Uri,
        options: undefined.LauncherOptions): undefined.IPromiseWithIAsyncOperation<undefined.LaunchUriResult>;

    /**
     * Asynchronously query whether an app can be activated for the specified file.
     * @param file The file for which to query support.
     * @return  A value that indicates whether an application can be activated for the file.
     */
    queryFileSupportAsync(
        file: undefined.StorageFile): undefined.IPromiseWithIAsyncOperation<undefined.LaunchQuerySupportStatus>;

    /**
     * Asynchronously query whether an app with the specified package name can be activated for the specified file.
     * @param file The file for which to query support.
     * @param packageFamilyName The package for which to query support.
     * @return  A value that indicates whether an application can be activated for the file.
     */
    queryFileSupportAsync(
        file: undefined.StorageFile,
        packageFamilyName: string): undefined.IPromiseWithIAsyncOperation<undefined.LaunchQuerySupportStatus>;

    /**
     * Asynchronously query whether an app can be activated for the specified URI, launch type, and package name.
     * @param uri The URI for which to query support.
     * @param launchQuerySupportType The type of launch for which to query support.
     * @param packageFamilyName Specifies a specific package that will be used to launch this URI.
     * @return  A value that indicates whether the application is available to launch the URI.
     */
    queryUriSupportAsync(
        uri: undefined.Uri,
        launchQuerySupportType: undefined.LaunchQuerySupportType,
        packageFamilyName: string): undefined.IPromiseWithIAsyncOperation<undefined.LaunchQuerySupportStatus>;

    /**
     * Asynchronously query whether an app can be activated for the specified URI and launch type.
     * @param uri The URI for which to query support.
     * @param launchQuerySupportType The type of launch for which to query support.
     * @return  A value that indicates whether an application is available to launch the URI.
     */
    queryUriSupportAsync(
        uri: undefined.Uri,
        launchQuerySupportType: undefined.LaunchQuerySupportType): undefined.IPromiseWithIAsyncOperation<undefined.LaunchQuerySupportStatus >
}


/**
 * Specifies the options used to launch the default app for a file or URI. 
 */
declare class LauncherOptions {

    /**
     * Creates and initializes a new instance of the launcher options object. 
     */
    constructor(): this;

    /**
     * Gets or sets the content type that is associated with a URI that represents a file on the network. 
     */
    contentType: string;

    /**
     * Launch a target app and have the currently running source app remain on the screen by sharing the space equally with the target app or by taking up more or less space than the target app. 
     */
    desiredRemainingView: undefined.ViewSizePreference;

    /**
     * Gets or sets a value that indicates whether to display the Open With dialog whenever the association launching API is called. 
     */
    displayApplicationPicker: boolean;

    /**
     * Gets or sets a value that represents a URI that the user should be taken to in the browser if no app exists to handle the file type or URI. 
     */
    fallbackUri: undefined.Uri;

    /**
     * Enables an app to access files that are related to the file used to activate the app. 
     */
    neighboringFilesQuery: undefined.StorageFileQueryResult;

    /**
     * Gets or sets a value that represents the display name of the app in the store that the user should install if no app exists to handle the file type or URI. 
     */
    preferredApplicationDisplayName: string;

    /**
     * Gets or sets a value that represents the package family name of the app in the Store that the user should install if no app exists to handle the file type or URI. 
     */
    preferredApplicationPackageFamilyName: string;

    /**
     * The package family name of the target package that should be used to launch a file or URI. This property is optional. 
     */
    targetApplicationPackageFamilyName: string;

    /**
     * Gets or sets a value that indicates whether the system should display a warning that the file or URI is potentially unsafe when starting the app associated with a file or URI. 
     */
    treatAsUntrusted: boolean;

    /**
     * Gets the user interface (UI) options when starting a default app. 
     */
    ui: undefined.LauncherUIOptions
}


/**
 * Specifies options for user interface elements such as the application picker that can be invoked by this API. 
 */
declare class LauncherUIOptions {

    /**
     * Gets or sets the point on the screen where the user opened a file or URI. 
     */
    invocationPoint: undefined.Point;

    /**
     * Gets or sets the preferred placement of the Open With and Warning dialog boxes when starting a default app. 
     */
    preferredPlacement: undefined.Placement;

    /**
     * Gets or sets the selection rectangle on the screen where the user opened a file or URI. 
     */
    selectionRect: undefined.Rect
}


/**
 * Provides access to information on an app's memory usage. 
 */
declare class MemoryManager {

    /**
     * Gets the app's current memory usage. 
     */
    appMemoryUsage: number;

    /**
     * Gets the app's memory usage level. 
     */
    appMemoryUsageLevel: undefined.AppMemoryUsageLevel;

    /**
     * Gets the app's memory usage limit. 
     */
    appMemoryUsageLimit: number;

    /**
     * Gets an AppMemoryReport for the app, which provides information about its memory usage.
     * @return  Information about the process' memory usage.
     */
    getAppMemoryReport(): undefined.AppMemoryReport;

    /**
     * Gets a ProcessMemoryReport for a process, which provides information about its memory usage.
     * @return  Information about the process' memory usage.
     */
    getProcessMemoryReport(): undefined.ProcessMemoryReport;

    /**
     * Raised when the app's memory consumption has decreased to a lower value in the AppMemoryUsageLevel enumeration. 
     */
    onappmemoryusagedecreased: undefined.EventHandler<any>;
    addEventListener(type: "appmemoryusagedecreased", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "appmemoryusagedecreased", listener: undefined.EventHandler<any>): void;

    /**
     * Raised when the app's memory consumption has increased to a higher value in the AppMemoryUsageLevel enumeration. 
     */
    onappmemoryusageincreased: undefined.EventHandler<any>;
    addEventListener(type: "appmemoryusageincreased", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "appmemoryusageincreased", listener: undefined.EventHandler<any>): void;

    /**
     * Raised just before the limit of how much total memory the app can use is changed. 
     */
    onappmemoryusagelimitchanging: undefined.EventHandler<any>;
    addEventListener(
        type: "appmemoryusagelimitchanging",
        listener: undefined.EventHandler<any>): void;
    removeEventListener(
        type: "appmemoryusagelimitchanging",
        listener: undefined.EventHandler<any>): void;
    trySetAppMemoryUsageLimit: any;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides information about your app's background energy usage. 
 */
declare class BackgroundEnergyManager {

    /**
     * Gets the excessive usage level, expressed as a percentage of normal energy usage. 
     */
    excessiveUsageLevel: number;

    /**
     * Gets the low usage level, expressed as a percentage of normal energy consumption. 
     */
    lowUsageLevel: number;

    /**
     * Gets the maximum acceptable usage level, expressed as a percentage of normal energy consumption. 
     */
    maxAcceptableUsageLevel: number;

    /**
     * Gets the near-maximum acceptable usage level, expressed as a percentage of normal energy usage. 
     */
    nearMaxAcceptableUsageLevel: number;

    /**
     * Gets the near-termination usage level, expressed as a percentage of normal energy usage. 
     */
    nearTerminationUsageLevel: number;

    /**
     * Occurs when the background task's energy usage has increased significantly. 
     */
    onrecentenergyusageincreased: undefined.EventHandler<any>;
    addEventListener(
        type: "recentenergyusageincreased",
        listener: undefined.EventHandler<any>): void;
    removeEventListener(
        type: "recentenergyusageincreased",
        listener: undefined.EventHandler<any>): void;

    /**
     * Occurs when the background task's energy usage has decreased to a low usage level. 
     */
    onrecentenergyusagereturnedtolow: undefined.EventHandler<any>;
    addEventListener(
        type: "recentenergyusagereturnedtolow",
        listener: undefined.EventHandler<any>): void;
    removeEventListener(
        type: "recentenergyusagereturnedtolow",
        listener: undefined.EventHandler<any>): void;

    /**
     * Gets the energy usage of the app's background task for the current 30 minute period, expressed as a percentage of normal. 
     */
    recentEnergyUsage: number;

    /**
     * Gets the nearest predefined energy level of the app's background task for the current 30 minute period, equal to LowUsageLevel , NearMaxAcceptableUsageLevel , MaxAcceptableUsageLevel , ExcessiveUsageLevel , NearTerminationUsageLevel , or TerminationUsageLevel . 
     */
    recentEnergyUsageLevel: number;

    /**
     * Gets the termination usage level, expressed as a percentage of normal energy usage. 
     */
    terminationUsageLevel: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides debugging APIs for calculating your app's background energy usage in real time. We recommend using these APIs only for debugging. 
 */
declare class BackgroundEnergyDiagnostics {

    /**
     * Computes the total cumulative energy usage of the background task since the last reset, expressed as a percentage of normal.
     * @return  The total cumulative energy usage of the background task since the last reset, expressed as a percentage of normal.
     */
    computeTotalEnergyUsage(): number;

    /**
     * Gets the device-specific conversion factor used to convert energy usage (mW) to a normalized percentage. 
     */
    deviceSpecificConversionFactor: number;

    /**
     * Clears the value that represents the total cumulative energy usage of the background task since the last reset. 
     */
    resetTotalEnergyUsage(): void
}


/**
 * Provides debugging APIs for calculating your app's foreground energy usage in real time. We recommend using these APIs only for debugging. 
 */
declare class ForegroundEnergyDiagnostics {

    /**
     * Computes the total cumulative energy usage of the foreground app since the last reset, expressed as a percentage of normal.
     * @return  The total cumulative energy usage of the foreground app since the last reset, expressed as a percentage of normal.
     */
    computeTotalEnergyUsage(): number;

    /**
     * Gets the device-specific conversion factor used to convert energy usage (mW) to a normalized percentage. 
     */
    deviceSpecificConversionFactor: number;

    /**
     * Clears the value that represents the total cumulative energy usage of the foreground app since the last reset. 
     */
    resetTotalEnergyUsage(): void
}


/**
 * Provides information about your app's foreground energy usage. 
 */
declare class ForegroundEnergyManager {

    /**
     * Gets the excessive usage level, expressed as a percentage of normal energy usage. 
     */
    excessiveUsageLevel: number;

    /**
     * Gets the low usage level, expressed as a percentage of normal energy consumption. 
     */
    lowUsageLevel: number;

    /**
     * Gets the maximum acceptable usage level, expressed as a percentage of normal energy consumption. 
     */
    maxAcceptableUsageLevel: number;

    /**
     * Gets the near-maximum acceptable usage level, expressed as a percentage of normal energy usage. 
     */
    nearMaxAcceptableUsageLevel: number;

    /**
     * Occurs when the app's foreground energy usage has increased significantly. 
     */
    onrecentenergyusageincreased: undefined.EventHandler<any>;
    addEventListener(
        type: "recentenergyusageincreased",
        listener: undefined.EventHandler<any>): void;
    removeEventListener(
        type: "recentenergyusageincreased",
        listener: undefined.EventHandler<any>): void;

    /**
     * Occurs when the app's energy usage has decreased to a low usage level. 
     */
    onrecentenergyusagereturnedtolow: undefined.EventHandler<any>;
    addEventListener(
        type: "recentenergyusagereturnedtolow",
        listener: undefined.EventHandler<any>): void;
    removeEventListener(
        type: "recentenergyusagereturnedtolow",
        listener: undefined.EventHandler<any>): void;

    /**
     * Gets the nearest predefined energy level of the foreground app for the current 30 minute period, equal to LowUsageLevel , NearMaxAcceptableUsageLevel , MaxAcceptableUsageLevel , or ExcessiveUsageLevel . 
     */
    recentEnergyUsage: number;

    /**
     * Gets the nearest predefined energy level of the foreground app for the current 30 minute period, equal to LowUsageLevel , NearMaxAcceptableUsageLevel , MaxAcceptableUsageLevel , or ExcessiveUsageLevel . 
     */
    recentEnergyUsageLevel: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides access to information about a device's battery and power supply status. 
 */
declare class PowerManager {

    /**
     * Gets the device's battery status. 
     */
    batteryStatus: undefined.BatteryStatus;

    /**
     * Gets battery saver status, indicating when to save energy. 
     */
    energySaverStatus: undefined.EnergySaverStatus;

    /**
     * Occurs when BatteryStatus changes. 
     */
    onbatterystatuschanged: undefined.EventHandler<any>;
    addEventListener(type: "batterystatuschanged", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "batterystatuschanged", listener: undefined.EventHandler<any>): void;

    /**
     * Occurs when EnergySaverStatus changes. 
     */
    onenergysaverstatuschanged: undefined.EventHandler<any>;
    addEventListener(type: "energysaverstatuschanged", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "energysaverstatuschanged", listener: undefined.EventHandler<any>): void;

    /**
     * Occurs when the PowerSupplyStatus changes. 
     */
    onpowersupplystatuschanged: undefined.EventHandler<any>;
    addEventListener(type: "powersupplystatuschanged", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "powersupplystatuschanged", listener: undefined.EventHandler<any>): void;

    /**
     * Occurs when RemainingChargePercent changes. 
     */
    onremainingchargepercentchanged: undefined.EventHandler<any>;
    addEventListener(
        type: "remainingchargepercentchanged",
        listener: undefined.EventHandler<any>): void;
    removeEventListener(
        type: "remainingchargepercentchanged",
        listener: undefined.EventHandler<any>): void;

    /**
     * Occurs when RemainingDischargeTime changes. 
     */
    onremainingdischargetimechanged: undefined.EventHandler<any>;
    addEventListener(
        type: "remainingdischargetimechanged",
        listener: undefined.EventHandler<any>): void;
    removeEventListener(
        type: "remainingdischargetimechanged",
        listener: undefined.EventHandler<any>): void;

    /**
     * Gets the device's power supply status. 
     */
    powerSupplyStatus: undefined.PowerSupplyStatus;

    /**
     * Gets the total percentage of charge remaining from all batteries connected to the device. 
     */
    remainingChargePercent: number;

    /**
     * Gets the total runtime remaining from all batteries connected to the device. 
     */
    remainingDischargeTime: number;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}

declare class ProcessLauncher {
    runToCompletionAsync: any
}

declare class ProcessLauncherOptions {
    standardError: any;
    standardInput: any;
    standardOutput: any;
    workingDirectory: any
}

declare class ProcessLauncherResult {
    exitCode: any
}


/**
 * Represents process memory usage at a single point in time. 
 */
declare class ProcessMemoryReport {

    /**
     * Gets the process' private working set usage. 
     */
    privateWorkingSetUsage: number;

    /**
     * Gets the process' total working set usage. 
     */
    totalWorkingSetUsage: number
}


/**
 * Provides information about the device for profiling purposes. 
 */
declare class AnalyticsInfo {

    /**
     * Gets the device form. 
     */
    deviceForm: string;

    /**
     * Gets version info about the device family. 
     */
    versionInfo: undefined.AnalyticsVersionInfo
}


/**
 * Provides version information about the device family. 
 */
declare class AnalyticsVersionInfo {

    /**
     * Gets the device family. 
     */
    deviceFamily: string;

    /**
     * Gets the version within the device family. 
     */
    deviceFamilyVersion: string
}


/**
 * Provides the ability to obtain a hardware identifier that represents the current hardware. 
 */
declare class HardwareIdentification {

    /**
     * Gets a hardware identifier ( ASHWID) that represents the current hardware. The returned ASHWID will be different for each application package. In other words, this API will return different identifiers when called by two apps from different packages. It will return the same identifier when called by two apps that are part of the same package.
     * @param nonce The cryptographic nonce is optional. The nonce is recommended when ASHWID needs to be verified on the cloud against replay attacks. In the scenarios where nonce is desired, the remote server should generate a random nonce and pass it to the client app, and then verify that the signature has the expected nonce once the ASHWID is received from the client system.
     * @return  The hardware Id information.
     */
    getPackageSpecificToken(nonce: undefined.IBuffer): undefined.HardwareToken
}


/**
 * Represents a token that contains a hardware based identification that is sufficiently unique. 
 */
declare class HardwareToken {

    /**
     * Gets the certificate that is used to sign the Id and is used to help verify the authenticity of the Id. 
     */
    certificate: undefined.IBuffer;

    /**
     * Gets the hardware identifier that identifies the device. 
     */
    id: undefined.IBuffer;

    /**
     * Gets the digital signature of hardware Id that helps verify the authenticity of returned Id. 
     */
    signature: undefined.IBuffer
}


/**
 * Identifies the string keys that might exist within the RetailInfo.Properties map of retail-demo relevant property values. 
 */
declare class KnownRetailInfoProperties {

    /**
     * Gets the string that identifies the KnownRetailInfoProperties retail demo property. 
     */
    batteryLifeDescription: string;

    /**
     * Gets the string that identifies the DisplayDescription retail demo property. 
     */
    displayDescription: string;

    /**
     * Gets the string that identifies the DisplayModelName retail demo property. 
     */
    displayModelName: string;

    /**
     * Gets the string that identifies the FormFactor retail demo property. 
     */
    formFactor: string;

    /**
     * Gets the string that identifies the FrontCameraDescription retail demo property. 
     */
    frontCameraDescription: string;

    /**
     * Gets the string that identifies the GraphicsDescription retail demo property. 
     */
    graphicsDescription: string;

    /**
     * Gets the string that identifies the HasNfc retail demo property. 
     */
    hasNfc: string;

    /**
     * Gets the string that identifies the HasOpticalDrive retail demo property. 
     */
    hasOpticalDrive: string;

    /**
     * Gets the string that identifies the HasSdSlot retail demo property. 
     */
    hasSdSlot: string;

    /**
     * Gets the string that identifies the IsFeatured retail demo property. 
     */
    isFeatured: string;

    /**
     * Gets the string that identifies the IsOfficeInstalled retail demo property. 
     */
    isOfficeInstalled: string;

    /**
     * Gets the string that identifies the ManufacturerName retail demo property. 
     */
    manufacturerName: string;

    /**
     * Gets the string that identifies the Memory retail demo property. 
     */
    memory: string;

    /**
     * Gets the string that identifies the ModelName retail demo property. 
     */
    modelName: string;

    /**
     * Gets the string that identifies the Price retail demo property. 
     */
    price: string;

    /**
     * Gets the string that identifies the ProcessorDescription retail demo property. 
     */
    processorDescription: string;

    /**
     * Gets the string that identifies the RearCameraDescription retail demo property. 
     */
    rearCameraDescription: string;

    /**
     * Gets the string that identifies the RetailAccessCode retail demo property. 
     */
    retailAccessCode: string;

    /**
     * Gets the string that identifies the ScreenSize retail demo property. 
     */
    screenSize: string;

    /**
     * Gets the string that identifies the StorageDescription retail demo property. 
     */
    storageDescription: string;

    /**
     * Gets the string that identifies the Weight retail demo property. 
     */
    weight: string;

    /**
     * Gets the string that identifies the WindowsEdition retail demo property. 
     */
    windowsEdition: string
}

declare
var security: any;

declare
var basic: any;

declare
var enhanced: any;

declare
var full: any;

declare class PlatformDiagnosticsAndUsageDataSettings {
    addEventListener: any;
    canCollectDiagnostics: any;
    collectionLevel: any;
    oncollectionlevelchanged: any;
    removeEventListener: any
}


/**
 * A utility class that supports one method, IsDemoModeEnabled , and one property, Properties . Call IsDemoModeEnabled to determine whether the device where the app is running has specifically enabled its retail demo mode. 
 */
declare class RetailInfo {

    /**
     * Determines whether the device where the app is running has specifically enabled its retail demo mode. 
     */
    isDemoModeEnabled: boolean;

    /**
     * Gets an object that represents the set of available retail demo properties and their values. 
     */
    properties: undefined.IMapView<string, any >
}


/**
 * Enables access to properties from the SMBIOS for the system. 
 */
declare class SmbiosInformation {

    /**
     * Gets the serial number from the SMBIOS for the system. 
     */
    serialNumber: string
}


/**
 * Represents the result to the application that launched the current application for results. 
 */
declare class ProtocolForResultsOperation {

    /**
     * Indicates that the application activated for results is ready to return to the application that launched it for results.
     * @param data The data to return to the application that activated this app.
     */
    reportCompleted(data: undefined.ValueSet): void
}


/**
 * Provides Remote Desktop information about the current session. 
 */
declare class InteractiveSession {

    /**
     * Indicates whether the calling process is running in a Remote Desktop session. 
     */
    isRemote: boolean
}

declare
var shutdown: any;

declare
var restart: any;

declare class ShutdownManager {
    beginShutdown: any;
    cancelShutdown: any
}



declare class TimeZoneSettings {
    canChangeTimeZone: any;
    changeTimeZoneByDisplayName: any;
    currentTimeZoneDisplayName: any;
    supportedTimeZoneDisplayNames: any
}


/**
 * Represents a user. 
 */
declare class User {

    /**
     * Creates a UserWatcher which enumerates users and raises events when the collection of users changes or when a user’s authentication state changes.
     * @return  A UserWatcher which enumerates users and raises events when the collection of users changes.
     */
    createWatcher(): undefined.UserWatcher;

    /**
     * Finds all users of a given type and authentication status asynchronously.
     * @param type The type of users to find.
     * @param status The authentication status of users to find.
     * @return  When this method completes successfully, it returns a list (type IVectorView ) of Users .
     */
    findAllAsync(
        type: undefined.UserType,
        status: undefined.UserAuthenticationStatus): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Finds all users asynchronously.
     * @return  When this method completes successfully, it returns a list (type IVectorView ) of Users .
     */
    findAllAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Finds all users of a given type asynchronously.
     * @param type The type of users to find.
     * @return  When this method completes successfully, it returns a list (type IVectorView ) of Users .
     */
    findAllAsync(
        type: undefined.UserType): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Gets a user with a given Id.
     * @param nonRoamableId The Id of the user to get.
     * @return  The user with the given Id.
     */
    getFromId(nonRoamableId: string): undefined.User;

    /**
     * Gets the authentication status of the user. 
     */
    authenticationStatus: undefined.UserAuthenticationStatus;

    /**
     * Gets a user's picture asynchronously.
     * @param desiredSize The desired size of the user's picture to return.
     * @return  When this method completes, it returns the user's picture.
     */
    getPictureAsync(
        desiredSize: undefined.UserPictureSize): undefined.IPromiseWithIAsyncOperation<undefined.IRandomAccessStreamReference>;

    /**
     * Gets properties for the user.
     * @param values The properties to get. Use the KnownUserProperties class to obtain property names.
     * @return  When this method completes, it returns the requested properties. If a property is missing or unavailable, it is reported as an empty string.
     */
    getPropertiesAsync(
        values: undefined.IVectorView<string>): undefined.IPromiseWithIAsyncOperation<undefined.IPropertySet>;

    /**
     * Gets a property for the user. Use the KnownUserProperties class to obtain property names.
     * @param value The property to get.
     * @return  When this method completes, it returns the requested property. If the property is missing or unavailable, an empty string is returned.
     */
    getPropertyAsync(value: string): undefined.IPromiseWithIAsyncOperation<any>;

    /**
     * Gets the user's non-roamable id. 
     */
    nonRoamableId: string;

    /**
     * Gets the user type. 
     */
    type: undefined.UserType
}


/**
 * Represents a user authentication status change deferral returned by the UserAuthenticationStatusChangingEventArgs.GetDeferral method. 
 */
declare class UserAuthenticationStatusChangeDeferral {

    /**
     * Reports that the application has completed its user authentication status change deferral. 
     */
    complete(): void
}


/**
 * Provides data for a user authentication status changing event. 
 */
declare class UserAuthenticationStatusChangingEventArgs {

    /**
     * Gets the user's current authentication status. 
     */
    currentStatus: undefined.UserAuthenticationStatus;

    /**
     * Requests a delay before the user's authentication status changes.
     * @return  The user authentication status change deferral.
     */
    getDeferral(): undefined.UserAuthenticationStatusChangeDeferral;

    /**
     * Gets the user's new authentication status. 
     */
    newStatus: undefined.UserAuthenticationStatus;

    /**
     * Gets the user. 
     */
    user: undefined.User
}


/**
 * Provides data for a user changed event. 
 */
declare class UserChangedEventArgs {

    /**
     * Gets the user. 
     */
    user: undefined.User
}


/**
 * Provides a property that lets the caller retrieve the advertising ID, which is an ID used to provide more relevant advertising by understanding which apps are used by the user and how they are used, and to improve quality of service by determining the frequency and effectiveness of ads and to detect fraud and security issues. 
 */
declare class AdvertisingManager {

    /**
     * Retrieves a unique ID used to provide more relevant advertising by understanding which apps are used by the user and how they are used, and to improve quality of service by determining the frequency and effectiveness of ads and to detect fraud and security issues. This ID is per-user, per-device; all of the apps for a single user on a device have the same advertising ID. If the advertising ID feature is turned off, no ID is retrieved. 
     */
    advertisingId: string
}


/**
 * Represents a collection of settings that a user can opt-in to during the first run experience. 
 */
declare class FirstSignInSettings {

    /**
     * Gets the default instance of the settings.
     * @return  The default instance of the settings.
     */
    getDefault(): undefined.FirstSignInSettings;

    /**
     * Returns an iterator for the items in the collection.
     * @return  The iterator.
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Determines whether the map view contains the specified key.
     * @param key The key to locate in the map view.
     * @return  true if the key is found; otherwise, false.
     */
    hasKey(key: string): boolean;

    /**
     * Returns the item in the map view with the specified key.
     * @param key The key to locate in the map view.
     * @return  The item associated with the specified key.
     */
    lookup(key: string): any;

    /**
     * Returns the number of elements in the map. 
     */
    size: number;

    /**
     * Splits the map view into two views.
     */
    split(): {
        first: undefined.IMapView<string,
        any>,
        second: undefined.IMapView<string,
        any >
    }
}


/**
 * A static class for holding various user globalization preferences. 
 */
declare class GlobalizationPreferences {

    /**
     * Gets the set of calendars that are preferred by the user, in order of preference. 
     */
    calendars: undefined.IVectorView<string>;

    /**
     * Gets the set of clocks that are preferred by the user, in order of preference. 
     */
    clocks: undefined.IVectorView<string>;

    /**
     * Gets the set of currencies that are preferred by the user, in order of preference. 
     */
    currencies: undefined.IVectorView<string>;

    /**
     * Gets the user's home geographic region. 
     */
    homeGeographicRegion: string;

    /**
     * Gets the set of languages that are preferred by the user, in order of preference. 
     */
    languages: undefined.IVectorView<string>;

    /**
     * Gets the day of the week that is considered to be the first day of the week. 
     */
    weekStartsOn: undefined.DayOfWeek
}


/**
 * Provides properties and methods to manage the full-screen image used as the lock screen background. 
 */
declare class LockScreen {

    /**
     * Gets the current lock screen image as a data stream.
     * @return  The stream that contains the lock screen image data.
     */
    getImageStream(): undefined.IRandomAccessStream;

    /**
     * Gets the current lock screen image. 
     */
    originalImageFile: undefined.Uri;

    /**
     * Registers an RSS image feed to be used as a lock screen slideshow. (Windows 8.1 only)
     * @param syndicationFeedUri The URI of the RSS image feed.
     * @return  One of the SetImageFeedResult values.
     */
    requestSetImageFeedAsync(
        syndicationFeedUri: undefined.Uri): undefined.IPromiseWithIAsyncOperation<undefined.SetImageFeedResult>;

    /**
     * Sets the lock screen image from a StorageFile object.
     * @param value The StorageFile object that contains the new image for the lock screen.
     * @return  The object used to set the image for the lock screen.
     */
    setImageFileAsync(value: undefined.IStorageFile): undefined.IPromiseWithIAsyncAction;

    /**
     * Sets the lock screen image from a data stream.
     * @param value The stream that contains the image data.
     * @return  The object used to set the lock screen image.
     */
    setImageStreamAsync(value: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncAction;

    /**
     * Unregisters the image feed being used in the lock screen slideshow, stopping the slideshow. (Windows 8.1 only)
     * @return  true if the image feed was disabled; otherwise, false.
     */
    tryRemoveImageFeed(): boolean
}


/**
 * Represents information about the user, such as name and account picture. 
 */
declare class UserInformation {

    /**
     * Determines if the user's account picture can be changed. 
     */
    accountPictureChangeEnabled: boolean;

    /**
     * Gets the account picture for the user.
     * @param kind An enumeration that you can use to determine what type of image you want (small, large, and so on).
     * @return  An object that contains the image.
     */
    getAccountPicture(kind: undefined.AccountPictureKind): undefined.IStorageFile;

    /**
     * Gets the display name for the user account.
     * @return  The display name for the user account.
     */
    getDisplayNameAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Gets the domain name for the user.
     * @return  A string that represents the domain name for the user.
     */
    getDomainNameAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Gets the user's first name.
     * @return  The user's first name.
     */
    getFirstNameAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Gets the user's last name.
     * @return  The user's last name.
     */
    getLastNameAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Gets the principal name for the user. This name is the User Principal Name (typically the user's address, although this is not always true.)
     * @return  The user's principal name.
     */
    getPrincipalNameAsync(): undefined.IPromiseWithIAsyncOperation<string>;

    /**
     * Gets the Uniform Resource Identifier (URI) of the session initiation protocol for the user.
     * @return  The URI of the session initiation protocol.
     */
    getSessionInitiationProtocolUriAsync(): undefined.IPromiseWithIAsyncOperation<undefined.Uri>;

    /**
     * Allows you to see if your app is allowed to access the user's information. 
     */
    nameAccessAllowed: boolean;

    /**
     * Occurs when the user's image or name changes. 
     */
    onaccountpicturechanged: undefined.EventHandler<any>;
    addEventListener(type: "accountpicturechanged", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "accountpicturechanged", listener: undefined.EventHandler<any>): void;

    /**
     * Sets the picture for the user's account using an IStorageFile object.
     * @param image A file that contains the image.
     * @return  A value that indicates the success or failure of the operation.
     */
    setAccountPictureAsync(
        image: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.SetAccountPictureResult>;

    /**
     * Sets the picture for the user's account using an IRandomAccessStream object.
     * @param image The image.
     * @return  A value that indicates the success or failure of the operation.
     */
    setAccountPictureFromStreamAsync(
        image: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncOperation<undefined.SetAccountPictureResult>;

    /**
     * Sets the pictures for the user's account using an IStorageFile object. Supports adding a small image, large image, and video.
     * @param smallImage A small version of the image.
     * @param largeImage A large version of the image.
     * @param video A video.
     * @return  A value that indicates the success or failure of the operation.
     */
    setAccountPicturesAsync(
        smallImage: undefined.IStorageFile,
        largeImage: undefined.IStorageFile,
        video: undefined.IStorageFile): undefined.IPromiseWithIAsyncOperation<undefined.SetAccountPictureResult>;

    /**
     * Sets the pictures for the user's account using an IRandomAccessStream object. Supports adding a small image, large image, and video.
     * @param smallImage A small version of the image.
     * @param largeImage A large version of the image.
     * @param video A video.
     * @return  A value that indicates the success or failure of the operation.
     */
    setAccountPicturesFromStreamsAsync(
        smallImage: undefined.IRandomAccessStream,
        largeImage: undefined.IRandomAccessStream,
        video: undefined.IRandomAccessStream): undefined.IPromiseWithIAsyncOperation<undefined.SetAccountPictureResult>;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides properties and methods to manage the user's desktop wallpaper and lock screen background image. 
 */
declare class UserProfilePersonalizationSettings {

    /**
     * Gets the current instance of UserProfilePersonalizationSettings . 
     */
    current: undefined.UserProfilePersonalizationSettings;

    /**
     * Gets a value that indicates whether changing the desktop and lock screen images is supported on the current device.
     * @return  true if changing the desktop and lock screen images is supported; otherwise, false.
     */
    isSupported(): boolean;

    /**
     * Attempts to set the specified image file as the lock screen background image.
     * @param imageFile The image to set as the lock screen background.
     * @return  The result of the async operation. true if the background image was set successfully; otherwise, false.
     */
    trySetLockScreenImageAsync(
        imageFile: undefined.StorageFile): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Attempts to set the specified image file as the desktop wallpaper image.
     * @param imageFile The image to set as the desktop background.
     * @return  The result of the async operation. true if the background image was set successfully; otherwise, false.
     */
    trySetWallpaperImageAsync(
        imageFile: undefined.StorageFile): undefined.IPromiseWithIAsyncOperation<boolean >
}


/**
 * Provides events that fire during enumeration of users, when the collection of users changes, or when a user's authentication status changes. 
 */
declare class UserWatcher {

    /**
     * Fires when a user is added to the collection of users returned by User.FindAllAsync . 
     */
    onadded: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>;
    addEventListener(
        type: "added",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>): void;
    removeEventListener(
        type: "added",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>): void;

    /**
     * Fires when a user's authentication status has changed. 
     */
    onauthenticationstatuschanged: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>;
    addEventListener(
        type: "authenticationstatuschanged",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>): void;
    removeEventListener(
        type: "authenticationstatuschanged",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>): void;

    /**
     * Fires when a user's authentication status is about to change. 
     */
    onauthenticationstatuschanging: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserAuthenticationStatusChangingEventArgs>;
    addEventListener(
        type: "authenticationstatuschanging",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserAuthenticationStatusChangingEventArgs>): void;
    removeEventListener(
        type: "authenticationstatuschanging",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserAuthenticationStatusChangingEventArgs>): void;

    /**
     * Fires when the initial pass of watcher events has been processed and the collection of users is complete. 
     */
    onenumerationcompleted: undefined.TypedEventHandler<undefined.UserWatcher, any>;
    addEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, any>): void;
    removeEventListener(
        type: "enumerationcompleted",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, any>): void;

    /**
     * Fires when a user is removed from the collection of users returned by User.FindAllAsync . 
     */
    onremoved: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>;
    addEventListener(
        type: "removed",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>): void;
    removeEventListener(
        type: "removed",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>): void;

    /**
     * Fires when the user watcher has stopped. 
     */
    onstopped: undefined.TypedEventHandler<undefined.UserWatcher, any>;
    addEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, any>): void;
    removeEventListener(
        type: "stopped",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, any>): void;

    /**
     * Fires when the data associated with a user has changed. 
     */
    onupdated: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>;
    addEventListener(
        type: "updated",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>): void;
    removeEventListener(
        type: "updated",
        listener: undefined.TypedEventHandler<undefined.UserWatcher, undefined.UserChangedEventArgs>): void;

    /**
     * Starts the user watcher. 
     */
    start(): void;

    /**
     * Gets the status of a user watcher. 
     */
    status: undefined.UserWatcherStatus;

    /**
     * Stops the user watcher. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides methods to show the accounts pane and also to enable the app to register callbacks when the accounts flyout is about to be displayed. 
 */
declare class AccountsSettingsPane {

    /**
     * Gets an AccountsSettingsPane object that is associated with the current app view (that is, with CoreWindow ).
     * @return  The account settings pane.
     */
    getForCurrentView(): undefined.AccountsSettingsPane;

    /**
     * Displays the account settings pane. 
     */
    show(): void;

    /**
     * Occurs when the user opens the accounts pane. Handling this event lets the app initialize the accounts commands and pause its UI until the user closes the pane. 
     */
    onaccountcommandsrequested: undefined.TypedEventHandler<undefined.AccountsSettingsPane, undefined.AccountsSettingsPaneCommandsRequestedEventArgs>;
    addEventListener(
        type: "accountcommandsrequested",
        listener: undefined.TypedEventHandler<undefined.AccountsSettingsPane, undefined.AccountsSettingsPaneCommandsRequestedEventArgs>): void;
    removeEventListener(
        type: "accountcommandsrequested",
        listener: undefined.TypedEventHandler<undefined.AccountsSettingsPane, undefined.AccountsSettingsPaneCommandsRequestedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the AccountCommandsRequested event. 
 */
declare class AccountsSettingsPaneCommandsRequestedEventArgs {

    /**
     * Gets the SettingsCommand collection for the account settings pane. 
     */
    commands: undefined.IVector<undefined.SettingsCommand>;

    /**
     * Gets the CredentialCommand collection for the account settings pane. 
     */
    credentialCommands: undefined.IVector<undefined.CredentialCommand>;

    /**
     * Gets the deferral object for the AccountCommandsRequested event.
     * @return  The deferral object.
     */
    getDeferral(): undefined.AccountsSettingsPaneEventDeferral;

    /**
     * Gets or sets the header text for the account settings pane. 
     */
    headerText: string;

    /**
     * Gets the WebAccountCommand collection for the account settings pane. 
     */
    webAccountCommands: undefined.IVector<undefined.WebAccountCommand>;

    /**
     * Gets the WebAccountProviderCommand collection for the account settings pane. 
     */
    webAccountProviderCommands: undefined.IVector<undefined.WebAccountProviderCommand >
}


/**
 * Enables the app to signal when it has finished populating command collections while handling the AccountCommandsRequested event. 
 */
declare class AccountsSettingsPaneEventDeferral {

    /**
     * Signals that the app has finished populating command collections while handling the AccountCommandsRequested event. 
     */
    complete(): void
}


/**
 * Deprecated. Represents a command for changing web account credentials in the account settings pane. 
 */
declare class CredentialCommand {

    /**
     * Initializes a new instance of the CredentialCommand class with a PasswordCredential object.
     * @param passwordCredential The password credential.
     */
    constructor(passwordCredential: undefined.PasswordCredential): this;

    /**
     * Initializes a new instance of the CredentialCommand class with a PasswordCredential object and a CredentialCommandCredentialDeletedHandler delegate.
     * @param passwordCredential The password credential.
     * @param deleted The delegate that handles credential deletion.
     */
    constructor(passwordCredential: undefined.PasswordCredential, deleted: undefined.CredentialCommandCredentialDeletedHandler): this;

    /**
     * Gets the delegate that's invoked by the account settings pane when the user deletes a credential. 
     */
    credentialDeleted: undefined.CredentialCommandCredentialDeletedHandler;

    /**
     * Gets the password credential that the current command applies to. 
     */
    passwordCredential: undefined.PasswordCredential
}


/**
 * Creates a settings command object that represents a settings entry. This settings command can be appended to the ApplicationCommands vector. 
 */
declare class SettingsCommand {

    /**
     * Gets the command for a web account in the account settings pane. 
     */
    accountsCommand: undefined.SettingsCommand;

    /**
     * Creates a new settings command.
     * @param settingsCommandId The ID of the command.
     * @param label The label for the command, which is displayed in the settings pane.
     * @param handler The event handler that is called when the user selects this command in the settings pane.
     */
    constructor(settingsCommandId: any, label: string, handler: undefined.UICommandInvokedHandler): this;

    /**
     * Gets or sets the command ID. 
     */
    id: any;

    /**
     * Gets or sets the handler for the event that is raised when the user selects the command. 
     */
    invoked: undefined.UICommandInvokedHandler;

    /**
     * Gets or sets the label for the command. 
     */
    label: string
}


/**
 * A static class that enables the app to control the Settings Charm pane. The app can add or remove commands, receive a notification when the user opens the pane, or open the pane programmatically. 
 */
declare class SettingsPane {

    /**
     * Gets a value indicating whether the Settings charm appears on the left or right edge of the screen. 
     */
    edge: undefined.SettingsEdgeLocation;

    /**
     * Gets a SettingsPane object that is associated with the current app view (that is, with CoreWindow ).
     * @return  The settings pane.
     */
    getForCurrentView(): undefined.SettingsPane;

    /**
     * Displays the Settings Charm pane to the user. 
     */
    show(): void;

    /**
     * Occurs when the user opens the settings pane. Listening for this event lets the app initialize the setting commands and pause its UI until the user closes the pane. 
     */
    oncommandsrequested: undefined.TypedEventHandler<undefined.SettingsPane, undefined.SettingsPaneCommandsRequestedEventArgs>;
    addEventListener(
        type: "commandsrequested",
        listener: undefined.TypedEventHandler<undefined.SettingsPane, undefined.SettingsPaneCommandsRequestedEventArgs>): void;
    removeEventListener(
        type: "commandsrequested",
        listener: undefined.TypedEventHandler<undefined.SettingsPane, undefined.SettingsPaneCommandsRequestedEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains properties that are only available during the CommandsRequested event. 
 */
declare class SettingsPaneCommandsRequest {

    /**
     * A vector that is available during the CommandsRequested event. Append SettingsCommand objects to it to make them available to the SettingsPane UI. 
     */
    applicationCommands: undefined.IVector<undefined.SettingsCommand >
}


/**
 * Contains arguments that are available from the event object during the CommandsRequested event. 
 */
declare class SettingsPaneCommandsRequestedEventArgs {

    /**
     * An instance of SettingsPaneCommandsRequest that is made available during the CommandsRequested event. 
     */
    request: undefined.SettingsPaneCommandsRequest
}


/**
 * Associates a command with a WebAccount in the account settings pane.. 
 */
declare class WebAccountCommand {

    /**
     * Initializes a new instance of the WebAccountCommand class.
     * @param webAccount The web account to associate with the current command.
     * @param invoked The delegate that handles the command.
     * @param actions A bitmask of web account actions.
     */
    constructor(webAccount: undefined.WebAccount, invoked: undefined.WebAccountCommandInvokedHandler, actions: undefined.SupportedWebAccountActions): this;

    /**
     * Gets the actions that the command performs on the web account in the accounts pane. 
     */
    actions: undefined.SupportedWebAccountActions;

    /**
     * Gets the delegate that's invoked when the user selects an account and a specific action in the account settings pane. 
     */
    invoked: undefined.WebAccountCommandInvokedHandler;

    /**
     * Gets the web account that's associated with the current command. 
     */
    webAccount: undefined.WebAccount
}


/**
 * Provides data for the WebAccountCommandInvokedHandler delegate. 
 */
declare class WebAccountInvokedArgs {

    /**
     * Gets the action for the web account in the accounts pane. 
     */
    action: undefined.WebAccountAction
}


/**
 * Associates a provider command with a WebAccountProvider in the account settings pane. 
 */
declare class WebAccountProviderCommand {

    /**
     * Initializes a new instance of the WebAccountProviderCommand class.
     * @param webAccountProvider The web account provider.
     * @param invoked The delegate that handles the provider command.
     */
    constructor(webAccountProvider: undefined.WebAccountProvider, invoked: undefined.WebAccountProviderCommandInvokedHandler): this;

    /**
     * Gets the delegate that's invoked when the user selects an account and a specific action in the accounts pane. 
     */
    invoked: undefined.WebAccountProviderCommandInvokedHandler;

    /**
     * Gets the web account provider that's associated with the current command. 
     */
    webAccountProvider: undefined.WebAccountProvider
}


/**
 * Represents the method that's invoked by the account settings pane when the user deletes a credential. 
 */
declare type ApplicationSettings$CredentialCommandCredentialDeletedHandler = (command: undefined.CredentialCommand) => void;


/**
 * Represents the method that's invoked when the user selects an account and a specific action in the account settings pane. 
 */
declare type ApplicationSettings$WebAccountCommandInvokedHandler = (
    command: undefined.WebAccountCommand,
    args: undefined.WebAccountInvokedArgs) => void;


/**
 * Represents the method that's invoked when the user selects an account and a specific action in the account settings pane. 
 */
declare type ApplicationSettings$WebAccountProviderCommandInvokedHandler = (command: undefined.WebAccountProviderCommand) => void;


/**
 * Provides static helper methods for processing Color values. C# and Microsoft Visual Basic code should use methods of Color instead. 
 */
declare class ColorHelper {

    /**
     * Generates a Color structure, based on discrete Byte values for ARGB components. C# and Microsoft Visual Basic code should use Color.FromArgb instead.
     * @param a The A (transparency) component of the desired color. Range is 0-255.
     * @param r The R component of the desired color. Range is 0-255.
     * @param g The G component of the desired color. Range is 0-255.
     * @param b The B component of the desired color. Range is 0-255.
     * @return  The generated Color value.
     */
    fromArgb(a: number, r: number, g: number, b: number): undefined.Color
}


/**
 * Implements a set of predefined colors. See Color for usage information. 
 */
declare class Colors {

    /**
     * Gets the color value that represents the AliceBlue named color. 
     */
    aliceBlue: undefined.Color;

    /**
     * Gets the color value that represents the AntiqueWhite named color. 
     */
    antiqueWhite: undefined.Color;

    /**
     * Gets the color value that represents the Aqua named color. 
     */
    aqua: undefined.Color;

    /**
     * Gets the color value that represents the Aquamarine named color. 
     */
    aquamarine: undefined.Color;

    /**
     * Gets the color value that represents the Azure named color. 
     */
    azure: undefined.Color;

    /**
     * Gets the color value that represents the Beige named color. 
     */
    beige: undefined.Color;

    /**
     * Gets the color value that represents the Bisque named color. 
     */
    bisque: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FF000000. 
     */
    black: undefined.Color;

    /**
     * Gets the color value that represents the BlanchedAlmond named color. 
     */
    blanchedAlmond: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FF0000FF. 
     */
    blue: undefined.Color;

    /**
     * Gets the color value that represents the BlueViolet named color. 
     */
    blueViolet: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FFA52A2A. 
     */
    brown: undefined.Color;

    /**
     * Gets the color value that represents the BurlyWood named color. 
     */
    burlyWood: undefined.Color;

    /**
     * Gets the color value that represents the CadetBlue named color. 
     */
    cadetBlue: undefined.Color;

    /**
     * Gets the color value that represents the Chartreuse named color. 
     */
    chartreuse: undefined.Color;

    /**
     * Gets the color value that represents the Chocolate named color. 
     */
    chocolate: undefined.Color;

    /**
     * Gets the color value that represents the Coral named color. 
     */
    coral: undefined.Color;

    /**
     * Gets the color value that represents the CornflowerBlue named color. 
     */
    cornflowerBlue: undefined.Color;

    /**
     * Gets the color value that represents the Cornsilk named color. 
     */
    cornsilk: undefined.Color;

    /**
     * Gets the color value that represents the Crimson named color. 
     */
    crimson: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FF00FFFF. 
     */
    cyan: undefined.Color;

    /**
     * Gets the color value that represents the DarkBlue named color. 
     */
    darkBlue: undefined.Color;

    /**
     * Gets the color value that represents the DarkCyan named color. 
     */
    darkCyan: undefined.Color;

    /**
     * Gets the color value that represents the DarkGoldenrod named color. 
     */
    darkGoldenrod: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FFA9A9A9. 
     */
    darkGray: undefined.Color;

    /**
     * Gets the color value that represents the DarkGreen named color. 
     */
    darkGreen: undefined.Color;

    /**
     * Gets the color value that represents the DarkKhaki named color. 
     */
    darkKhaki: undefined.Color;

    /**
     * Gets the color value that represents the DarkMagenta named color. 
     */
    darkMagenta: undefined.Color;

    /**
     * Gets the color value that represents the DarkOliveGreen named color. 
     */
    darkOliveGreen: undefined.Color;

    /**
     * Gets the color value that represents the DarkOrange named color. 
     */
    darkOrange: undefined.Color;

    /**
     * Gets the color value that represents the DarkOrchid named color. 
     */
    darkOrchid: undefined.Color;

    /**
     * Gets the color value that represents the DarkRed named color. 
     */
    darkRed: undefined.Color;

    /**
     * Gets the color value that represents the DarkSalmon named color. 
     */
    darkSalmon: undefined.Color;

    /**
     * Gets the color value that represents the DarkSeaGreen named color. 
     */
    darkSeaGreen: undefined.Color;

    /**
     * Gets the color value that represents the DarkSlateBlue named color. 
     */
    darkSlateBlue: undefined.Color;

    /**
     * Gets the color value that represents the DarkSlateGray named color. 
     */
    darkSlateGray: undefined.Color;

    /**
     * Gets the color value that represents the DarkTurquoise named color. 
     */
    darkTurquoise: undefined.Color;

    /**
     * Gets the color value that represents the DarkViolet named color. 
     */
    darkViolet: undefined.Color;

    /**
     * Gets the color value that represents the DeepPink named color. 
     */
    deepPink: undefined.Color;

    /**
     * Gets the color value that represents the DeepSkyBlue named color. 
     */
    deepSkyBlue: undefined.Color;

    /**
     * Gets the color value that represents the DimGray named color. 
     */
    dimGray: undefined.Color;

    /**
     * Gets the color value that represents the DodgerBlue named color. 
     */
    dodgerBlue: undefined.Color;

    /**
     * Gets the color value that represents the Firebrick named color. 
     */
    firebrick: undefined.Color;

    /**
     * Gets the color value that represents the FloralWhite named color. 
     */
    floralWhite: undefined.Color;

    /**
     * Gets the color value that represents the ForestGreen named color. 
     */
    forestGreen: undefined.Color;

    /**
     * Gets the color value that represents the Fuchsia named color. 
     */
    fuchsia: undefined.Color;

    /**
     * Gets the color value that represents the Gainsboro named color. 
     */
    gainsboro: undefined.Color;

    /**
     * Gets the color value that represents the GhostWhite named color. 
     */
    ghostWhite: undefined.Color;

    /**
     * Gets the color value that represents the Gold named color. 
     */
    gold: undefined.Color;

    /**
     * Gets the color value that represents the Goldenrod named color. 
     */
    goldenrod: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FF808080. 
     */
    gray: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FF008000. 
     */
    green: undefined.Color;

    /**
     * Gets the color value that represents the GreenYellow named color. 
     */
    greenYellow: undefined.Color;

    /**
     * Gets the color value that represents the Honeydew named color. 
     */
    honeydew: undefined.Color;

    /**
     * Gets the color value that represents the HotPink named color. 
     */
    hotPink: undefined.Color;

    /**
     * Gets the color value that represents the IndianRed named color. 
     */
    indianRed: undefined.Color;

    /**
     * Gets the color value that represents the Indigo named color. 
     */
    indigo: undefined.Color;

    /**
     * Gets the color value that represents the Ivory named color. 
     */
    ivory: undefined.Color;

    /**
     * Gets the color value that represents the Khaki named color. 
     */
    khaki: undefined.Color;

    /**
     * Gets the color value that represents the Lavender named color. 
     */
    lavender: undefined.Color;

    /**
     * Gets the color value that represents the LavenderBlush named color. 
     */
    lavenderBlush: undefined.Color;

    /**
     * Gets the color value that represents the LawnGreen named color. 
     */
    lawnGreen: undefined.Color;

    /**
     * Gets the color value that represents the LemonChiffon named color. 
     */
    lemonChiffon: undefined.Color;

    /**
     * Gets the color value that represents the LightBlue named color. 
     */
    lightBlue: undefined.Color;

    /**
     * Gets the color value that represents the LightCoral named color. 
     */
    lightCoral: undefined.Color;

    /**
     * Gets the color value that represents the LightCyan named color. 
     */
    lightCyan: undefined.Color;

    /**
     * Gets the color value that represents the LightGoldenrodYellow named color. 
     */
    lightGoldenrodYellow: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FFD3D3D3. 
     */
    lightGray: undefined.Color;

    /**
     * Gets the color value that represents the LightGreen named color. 
     */
    lightGreen: undefined.Color;

    /**
     * Gets the color value that represents the LightPink named color. 
     */
    lightPink: undefined.Color;

    /**
     * Gets the color value that represents the LightSalmon named color. 
     */
    lightSalmon: undefined.Color;

    /**
     * Gets the color value that represents the LightSeaGreen named color. 
     */
    lightSeaGreen: undefined.Color;

    /**
     * Gets the color value that represents the LightSkyBlue named color. 
     */
    lightSkyBlue: undefined.Color;

    /**
     * Gets the color value that represents the LightSlateGray named color. 
     */
    lightSlateGray: undefined.Color;

    /**
     * Gets the color value that represents the LightSteelBlue named color. 
     */
    lightSteelBlue: undefined.Color;

    /**
     * Gets the color value that represents the LightYellow named color. 
     */
    lightYellow: undefined.Color;

    /**
     * Gets the color value that represents the Lime named color. 
     */
    lime: undefined.Color;

    /**
     * Gets the color value that represents the LimeGreen named color. 
     */
    limeGreen: undefined.Color;

    /**
     * Gets the color value that represents the Linen named color. 
     */
    linen: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FFFF00FF.. 
     */
    magenta: undefined.Color;

    /**
     * Gets the color value that represents the Maroon named color. 
     */
    maroon: undefined.Color;

    /**
     * Gets the color value that represents the MediumAquamarine named color. 
     */
    mediumAquamarine: undefined.Color;

    /**
     * Gets the color value that represents the MediumBlue named color. 
     */
    mediumBlue: undefined.Color;

    /**
     * Gets the color value that represents the MediumOrchid named color. 
     */
    mediumOrchid: undefined.Color;

    /**
     * Gets the color value that represents the MediumPurple named color. 
     */
    mediumPurple: undefined.Color;

    /**
     * Gets the color value that represents the MediumSeaGreen named color. 
     */
    mediumSeaGreen: undefined.Color;

    /**
     * Gets the color value that represents the MediumSlateBlue named color. 
     */
    mediumSlateBlue: undefined.Color;

    /**
     * Gets the color value that represents the MediumSpringGreen named color. 
     */
    mediumSpringGreen: undefined.Color;

    /**
     * Gets the color value that represents the MediumTurquoise named color. 
     */
    mediumTurquoise: undefined.Color;

    /**
     * Gets the color value that represents the MediumVioletRed named color. 
     */
    mediumVioletRed: undefined.Color;

    /**
     * Gets the color value that represents the MidnightBlue named color. 
     */
    midnightBlue: undefined.Color;

    /**
     * Gets the color value that represents the MintCream named color. 
     */
    mintCream: undefined.Color;

    /**
     * Gets the color value that represents the MistyRose named color. 
     */
    mistyRose: undefined.Color;

    /**
     * Gets the color value that represents the Moccasin named color. 
     */
    moccasin: undefined.Color;

    /**
     * Gets the color value that represents the NavajoWhite named color. 
     */
    navajoWhite: undefined.Color;

    /**
     * Gets the color value that represents the Navy named color. 
     */
    navy: undefined.Color;

    /**
     * Gets the color value that represents the OldLace named color. 
     */
    oldLace: undefined.Color;

    /**
     * Gets the color value that represents the Olive named color. 
     */
    olive: undefined.Color;

    /**
     * Gets the color value that represents the OliveDrab named color. 
     */
    oliveDrab: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FFFFA500.. 
     */
    orange: undefined.Color;

    /**
     * Gets the color value that represents the OrangeRed named color. 
     */
    orangeRed: undefined.Color;

    /**
     * Gets the color value that represents the Orchid named color. 
     */
    orchid: undefined.Color;

    /**
     * Gets the color value that represents the PaleGoldenrod named color. 
     */
    paleGoldenrod: undefined.Color;

    /**
     * Gets the color value that represents the PaleGreen named color. 
     */
    paleGreen: undefined.Color;

    /**
     * Gets the color value that represents the PaleTurquoise named color. 
     */
    paleTurquoise: undefined.Color;

    /**
     * Gets the color value that represents the PaleVioletRed named color. 
     */
    paleVioletRed: undefined.Color;

    /**
     * Gets the color value that represents the PapayaWhip named color. 
     */
    papayaWhip: undefined.Color;

    /**
     * Gets the color value that represents the PeachPuff named color. 
     */
    peachPuff: undefined.Color;

    /**
     * Gets the color value that represents the Peru named color. 
     */
    peru: undefined.Color;

    /**
     * Gets the color value that represents the Pink named color. 
     */
    pink: undefined.Color;

    /**
     * Gets the color value that represents the Plum named color. 
     */
    plum: undefined.Color;

    /**
     * Gets the color value that represents the PowderBlue named color. 
     */
    powderBlue: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FF800080.. 
     */
    purple: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FFFF0000. 
     */
    red: undefined.Color;

    /**
     * Gets the color value that represents the RosyBrown named color. 
     */
    rosyBrown: undefined.Color;

    /**
     * Gets the color value that represents the RoyalBlue named color. 
     */
    royalBlue: undefined.Color;

    /**
     * Gets the color value that represents the SaddleBrown named color. 
     */
    saddleBrown: undefined.Color;

    /**
     * Gets the color value that represents the Salmon named color. 
     */
    salmon: undefined.Color;

    /**
     * Gets the color value that represents the SandyBrown named color. 
     */
    sandyBrown: undefined.Color;

    /**
     * Gets the color value that represents the SeaGreen named color. 
     */
    seaGreen: undefined.Color;

    /**
     * Gets the color value that represents the SeaShell named color. 
     */
    seaShell: undefined.Color;

    /**
     * Gets the color value that represents the Sienna named color. 
     */
    sienna: undefined.Color;

    /**
     * Gets the color value that represents the Silver named color. 
     */
    silver: undefined.Color;

    /**
     * Gets the color value that represents the SkyBlue named color. 
     */
    skyBlue: undefined.Color;

    /**
     * Gets the color value that represents the SlateBlue named color. 
     */
    slateBlue: undefined.Color;

    /**
     * Gets the color value that represents the SlateGray named color. 
     */
    slateGray: undefined.Color;

    /**
     * Gets the color value that represents the Snow named color. 
     */
    snow: undefined.Color;

    /**
     * Gets the color value that represents the SpringGreen named color. 
     */
    springGreen: undefined.Color;

    /**
     * Gets the color value that represents the SteelBlue named color. 
     */
    steelBlue: undefined.Color;

    /**
     * Gets the color value that represents the Tan named color. 
     */
    tan: undefined.Color;

    /**
     * Gets the color value that represents the Teal named color. 
     */
    teal: undefined.Color;

    /**
     * Gets the color value that represents the Thistle named color. 
     */
    thistle: undefined.Color;

    /**
     * Gets the color value that represents the Tomato named color. 
     */
    tomato: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #00FFFFFF. 
     */
    transparent: undefined.Color;

    /**
     * Gets the color value that represents the Turquoise named color. 
     */
    turquoise: undefined.Color;

    /**
     * Gets the color value that represents the Violet named color. 
     */
    violet: undefined.Color;

    /**
     * Gets the color value that represents the Wheat named color. 
     */
    wheat: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FFFFFFFF. 
     */
    white: undefined.Color;

    /**
     * Gets the color value that represents the WhiteSmoke named color. 
     */
    whiteSmoke: undefined.Color;

    /**
     * Gets the system-defined color that has the ARGB value of #FFFFFF00. 
     */
    yellow: undefined.Color;

    /**
     * Gets the color value that represents the YellowGreen named color. 
     */
    yellowGreen: undefined.Color
}


/**
 * Represents an animation. 
 */
declare class CompositionAnimation {}


/**
 * Represents a function for interpolating between animation key frames. 
 */
declare class CompositionEasingFunction {}


/**
 * Exposes a collection of individual animation effects that are performed on a specific target to make up a complete Windows opacity, scaling, or translation animation. 
 */
declare class AnimationDescription {

    /**
     * Creates an AnimationDescription object with a specific animation and target.
     * @param effect The animation effect to apply to the target.
     * @param target The target of the animation effect.
     */
    constructor(effect: undefined.AnimationEffect, target: undefined.AnimationEffectTarget): this;

    /**
     * Gets the collection of animations that are associated with the AnimationDescription object. 
     */
    animations: undefined.IVectorView<undefined.IPropertyAnimation>;

    /**
     * Gets the maximum cumulative delay time for the animation to be applied to the collection of objects in a target. 
     */
    delayLimit: number;

    /**
     * Gets the amount of time between the application of the animation effect to each object in a target that contains multiple objects. The StaggerDelay, together with the StaggerDelayFactor and DelayLimit, is one of the three elements used to control the relative timing of the animation effects. 
     */
    staggerDelay: number;

    /**
     * Gets a multiplier that is applied to each occurrence of the stagger delay, increasing or decreasing the previous delay instance by that amount. 
     */
    staggerDelayFactor: number;

    /**
     * Gets the z-order position of an AnimationDescription object relative to other AnimationDescription objects in the same animation effect. AnimationDescription objects with a higher z-order cover transitions with a lower z-order. 
     */
    zorder: number
}


/**
 * Provides methods that enable you to retrieve the parameters of an opacity (fade in or fade out) animation. 
 */
declare class OpacityAnimation {

    /**
     * Gets the location of the first control point for the cubic Bézier curve that describes how the opacity should animate over time. 
     */
    control1: undefined.Point;

    /**
     * Gets the location of the second control point for the cubic Bézier curve that describes how the opacity should animate over time. 
     */
    control2: undefined.Point;

    /**
     * Gets the amount of time between when the opacity animation is instructed to begin and when that animation actually begins to draw. 
     */
    delay: number;

    /**
     * Gets the amount of time over which the opacity animation should be performed. This does not include the delay. 
     */
    duration: number;

    /**
     * Gets the object's final opacity. 
     */
    finalOpacity: number;

    /**
     * Gets the object's initial opacity. 
     */
    initialOpacity: number;

    /**
     * Gets the type of animation represented by this object. 
     */
    type: undefined.PropertyAnimationType
}


/**
 * Provides methods that enable you to retrieve animation property values that are common to all property animation types . 
 */
declare class PropertyAnimation {

    /**
     * Gets the location of the first control point for the cubic Bézier curve that describes how this property of this object should animate over time. 
     */
    control1: undefined.Point;

    /**
     * Gets the location of the second control point for the cubic Bézier curve that describes how this property of this object should animate over time. 
     */
    control2: undefined.Point;

    /**
     * Gets the amount of time between when the animation is instructed to begin and when that animation actually begins to draw. 
     */
    delay: number;

    /**
     * Gets the amount of time over which the animation should be performed. This does not include the delay. 
     */
    duration: number;

    /**
     * Gets the type of animation represented by this object. 
     */
    type: undefined.PropertyAnimationType
}


/**
 * Provides methods that enable you to retrieve the parameters for a scaling (growing or shrinking) animation. 
 */
declare class ScaleAnimation {

    /**
     * Gets the location of the first control point for the cubic Bézier curve that describes how the scale should animate over time. 
     */
    control1: undefined.Point;

    /**
     * Gets the location of the second control point for the cubic Bézier curve that describes how the scale should animate over time. 
     */
    control2: undefined.Point;

    /**
     * Gets the amount of time between when the scale animation is instructed to begin and when that animation actually begins to draw. 
     */
    delay: number;

    /**
     * Gets the amount of time over which the scale animation should be performed. This does not include the delay. 
     */
    duration: number;

    /**
     * Gets the final horizontal scale factor for the object. 
     */
    finalScaleX: number;

    /**
     * Gets the final vertical scale factor for the object. 
     */
    finalScaleY: number;

    /**
     * Gets the initial horizontal scale factor for the object. 
     */
    initialScaleX: number;

    /**
     * Gets the initial vertical scale factor for the object. 
     */
    initialScaleY: number;

    /**
     * Gets the center point for the scaling animation, expressed as a point relative to the object's normal size. 
     */
    normalizedOrigin: undefined.Point;

    /**
     * Gets the type of animation represented by this object. 
     */
    type: undefined.PropertyAnimationType
}


/**
 * Provides methods that enable you to retrieve the parameters for a translation (move to a new location) animation. 
 */
declare class TranslationAnimation {

    /**
     * Gets the location of the first control point for the cubic Bézier curve that describes how the translation should animate over time. 
     */
    control1: undefined.Point;

    /**
     * Gets the location of the second control point for the cubic Bézier curve that describes how the translation should animate over time. 
     */
    control2: undefined.Point;

    /**
     * Gets the amount of time between when the translation animation is instructed to begin and when that animation actually begins to draw. 
     */
    delay: number;

    /**
     * Gets the amount of time over which the translation animation should be performed. This does not include the delay. 
     */
    duration: number;

    /**
     * Gets the type of animation represented by this object. 
     */
    type: undefined.PropertyAnimationType
}


/**
 * Describes properties of animations that are common to all animation effects. 
 */
declare interface AnimationMetrics$IPropertyAnimation {

    /**
     * Gets the location of the first control point for the cubic Bézier curve that describes how this property of this object should animate over time. 
     */
    control1: undefined.Point,

        /**
         * Gets the location of the second control point for the cubic Bézier curve that describes how this property of this object should animate over time. 
         */
        control2: undefined.Point,

        /**
         * Gets the amount of time between when the animation is instructed to begin and when that animation actually begins to draw. 
         */
        delay: number,

        /**
         * Gets the amount of time over which the animation should be performed. This does not include the delay. 
         */
        duration: number,

        /**
         * Gets the type of animation represented by this object. 
         */
        type: undefined.PropertyAnimationType
}


/**
 * Provides event data for the SystemNavigationManager.BackRequested event. 
 */
declare class BackRequestedEventArgs {

    /**
     * Gets or sets a value that indicates whether the app performed the requested back-navigation. 
     */
    handled: boolean
}


/**
 * Provides a way for an app to respond to system provided back-navigation events. 
 */
declare class SystemNavigationManager {

    /**
     * Returns the SystemNavigationManager object associated with the current window.
     * @return  The SystemNavigationManager object associated with the current window.
     */
    getForCurrentView(): undefined.SystemNavigationManager;

    /**
     * Gets or sets a value that indicates whether a back button is shown in the system UI. 
     */
    appViewBackButtonVisibility: undefined.AppViewBackButtonVisibility;

    /**
     * Occurs when the user invokes the system provided button, gesture, or voice command for back-navigation. 
     */
    onbackrequested: undefined.EventHandler<any>;
    addEventListener(type: "backrequested", listener: undefined.EventHandler<any>): void;
    removeEventListener(type: "backrequested", listener: undefined.EventHandler<any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains event data for the CrossSliding event. 
 */
declare class CrossSlidingEventArgs {

    /**
     * Gets the state of the CrossSliding event. 
     */
    crossSlidingState: undefined.CrossSlidingState;

    /**
     * Gets the device type of the input source. 
     */
    pointerDeviceType: undefined.PointerDeviceType;

    /**
     * Gets the location of the touch contact. 
     */
    position: undefined.Point
}


/**
 * Contains event data for the Dragging event. 
 */
declare class DraggingEventArgs {

    /**
     * Gets the state of the Dragging event. 
     */
    draggingState: undefined.DraggingState;

    /**
     * Gets the device type of the input source. 
     */
    pointerDeviceType: undefined.PointerDeviceType;

    /**
     * Gets the location of the mouse or pen/stylus contact. 
     */
    position: undefined.Point
}


/**
 * Provides access to the events that notify an app of triggers to its edge-based UI. 
 */
declare class EdgeGesture {

    /**
     * Gets an instance of the EdgeGesture class that is used to add and remove event delegate handlers for the current view.
     * @return  The currently relevant instance of the EdgeGesture object.
     */
    getForCurrentView(): undefined.EdgeGesture;

    /**
     * Fires when a user cancels a show or hide action for an edge-based UI. 
     */
    oncanceled: undefined.TypedEventHandler<undefined.EdgeGesture, undefined.EdgeGestureEventArgs>;
    addEventListener(
        type: "canceled",
        listener: undefined.TypedEventHandler<undefined.EdgeGesture, undefined.EdgeGestureEventArgs>): void;
    removeEventListener(
        type: "canceled",
        listener: undefined.TypedEventHandler<undefined.EdgeGesture, undefined.EdgeGestureEventArgs>): void;

    /**
     * Fires to indicate that the user has successfully summoned or dismissed the edge-based UI. This occurs either when the user lifts his or her finger from a touch-enabled screen or when the user presses Win+Z on the keyboard. 
     */
    oncompleted: undefined.TypedEventHandler<undefined.EdgeGesture, undefined.EdgeGestureEventArgs>;
    addEventListener(
        type: "completed",
        listener: undefined.TypedEventHandler<undefined.EdgeGesture, undefined.EdgeGestureEventArgs>): void;
    removeEventListener(
        type: "completed",
        listener: undefined.TypedEventHandler<undefined.EdgeGesture, undefined.EdgeGestureEventArgs>): void;

    /**
     * Fires when a user begins an action to summon or dismiss edge-based UI. 
     */
    onstarting: undefined.TypedEventHandler<undefined.EdgeGesture, undefined.EdgeGestureEventArgs>;
    addEventListener(
        type: "starting",
        listener: undefined.TypedEventHandler<undefined.EdgeGesture, undefined.EdgeGestureEventArgs>): void;
    removeEventListener(
        type: "starting",
        listener: undefined.TypedEventHandler<undefined.EdgeGesture, undefined.EdgeGestureEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides access to the type of user input that triggered the edge gesture event. 
 */
declare class EdgeGestureEventArgs {

    /**
     * Gets the type of user input that triggered the edge gesture event. 
     */
    kind: undefined.EdgeGestureKind
}


/**
 * Provides gesture and manipulation recognition, event listeners, and settings. 
 */
declare class GestureRecognizer {

    /**
     * Initializes a new instance of a GestureRecognizer object. 
     */
    constructor(): this;

    /**
     * Gets or sets a value that indicates whether manipulations during inertia are generated automatically. 
     */
    autoProcessInertia: boolean;

    /**
     * Identifies whether a tap can still be interpreted as the second tap of a double tap gesture.
     * @param value The last input pointer.
     * @return  True if a UI element supports the double tap gesture and the time threshold to complete the gesture has not been crossed; otherwise false.
     */
    canBeDoubleTap(value: undefined.PointerPoint): boolean;

    /**
     * Causes the gesture recognizer to finalize an interaction. 
     */
    completeGesture(): void;

    /**
     * Gets or sets a value that indicates whether the exact distance from initial contact to end of the cross-slide interaction is reported. 
     */
    crossSlideExact: boolean;

    /**
     * Gets or sets a value that indicates whether the cross-slide axis is horizontal. 
     */
    crossSlideHorizontally: boolean;

    /**
     * Gets or sets values that indicate the distance thresholds for a CrossSliding interaction. 
     */
    crossSlideThresholds: undefined.CrossSlideThresholds;

    /**
     * Gets or sets a value that indicates the gesture and manipulation settings supported by an application. 
     */
    gestureSettings: undefined.GestureSettings;

    /**
     * Gets or sets a value that indicates the relative change in size of an object from the start of inertia to the end of inertia (when resizing, or scaling, is complete). 
     */
    inertiaExpansion: number;

    /**
     * Gets or sets a value that indicates the rate of deceleration from the start of inertia to the end of inertia (when the resizing, or expansion, manipulation is complete). 
     */
    inertiaExpansionDeceleration: number;

    /**
     * Gets or sets a value that indicates the final angle of rotation of an object at the end of inertia (when the rotation manipulation is complete). 
     */
    inertiaRotationAngle: number;

    /**
     * Gets or sets a value that indicates the rate of deceleration from the start of inertia to the end of inertia (when the rotation manipulation is complete). 
     */
    inertiaRotationDeceleration: number;

    /**
     * Gets or sets a value that indicates the rate of deceleration from the start of inertia to the end of inertia (when the translation manipulation is complete). 
     */
    inertiaTranslationDeceleration: number;

    /**
     * Gets or sets a value that indicates the relative change in the screen location of an object from the start of inertia to the end of inertia (when the translation manipulation is complete). 
     */
    inertiaTranslationDisplacement: number;

    /**
     * Gets a value that indicates whether an interaction is being processed. 
     */
    isActive: boolean;

    /**
     * Gets a value that indicates whether a manipulation is still being processed during inertia (no input points are active). 
     */
    isInertial: boolean;

    /**
     * Gets or sets a value that indicates whether the exact distance from initial contact to end of the interaction is reported. 
     */
    manipulationExact: boolean;

    /**
     * Gets a set of properties that are associated with the wheel button of a mouse device. 
     */
    mouseWheelParameters: undefined.MouseWheelParameters;

    /**
     * Occurs when a user performs a slide or swipe gesture (through a single touch contact) within a content area that supports panning along a single axis only. The gesture must occur in a direction that is perpendicular to this panning axis. 
     */
    oncrosssliding: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.CrossSlidingEventArgs>;
    addEventListener(
        type: "crosssliding",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.CrossSlidingEventArgs>): void;
    removeEventListener(
        type: "crosssliding",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.CrossSlidingEventArgs>): void;

    /**
     * Occurs when a user performs a slide or swipe gesture with a mouse or pen/stylus (single contact). 
     */
    ondragging: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.DraggingEventArgs>;
    addEventListener(
        type: "dragging",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.DraggingEventArgs>): void;
    removeEventListener(
        type: "dragging",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.DraggingEventArgs>): void;

    /**
     * Occurs when a user performs a press and hold gesture (with a single touch, mouse, or pen/stylus contact). 
     */
    onholding: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.HoldingEventArgs>;
    addEventListener(
        type: "holding",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.HoldingEventArgs>): void;
    removeEventListener(
        type: "holding",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.HoldingEventArgs>): void;

    /**
     * Occurs when the input points are lifted and all subsequent motion (translation, expansion, or rotation) through inertia has ended. 
     */
    onmanipulationcompleted: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationCompletedEventArgs>;
    addEventListener(
        type: "manipulationcompleted",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationCompletedEventArgs>): void;
    removeEventListener(
        type: "manipulationcompleted",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationCompletedEventArgs>): void;

    /**
     * Occurs when all contact points are lifted during a manipulation and the velocity of the manipulation is significant enough to initiate inertia behavior (translation, expansion, or rotation continue after the input pointers are lifted). 
     */
    onmanipulationinertiastarting: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationInertiaStartingEventArgs>;
    addEventListener(
        type: "manipulationinertiastarting",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationInertiaStartingEventArgs>): void;
    removeEventListener(
        type: "manipulationinertiastarting",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationInertiaStartingEventArgs>): void;

    /**
     * Occurs when one or more input points have been initiated and subsequent motion (translation, expansion, or rotation) has begun. 
     */
    onmanipulationstarted: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationStartedEventArgs>;
    addEventListener(
        type: "manipulationstarted",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationStartedEventArgs>): void;
    removeEventListener(
        type: "manipulationstarted",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationStartedEventArgs>): void;

    /**
     * Occurs after one or more input points have been initiated and subsequent motion (translation, expansion, or rotation) is under way. 
     */
    onmanipulationupdated: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationUpdatedEventArgs>;
    addEventListener(
        type: "manipulationupdated",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationUpdatedEventArgs>): void;
    removeEventListener(
        type: "manipulationupdated",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.ManipulationUpdatedEventArgs>): void;

    /**
     * Occurs when the pointer input is interpreted as a right-tap gesture, regardless of input device. 
     */
    onrighttapped: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.RightTappedEventArgs>;
    addEventListener(
        type: "righttapped",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.RightTappedEventArgs>): void;
    removeEventListener(
        type: "righttapped",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.RightTappedEventArgs>): void;

    /**
     * Occurs when the pointer input is interpreted as a tap gesture. 
     */
    ontapped: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.TappedEventArgs>;
    addEventListener(
        type: "tapped",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.TappedEventArgs>): void;
    removeEventListener(
        type: "tapped",
        listener: undefined.TypedEventHandler<undefined.GestureRecognizer, undefined.TappedEventArgs>): void;

    /**
     * Gets or sets the center point for a rotation interaction when single pointer input is detected. 
     */
    pivotCenter: undefined.Point;

    /**
     * Gets or sets the radius, from the PivotCenter to the pointer input, for a rotation interaction when single pointer input is detected. 
     */
    pivotRadius: number;

    /**
     * Processes pointer input and raises the GestureRecognizer events appropriate to a pointer down action for the gestures and manipulations specified by the GestureSettings property.
     * @param value The input point.
     */
    processDownEvent(value: undefined.PointerPoint): void;

    /**
     * Performs inertia calculations and raises the various inertia events. 
     */
    processInertia(): void;

    /**
     * Processes pointer input and raises the GestureRecognizer events appropriate to a mouse wheel action for the gestures and manipulations specified by the GestureSettings property.
     * @param value The input point.
     * @param isShiftKeyDown True if the Shift key is pressed; otherwise false.
     * @param isControlKeyDown True if the Ctrl key is pressed.
     */
    processMouseWheelEvent(
        value: undefined.PointerPoint,
        isShiftKeyDown: boolean,
        isControlKeyDown: boolean): void;

    /**
     * Processes pointer input and raises the GestureRecognizer events appropriate to a pointer move action for the gestures and manipulations specified by the GestureSettings property.
     * @param value The pointer location history based on the PointerId . If no history is available then the value is the current location of the input pointer.
     */
    processMoveEvents(value: undefined.IVector<undefined.PointerPoint>): void;

    /**
     * Processes pointer input and raises the GestureRecognizer events appropriate to a pointer up action for the gestures and manipulations specified by the GestureSettings property.
     * @param value The input point.
     */
    processUpEvent(value: undefined.PointerPoint): void;

    /**
     * Gets or sets a value that indicates whether visual feedback is displayed during an interaction. 
     */
    showGestureFeedback: boolean;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains event data for the Holding event. 
 */
declare class HoldingEventArgs {

    /**
     * Gets the state of the Holding event. 
     */
    holdingState: undefined.HoldingState;

    /**
     * Gets the device type of the input source. 
     */
    pointerDeviceType: undefined.PointerDeviceType;

    /**
     * Gets the location of the touch, mouse, or pen/stylus contact. 
     */
    position: undefined.Point
}




/**
 * Provides properties associated with the drawing of an InkStroke . 
 */
declare class InkDrawingAttributes {

    /**
     * Creates a new InkDrawingAttributes object that is used to specify InkStroke attributes. 
     */
    constructor(): this;

    /**
     * Gets or sets a value that indicates the color of an InkStroke . 
     */
    color: undefined.Color;

    /**
     * Gets or sets a value that indicates whether the InkStroke is rendered as a highlighter overlay. The stroke is typically set to a bright color, such as yellow. 
     */
    drawAsHighlighter: boolean;

    /**
     * Gets or sets a value that indicates whether a Bezier curve or a collection of straight line segments is used to draw an InkStroke . 
     */
    fitToCurve: boolean;

    /**
     * Gets or sets a value that indicates whether the pressure of the contact on the digitizer surface is ignored when you draw an InkStroke . 
     */
    ignorePressure: boolean;

    /**
     * Gets or sets a value that indicates the shape of the pen tip when you draw an InkStroke . 
     */
    penTip: undefined.PenTipShape;

    /**
     * Gets or sets an affine transformation matrix applied to the PenTipShape used for an InkStroke . 
     */
    penTipTransform: undefined.Matrix3x2;

    /**
     * Gets or sets a value that indicates the dimensions of the pen tip ( PenTip ) when you draw an InkStroke . 
     */
    size: undefined.Size
}


/**
 * Provides properties and methods to manage the input, manipulation, and processing (including handwriting recognition) of one or more InkStroke objects. 
 */
declare class InkManager {

    /**
     * Creates a new InkManager object that is used to manage InkStroke objects. 
     */
    constructor(): this;

    /**
     * Adds one or more InkStroke objects to the collection managed by the InkManager .
     * @param stroke The ink stroke to be added.
     */
    addStroke(stroke: undefined.InkStroke): void;

    /**
     * Gets the bounding rectangle of the InkStroke collection that is managed by the InkManager . 
     */
    boundingRect: undefined.Rect;

    /**
     * Identifies whether content on the clipboard can be added to the InkStroke collection that is managed by the InkManager .
     * @return  True if content can be pasted from the clipboard; otherwise, false.
     */
    canPasteFromClipboard(): boolean;

    /**
     * Copies the selected InkStroke objects (from the InkStroke collection managed by the InkManager ) to the clipboard in Ink Serialized Format (ISF) format. 
     */
    copySelectedToClipboard(): void;

    /**
     * Deletes the selected InkStroke objects from the InkStroke collection managed by the InkManager .
     * @return  The bounding rectangle of the selected ink strokes, or the invalidated rectangle (0, 0, 0, 0) if no strokes were removed (no selected strokes).
     */
    deleteSelected(): undefined.Rect;

    /**
     * Retrieves the collection of words returned by handwriting recognition.
     * @return  The words returned by the handwriting recognizer as a collection of InkRecognitionResult objects.
     */
    getRecognitionResults(): undefined.IVectorView<undefined.InkRecognitionResult>;

    /**
     * Gets the collection of installed handwriting recognizers.
     * @return  The installed handwriting recognizers as a collection of InkRecognizer objects.
     */
    getRecognizers(): undefined.IVectorView<undefined.InkRecognizer>;

    /**
     * Retrieves all ink strokes in the collection managed by the InkManager .
     * @return  The ink strokes managed by the InkManager as a collection of InkStroke objects.
     */
    getStrokes(): undefined.IVectorView<undefined.InkStroke>;

    /**
     * Asynchronously loads all InkStroke objects from the specified stream to the InkStroke collection that is managed by the InkManager .
     * @param inputStream The stream that contains the stroke collection. An IRandomAccessStream (requires IOutputStream ) object can be specified instead.
     * @return  The status of the asynchronous operation as the number of bytes fetched. For more information, see ReadAsync method.
     */
    loadAsync(
        inputStream: undefined.IInputStream): undefined.IPromiseWithIAsyncActionWithProgress<number>;

    /**
     * Gets or sets the ink input mode. 
     */
    mode: undefined.InkManipulationMode;

    /**
     * Moves the selected strokes. All affected strokes are re-rendered.
     * @param translation The destination screen coordinates for the upper-left corner of the bounding rectangle of the selected strokes.
     * @return  The bounding rectangle of the selected ink strokes.
     */
    moveSelected(translation: undefined.Point): undefined.Rect;

    /**
     * Adds the InkStroke content from the clipboard to the InkStroke collection that is managed by the InkManager and renders the new strokes..
     * @param position The screen coordinates for the upper-left corner of the bounding rectangle of the clipboard content.
     * @return  The invalidated bounding rectangle of the InkStroke collection.
     */
    pasteFromClipboard(position: undefined.Point): undefined.Rect;

    /**
     * Processes information about the position and features of the contact point, like pressure and tilt, on initial down contact. You must call this method before you call ProcessPointerUpdate , and then ProcessPointerUp.
     * @param pointerPoint Information about the position and features of the contact point.
     */
    processPointerDown(pointerPoint: undefined.PointerPoint): void;

    /**
     * Processes information about the position and features of the contact point, like pressure and tilt, on up contact. You must call this method after you call ProcessPointerUpdate .
     * @param pointerPoint Information about the position and features of the contact point.
     * @return  For Inking and Selecting modes, this is the bounding box for the stroke (invalidated rectangle). For Erasing mode, the invalidated rectangle is (0,0,0,0).
     */
    processPointerUp(pointerPoint: undefined.PointerPoint): undefined.Rect;

    /**
     * Processes position and state properties, such as pressure and tilt, for the specified pointer, from the last pointer event up to and including the current pointer event.
     * @param pointerPoint The input pointer for which updates are to be processed.
     * @return  When the current InkManipulationMode is Inking or Selecting, this method returns the Point (screen position in ink space) associated with the last ProcessPointerUpdate of pointerPoint.
     */
    processPointerUpdate(pointerPoint: undefined.PointerPoint): any;

    /**
     * Performs handwriting recognition on one or more InkStroke objects.
     * @param recognitionTarget One of the values from the InkRecognitionTarget enumeration.
     * @return  The results of the recognition as a collection of InkRecognitionResult objects.
     */
    recognizeAsync(
        recognitionTarget: undefined.InkRecognitionTarget): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Performs handwriting recognition on one or more InkStroke objects.
     * @param strokeCollection The set of strokes on which recognition is performed.
     * @param recognitionTarget One of the values from the InkRecognitionTarget enumeration.
     * @return  The results of the recognition as a collection of InkRecognitionResult objects.
     */
    recognizeAsync(
        strokeCollection: undefined.InkStrokeContainer,
        recognitionTarget: undefined.InkRecognitionTarget): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Asynchronously saves all InkStroke objects in the InkStroke collection that is managed by the InkManager to the specified stream.
     * @param outputStream The target stream. An IRandomAccessStream (requires IOutputStream ) object can be specified instead.
     * @return  The size of the saved stream and the status of the asynchronous operation as the number of bytes sent. For more information, see WriteAsync method.
     */
    saveAsync(
        outputStream: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperationWithProgress<number, number>;

    /**
     * Selects all strokes intersected by the new stroke.
     * @param from The start of the stroke.
     * @param to The end of the stroke.
     * @return  The bounding rectangle of the selected ink strokes.
     */
    selectWithLine(from: undefined.Point, to: undefined.Point): undefined.Rect;

    /**
     * Selects all strokes contained entirely within the polyline.
     * @param polyline The points of the polyline.
     * @return  The bounding rectangle of the selected ink strokes.
     */
    selectWithPolyLine(polyline: undefined.IIterable<undefined.Point>): undefined.Rect;

    /**
     * Sets the default InkDrawingAttributes for all new InkStroke objects added to the InkStroke collection managed by the InkManager .
     * @param drawingAttributes The default attributes applied to a new ink stroke.
     */
    setDefaultDrawingAttributes(drawingAttributes: undefined.InkDrawingAttributes): void;

    /**
     * Sets the default InkRecognizer used for handwriting recognition.
     * @param recognizer The InkRecognizer .
     */
    setDefaultRecognizer(recognizer: undefined.InkRecognizer): void;

    /**
     * Updates the collection of potential text matches from handwriting recognition.
     * @param recognitionResults The results returned by recognition, where each InkRecognitionResult object represents one written word.
     */
    updateRecognitionResults(
        recognitionResults: undefined.IVectorView<undefined.InkRecognitionResult>): void
}

declare class InkPoint {

    /**
     * Creates a new InkPoint object used in the construction of an InkStroke .
     * @param position The screen coordinates for the InkPoint object.
     * @param pressure The pressure of the contact on the digitizer surface. The default is 0.5.
     */
    constructor(position: undefined.Point, pressure: number): this;

    /**
     * The X, Y coordinates of the InkPoint , in device-independent pixels (DIPs) relative to the upper left-hand corner of the inking area. 
     */
    position: undefined.Point;
    pressure: any
}


/**
 * Provides properties and methods to manage InkStroke handwriting recognition data. 
 */
declare class InkRecognitionResult {

    /**
     * Gets the bounding rectangle of the InkStroke data used for handwriting recognition. 
     */
    boundingRect: undefined.Rect;

    /**
     * Retrieves all ink strokes used for handwriting recognition.
     * @return  The ink strokes used for handwriting recognition as a collection of InkStroke objects.
     */
    getStrokes(): undefined.IVectorView<undefined.InkStroke>;

    /**
     * Retrieves the collection of strings identified as potential matches for each word returned by handwriting recognition.
     * @return  The recognition matches as a collection of String objects. The most likely candidate is topmost in the collection.
     */
    getTextCandidates(): undefined.IVectorView<string >
}


/**
 * Manages all aspects of handwriting recognition. 
 */
declare class InkRecognizer {

    /**
     * Gets the name of the InkRecognizer . 
     */
    name: string
}


/**
 * Provides properties and methods to manage one or more InkRecognizer objects used for handwriting recognition. 
 */
declare class InkRecognizerContainer {

    /**
     * Creates a new InkRecognizerContainer object to manage InkRecognizer objects used for handwriting recognition. 
     */
    constructor(): this;

    /**
     * Gets the collection of installed handwriting recognizers.
     * @return  The installed handwriting recognizers as a collection of InkRecognizer objects.
     */
    getRecognizers(): undefined.IVectorView<undefined.InkRecognizer>;

    /**
     * Performs handwriting recognition on one or more InkStroke objects.
     * @param strokeCollection The set of strokes on which recognition is performed.
     * @param recognitionTarget One of the values from the InkRecognitionTarget enumeration.
     * @return  The results of the recognition as a collection of InkRecognitionResult objects.
     */
    recognizeAsync(
        strokeCollection: undefined.InkStrokeContainer,
        recognitionTarget: undefined.InkRecognitionTarget): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Sets the default InkRecognizer used for handwriting recognition.
     * @param recognizer The InkRecognizer .
     */
    setDefaultRecognizer(recognizer: undefined.InkRecognizer): void
}


/**
 * A single ink stroke, including the Bézier curve parameters used for final rendering of the stroke. 
 */
declare class InkStroke {

    /**
     * Gets the bounding box for the InkStroke . 
     */
    boundingRect: undefined.Rect;

    /**
     * Copies the InkStroke to another InkManager (or InkStrokeContainer ).
     * @return  The new stroke.
     */
    clone(): undefined.InkStroke;

    /**
     * Gets or sets the properties associated with an InkStroke . 
     */
    drawingAttributes: undefined.InkDrawingAttributes;

    /**
     * Gets the collection of InkPoint objects used to construct the InkStroke .
     * @return  The collection of InkPoint objects used to construct the InkStroke .
     */
    getInkPoints(): undefined.IVectorView<Inking$InkPoint>;

    /**
     * Gets the rendering segments of the stroke.
     * @return  The collection of InkStrokeRenderingSegment objects.
     */
    getRenderingSegments(): undefined.IVectorView<undefined.InkStrokeRenderingSegment>;

    /**
     * Gets or sets an affine transformation matrix to apply to the InkStroke object. 
     */
    pointTransform: undefined.Matrix3x2;

    /**
     * Gets whether the stroke is recognized. 
     */
    recognized: boolean;

    /**
     * Gets whether the stroke is selected. 
     */
    selected: boolean
}


/**
 * Builds strokes from raw pointer input. 
 */
declare class InkStrokeBuilder {

    /**
     * Creates a new InkStrokeBuilder object that is used to construct InkStroke objects. 
     */
    constructor(): this;

    /**
     * Adds a new segment to the ink stroke.
     * @param pointerPoint The end point of the new segment.
     * @return  The previous end point. This end point can be used when rendering the stroke.
     */
    appendToStroke(pointerPoint: undefined.PointerPoint): undefined.PointerPoint;

    /**
     * Starts building the ink stroke.
     * @param pointerPoint The first point for the stroke.
     */
    beginStroke(pointerPoint: undefined.PointerPoint): void;

    /**
     * Creates a stroke from an array of Point coordinates.
     * @param points An array of Point coordinates.
     * @return  The new stroke.
     */
    createStroke(points: undefined.IIterable<undefined.Point>): undefined.InkStroke;

    /**
     * Creates a stroke from collection of InkPoint objects.
     * @param inkPoints The collection of InkPoint objects.
     * @param transform A 2-D transformation matrix.
     * @return  The ink stroke, including the Bézier curve parameters used for final rendering of the stroke.
     */
    createStrokeFromInkPoints(
        inkPoints: undefined.IIterable<Inking$InkPoint>,
        transform: undefined.Matrix3x2): undefined.InkStroke;

    /**
     * Stops building the ink stroke.
     * @param pointerPoint The last point for the stroke.
     * @return  The stroke built from the points.
     */
    endStroke(pointerPoint: undefined.PointerPoint): undefined.InkStroke;

    /**
     * Sets the default InkDrawingAttributes for all new ink strokes created after the current stroke.
     * @param drawingAttributes The default attributes.
     */
    setDefaultDrawingAttributes(drawingAttributes: undefined.InkDrawingAttributes): void
}


/**
 * Provides properties and methods to store and manage the collection of InkStroke objects rendered by the InkPresenter . 
 */
declare class InkStrokeContainer {

    /**
     * Creates a new InkStrokeContainer object that is used to manage InkStroke objects. 
     */
    constructor(): this;

    /**
     * Adds an InkStroke object to the collection managed by the InkStrokeContainer .
     * @param stroke The ink stroke to be added.
     */
    addStroke(stroke: undefined.InkStroke): void;

    /**
     * Adds one or more ink strokes to the collection managed by the InkStrokeContainer .
     * @param strokes The ink strokes to be added as a collection of InkStroke objects.
     */
    addStrokes(strokes: undefined.IIterable<undefined.InkStroke>): void;

    /**
     * Gets the bounding rectangle of the InkStroke collection managed by the InkStrokeContainer . 
     */
    boundingRect: undefined.Rect;

    /**
     * Identifies whether content on the clipboard can be added to the InkStroke collection managed by the InkStrokeContainer .
     * @return  True if content can be pasted from the clipboard; otherwise, false.
     */
    canPasteFromClipboard(): boolean;

    /**
     * Deletes all InkStroke objects from the collection managed by the InkStrokeContainer . 
     */
    clear(): void;

    /**
     * Copies the selected InkStroke objects (from the InkStroke collection managed by the InkStrokeContainer ) to the clipboard in Ink Serialized Format (ISF) format. 
     */
    copySelectedToClipboard(): void;

    /**
     * Deletes the selected InkStroke objects from the InkStroke collection managed by the InkStrokeContainer .
     * @return  The bounding rectangle of the selected ink strokes, or the invalidated rectangle (0, 0, 0, 0) if no strokes were removed (no selected strokes).
     */
    deleteSelected(): undefined.Rect;

    /**
     * Gets the collection of recognition matches previously processed by an InkRecognizer and stored in an InkRecognizerContainer .
     * @return  The results of the recognition as a collection of InkRecognitionResult objects.
     */
    getRecognitionResults(): undefined.IVectorView<undefined.InkRecognitionResult>;

    /**
     * Retrieves all ink strokes in the collection managed by the InkStrokeContainer .
     * @return  The ink strokes managed by the InkStrokeContainer as a collection of InkStroke objects.
     */
    getStrokes(): undefined.IVectorView<undefined.InkStroke>;

    /**
     * Asynchronously loads all InkStroke objects from the specified stream to the InkStroke collection that is managed by the InkStrokeContainer .
     * @param inputStream The target stream.
     * @return  The status of the asynchronous operation as the number of bytes fetched. For more information, see ReadAsync method.
     */
    loadAsync(
        inputStream: undefined.IInputStream): undefined.IPromiseWithIAsyncActionWithProgress<number>;

    /**
     * Moves the selected strokes. All affected strokes are re-rendered.
     * @param translation The destination screen coordinates for the upper-left corner of the bounding rectangle of the selected strokes.
     * @return  The bounding rectangle of the selected ink strokes.
     */
    moveSelected(translation: undefined.Point): undefined.Rect;

    /**
     * Adds the InkStroke content from the clipboard to the InkStroke collection that is managed by the InkStrokeContainer and renders the new strokes..
     * @param position The screen coordinates for the upper-left corner of the bounding rectangle of the clipboard content.
     * @return  The invalidated bounding rectangle of the InkStroke collection.
     */
    pasteFromClipboard(position: undefined.Point): undefined.Rect;

    /**
     * Asynchronously saves all InkStroke objects in the InkStroke collection that is managed by the InkStrokeContainer to the specified stream.
     * @param outputStream The target stream. An IRandomAccessStream (requires IOutputStream ) object can be specified instead.
     * @return  The status of the asynchronous operation as the number of bytes sent. For more information, see WriteAsync method.
     */
    saveAsync(
        outputStream: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperationWithProgress<number, number>;

    /**
     * Selects all strokes intersected by the new stroke.
     * @param from The start of the line.
     * @param to The of the line.
     * @return  The bounding rectangle of the selected ink strokes.
     */
    selectWithLine(from: undefined.Point, to: undefined.Point): undefined.Rect;

    /**
     * Selects all strokes contained entirely within the polyline.
     * @param polyline The points of the polyline.
     * @return  The bounding rectangle of the selected ink strokes.
     */
    selectWithPolyLine(polyline: undefined.IIterable<undefined.Point>): undefined.Rect;

    /**
     * Updates the collection of recognition matches previously processed by an InkRecognizer and stored in an InkRecognizerContainer .
     * @param recognitionResults The updated collection of InkRecognitionResult objects.
     */
    updateRecognitionResults(
        recognitionResults: undefined.IVectorView<undefined.InkRecognitionResult>): void
}


/**
 * A single segment of a complete ink stroke. 
 */
declare class InkStrokeRenderingSegment {

    /**
     * Gets the first control point for the Bézier curve. 
     */
    bezierControlPoint1: undefined.Point;

    /**
     * Gets the second control point for the Bézier curve. 
     */
    bezierControlPoint2: undefined.Point;

    /**
     * Gets the end point of the segment. 
     */
    position: undefined.Point;

    /**
     * Gets the pressure of the contact on the digitizer surface. 
     */
    pressure: number;

    /**
     * Gets the tilt of the contact along the x axis. 
     */
    tiltX: number;

    /**
     * Gets the tilt of the contact along the y axis. 
     */
    tiltY: number;

    /**
     * Gets the twist of the contact along the rotational axis. 
     */
    twist: number
}


/**
 * Enables an app to override the system processing of raw keyboard input, including key combinations such as shortcut keys, access keys (or hot keys), accelerator keys, and application keys. 
 */
declare class KeyboardDeliveryInterceptor {

    /**
     * Retrieves a KeyboardDeliveryInterceptor object associated with the current app view.
     * @return  The KeyboardDeliveryInterceptor object associated with the current app.
     */
    getForCurrentView(): undefined.KeyboardDeliveryInterceptor;

    /**
     * Gets or sets whether the app overrides the system processing of raw keyboard input, including key combinations such as shortcut keys, access keys (or hot keys), accelerator keys, and application keys. 
     */
    isInterceptionEnabledWhenInForeground: boolean;

    /**
     * Occurs when a keyboard key is pressed. State info and event data is routed through this event instead of CoreWindow.KeyDown . 
     */
    onkeydown: undefined.TypedEventHandler<undefined.KeyboardDeliveryInterceptor, any>;
    addEventListener(
        type: "keydown",
        listener: undefined.TypedEventHandler<undefined.KeyboardDeliveryInterceptor, any>): void;
    removeEventListener(
        type: "keydown",
        listener: undefined.TypedEventHandler<undefined.KeyboardDeliveryInterceptor, any>): void;

    /**
     * Occurs when a pressed keyboard key is released. State info and event data is routed through this event instead of CoreWindow.KeyUp . 
     */
    onkeyup: undefined.TypedEventHandler<undefined.KeyboardDeliveryInterceptor, any>;
    addEventListener(
        type: "keyup",
        listener: undefined.TypedEventHandler<undefined.KeyboardDeliveryInterceptor, any>): void;
    removeEventListener(
        type: "keyup",
        listener: undefined.TypedEventHandler<undefined.KeyboardDeliveryInterceptor, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains event data for the ManipulationCompleted event. 
 */
declare class ManipulationCompletedEventArgs {

    /**
     * Gets values that indicate the accumulated transformation deltas (translation, rotation, scale) of a completed manipulation (from the start of the manipulation to the end of inertia). 
     */
    cumulative: undefined.ManipulationDelta;

    /**
     * Gets the device type of the input source. 
     */
    pointerDeviceType: undefined.PointerDeviceType;

    /**
     * Gets the location of the pointer associated with the manipulation for the last manipulation event. 
     */
    position: undefined.Point;

    /**
     * Gets values that indicate the velocities of the transformation deltas (translation, rotation, scale) for a manipulation at the ManipulationCompleted event. 
     */
    velocities: undefined.ManipulationVelocities
}


/**
 * Contains event data for the GestureRecognizer.ManipulationInertiaStartingEvent . 
 */
declare class ManipulationInertiaStartingEventArgs {

    /**
     * Gets values that indicate the accumulated transformation deltas (translation, rotation, scale) for a manipulation before inertia begins. 
     */
    cumulative: undefined.ManipulationDelta;

    /**
     * Gets values that indicate the changes in the transformation deltas (translation, rotation, scale) of a manipulation since the last manipulation event. 
     */
    delta: undefined.ManipulationDelta;

    /**
     * Gets the device type of the input source. 
     */
    pointerDeviceType: undefined.PointerDeviceType;

    /**
     * Gets the location of the pointer associated with the manipulation for the last manipulation event. 
     */
    position: undefined.Point;

    /**
     * Gets values that indicate the velocities of the transformation deltas (translation, rotation, scale) for a manipulation at the ManipulationInertiaStarting event. 
     */
    velocities: undefined.ManipulationVelocities
}


/**
 * Contains event data for the ManipulationStarted event. 
 */
declare class ManipulationStartedEventArgs {

    /**
     * Gets values that indicate the accumulated transformation deltas (translation, rotation, scale) for a manipulation before the ManipulationStarted event. 
     */
    cumulative: undefined.ManipulationDelta;

    /**
     * Gets the device type of the input source. 
     */
    pointerDeviceType: undefined.PointerDeviceType;

    /**
     * Gets the location of the pointer associated with the manipulation for the last manipulation event. 
     */
    position: undefined.Point
}


/**
 * Contains event data for the ManipulationUpdated event. 
 */
declare class ManipulationUpdatedEventArgs {

    /**
     * Gets values that indicate the accumulated transformation deltas (translation, rotation, scale) for a manipulation from the beginning of the interaction to the ManipulationUpdated event. 
     */
    cumulative: undefined.ManipulationDelta;

    /**
     * Gets values that indicate the changes in the transformation deltas (translation, rotation, scale) of a manipulation since the last manipulation event. 
     */
    delta: undefined.ManipulationDelta;

    /**
     * Gets the device type of the input source. 
     */
    pointerDeviceType: undefined.PointerDeviceType;

    /**
     * Gets the location of the pointer associated with the manipulation for the last manipulation event. 
     */
    position: undefined.Point;

    /**
     * Gets values that indicate the velocities of the transformation deltas (translation, rotation, scale) for a manipulation at the ManipulationUpdated event. 
     */
    velocities: undefined.ManipulationVelocities
}


/**
 * Provides properties associated with the button wheel of a mouse device. 
 */
declare class MouseWheelParameters {

    /**
     * Gets or sets the device-independent pixel (DIP) conversion factors for both character width and line height units (as set in the Wheel settings of the Mouse control panel). 
     */
    charTranslation: undefined.Point;

    /**
     * Gets or sets a value that indicates the change in the angle of rotation associated with input from the wheel button of a mouse. 
     */
    deltaRotationAngle: number;

    /**
     * Gets or sets a value that indicates the change in scale associated with input from the wheel button of a mouse. 
     */
    deltaScale: number;

    /**
     * Gets or sets the device-independent pixel (DIP) conversion factors for both page width and height units (as set in the Wheel settings of the Mouse control panel). 
     */
    pageTranslation: undefined.Point
}


/**
 * Provides basic properties for the input pointer associated with a single mouse, pen/stylus, or touch contact. 
 */
declare class PointerPoint {

    /**
     * Retrieves position and state information for the specified pointer.
     * @param pointerId The ID of the pointer.
     * @return  The pointer property values.
     */
    getCurrentPoint(pointerId: number): undefined.PointerPoint;

    /**
     * Retrieves the transformed information for the specified pointer.
     * @param pointerId The ID of the pointer.
     * @param transform The transform to apply to the pointer.
     * @return  The pointer property values.
     */
    getCurrentPoint(
        pointerId: number,
        transform: undefined.IPointerPointTransform): undefined.PointerPoint;

    /**
     * Retrieves the transformed position and state information for the specified pointer, from the last pointer event up to and including the current pointer event.
     * @param pointerId The ID of the pointer.
     * @param transform The transform to apply to the pointer.
     * @return  The transformed pointer properties (current and historic).
     */
    getIntermediatePoints(
        pointerId: number,
        transform: undefined.IPointerPointTransform): undefined.IVector<undefined.PointerPoint>;

    /**
     * Retrieves position and state information for the specified pointer, from the last pointer event up to and including the current pointer event.
     * @param pointerId The ID of the pointer.
     * @return  The transformed pointer properties (current and historic).
     */
    getIntermediatePoints(pointerId: number): undefined.IVector<undefined.PointerPoint>;

    /**
     * Gets the ID of an input frame. 
     */
    frameId: number;

    /**
     * Gets a value that indicates whether the physical entity (touch, pen/stylus, or mouse button) is pressed down. 
     */
    isInContact: boolean;

    /**
     * Gets information about the device associated with the input pointer. 
     */
    pointerDevice: undefined.PointerDevice;

    /**
     * Gets a unique identifier for the input pointer. 
     */
    pointerId: number;

    /**
     * Gets the location of the pointer input in client coordinates. 
     */
    position: undefined.Point;

    /**
     * Gets extended information about the input pointer. 
     */
    properties: undefined.PointerPointProperties;

    /**
     * Gets the raw location of the pointer input in client coordinates. 
     */
    rawPosition: undefined.Point;

    /**
     * Gets the time when the input occurred. 
     */
    timestamp: number
}


/**
 * Provides extended properties for a PointerPoint object. 
 */
declare class PointerPointProperties {

    /**
     * Gets the bounding rectangle of the contact area (typically from touch input). 
     */
    contactRect: undefined.Rect;

    /**
     * Gets the bounding rectangle of the raw input (typically from touch input). 
     */
    contactRectRaw: undefined.Rect;

    /**
     * Gets the Human Interface Device (HID) usage value of the raw input.
     * @param usagePage The HID usage page of the pointer device.
     * @param usageId Indicates a usage in a usage page.
     * @return  The extended usage of the raw input pointer.
     */
    getUsageValue(usagePage: number, usageId: number): number;

    /**
     * Gets a value that indicates whether the input data from the pointer device contains the specified Human Interface Device (HID) usage information.
     * @param usagePage The HID usage page of the pointer device.
     * @param usageId Indicates a usage in a usage page.
     * @return  True if the input data includes usage information; otherwise false.
     */
    hasUsage(usagePage: number, usageId: number): boolean;

    /**
     * Gets a value that indicates whether the barrel button of the pen/stylus device is pressed. 
     */
    isBarrelButtonPressed: boolean;

    /**
     * Gets a value that indicates whether the input was canceled by the pointer device. 
     */
    isCanceled: boolean;

    /**
     * Gets a value that indicates whether the input is from a digitizer eraser. 
     */
    isEraser: boolean;

    /**
     * Gets a value that indicates whether the input is from a mouse tilt wheel. 
     */
    isHorizontalMouseWheel: boolean;

    /**
     * Gets a value that indicates whether the pointer device is within detection range of a sensor or digitizer. 
     */
    isInRange: boolean;

    /**
     * Gets a value that indicates whether the digitizer pen is inverted. 
     */
    isInverted: boolean;

    /**
     * Gets a value that indicates whether the input is from the left button of a mouse or other input method. 
     */
    isLeftButtonPressed: boolean;

    /**
     * Gets a value that indicates whether the input is from the middle button of a mouse or other input method. 
     */
    isMiddleButtonPressed: boolean;

    /**
     * Gets a value that indicates whether the input is from the primary pointer when multiple pointers are registered. 
     */
    isPrimary: boolean;

    /**
     * Gets a value that indicates whether the input is from the right button of a mouse or other input method. 
     */
    isRightButtonPressed: boolean;

    /**
     * Gets the pressed state of the first extended mouse button. 
     */
    isXButton1Pressed: boolean;

    /**
     * Gets the pressed state of the second extended mouse button. 
     */
    isXButton2Pressed: boolean;

    /**
     * Gets a value (the raw value reported by the device) that indicates the change in wheel button input from the last pointer event. 
     */
    mouseWheelDelta: number;

    /**
     * Gets the counter-clockwise angle of rotation around the major axis of the pointer device (the z-axis, perpendicular to the surface of the digitizer). A value of 0.0 degrees indicates the device is oriented towards the top of the digitizer. 
     */
    orientation: number;

    /**
     * Gets the kind of pointer state change. 
     */
    pointerUpdateKind: undefined.PointerUpdateKind;

    /**
     * Gets a value that indicates the force that the pointer device (typically a pen/stylus) exerts on the surface of the digitizer. 
     */
    pressure: number;

    /**
     * Gets a value that indicates whether the pointer device rejected the touch contact. 
     */
    touchConfidence: boolean;

    /**
     * Gets the clockwise rotation in degrees of a pen device around its own major axis (such as when the user spins the pen in their fingers). 
     */
    twist: number;

    /**
     * Gets the plane angle between the Y-Z plane and the plane that contains the Y axis and the axis of the input device (typically a pen/stylus). 
     */
    xtilt: number;

    /**
     * Gets the plane angle between the X-Z plane and the plane that contains the X axis and the axis of the input device (typically a pen/stylus). 
     */
    ytilt: number;
    zdistance: any
}


/**
 * Provides access to the visual feedback settings for pointer input. 
 */
declare class PointerVisualizationSettings {

    /**
     * Gets a PointerVisualizationSettings object associated with the current app.
     * @return  The PointerVisualizationSettings object associated with the current app.
     */
    getForCurrentView(): undefined.PointerVisualizationSettings;

    /**
     * Gets or sets a value that indicates whether visual feedback is enabled for pen/stylus input when the barrel button is pressed. 
     */
    isBarrelButtonFeedbackEnabled: boolean;

    /**
     * Gets or sets a value that indicates whether visual feedback is enabled when a pointer contact is detected. 
     */
    isContactFeedbackEnabled: boolean
}


/**
 * Contains event data for the RightTapped event. 
 */
declare class RightTappedEventArgs {

    /**
     * Gets the device type of the input source. 
     */
    pointerDeviceType: undefined.PointerDeviceType;

    /**
     * Gets the location of the touch, mouse, or pen/stylus contact. 
     */
    position: undefined.Point
}

declare class SpatialGestureRecognizer {
    addEventListener: any;
    cancelPendingGestures: any;
    captureInteraction: any;
    gestureSettings: any;
    onholdcanceled: any;
    onholdcompleted: any;
    onholdstarted: any;
    onmanipulationcanceled: any;
    onmanipulationcompleted: any;
    onmanipulationstarted: any;
    onmanipulationupdated: any;
    onnavigationcanceled: any;
    onnavigationcompleted: any;
    onnavigationstarted: any;
    onnavigationupdated: any;
    onrecognitionended: any;
    onrecognitionstarted: any;
    ontapped: any;
    removeEventListener: any;
    trySetGestureSettings: any
}

declare
var none: any;

declare
var tap: any;

declare
var doubleTap: any;

declare
var hold: any;

declare
var manipulationTranslate: any;

declare
var navigationX: any;

declare
var navigationY: any;

declare
var navigationZ: any;

declare
var navigationRailsX: any;

declare
var navigationRailsY: any;

declare
var navigationRailsZ: any;

declare class SpatialHoldCanceledEventArgs {
    interactionSourceKind: any
}

declare class SpatialHoldCompletedEventArgs {
    interactionSourceKind: any
}

declare class SpatialHoldStartedEventArgs {
    interactionSourceKind: any;
    tryGetPointerPose: any
}

declare class SpatialInteraction {
    sourceState: any
}

declare class SpatialInteractionDetectedEventArgs {
    interaction: any;
    interactionSourceKind: any;
    tryGetPointerPose: any
}

declare class SpatialInteractionManager {
    getForCurrentView: any;
    addEventListener: any;
    getDetectedSourcesAtTimestamp: any;
    oninteractiondetected: any;
    onsourcedetected: any;
    onsourcelost: any;
    onsourcepressed: any;
    onsourcereleased: any;
    onsourceupdated: any;
    removeEventListener: any
}

declare class SpatialInteractionSource {
    id: any;
    kind: any
}

declare class SpatialInteractionSourceEventArgs {
    state: any
}

declare
var other: any;

declare
var hand: any;

declare
var voice: any;

declare
var controller: any;

declare class SpatialInteractionSourceLocation {
    position: any;
    velocity: any
}

declare class SpatialInteractionSourceProperties {
    sourceLossRisk: any;
    tryGetLocation: any;
    tryGetSourceLossMitigationDirection: any
}

declare class SpatialInteractionSourceState {
    isPressed: any;
    properties: any;
    source: any;
    timestamp: any;
    tryGetPointerPose: any
}

declare class SpatialManipulationCanceledEventArgs {
    interactionSourceKind: any
}

declare class SpatialManipulationCompletedEventArgs {
    interactionSourceKind: any;
    tryGetCumulativeDelta: any
}

declare class SpatialManipulationDelta {
    translation: any
}

declare class SpatialManipulationStartedEventArgs {
    interactionSourceKind: any;
    tryGetPointerPose: any
}

declare class SpatialManipulationUpdatedEventArgs {
    interactionSourceKind: any;
    tryGetCumulativeDelta: any
}

declare class SpatialNavigationCanceledEventArgs {
    interactionSourceKind: any
}

declare class SpatialNavigationCompletedEventArgs {
    interactionSourceKind: any;
    normalizedOffset: any
}

declare class SpatialNavigationStartedEventArgs {
    interactionSourceKind: any;
    isNavigatingX: any;
    isNavigatingY: any;
    isNavigatingZ: any;
    tryGetPointerPose: any
}

declare class SpatialNavigationUpdatedEventArgs {
    interactionSourceKind: any;
    normalizedOffset: any
}

declare class SpatialPointerPose {
    tryGetAtTimestamp: any;
    head: any;
    timestamp: any
}

declare class SpatialRecognitionEndedEventArgs {
    interactionSourceKind: any
}

declare class SpatialRecognitionStartedEventArgs {
    interactionSourceKind: any;
    isGesturePossible: any;
    tryGetPointerPose: any
}

declare class SpatialTappedEventArgs {
    interactionSourceKind: any;
    tapCount: any;
    tryGetPointerPose: any
}


/**
 * Contains event data for the Tapped event. 
 */
declare class TappedEventArgs {

    /**
     * Gets the device type of the input source. 
     */
    pointerDeviceType: undefined.PointerDeviceType;

    /**
     * Gets the location of the touch, mouse, or pen/stylus contact. 
     */
    position: undefined.Point;

    /**
     * Gets the number of times the tap interaction was detected. 
     */
    tapCount: number
}


/**
 * Contains the distance thresholds for a CrossSliding interaction. 
 */
declare interface Input$CrossSlideThresholds {

    /**
     * The distance, in DIPs, from the initial point of contact until the rearrange action is initiated. 
     */
    rearrangeStart: number,

        /**
         * The distance, in DIPs, from the initial point of contact until the selection action is initiated. 
         */
        selectionStart: number,

        /**
         * The distance, in DIPs, from the initial point of contact until the end of the speed bump. 
         */
        speedBumpEnd: number,

        /**
         * The distance, in DIPs, from the initial point of contact until the speed bump is initiated. 
         */
        speedBumpStart: number
}


/**
 * Contains the accumulated transformations for the current manipulation. 
 */
declare interface Input$ManipulationDelta {

    /**
     * The change in distance between touch contacts, as DIPs. For example, if the distance between two contacts changes from 100 DIPs to 200 DIPs during a manipulation, the value of Expansion would be 100.0. 
     */
    expansion: number,

        /**
         * The change in angle of rotation, in degrees. 
         */
        rotation: number,

        /**
         * The change in distance between touch contacts, as a percentage. For example, if the distance between two contacts changes from 100 DIPs to 200 DIPs during a manipulation, the value of Scale would be 1.0. 
         */
        scale: number,

        /**
         * The change in x-y screen coordinates, in DIPs. 
         */
        translation: undefined.Point
}


/**
 * Contains the velocities of the accumulated transformations for the current interaction. 
 */
declare interface Input$ManipulationVelocities {

    /**
     * The rotational velocity in degrees per millisecond. 
     */
    angular: number,

        /**
         * The expansion, or scaling, velocity in DIPs per millisecond. 
         */
        expansion: number,

        /**
         * The straight line velocity in DIPs per millisecond. 
         */
        linear: undefined.Point
}


/**
 * Provides generalized transformation functions. 
 */
declare interface Input$IPointerPointTransform {

    /**
     * Transforms the specified bounding rectangle.
     * @param rect The bounding rectangle to transform.
     * @return  The smallest, axis-aligned bounding box that encloses rect after the transformation. (An axis-aligned bounding box is one which has all sides parallel to the coordinate axes.)
     */
    transformBounds(rect: undefined.Rect): undefined.Rect,

        /**
         * Attempts to perform the transformation on the specified input point.
         * @param inPoint The original input point.
         */
        tryTransform(inPoint: undefined.Point): {
            outPoint: undefined.Point,
            returnValue: boolean
        },

        /**
         * Gets the inverse of the specified transformation. 
         */
        inverse: undefined.IPointerPointTransform
}


/**
 * Defines the content, associated metadata, and expiration time of an update to a tile's badge overlay. A badge can display a number from 1 to 99 or a status glyph. 
 */
declare class BadgeNotification {

    /**
     * Creates and initializes a new instance of the BadgeNotification .
     * @param content The XML content that defines the badge update.
     */
    constructor(content: undefined.XmlDocument): this;

    /**
     * Gets the XML that defines the value or glyph used as the tile's badge. 
     */
    content: undefined.XmlDocument;

    /**
     * Gets or sets the time that Windows will remove the badge from the tile. By default, local badge notifications do not expire and push, periodic, and scheduled badge notifications expire after three days. It is a best practice to explicitly set an expiration time to avoid stale content. 
     */
    expirationTime: Date
}


/**
 * Creates BadgeUpdater objects that you use to manipulate a tile's badge overlay. This class also provides access to the XML content of the system-provided badge templates so that you can customize that content for use in updating your badges. 
 */
declare class BadgeUpdateManager {

    /**
     * Creates and initializes a new instance of the BadgeUpdater , which lets you change the appearance or content of the badge on the calling app's tile.
     * @return  The object you will use to send changes to the app tile's badge.
     */
    createBadgeUpdaterForApplication(): undefined.BadgeUpdater;

    /**
     * Creates and initializes a new instance of the BadgeUpdater for a specified app tile's badge, usually the tile of another app in the package. The BadgeUpdater lets you change the appearance or content of that badge.
     * @param applicationId The unique ID of the tile whose badge you want to update.
     * @return  The object you will use to send changes to the application tile's badge.
     */
    createBadgeUpdaterForApplication(applicationId: string): undefined.BadgeUpdater;

    /**
     * Creates and initializes a new instance of the BadgeUpdater , which enables you to change the appearance or content of a badge on a secondary tile . The tile can belong to the calling app or any other app in the same package.
     * @param tileId The unique ID of the tile.
     * @return  The object you will use to send badge updates to the tile identified by tileID.
     */
    createBadgeUpdaterForSecondaryTile(tileId: string): undefined.BadgeUpdater;

    /**
     * Gets the XML content of one of the predefined badge templates so that you can customize it for a badge update.
     * @param type The type of badge template, either a glyph or a number.
     * @return  The object that contains the template XML.
     */
    getTemplateContent(type: undefined.BadgeTemplateType): undefined.XmlDocument
}


/**
 * Updates a badge overlay on the specific tile that the updater is bound to. 
 */
declare class BadgeUpdater {

    /**
     * Removes the badge from the tile that the updater is bound to. 
     */
    clear(): void;

    /**
     * Begins a series of timed updates for the badge from a web resource that the updater is bound to. Updates begin at a specified time. Note that only web resources (http/https) are allowed in a periodic update.
     * @param badgeContent The URI from which the XML content of the badge update will be retrieved.
     * @param startTime The time at which the URI should first be polled for new badge content.
     * @param requestedInterval The frequency with which the URI is polled for new badge content, following the initial update at startTime.
     */
    startPeriodicUpdate(
        badgeContent: undefined.Uri,
        startTime: Date,
        requestedInterval: undefined.PeriodicUpdateRecurrence): void;

    /**
     * Begins a series of timed updates for the badge from a web resource that the updater is bound to, beginning immediately. Note that only web resources (http/https) are allowed in a periodic update.
     * @param badgeContent The URI from which the XML content of the badge update will be retrieved.
     * @param requestedInterval The frequency with which the URI is polled for new badge content.
     */
    startPeriodicUpdate(
        badgeContent: undefined.Uri,
        requestedInterval: undefined.PeriodicUpdateRecurrence): void;

    /**
     * Cancels the current series of timed updates for the badge that the updater is bound to. 
     */
    stopPeriodicUpdate(): void;

    /**
     * Applies a change to the badge's glyph or number.
     * @param notification The object that supplies the new XML definition for the badge.
     */
    update(notification: undefined.BadgeNotification): void
}


/**
 * Defines the visual content and timing for a single, non-recurring scheduled update to a tile. 
 */
declare class ScheduledTileNotification {

    /**
     * Creates and initializes a new instance of the ScheduledTileNotification object for use with a TileUpdater .
     * @param content The object that provides the content for the tile notification.
     * @param deliveryTime The time at which the tile should be updated with the notification information.
     */
    constructor(content: undefined.XmlDocument, deliveryTime: Date): this;

    /**
     * Gets the XML description of the content of the scheduled tile update. 
     */
    content: undefined.XmlDocument;

    /**
     * Gets the time at which the tile is scheduled to be updated. 
     */
    deliveryTime: Date;

    /**
     * Gets or sets the time after which the tile notification should no longer be shown. By default, a tile notification does not expire. It is a best practice to explicitly set an expiration time to avoid stale content. 
     */
    expirationTime: Date;

    /**
     * Gets or sets the unique ID that is used to identify the scheduled tile in the schedule. 
     */
    id: string;

    /**
     * Gets or sets a string that Windows can use to prevent duplicate notification content from appearing in the queue. 
     */
    tag: string
}


/**
 * Contains the XML that defines the toast notification that will display at the scheduled time. 
 */
declare class ScheduledToastNotification {

    /**
     * Creates and initializes a new instance of a recurring ScheduledToastNotification .
     * @param content The XML that defines the toast notification content.
     * @param deliveryTime The date and time that Windows should first display the toast notification. You must call AddToSchedule before this time.
     * @param snoozeInterval The amount of time between occurrences of the notification. To be valid, this value must be no less than 60 seconds and no more than 60 minutes.
     * @param maximumSnoozeCount The maximum number of times to display this notification. Valid values range from 1 to 5.
     */
    constructor(content: undefined.XmlDocument, deliveryTime: Date, snoozeInterval: number, maximumSnoozeCount: number): this;

    /**
     * Creates and initializes a new instance of a ScheduledToastNotification that will be displayed only once.
     * @param content The XML that defines the toast notification content.
     * @param deliveryTime The date and time that Windows should display the toast notification. You must call AddToSchedule before this time.
     */
    constructor(content: undefined.XmlDocument, deliveryTime: Date): this;

    /**
     * Gets the XML that defines this scheduled toast notification. 
     */
    content: undefined.XmlDocument;

    /**
     * Gets the time that this toast notification is scheduled to be displayed. 
     */
    deliveryTime: Date;

    /**
     * Gets or sets the group identifier for the notification. 
     */
    group: string;

    /**
     * Gets a developer-specified value used to identify a specific scheduled toast. 
     */
    id: string;

    /**
     * Gets the maximum number of times to display this notification. 
     */
    maximumSnoozeCount: number;

    /**
     * Gets the amount of time between occurrences of the notification. 
     */
    snoozeInterval: number;

    /**
     * Gets or sets whether a toast's pop-up UI is displayed on the Windows Phone 8.1 screen. 
     */
    suppressPopup: boolean;

    /**
     * Gets or sets a string that uniquely identifies a toast notification inside a Group . 
     */
    tag: string
}

declare class TileFlyoutNotification {
    content: any;
    expirationTime: any
}

declare
var tileFlyoutTemplate01: any;

declare class TileFlyoutUpdateManager {
    createTileFlyoutUpdaterForApplication: any;
    createTileFlyoutUpdaterForSecondaryTile: any;
    getTemplateContent: any
}

declare class TileFlyoutUpdater {
    clear: any;
    setting: any;
    startPeriodicUpdate: any;
    stopPeriodicUpdate: any;
    update: any
}


/**
 * Defines an update to a tile, including its visuals, identification tag, and expiration time. 
 */
declare class TileNotification {

    /**
     * Creates and initializes a new instance of the TileNotification object for use with a TileUpdater .
     * @param content The object that provides the content for the tile notification.
     */
    constructor(content: undefined.XmlDocument): this;

    /**
     * Gets the XML description of the notification content, which you can then manipulate to alter the notification. 
     */
    content: undefined.XmlDocument;

    /**
     * Gets or sets the time that Windows will remove the notification from the tile. By default, a tile update does not expire. It is a best practice to explicitly set an expiration time to avoid stale content. 
     */
    expirationTime: Date;

    /**
     * Gets or sets a string that Windows can use to prevent duplicate notification content from appearing in the queue. 
     */
    tag: string
}


/**
 * Creates TileUpdater objects used to change and update Start menu tiles. This class also provides access to the XML content of the system-provided tile templates so that you can customize that content for use in updating your tiles. 
 */
declare class TileUpdateManager {

    /**
     * Creates and initializes a new instance of the TileUpdater , which lets you change the appearance of the calling app's tile.
     * @return  The object you will use to send changes to the app's tile.
     */
    createTileUpdaterForApplication(): undefined.TileUpdater;

    /**
     * Creates and initializes a new instance of the TileUpdater for a tile that belongs to another app in the same package as the calling app. The TileUpdater lets a developer change the appearance of that tile.
     * @param applicationId The Package Relative Application ID (PRAID) of the tile.
     * @return  The object you will use to send changes to the tile identified by applicationId.
     */
    createTileUpdaterForApplication(applicationId: string): undefined.TileUpdater;

    /**
     * Creates and initializes a new instance of the TileUpdater , which enables you to change the appearance of a secondary tile . The tile can belong to the calling app or any other app in the same package.
     * @param tileId A unique ID for the tile.
     * @return  The object you will use to send updates to the tile identified by tileID.
     */
    createTileUpdaterForSecondaryTile(tileId: string): undefined.TileUpdater;

    /**
     * Gets the XML content of one of the predefined tile templates so that you can customize it for a tile update.
     * @param type The name of the template.
     * @return  The object that contains the XML.
     */
    getTemplateContent(type: undefined.TileTemplateType): undefined.XmlDocument
}


/**
 * Changes the content of the specific tile that the updater is bound to. 
 */
declare class TileUpdater {

    /**
     * Adds a ScheduledTileNotification to the schedule.
     * @param scheduledTile The scheduled tile update object.
     */
    addToSchedule(scheduledTile: undefined.ScheduledTileNotification): void;

    /**
     * Removes all updates and causes the tile to display its default content as declared in the app's manifest. 
     */
    clear(): void;

    /**
     * Enables the tile to queue up to five notifications. This enables the notification queue on all tile sizes.
     * @param enable True to enable queuing; otherwise false.
     */
    enableNotificationQueue(enable: boolean): void;

    /**
     * Enables the tile to queue up to five notifications on the medium tile.
     * @param enable True to enable queuing on this tile size; otherwise false.
     */
    enableNotificationQueueForSquare150x150(enable: boolean): void;

    /**
     * Enables the tile to queue up to five notifications on the large tile.
     * @param enable True to enable queuing on this tile size; otherwise false.
     */
    enableNotificationQueueForSquare310x310(enable: boolean): void;

    /**
     * Enables the tile to queue up to five notifications on the wide tile.
     * @param enable True to enable queuing on this tile size; otherwise false.
     */
    enableNotificationQueueForWide310x150(enable: boolean): void;

    /**
     * Retrieves a list of scheduled updates to the tile.
     * @return  The collection of scheduled updates for this tile.
     */
    getScheduledTileNotifications(): undefined.IVectorView<undefined.ScheduledTileNotification>;

    /**
     * Removes an upcoming tile update from the schedule.
     * @param scheduledTile The notification to remove from the schedule.
     */
    removeFromSchedule(scheduledTile: undefined.ScheduledTileNotification): void;

    /**
     * Gets a value that specifies whether a tile can be updated through notifications. 
     */
    setting: undefined.NotificationSetting;

    /**
     * Begins a series of timed content changes for the tile that the updater is bound to, beginning immediately.
     * @param tileContent The URI from which the XML content of the tile update will be retrieved.
     * @param requestedInterval The frequency with which the URI is polled for new tile content, following the initial update at startTime.
     */
    startPeriodicUpdate(
        tileContent: undefined.Uri,
        requestedInterval: undefined.PeriodicUpdateRecurrence): void;

    /**
     * Begins a series of timed updates for the tile that the updater is bound to. Update content is retrieved from a specified Uniform Resource Identifier (URI). Updates begin at a specified time.
     * @param tileContent The URI from which the XML content of the tile update will be retrieved.
     * @param startTime The time at which the URI should first be polled for new tile content.
     * @param requestedInterval The frequency with which the URI is polled for new tile content, following the initial update at startTime.
     */
    startPeriodicUpdate(
        tileContent: undefined.Uri,
        startTime: Date,
        requestedInterval: undefined.PeriodicUpdateRecurrence): void;

    /**
     * Begins a series of timed updates that cycle on the tile that the updater is bound to. Update content is retrieved from an array of specified Uniform Resource Identifiers (URIs), the first update happening immediately and subsequent updates occurring at the periodic interval thereafter.
     * @param tileContents An array of up to five URIs from which the XML content of the cycling tile updates will be retrieved. If the array contains more than five URIs, the method will fail.
     * @param requestedInterval The frequency with which the URI is polled for new tile content, following the initial update at startTime.
     */
    startPeriodicUpdateBatch(
        tileContents: undefined.IIterable<undefined.Uri>,
        requestedInterval: undefined.PeriodicUpdateRecurrence): void;

    /**
     * Begins a series of timed updates that cycle on the tile that the updater is bound to. Update content is retrieved from an array of specified Uniform Resource Identifiers (URIs) with updates beginning at a specified time and subsequent updates occurring at the periodic interval thereafter.
     * @param tileContents An array of up to five URIs from which the XML content of the cycling tile updates will be retrieved. If the array contains more than five URIs, the method will fail.
     * @param startTime The time at which the initial URI should first be polled for new content.
     * @param requestedInterval The frequency with which the URI is polled for new tile content, following the initial update at startTime.
     */
    startPeriodicUpdateBatch(
        tileContents: undefined.IIterable<undefined.Uri>,
        startTime: Date,
        requestedInterval: undefined.PeriodicUpdateRecurrence): void;

    /**
     * Cancels the current series of timed updates for the tile that the updater is bound to. 
     */
    stopPeriodicUpdate(): void;

    /**
     * Applies a change in content or appearance to the tile.
     * @param notification The object that supplies the new XML definition for the tile's content.
     */
    update(notification: undefined.TileNotification): void
}


/**
 * Exposes a method that retrieves the arguments associated with a toast action initiated by the user. This lets the app tell which action was taken when multiple actions were exposed. 
 */
declare class ToastActivatedEventArgs {

    /**
     * Gets the arguments associated with a toast action initiated by the user. This arguments string was included in the toast's XML payload. 
     */
    arguments: string
}


/**
 * Provides the reason that a toast notification is no longer displayed on-screen. 
 */
declare class ToastDismissedEventArgs {

    /**
     * Gets the reason that a toast notification is no longer displayed on-screen. 
     */
    reason: undefined.ToastDismissalReason
}


/**
 * Provides the error code that was generated in the process of raising a toast notification. 
 */
declare class ToastFailedEventArgs {

    /**
     * Gets the error code that was generated in the process of raising a toast notification. 
     */
    errorCode: Windows$WinRTError
}


/**
 * Defines the content, associated metadata and events, and expiration time of a toast notification. 
 */
declare class ToastNotification {

    /**
     * Creates and initializes a new instance of the ToastNotification .
     * @param content The XML content that defines the toast notification.
     */
    constructor(content: undefined.XmlDocument): this;

    /**
     * Gets the XML that defines the current toast notification. 
     */
    content: undefined.XmlDocument;

    /**
     * Gets or sets the time after which a toast notification should not be displayed. 
     */
    expirationTime: Date;

    /**
     * Gets or sets the group identifier for the notification. 
     */
    group: string;

    /**
     * Occurs when user activates a toast notification through a click or touch. Apps that are running subscribe to this event. 
     */
    onactivated: undefined.TypedEventHandler<undefined.ToastNotification, any>;
    addEventListener(
        type: "activated",
        listener: undefined.TypedEventHandler<undefined.ToastNotification, any>): void;
    removeEventListener(
        type: "activated",
        listener: undefined.TypedEventHandler<undefined.ToastNotification, any>): void;

    /**
     * Occurs when a toast notification leaves the screen, either by expiring or being explicitly dismissed by the user. Apps that are running subscribe to this event. 
     */
    ondismissed: undefined.TypedEventHandler<undefined.ToastNotification, undefined.ToastDismissedEventArgs>;
    addEventListener(
        type: "dismissed",
        listener: undefined.TypedEventHandler<undefined.ToastNotification, undefined.ToastDismissedEventArgs>): void;
    removeEventListener(
        type: "dismissed",
        listener: undefined.TypedEventHandler<undefined.ToastNotification, undefined.ToastDismissedEventArgs>): void;

    /**
     * Occurs when an error is caused when Windows attempts to raise a toast notification. Apps that are running subscribe to this event. 
     */
    onfailed: undefined.TypedEventHandler<undefined.ToastNotification, undefined.ToastFailedEventArgs>;
    addEventListener(
        type: "failed",
        listener: undefined.TypedEventHandler<undefined.ToastNotification, undefined.ToastFailedEventArgs>): void;
    removeEventListener(
        type: "failed",
        listener: undefined.TypedEventHandler<undefined.ToastNotification, undefined.ToastFailedEventArgs>): void;

    /**
     * Gets or sets whether a toast's pop-up UI is displayed on the Windows Phone 8.1 screen. 
     */
    suppressPopup: boolean;

    /**
     * Gets or sets the unique identifier of this notification within the notification Group . 
     */
    tag: string;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}

declare class ToastNotificationActionTriggerDetail {
    argument: any;
    userInput: any
}


/**
 * Manages the toast notifications for an app including the ability the clear all toast history and removing individual toasts. 
 */
declare class ToastNotificationHistory {

    /**
     * Removes all notifications from action center that were sent by another app inside the same app package.
     * @param applicationId The ID of the app inside the app package whose notifications are to be deleted.
     */
    clear(applicationId: string): void;

    /**
     * Removes all notifications sent by this app from action center. 
     */
    clear(): void;

    /**
     * Gets notification history, for a toast with the specified tag label, from action center.
     * @param applicationId The tag label for the toast being queried-for.
     * @return  A collection of toasts.
     */
    getHistory(applicationId: string): undefined.IVectorView<undefined.ToastNotification>;

    /**
     * Gets notification history, for all notifications sent by this app, from action center.
     * @return  A collection of toasts.
     */
    getHistory(): undefined.IVectorView<undefined.ToastNotification>;

    /**
     * Removes an individual toast, with the specified tag label, from action center.
     * @param tag The tag label of the toast notification to be removed.
     */
    remove(tag: string): void;

    /**
     * Removes an individual toast notification from action center, identified by the combination of tag label, group label and app ID.
     * @param tag The tag label of the toast notification to be removed.
     * @param group The group label of the toast notification to be removed.
     * @param applicationId The app ID of the app that sent the specified toast notification. This app must be part of the same app package as the app making this remove request.
     */
    remove(tag: string, group: string, applicationId: string): void;

    /**
     * Removes a toast notification from the action using the notification's tag and group labels.
     * @param tag The tag label of the toast notification to be removed.
     * @param group The group label of the toast notification to be removed.
     */
    remove(tag: string, group: string): void;

    /**
     * Removes a group of toast notifications, identified by the specified group label, from action center.
     * @param group The group label of the toast notifications to be removed.
     */
    removeGroup(group: string): void;

    /**
     * Removes a group of toast notifications sent by the another app inside the same app package from action center using the group label.
     * @param group The group label of the toast notifications to be removed.
     * @param applicationId The app ID of the app within the same app package of the calling app.
     */
    removeGroup(group: string, applicationId: string): void
}


/**
 * Represents the details of a toast history changed trigger. 
 */
declare class ToastNotificationHistoryChangedTriggerDetail {

    /**
     * Gets a value representing the kind of change that caused the toast history changed trigger. 
     */
    changeType: undefined.ToastHistoryChangedType
}


/**
 * Creates ToastNotifier objects that you use to raise toast notifications. This class also provides access to the XML content of the system-provided toast templates so that you can customize that content for use in your notifications. 
 */
declare class ToastNotificationManager {

    /**
     * Creates and initializes a new instance of the ToastNotification , bound to the calling application, that lets you raise a toast notification to that app.
     * @return  The object you will use to send the toast notification to the app.
     */
    createToastNotifier(): undefined.ToastNotifier;

    /**
     * Creates and initializes a new instance of the ToastNotification , bound to a specified app, usually another app in the same package.
     * @param applicationId The unique ID of the app.
     * @return  The object you will use to send the toast notification to the tile.
     */
    createToastNotifier(applicationId: string): undefined.ToastNotifier;

    /**
     * Gets the XML content of one of the predefined toast templates so that you can customize it for use in your notification.
     * @param type One of the system-provided toast templates.
     * @return  The object that contains the template XML.
     */
    getTemplateContent(type: undefined.ToastTemplateType): undefined.XmlDocument;

    /**
     * Gets the ToastNotificationHistory object. 
     */
    history: undefined.ToastNotificationHistory
}


/**
 * Raises a toast notification to the specific app to which the ToastNotifier is bound. This class also lets you schedule and remove toast notifications. 
 */
declare class ToastNotifier {

    /**
     * Adds a ScheduledToastNotification for later display by Windows.
     * @param scheduledToast The scheduled toast notification, which includes its content and timing instructions.
     */
    addToSchedule(scheduledToast: undefined.ScheduledToastNotification): void;

    /**
     * Gets the collection of ScheduledToastNotification objects that this app has scheduled for display.
     * @return  The collection of scheduled toast notifications that the app bound to this notifier has scheduled for timed display.
     */
    getScheduledToastNotifications(): undefined.IVectorView<undefined.ScheduledToastNotification>;

    /**
     * Removes the specified toast notification from the screen.
     * @param notification The object that specifies the toast to hide.
     */
    hide(notification: undefined.ToastNotification): void;

    /**
     * Cancels the scheduled display of a specified ScheduledToastNotification .
     * @param scheduledToast The notification to remove from the schedule.
     */
    removeFromSchedule(scheduledToast: undefined.ScheduledToastNotification): void;

    /**
     * Gets a value that tells you whether there is an app, user, or system block that prevents the display of a toast notification. 
     */
    setting: undefined.NotificationSetting;

    /**
     * Displays the specified toast notification.
     * @param notification The object that contains the content of the toast notification to display.
     */
    show(notification: undefined.ToastNotification): void
}


/**
 * Represents a dialog. The dialog has a command bar that can support up to three commands. If you don't specify any commands, then a default command is added to close the dialog. 
 */
declare class MessageDialog {

    /**
     * Initializes a new instance of the MessageDialog class to display a titled message dialog that can be used to ask your user simple questions.
     * @param content The message displayed to the user.
     * @param title The title you want displayed on the dialog.
     */
    constructor(content: string, title: string): this;

    /**
     * Initializes a new instance of the MessageDialog class to display an untitled message dialog that can be used to ask your user simple questions.
     * @param content The message displayed to the user.
     */
    constructor(content: string): this;

    /**
     * Gets or sets the index of the command you want to use as the cancel command. This is the command that fires when users press the ESC key. 
     */
    cancelCommandIndex: number;

    /**
     * Gets an array of commands that appear in the command bar of the message dialog. These commands makes the dialog actionable. 
     */
    commands: undefined.IVector<undefined.IUICommand>;

    /**
     * Gets or sets the message to be displayed to the user. 
     */
    content: string;

    /**
     * Gets or sets the index of the command you want to use as the default. This is the command that fires by default when users press the ENTER key. 
     */
    defaultCommandIndex: number;

    /**
     * Gets or sets the options for a MessageDialog . 
     */
    options: undefined.MessageDialogOptions;

    /**
     * Begins an asynchronous operation showing a dialog.
     * @return  An object that represents the asynchronous operation. For more on the async pattern, see Asynchronous programming.
     */
    showAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IUICommand>;

    /**
     * Gets or sets the title to display on the dialog, if any. 
     */
    title: string
}


/**
 * Represents a context menu. 
 */
declare class PopupMenu {

    /**
     * Creates a new instance of the PopupMenu class. 
     */
    constructor(): this;

    /**
     * Gets the commands for the context menu. 
     */
    commands: undefined.IVector<undefined.IUICommand>;

    /**
     * Shows the context menu at the specified client coordinates.
     * @param invocationPoint The coordinates (in DIPs), relative to the window, of the user's finger or mouse pointer when the oncontextmenu event fired. The menu is placed above and centered on this point.
     * @return  A IUICommand object that represents the context menu command that was invoked by the user, after the ShowAsync call completes.
     */
    showAsync(
        invocationPoint: undefined.Point): undefined.IPromiseWithIAsyncOperation<undefined.IUICommand>;

    /**
     * Shows the context menu above the specified selection.
     * @param selection The coordinates (in DIPs) of the selected rectangle, relative to the window. The context menu is placed directly above and centered on this rectangle such that selection is not covered.
     * @return  A IUICommand object that represents the context menu command invoked by the user, after the ShowForSelectionAsync call completes.
     */
    showForSelectionAsync(
        selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<undefined.IUICommand>;

    /**
     * Shows the context menu in the preferred placement relative to the specified selection.
     * @param selection The coordinates (in DIPs) of the selected rectangle, relative to the window.
     * @param preferredPlacement The preferred placement of the context menu relative to the selection rectangle.
     * @return  A IUICommand object that represents the context menu command invoked by the user, after the ShowForSelectionAsync call completes.
     */
    showForSelectionAsync(
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement): undefined.IPromiseWithIAsyncOperation<undefined.IUICommand >
}


/**
 * Represents a command in a context menu. 
 */
declare class UICommand {

    /**
     * Creates a new instance of the UICommand class. 
     */
    constructor(): this;

    /**
     * Creates a new instance of the UICommand class using the specified label and event handler.
     * @param label The label for the new command.
     * @param action The event handler for the new command.
     */
    constructor(label: string, action: undefined.UICommandInvokedHandler): this;

    /**
     * Creates a new instance of the UICommand class using the specified label, event handler, and command identifier.
     * @param label The label for the new command.
     * @param action The event handler for the new command.
     * @param commandId The command identifier for the new command.
     */
    constructor(label: string, action: undefined.UICommandInvokedHandler, commandId: any): this;

    /**
     * Creates a new instance of the UICommand class using the specified label.
     * @param label The label for the UICommand .
     */
    constructor(label: string): this;

    /**
     * Gets or sets the identifier of the command. 
     */
    id: any;

    /**
     * Gets or sets the handler for the event that is fired when the user selects the UICommand . 
     */
    invoked: undefined.UICommandInvokedHandler;

    /**
     * Gets or sets the label for the command. 
     */
    label: string
}


/**
 * Represents a command separator in a context menu. 
 */
declare class UICommandSeparator {

    /**
     * Creates a new instance of the UICommandSeparator class. 
     */
    constructor(): this;

    /**
     * Gets or sets the identifier of the command separator. 
     */
    id: any;

    /**
     * Gets or sets the handler for the event that is fired for the command separator. 
     */
    invoked: undefined.UICommandInvokedHandler;

    /**
     * Gets or sets the label for the command separator. 
     */
    label: string
}


/**
 * Represents a callback function that handles the event that is fired when the user invokes a context menu command. 
 */
declare type Popups$UICommandInvokedHandler = (command: undefined.IUICommand) => void;


/**
 * Represents a command in a context menu or message dialog box. 
 */
declare interface Popups$IUICommand {

    /**
     * Gets or sets the identifier of the command. 
     */
    id: any,

        /**
         * Gets or sets the handler for the event that is fired when the user invokes the command. 
         */
        invoked: undefined.UICommandInvokedHandler,

        /**
         * Gets or sets the label for the command. 
         */
        label: string
}


/**
 * Provides functionality for selecting the type of system-managed jump list that is used by an app, adding custom task entry points to an app's jump list, and adding custom groups to an app's jump list. A jump list consists of an optional system-provided list of items, as well as optional app-provided items. Not all device families support jump lists. 
 */
declare class JumpList {

    /**
     * Gets a value that indicates whether the system supports jump lists.
     * @return  A boolean value that is True if jump lists are supported. Otherwise, False.
     */
    isSupported(): boolean;

    /**
     * Asynchronously retrieves the current jump list and its items.
     * @return  When this method completes successfully, it returns the current JumpList . If the system does not support jump lists, this method returns an empty jump list and the SaveAsync method has no effect. Apps can check for this case using the isSupported method.
     */
    loadCurrentAsync(): undefined.IPromiseWithIAsyncOperation<undefined.JumpList>;

    /**
     * Gets the list of JumpListItem 's for the jump list. Items is of type IVector(JumpListItem) . 
     */
    items: undefined.IVector<undefined.JumpListItem>;

    /**
     * Asynchronously saves changes to the jump list and its items.
     * @return  Returns an IAsyncAction object that is used to control the asynchronous operation. If the system does not support jump lists, the SaveAsync method has no effect and future calls to LoadCurrentAsync will produce an empty jump list. An app can check for this case using the IsSupported method.
     */
    saveAsync(): undefined.IPromiseWithIAsyncAction;

    /**
     * Gets or sets the current type of the system managed jump list group. 
     */
    systemGroupKind: undefined.JumpListSystemGroupKind
}


/**
 * Provides functionality for creating and defining jump list items for an app's jump list. 
 */
declare class JumpListItem {

    /**
     * Creates a jump list item that is an inert separator for a custom group within the app's jump list.
     * @return  A jump list item that can be added to an app's jump list through the items property.
     */
    createSeparator(): undefined.JumpListItem;

    /**
     * Creates a new jump list item for an app's jump list.
     * @param arguments String that specifies any command line arguments that should be passed onto the app when the jump list item is selected by a user.
     * @param displayName String that specifies a display name for the jump list item. If localization is desired, this string must be a ms-resource: scheme specified URI.
     * @return  A jump list item with the specified parameters that can be added to an app's jump list through the items property.
     */
    createWithArguments(args: string, displayName: string): undefined.JumpListItem;

    /**
     * Gets the command line arguments for the jump list item. 
     */
    arguments: string;

    /**
     * Gets or sets the jump list item task description. 
     */
    description: string;

    /**
     * Gets or sets the jump list item display name. The display name can also be specified as a parameter using the CreateWithArguments method when the jump list item is created. 
     */
    displayName: string;

    /**
     * Gets or sets the jump list item custom group name. If no name is specified, the item will be added to the Tasks group by default. 
     */
    groupName: string;

    /**
     * Gets the JumpListItemKind of a jump list item. 
     */
    kind: undefined.JumpListItemKind;

    /**
     * Gets or sets the jump list item's logo. 
     */
    logo: undefined.Uri;

    /**
     * Gets a boolean indicating whether the jump list item was removed from the app's jump list by the user. 
     */
    removedByUser: boolean
}


/**
 * Creates, enumerates, and provides information about a secondary tile. 
 */
declare class SecondaryTile {

    /**
     * Checks whether a specific secondary tile exists for the calling app.
     * @param tileId The unique ID string that was assigned to the tile when it was created.
     * @return  True if the tile exists in the calling application; otherwise, false.
     */
    exists(tileId: string): boolean;

    /**
     * Retrieves a list of secondary tiles created for the calling app.
     * @return  An enumeration object that allows you to examine the set of tiles.
     */
    findAllAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a list of secondary tiles created for another app in the same package as the calling app.
     * @param applicationId The Package Relative Application ID (PRAID) of the app.
     * @return  An enumeration object that allows you to examine the set of tiles.
     */
    findAllAsync(
        applicationId: string): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Retrieves a list of secondary tiles created for all of the apps in the package of the calling app.
     * @return  An enumeration object that allows you to examine the set of tiles.
     */
    findAllForPackageAsync(): undefined.IPromiseWithIAsyncOperation<undefined.IVectorView<any >> ;

    /**
     * Creates a SecondaryTile object. The caller must then set any mandatory properties through the object before attempting to pin, update, or delete the tile. 
     */
    constructor(): this;

    /**
     * Creates a SecondaryTile object as a wide tile.
     * @param tileId A string that will uniquely identify the tile within your app's package. Choose a unique ID that is descriptive and meaningful to your app. It is limited to 64 characters and must begin with a number or letter and be composed of the characters a-z, A-Z, 0-9, period (.), or underscore (_). If you provide the same ID as that of an existing secondary tile, the existing secondary tile will be overwritten. Can be set or retrieved through the TileId property.
     * @param shortName A short name to display directly on the tile if the app chooses to do so. Anything over 40 characters will be truncated. The user has the option to change this value as part of the pinning process. Can be set or retrieved through the ShortName property.
     * @param displayName A name to be displayed on the tile, in the tile's tooltip, and when showing small tiles, such as on the Apps or search results screens. This string is equivalent to the display name given in the manifest for the main tile. It is restricted to 256 characters, but in practice should be kept short to avoid truncation. This value can be set or retrieved through the DisplayName property.
     * @param arguments An app-defined string meaningful to the calling application. This argument string is passed back to the app when the app is activated from the secondary tile. It will be truncated after 2048 characters. Can be set or retrieved through the Arguments property.
     * @param tileOptions A value that specifies various options such as whether the name will be displayed on the secondary tile. Can be set or retrieved through the TileOptions property.
     * @param logoReference A reference to a medium logo image stored at a URI. Can be set or retrieved through the Square150x150Logo property. This value can be expressed using one of these schemes:
     * @param wideLogoReference A reference to a wide logo image stored at a URI. Can be set or retrieved through the WideLogo property. This value can be expressed using one of these schemes:
     */
    constructor(tileId: string, shortName: string, displayName: string, args: string, tileOptions: undefined.TileOptions, logoReference: undefined.Uri, wideLogoReference: undefined.Uri): this;

    /**
     * Creates a SecondaryTile object with a specific ID. This form of the constructor should be used to create a secondary tile object to perform a tile update or deletion.
     * @param tileId A string that will uniquely identify the tile within your app. Choose a unique ID that is descriptive and meaningful to your app. If you provide the same ID as that of an existing secondary tile, the existing secondary tile will be overwritten.
     */
    constructor(tileId: string): this;

    /**
     * Creates a SecondaryTile object as a medium tile.
     * @param tileId A string that will uniquely identify the tile within your app's package. Choose a unique ID that is descriptive and meaningful to your app. It is limited to 64 characters and must begin with a number or letter and be composed of the characters a-z, A-Z, 0-9, period (.), or underscore (_). If you provide the same ID as that of an existing secondary tile, the existing secondary tile will be overwritten. Can be set or retrieved through the TileId property.
     * @param shortName A short name to display directly on the tile if the app chooses to do so. Anything over 40 characters will be truncated. The user has the option to change this value as part of the pinning process. Can be set or retrieved through the ShortName property.
     * @param displayName A name to be displayed on the tile, in the tile's tooltip, and when showing small tiles, such as on the Apps or search results screens. This string is equivalent to the display name given in the manifest for the main tile. It is restricted to 256 characters, but in practice should be kept short to avoid truncation. This value can be set or retrieved through the DisplayName property.
     * @param arguments An app-defined string meaningful to the calling application. This argument string is passed back to the app when the app is activated from the secondary tile. It will be truncated after 2048 characters. Can be set or retrieved through the Arguments property.
     * @param tileOptions A value that specifies various options such as whether the name will be displayed on the secondary tile. Can be set or retrieved through the TileOptions property.
     * @param logoReference A reference to a square logo image stored at a URI. Can be set or retrieved through the Logo property. This value can be expressed using one of these schemes:
     */
    constructor(tileId: string, shortName: string, displayName: string, args: string, tileOptions: undefined.TileOptions, logoReference: undefined.Uri): this;

    /**
     * Creates a SecondaryTile object that includes all of the mandatory properties required to create a medium tile.
     * @param tileId A string that will uniquely identify the tile within your app's package. Choose a unique ID that is descriptive and meaningful to your app. It is limited to 64 characters and must begin with a number or letter and be composed of the characters a-z, A-Z, 0-9, period (.), or underscore (_). If you provide the same ID as that of an existing secondary tile, the existing secondary tile will be overwritten. Can be set or retrieved through the TileId property.
     * @param displayName A name to be displayed on the tile, in the tile's tooltip, and when showing small tiles, such as on the Apps or search results screens. This string is equivalent to the display name given in the manifest for the main tile. It is restricted to 256 characters, but in practice should be kept short to avoid truncation. This value can be set or retrieved through the DisplayName property.
     * @param arguments An app-defined string meaningful to the calling application. This argument string is passed back to the app when the app is activated from the secondary tile. It will be truncated after 2048 characters. Can be set or retrieved through the Arguments property.
     * @param square150x150Logo A reference to a medium logo image stored at a URI. Can be set or retrieved through the SecondaryTileVisualElements.Square150x150Logo property. This value can be expressed using one of these schemes:
     * @param desiredSize The size of tile to pin. This value must be Default (which provides Windows 8 behavior), Square150x150, or Wide310x150. Any other TileSize value causes an exception to be thrown during runtime.
     */
    constructor(tileId: string, displayName: string, args: string, square150x150Logo: undefined.Uri, desiredSize: undefined.TileSize): this;

    /**
     * Gets or sets an app-defined set of information that is passed from the secondary tile to the app on activation. This property is required when you create a tile. 
     */
    arguments: string;

    /**
     * Gets or sets the tile's background color. 
     */
    backgroundColor: undefined.Color;

    /**
     * Gets or sets a name that is associated with and displayed on the tile. This name is displayed on the tile in Start, in the tile's tooltip, next to the small tile representation in the Apps list, and in some Control Panel applications. This property is required when you create a tile. It is the equivalent of the display name declared in the manifest for the app's main tile. 
     */
    displayName: string;

    /**
     * Gets or sets whether the tile should use dark or light text. 
     */
    foregroundText: undefined.ForegroundText;

    /**
     * Gets or sets the location of a badge logo image to represent the secondary tile on the lock screen. By supplying this image, you declare that the secondary tile is eligible to display a badge on the lock screen. If you also want the secondary tile to be eligible for the lock screen's detailed tile slot, you must also set the LockScreenDisplayBadgeAndTileText property to True. 
     */
    lockScreenBadgeLogo: undefined.Uri;

    /**
     * Gets or sets whether the secondary tile is eligible to display both a badge and a detailed tile on the lock screen. If you set this property to True, you must also provide a badge image through the LockScreenBadgeLogo property. If you do not want to use the detailed tile capability, provide a badge image through the LockScreenBadgeLogo property and set LockScreenDisplayBadgeAndTileText to False. 
     */
    lockScreenDisplayBadgeAndTileText: boolean;

    /**
     * Gets or sets the logo image used in a medium tile. This property is required when you create either a square or a wide tile. 
     */
    logo: undefined.Uri;

    /**
     * Fired when a call is made to RequestCreateAsync . 
     */
    onvisualelementsrequested: undefined.TypedEventHandler<undefined.SecondaryTile, undefined.VisualElementsRequestedEventArgs>;
    addEventListener(
        type: "visualelementsrequested",
        listener: undefined.TypedEventHandler<undefined.SecondaryTile, undefined.VisualElementsRequestedEventArgs>): void;
    removeEventListener(
        type: "visualelementsrequested",
        listener: undefined.TypedEventHandler<undefined.SecondaryTile, undefined.VisualElementsRequestedEventArgs>): void;

    /**
     * Gets or sets a phonetic version of the secondary tile name. Used with character-based languages for UI sorting purposes. 
     */
    phoneticName: string;

    /**
     * Displays the Pin to Start flyout above a specified location, through which the user can confirm that they want to create the secondary tile, which in turn creates the tile.
     * @param invocationPoint The point used as the lower-right corner of the Pin to Start flyout.
     * @return  An object that provides information concerning the asynchronous create operation.
     */
    requestCreateAsync(
        invocationPoint: undefined.Point): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Displays the Pin to Start flyout, through which the user can confirm that they want to create the secondary tile, which in turn creates the tile. Overloads of this method let you specify the on-screen location of the flyout.
     * @return  An object used to launch the asynchronous create operation as well as to retrieve information about it.
     */
    requestCreateAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Displays the Pin to Start flyout above a specified area. This flyout is used by the user to confirm that they want to create the secondary tile, which in turn creates the tile.
     * @param selection The area that the flyout is displayed directly above.
     * @return  An object that provides information concerning the asynchronous create operation.
     */
    requestCreateForSelectionAsync(selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Displays the Pin to Start flyout at the specified side of a specified area. This flyout is used by the user to confirm that they want to create the secondary tile, which in turn creates the tile.
     * @param selection The area to one side of which the flyout will be displayed.
     * @param preferredPlacement The side of the rectangle where the flyout should appear.
     * @return  An object that provides information concerning the asynchronous create operation.
     */
    requestCreateForSelectionAsync(
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Displays the Unpin from Start flyout. This flyout lets the user confirm removal of the secondary tile.
     * @return  An object that provides information concerning the asynchronous delete operation.
     */
    requestDeleteAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Displays the Unpin from Start flyout at a specified point. This flyout lets the user confirm removal of the secondary tile.
     * @param invocationPoint The point used as the lower-right corner of the Pin to Start flyout.
     * @return  An object that provides information concerning the asynchronous delete operation.
     */
    requestDeleteAsync(
        invocationPoint: undefined.Point): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Displays the Unpin from Start flyout above a specified area. This flyout lets the user confirm removal of the secondary tile.
     * @param selection The area that the secondary tile is displayed directly above.
     * @return  An object that provides information concerning the asynchronous delete operation.
     */
    requestDeleteForSelectionAsync(selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Displays the Unpin from Start flyout at the specified side of a specified area. This flyout lets the user confirm removal of the secondary tile.
     * @param selection The area to the side of which the flyout will be displayed.
     * @param preferredPlacement One of the enumeration values that specifies the side of the rectangle where the flyout should be shown.
     * @return  An object that provides information concerning the asynchronous delete operation.
     */
    requestDeleteForSelectionAsync(
        selection: undefined.Rect,
        preferredPlacement: undefined.Placement): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets or sets a value that determines whether the secondary tile will be reacquired through the cloud when the parent app is installed by the user, using their Microsoft account, on another computer. Note that as of Windows 8.1, roaming is the default behavior. This is the opposite of the default Windows 8 behavior, where roaming was opt-in. 
     */
    roamingEnabled: boolean;

    /**
     * Gets or sets a short name to display directly on the tile. 
     */
    shortName: string;

    /**
     * Gets or sets the small logo image, used in search results, the All Programs list, and other locations in the UI. 
     */
    smallLogo: undefined.Uri;

    /**
     * Gets or sets a unique string to identify the tile within the package. This property is required when you create or delete a tile. 
     */
    tileId: string;

    /**
     * Gets or sets options available to a secondary tile. 
     */
    tileOptions: undefined.TileOptions;

    /**
     * Updates a secondary tile after that tile is pinned to the Start screen.
     * @return  An object used to launch the asynchronous create operation as well as to retrieve information about it.
     */
    updateAsync(): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Gets an object through which you can get or set a secondary tile's background color, foreground text, tile images, and app name display options. As of Windows 8.1, the properties of this object replace these SecondaryTile properties: 
     */
    visualElements: undefined.SecondaryTileVisualElements;

    /**
     * Gets or sets the logo image used in a wide secondary tile. This property is required when you create a wide secondary tile and gives the user the option of a wide tile when they resize the tile. 
     */
    wideLogo: undefined.Uri;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains properties through which you can get or set a secondary tile's background color, foreground text, tile images, and app name display options. The properties in this class replace these SecondaryTile properties: 
 */
declare class SecondaryTileVisualElements {

    /**
     * Gets or sets the secondary tile's background color. 
     */
    backgroundColor: undefined.Color;

    /**
     * Specifies whether the tile should use dark or light text. 
     */
    foregroundText: undefined.ForegroundText;

    /**
     * Specifies whether the display name should be shown on the medium secondary tile. 
     */
    showNameOnSquare150x150Logo: boolean;

    /**
     * Specifies whether the display name should be shown on the large secondary tile. 
     */
    showNameOnSquare310x310Logo: boolean;

    /**
     * Specifies whether the display name should be shown on the wide secondary tile. 
     */
    showNameOnWide310x150Logo: boolean;

    /**
     * Gets or sets the medium secondary tile image. 
     */
    square150x150Logo: undefined.Uri;

    /**
     * Gets or sets the square30x30 secondary tile image. 
     */
    square30x30Logo: undefined.Uri;

    /**
     * Gets or sets the large secondary tile image. 
     */
    square310x310Logo: undefined.Uri;

    /**
     * Gets or sets the square44x44 secondary tile image. 
     */
    square44x44Logo: undefined.Uri;

    /**
     * Gets or sets the small secondary tile image. 
     */
    square70x70Logo: undefined.Uri;

    /**
     * Gets or sets the small secondary tile image. 
     */
    square71x71Logo: undefined.Uri;

    /**
     * Gets or sets the wide secondary tile image. 
     */
    wide310x150Logo: undefined.Uri
}


/**
 * Provides a method to delay the display of the Pin to Start flyout, as well as methods through which you can set the visual elements of the secondary tile to be presented in that flyout as well as alternate versions of the tile that can also be presented as options. 
 */
declare class VisualElementsRequest {

    /**
     * Gets a set of objects that provide alternate logo images, background and foreground colors, and display name. These alternates are shown to the user in the Pin to Start flyout. 
     */
    alternateVisualElements: undefined.IVectorView<undefined.SecondaryTileVisualElements>;

    /**
     * Gets the approximate time at which the deferral will time-out. 
     */
    deadline: Date;

    /**
     * Retrieves a deferral object, which allows the app time to provide information and assets used in the Pin to Start flyout.
     * @return  The deferral object.
     */
    getDeferral(): undefined.VisualElementsRequestDeferral;

    /**
     * Gets a copy of the parent secondary tile's SecondaryTileVisualElements object. The visual elements properties can be set or read through this object. When deferral is complete (or the handler returns without a deferral), the properties in this object are verified and then reflected in the Pin to Start flyout. 
     */
    visualElements: undefined.SecondaryTileVisualElements
}


/**
 * A deferral object used during the creation of the Pin to Start flyout. By using this object, the app can delay the display of the flyout while it gathers the information and assets that will be shown in that flyout. 
 */
declare class VisualElementsRequestDeferral {

    /**
     * Tells Windows that the app is ready to display the Pin to Start flyout. The app calls this method when it has finished setting the properties that specify what to show in that flyout. 
     */
    complete(): void
}


/**
 * Passed to the SecondaryTile.VisualElementsRequested event handler to provide the visual elements details. 
 */
declare class VisualElementsRequestedEventArgs {

    /**
     * Gets the VisualElementsRequest object for the event. 
     */
    request: undefined.VisualElementsRequest
}


/**
 * Provides data for the CompositionCompleted event. 
 */
declare class CoreTextCompositionCompletedEventArgs {

    /**
     * Gets a collection of CoreTextCompositionSegment objects representing the segments in the composition string. Applications can use this property, for example, to get the pre-conversion string for each composition segment. 
     */
    compositionSegments: undefined.IVectorView<undefined.CoreTextCompositionSegment>;

    /**
     * Requests that the operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
     * @return  A Deferral object.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Gets a value that indicates whether the operation is canceled. 
     */
    isCanceled: boolean
}


/**
 * Represents a segment in a composition string. See Remarks for an illustration. 
 */
declare class CoreTextCompositionSegment {

    /**
     * Gets a string that represents the state of the user input after IME-processing but before final conversion. 
     */
    preconversionString: string;

    /**
     * Gets an object that represents the range that defines this composition segment. 
     */
    range: undefined.CoreTextRange
}


/**
 * Provides data for the CompositionStarted event. 
 */
declare class CoreTextCompositionStartedEventArgs {

    /**
     * Requests that the operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
     * @return  A Deferral object.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Gets a value that indicates whether the operation is canceled. 
     */
    isCanceled: boolean
}


/**
 * The primary object used by text input controls to communicate with the text input server. 
 */
declare class CoreTextEditContext {

    /**
     * Gets or sets a value that indicates whether the input pane should be shown automatically when focus enters your text input control. The default value is Automatic, indicating that the input pane will be shown automatically. A value of Manual indicates that your app will be responsible for showing and hiding the input pane using InputPane.TryShow and TryHide . 
     */
    inputPaneDisplayPolicy: undefined.CoreTextInputPaneDisplayPolicy;

    /**
     * Gets or sets a value that indicates the input scope of the text input control. 
     */
    inputScope: undefined.CoreTextInputScope;

    /**
     * Gets or sets a value that indicates whether the edit control is editable. 
     */
    isReadOnly: boolean;

    /**
     * Gets or sets a descriptive name for the text input control. An application framework usually uses properties such as "name" or "id" to identify a control, so it’s recommended that you set this property accordingly on the text input server so that input processors can better preserve the input context, and provide better suggestions. 
     */
    name: string;

    /**
     * Notifies the text input server that focus has entered the text input control. 
     */
    notifyFocusEnter(): void;

    /**
     * Notifies the text input server that focus has left the text input control. 
     */
    notifyFocusLeave(): void;

    /**
     * Notifies the text input server that the layout of text inside the text input control has changed. 
     */
    notifyLayoutChanged(): void;

    /**
     * Notifies the text input server about any change that the text input control needs to make to the selection range. This is important in order to keep the internal state of the control and the internal state of the server synchronized.
     * @param selection The range of selection currently in effect.
     */
    notifySelectionChanged(selection: undefined.CoreTextRange): void;

    /**
     * Notifies the text input server about any change that the text input control needs to make to the text. This is important in order to keep the internal state of the control and the internal state of the server synchronized. Since a change to the text is also likely to affect the selection range, the method takes the selection range as a parameter.
     * @param modifiedRange The range of text to replace, in terms of the state the text buffer is in prior to this text change.
     * @param newLength The length of the text that should replace modifiedRange.
     * @param newSelection The range of selection in effect after the text change.
     */
    notifyTextChanged(
        modifiedRange: undefined.CoreTextRange,
        newLength: number,
        newSelection: undefined.CoreTextRange): void;

    /**
     * Occurs when composition has completed. 
     */
    oncompositioncompleted: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextCompositionCompletedEventArgs>;
    addEventListener(
        type: "compositioncompleted",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextCompositionCompletedEventArgs>): void;
    removeEventListener(
        type: "compositioncompleted",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextCompositionCompletedEventArgs>): void;

    /**
     * Occurs when composition has started. 
     */
    oncompositionstarted: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextCompositionStartedEventArgs>;
    addEventListener(
        type: "compositionstarted",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextCompositionStartedEventArgs>): void;
    removeEventListener(
        type: "compositionstarted",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextCompositionStartedEventArgs>): void;

    /**
     * Occurs when focus was forcibly removed from a text input control. The application should handle this event to remove focus for the text input control accordingly. 
     */
    onfocusremoved: undefined.TypedEventHandler<undefined.CoreTextEditContext, any>;
    addEventListener(
        type: "focusremoved",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, any>): void;
    removeEventListener(
        type: "focusremoved",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, any>): void;

    /**
     * Occurs when the text input server needs to apply a different format to a particular range of text. This usually happens during composition. 
     */
    onformatupdating: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextFormatUpdatingEventArgs>;
    addEventListener(
        type: "formatupdating",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextFormatUpdatingEventArgs>): void;
    removeEventListener(
        type: "formatupdating",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextFormatUpdatingEventArgs>): void;

    /**
     * Occurs when the text input server needs to get the bounding box of a range of text and of the text input control itself. The application should handle this event and return the geometry information requested. 
     */
    onlayoutrequested: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextLayoutRequestedEventArgs>;
    addEventListener(
        type: "layoutrequested",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextLayoutRequestedEventArgs>): void;
    removeEventListener(
        type: "layoutrequested",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextLayoutRequestedEventArgs>): void;

    /**
     * Occurs after focus has left the text input control. 
     */
    onnotifyfocusleavecompleted: undefined.TypedEventHandler<undefined.CoreTextEditContext, any>;
    addEventListener(
        type: "notifyfocusleavecompleted",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, any>): void;
    removeEventListener(
        type: "notifyfocusleavecompleted",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, any>): void;

    /**
     * Occurs when the text input server needs to get the text range representing the currently selected text in the text input control. The application should handle this event and return the range requested. 
     */
    onselectionrequested: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextSelectionRequestedEventArgs>;
    addEventListener(
        type: "selectionrequested",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextSelectionRequestedEventArgs>): void;
    removeEventListener(
        type: "selectionrequested",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextSelectionRequestedEventArgs>): void;

    /**
     * Occurs when the text input server needs to modify the range of text currently selected in the text input control. This event could be the result of an input processor needing to select some text, or to move the caret. The text input control should set its selection range accordingly. 
     */
    onselectionupdating: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextSelectionUpdatingEventArgs>;
    addEventListener(
        type: "selectionupdating",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextSelectionUpdatingEventArgs>): void;
    removeEventListener(
        type: "selectionupdating",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextSelectionUpdatingEventArgs>): void;

    /**
     * Occurs when the text input server needs to get a range of text from the text input control. The application should handle this event and return the range requested. 
     */
    ontextrequested: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextTextRequestedEventArgs>;
    addEventListener(
        type: "textrequested",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextTextRequestedEventArgs>): void;
    removeEventListener(
        type: "textrequested",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextTextRequestedEventArgs>): void;

    /**
     * Occurs when the text input server needs to modify text inside the text input control. This event could be the result of a key event—such as inserting a single character—or the result of processing done by an input processor, such as auto-correction and prediction. 
     */
    ontextupdating: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextTextUpdatingEventArgs>;
    addEventListener(
        type: "textupdating",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextTextUpdatingEventArgs>): void;
    removeEventListener(
        type: "textupdating",
        listener: undefined.TypedEventHandler<undefined.CoreTextEditContext, undefined.CoreTextTextUpdatingEventArgs>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the FormatUpdating event. 
 */
declare class CoreTextFormatUpdatingEventArgs {

    /**
     * Gets a value that represents the background color to be applied to the text range. The text input server populates this property before raising the event. 
     */
    backgroundColor: undefined.UIElementType;

    /**
     * Requests that the format update operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
     * @return  A Deferral object.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Gets a value that indicates whether the format update operation is canceled. 
     */
    isCanceled: boolean;

    /**
     * Gets a value that indicates the range of text that the text input server needs to format. The server populates this property before raising the event. 
     */
    range: undefined.CoreTextRange;

    /**
     * Gets a value that indicates the reason that the text input server needs to apply formatting to this range of text. The server populates this property before raising the event. 
     */
    reason: undefined.CoreTextFormatUpdatingReason;

    /**
     * Gets or sets a value that indicates the result of handling the FormatUpdating event. The default value is Succeeded but if you can't action the operation as the text input server expects then before returning from the event handler set the property to the appropriate value to indicate what has happened. 
     */
    result: undefined.CoreTextFormatUpdatingResult;

    /**
     * Gets a value that represents the text color to be applied to the text range. The text input server populates this property before raising the event. 
     */
    textColor: undefined.UIElementType;

    /**
     * Gets a value that represents the underline color to be applied to the text range. The text input server populates this property before raising the event. 
     */
    underlineColor: undefined.UIElementType;

    /**
     * Gets a value that represents the underline type to be applied to the text range. The text input server populates this property before raising the event. 
     */
    underlineType: undefined.UnderlineType
}


/**
 * Represents the bounding boxes—in screen coordinates—of a range of text, and of a text input control. 
 */
declare class CoreTextLayoutBounds {

    /**
     * Gets or sets the bounding box in screen coordinates of a text input control. 
     */
    controlBounds: undefined.Rect;

    /**
     * Gets or sets the bounding box in screen coordinates of a range of text. 
     */
    textBounds: undefined.Rect
}


/**
 * Represents information about a LayoutRequested event. 
 */
declare class CoreTextLayoutRequest {

    /**
     * Requests that the layout request operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
     * @return  A Deferral object.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Gets a value that indicates whether the layout request operation is canceled. 
     */
    isCanceled: boolean;

    /**
     * Gets an object that represents the layout bounds information requested by the text input server. The application should populate the properties of this object to the layout bounds being requested before returning from the event handler. 
     */
    layoutBounds: undefined.CoreTextLayoutBounds;

    /**
     * Gets a value that indicates the range of text whose bounding box is being requested by the text input server. The server populates this property before raising the event. 
     */
    range: undefined.CoreTextRange
}


/**
 * Provides data for the LayoutRequested event. 
 */
declare class CoreTextLayoutRequestedEventArgs {

    /**
     * Gets information about a LayoutRequested event. 
     */
    request: undefined.CoreTextLayoutRequest
}


/**
 * Represents information about a SelectionRequested event. 
 */
declare class CoreTextSelectionRequest {

    /**
     * Requests that the selection request operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
     * @return  A Deferral object.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Gets a value that indicates whether the selection request operation is canceled. 
     */
    isCanceled: boolean;

    /**
     * Gets or sets the selection range that the text input server is requesting. The application should set the current range of selection before returning from the event handler. 
     */
    selection: undefined.CoreTextRange
}


/**
 * Provides data for the SelectionRequested event. 
 */
declare class CoreTextSelectionRequestedEventArgs {

    /**
     * Gets information about a SelectionRequested event. 
     */
    request: undefined.CoreTextSelectionRequest
}


/**
 * Provides data for the SelectionUpdating event. 
 */
declare class CoreTextSelectionUpdatingEventArgs {

    /**
     * Requests that the selection update operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
     * @return  A Deferral object.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Gets a value that indicates whether the selection update operation is canceled. 
     */
    isCanceled: boolean;

    /**
     * Gets or sets a value that indicates the result of handling the SelectionUpdating event. The default value is Succeeded but if you can't action the operation as the text input server expects then before returning from the event handler set the property to the appropriate value to indicate what has happened. 
     */
    result: undefined.CoreTextSelectionUpdatingResult;

    /**
     * Gets a value that indicates the range of text that the text input server indicates should be selected. The server populates this property before raising the event. 
     */
    selection: undefined.CoreTextRange
}


/**
 * Provides constant values for use with the Windows core text APIs and the text input server. 
 */
declare class CoreTextServicesConstants {

    /**
     * Gets a value to use to replace hidden data inside a text stream before returning the text to the text input server. 
     */
    hiddenCharacter: string
}


/**
 * The entry point to all services provided by the Windows core text APIs and the text input server. This object is associated with an application's UI thread (the thread that CoreWindow runs on). 
 */
declare class CoreTextServicesManager {

    /**
     * Gets the CoreTextServicesManager object for the currently active view.
     * @return  A CoreTextServicesManager instance, which can be used to create further objects to support the app's text input scenarios.
     */
    getForCurrentView(): undefined.CoreTextServicesManager;

    /**
     * Creates a context object used by a text input control to communicate with the text input server. Each text input control must create its own context object.
     * @return  A CoreTextEditContext instance, which is the primary object used for communicating with the text input server.
     */
    createEditContext(): undefined.CoreTextEditContext;

    /**
     * Gets a Language object representing the current input language. 
     */
    inputLanguage: undefined.Language;

    /**
     * Occurs when the current input language has changed. 
     */
    oninputlanguagechanged: undefined.TypedEventHandler<undefined.CoreTextServicesManager, any>;
    addEventListener(
        type: "inputlanguagechanged",
        listener: undefined.TypedEventHandler<undefined.CoreTextServicesManager, any>): void;
    removeEventListener(
        type: "inputlanguagechanged",
        listener: undefined.TypedEventHandler<undefined.CoreTextServicesManager, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents information about a TextRequested event. 
 */
declare class CoreTextTextRequest {

    /**
     * Requests that the text request operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
     * @return  A Deferral object.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Gets a value that indicates whether the text request operation is canceled. 
     */
    isCanceled: boolean;

    /**
     * Gets a value that indicates the range of text being requested by the text input server. The server populates this property before raising the event. 
     */
    range: undefined.CoreTextRange;

    /**
     * Gets or sets the text that the text input server is requesting. The application should set the text being requested before returning from the event handler. 
     */
    text: string
}


/**
 * Provides data for the TextRequested event. 
 */
declare class CoreTextTextRequestedEventArgs {

    /**
     * Gets information about a TextRequested event. 
     */
    request: undefined.CoreTextTextRequest
}


/**
 * Provides data for the TextUpdating event. 
 */
declare class CoreTextTextUpdatingEventArgs {

    /**
     * Requests that the text update operation be delayed. Call this method if your text input control is hosted on a worker thread rather than on the UI thread.
     * @return  A Deferral deferral object.
     */
    getDeferral(): undefined.Deferral;

    /**
     * Gets a Language object representing the current input language. 
     */
    inputLanguage: undefined.Language;

    /**
     * Gets a value that indicates whether the text update operation is canceled. 
     */
    isCanceled: boolean;

    /**
     * Gets a value that indicates the range of text that the text input server indicates should be selected. The server populates this property before raising the event. 
     */
    newSelection: undefined.CoreTextRange;

    /**
     * Gets a value that indicates the range of text that the text input server needs to modify. The server populates this property before raising the event. 
     */
    range: undefined.CoreTextRange;

    /**
     * Gets or sets a value that indicates the result of handling the TextUpdating event. The default value is Succeeded but if you can't action the operation as the text input server expects then before returning from the event handler set the property to the appropriate value to indicate what has happened. 
     */
    result: undefined.CoreTextTextUpdatingResult;

    /**
     * Gets the text that the text input server is requesting to be set into the modified range. The server populates this property before raising the event. 
     */
    text: string
}


/**
 * Defines a range of text inside a text input control. 
 */
declare interface Core$CoreTextRange {

    /**
     * The end position of a range in Application Character Position (ACP) terms. 
     */
    endCaretPosition: number,

        /**
         * The start position of a range in Application Character Position (ACP) terms. 
         */
        startCaretPosition: number
}


/**
 * Refers to the density of a typeface, in terms of the lightness or heaviness of the strokes. 
 */
declare interface Text$FontWeight {

    /**
     * The font weight expressed as a numeric value. See Remarks. 
     */
    weight: number
}


/**
 * Provides access to the high contrast accessibility settings. 
 */
declare class AccessibilitySettings {

    /**
     * Initializes a new AccessibilitySettings object. 
     */
    constructor(): this;

    /**
     * Gets a value that indicates whether the system high contrast feature is on or off. 
     */
    highContrast: boolean;

    /**
     * Gets the name of the default high contrast color scheme. 
     */
    highContrastScheme: string;

    /**
     * Occurs when the system high contrast feature turns on or off. 
     */
    onhighcontrastchanged: undefined.TypedEventHandler<undefined.AccessibilitySettings, any>;
    addEventListener(
        type: "highcontrastchanged",
        listener: undefined.TypedEventHandler<undefined.AccessibilitySettings, any>): void;
    removeEventListener(
        type: "highcontrastchanged",
        listener: undefined.TypedEventHandler<undefined.AccessibilitySettings, any>): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}

declare class ActivationViewSwitcher {
    isViewPresentedOnActivationVirtualDesktop: any;

    /**
     * Shows the view in a new standalone window and sets the size preference for the view.
     * @param viewId The identifier for the view.
     * @param sizePreference The preferred size of the view.
     * @return  The asynchronous results of the operation. Use this to determine when the async call is complete.
     */
    showAsStandaloneAsync(
        viewId: number,
        sizePreference: undefined.ViewSizePreference): undefined.IPromiseWithIAsyncAction;

    /**
     * Shows the view in a new standalone window.
     * @param viewId The identifier for the view.
     * @return  The asynchronous results of the operation. Use this to determine when the async call is complete.
     */
    showAsStandaloneAsync(viewId: number): undefined.IPromiseWithIAsyncAction
}


/**
 * Represents the active application view and associated states and behaviors. 
 */
declare class ApplicationView {

    /**
     * Gets the view state and behavior settings of the active application.
     * @return  An ApplicationView instance that can be used to get and set app display properties.
     */
    getForCurrentView(): undefined.ApplicationView;

    /**
     * Gets or sets the size the app launches with if no view size is remembered by Windows. 
     */
    preferredLaunchViewSize: undefined.Size;

    /**
     * Gets or sets a value that indicates the windowing mode the app launches with. 
     */
    preferredLaunchWindowingMode: undefined.ApplicationViewWindowingMode;

    /**
     * Indicates whether the app terminates when the last window is closed. 
     */
    terminateAppOnFinalViewClose: boolean;

    /**
     * Attempts to unsnap a previously snapped app. This call will only succeed when the app is running in the foreground.
     * @return  true if the app has been successfully unsnapped; false if the unsnap attempt failed.
     */
    tryUnsnap(): boolean;
    tryUnsnapToFullscreen: any;

    /**
     * Gets the state of the current window (app view). 
     */
    value: undefined.ApplicationViewState;

    /**
     * Gets whether the current window (app view) is adjacent to the left edge of the screen, whether the window is full-screen or docked. 
     */
    adjacentToLeftDisplayEdge: boolean;

    /**
     * Gets whether the current window (app view) is adjacent to the right edge of the screen, whether the window is full-screen or docked. 
     */
    adjacentToRightDisplayEdge: boolean;

    /**
     * Gets a value that indicates the bounds used by the framework to lay out the contents of the window (app view). 
     */
    desiredBoundsMode: undefined.ApplicationViewBoundsMode;

    /**
     * Takes the app out of full-screen mode. 
     */
    exitFullScreenMode(): void;

    /**
     * Gets or sets a value that indicates how an app in full-screen mode responds to edge swipe actions. 
     */
    fullScreenSystemOverlayMode: undefined.FullScreenSystemOverlayMode;

    /**
     * Gets the ID of the window (app view). 
     */
    id: number;

    /**
     * Gets whether the window (app view) fills the entire screen. 
     */
    isFullScreen: boolean;
    isFullScreenMode: any;

    /**
     * Gets whether the window (app view) is on the Windows lock screen. 
     */
    isOnLockScreen: boolean;

    /**
     * Gets or sets whether screen capture is enabled for the window (app view). 
     */
    isScreenCaptureEnabled: boolean;

    /**
     * Occurs when the window is removed from the list of recently used apps, or if the user executes a close gesture on it. 
     */
    onconsolidated: undefined.TypedEventHandler<undefined.ApplicationView, undefined.ApplicationViewConsolidatedEventArgs>;
    addEventListener(
        type: "consolidated",
        listener: undefined.TypedEventHandler<undefined.ApplicationView, undefined.ApplicationViewConsolidatedEventArgs>): void;
    removeEventListener(
        type: "consolidated",
        listener: undefined.TypedEventHandler<undefined.ApplicationView, undefined.ApplicationViewConsolidatedEventArgs>): void;

    /**
     * This event is raised when the value of VisibleBounds changes, typically as a result of the status bar, app bar, or other chrome being shown or hidden. 
     */
    onvisibleboundschanged: undefined.TypedEventHandler<undefined.ApplicationView, any>;
    addEventListener(
        type: "visibleboundschanged",
        listener: undefined.TypedEventHandler<undefined.ApplicationView, any>): void;
    removeEventListener(
        type: "visibleboundschanged",
        listener: undefined.TypedEventHandler<undefined.ApplicationView, any>): void;

    /**
     * Gets the current orientation (landscape or portrait) of the window (app view) with respect to the display. 
     */
    orientation: undefined.ApplicationViewOrientation;

    /**
     * Sets a value indicating the bounds used by the framework to lay out the contents of the window (app view).
     * @param boundsMode The bounds that the framework should use to lay out the contents of the window (app view).
     * @return  true to confirm that the change to DesiredBoundsMode was successful; otherwise, false.
     */
    setDesiredBoundsMode(boundsMode: undefined.ApplicationViewBoundsMode): boolean;

    /**
     * Sets the smallest size, in effective pixels, allowed for the app window.
     * @param minSize The smallest size allowed for the app window, or a Size whose height and width are both zero to use the system default minimum size.
     */
    setPreferredMinSize(minSize: undefined.Size): void;

    /**
     * Shows system UI elements, like the title bar, over a full-screen app. 
     */
    showStandardSystemOverlays(): void;

    /**
     * Gets or sets a value indicating whether or not system overlays (such as overlay applications or the soft steering wheel) should be shown. 
     */
    suppressSystemOverlays: boolean;

    /**
     * Gets or sets the displayed title of the window. 
     */
    title: string;

    /**
     * Gets the title bar of the app. 
     */
    titleBar: undefined.ApplicationViewTitleBar;

    /**
     * Attempts to place the app in full-screen mode.
     * @return  true if the app is placed in full-screen mode; otherwise, false.
     */
    tryEnterFullScreenMode(): boolean;

    /**
     * Attempts to change the size of the view to the specified size.
     * @param value The new size of the view.
     * @return  true if the view is resized; otherwise, false.
     */
    tryResizeView(value: undefined.Size): boolean;

    /**
     * Gets the visible region of the window (app view). The visible region is the region not occluded by chrome such as the status bar and app bar. 
     */
    visibleBounds: undefined.Rect;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains the results of a window (app view) consolidation operation. 
 */
declare class ApplicationViewConsolidatedEventArgs {

    /**
     * Indicates whether the window consolidation was user- or system-initiated. 
     */
    isUserInitiated: boolean
}


/**
 * Represents the app view switching behaviors for an app. 
 */
declare class ApplicationViewSwitcher {

    /**
     * Disables the primary window (app view) when the app is activated, showing the most recently displayed window instead. 
     */
    disableShowingMainViewOnActivation(): void;
    disableSystemViewActivationPolicy: any;

    /**
     * Prepares your app to visually transition between two windows with a custom animation.
     * @param toViewId The ID of the window from which your app is transitioning.
     * @param fromViewId The ID of the window to which your app is transitioning.
     * @param options Enumeration value that specifies thw view switching behaviors.
     * @return  Asynchronously returns true if the call succeeds; false if it does not.
     */
    prepareForCustomAnimatedSwitchAsync(
        toViewId: number,
        fromViewId: number,
        options: undefined.ApplicationViewSwitchingOptions): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Visually replaces the calling window (app view) with a specified window.
     * @param viewId The ID of the window under preparation for display.
     * @return  The asynchronous results of the operation. Use this to determine when the async call is complete.
     */
    switchAsync(viewId: number): undefined.IPromiseWithIAsyncAction;

    /**
     * Visually replaces the calling window (app view) with a specified window.
     * @param toViewId The ID of the window under preparation for display.
     * @param fromViewId The ID of the calling, currently displayed window.
     * @return  The asynchronous results of the operation. Use this to determine when the async call is complete.
     */
    switchAsync(toViewId: number, fromViewId: number): undefined.IPromiseWithIAsyncAction;

    /**
     * Visually replaces the calling window (app view) with a specified window.
     * @param toViewId The ID of the window under preparation for display.
     * @param fromViewId The ID of the calling, currently displayed window.
     * @param options Options for the display transition behaviors.
     * @return  The asynchronous results of the operation. Use this to determine when the async call is complete.
     */
    switchAsync(
        toViewId: number,
        fromViewId: number,
        options: undefined.ApplicationViewSwitchingOptions): undefined.IPromiseWithIAsyncAction;

    /**
     * Displays another window (app view) for the app on the screen, adjacent to the original window.
     * @param viewId The ID of the new window to display.
     * @param sizePreference The preferred general sizing of the new window.
     * @param anchorViewId The ID of the calling (anchor) window.
     * @param anchorSizePreference The preferred new general sizing of the calling window if this call succeeds.
     * @return  Asynchronously returns true if the call succeeds; false if it does not.
     */
    tryShowAsStandaloneAsync(
        viewId: number,
        sizePreference: undefined.ViewSizePreference,
        anchorViewId: number,
        anchorSizePreference: undefined.ViewSizePreference): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Displays another window (app view) for the app on the screen, adjacent to the original window
     * @param viewId The ID of the new window to display.
     * @return  Asynchronously returns true if the call succeeds; false if it does not.
     */
    tryShowAsStandaloneAsync(viewId: number): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Displays another window (app view) for the app on the screen, adjacent to the original window
     * @param viewId The ID of the new window to display.
     * @param sizePreference The preferred general sizing of the new window.
     * @return  Asynchronously returns true if the call succeeds; false if it does not.
     */
    tryShowAsStandaloneAsync(
        viewId: number,
        sizePreference: undefined.ViewSizePreference): undefined.IPromiseWithIAsyncOperation<boolean >
}


/**
 * Represents the title bar of an app. 
 */
declare class ApplicationViewTitleBar {

    /**
     * Gets or sets the color of the title bar background. 
     */
    backgroundColor: undefined.Color;

    /**
     * Gets or sets the background color of the title bar buttons. 
     */
    buttonBackgroundColor: undefined.Color;

    /**
     * Gets or sets the foreground color of the title bar buttons. 
     */
    buttonForegroundColor: undefined.Color;

    /**
     * Gets or sets the background color of a title bar button when the pointer is over it. 
     */
    buttonHoverBackgroundColor: undefined.Color;

    /**
     * Gets or sets the foreground color of a title bar button when the pointer is over it. 
     */
    buttonHoverForegroundColor: undefined.Color;

    /**
     * Gets or sets the background color of a title bar button when it's inactive. 
     */
    buttonInactiveBackgroundColor: undefined.Color;

    /**
     * Gets or sets the foreground color of a title bar button when it's inactive. 
     */
    buttonInactiveForegroundColor: undefined.Color;

    /**
     * Gets or sets the background color of a title bar button when it's pressed. 
     */
    buttonPressedBackgroundColor: undefined.Color;

    /**
     * Gets or sets the foreground color of a title bar button when it's pressed. 
     */
    buttonPressedForegroundColor: undefined.Color;

    /**
     * Gets or sets the color of the title bar foreground. 
     */
    foregroundColor: undefined.Color;

    /**
     * Gets or sets the color of the title bar background when it's inactive. 
     */
    inactiveBackgroundColor: undefined.Color;

    /**
     * Gets or sets the color of the title bar foreground when it's inactive. 
     */
    inactiveForegroundColor: undefined.Color
}

declare class ApplicationViewTransferContext {
    dataPackageFormatId: any;
    viewId: any
}


/**
 * Enables an app to register to receive notifications when the input pane is about to be displayed or hidden, and to determine which portion of the application's window is being obscured by the input pane. 
 */
declare class InputPane {

    /**
     * Gets the InputPane object associated with the application window that is currently visible.
     * @return  The input pane.
     */
    getForCurrentView(): undefined.InputPane;

    /**
     * Gets the region of the app window obscured by the input pane. 
     */
    occludedRect: undefined.Rect;

    /**
     * Occurs when the input pane is about to be hidden by sliding out of view. 
     */
    onhiding: undefined.TypedEventHandler<undefined.InputPane, undefined.InputPaneVisibilityEventArgs>;
    addEventListener(
        type: "hiding",
        listener: undefined.TypedEventHandler<undefined.InputPane, undefined.InputPaneVisibilityEventArgs>): void;
    removeEventListener(
        type: "hiding",
        listener: undefined.TypedEventHandler<undefined.InputPane, undefined.InputPaneVisibilityEventArgs>): void;

    /**
     * Occurs when the input pane is about to be displayed by sliding into view. 
     */
    onshowing: undefined.TypedEventHandler<undefined.InputPane, undefined.InputPaneVisibilityEventArgs>;
    addEventListener(
        type: "showing",
        listener: undefined.TypedEventHandler<undefined.InputPane, undefined.InputPaneVisibilityEventArgs>): void;
    removeEventListener(
        type: "showing",
        listener: undefined.TypedEventHandler<undefined.InputPane, undefined.InputPaneVisibilityEventArgs>): void;

    /**
     * Hides the InputPane if it is showing.
     * @return  true if the InputPane was hidden successfully; otherwise false.
     */
    tryHide(): boolean;

    /**
     * Shows the InputPane if it is hidden.
     * @return  true if the InputPane was shown successfully; otherwise false.
     */
    tryShow(): boolean;

    /**
     * Gets or sets a value that indicates whether the input pane is shown. 
     */
    visible: boolean;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the input pane Hiding and Showing events. 
 */
declare class InputPaneVisibilityEventArgs {

    /**
     * Identifies whether the application has taken steps to ensure that the input pane doesn't cover the UI element that has focus. 
     */
    ensuredFocusedElementInView: boolean;

    /**
     * Gets the region of the application's window that the input pane is covering. 
     */
    occludedRect: undefined.Rect
}


/**
 * Defines a set of methods for managing the windows (app views) sent to secondary displays, such as projectors. 
 */
declare class ProjectionManager {

    /**
     * Returns a string that is used to enumerate device services.
     * @return  A string that is used to enumerate device services.
     */
    getDeviceSelector(): string;

    /**
     * Occurs when a projector or other secondary display becomes available or unavailable. 
     */
    onprojectiondisplayavailablechanged: undefined.EventHandler<any>;
    addEventListener(
        type: "projectiondisplayavailablechanged",
        listener: undefined.EventHandler<any>): void;
    removeEventListener(
        type: "projectiondisplayavailablechanged",
        listener: undefined.EventHandler<any>): void;

    /**
     * Gets whether or not a projection display is available to use. 
     */
    projectionDisplayAvailable: boolean;

    /**
     * Makes a request to asynchronously sends a window (app view) to the projector or other secondary display with the specified preferred placement.
     * @param projectionViewId The new ID of the window to be displayed by the projector or other secondary display.
     * @param anchorViewId The ID of the original window before projection.
     * @param selection The area to one side of which the flyout is displayed.
     * @param prefferedPlacement The side of the rectangle where the flyout should appear.
     * @return  true if projection started; otherwise, false.
     */
    requestStartProjectingAsync(
        projectionViewId: number,
        anchorViewId: number,
        selection: undefined.Rect,
        prefferedPlacement: undefined.Placement): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Makes a request to asynchronously sends a window (app view) to the projector or other secondary display.
     * @param projectionViewId The new ID of the window to be displayed by the projector or other secondary display.
     * @param anchorViewId The ID of the original window before projection.
     * @param selection The area to one side of which the flyout is displayed.
     * @return  true if projection started; otherwise, false.
     */
    requestStartProjectingAsync(
        projectionViewId: number,
        anchorViewId: number,
        selection: undefined.Rect): undefined.IPromiseWithIAsyncOperation<boolean>;

    /**
     * Asynchronously sends a window (app view) to the projector or other secondary display.
     * @param projectionViewId The new ID of the window to be displayed by the projector or other secondary display.
     * @param anchorViewId The ID of the original window before projection.
     * @return  The asynchronous results of the operation. Use this to determine when the async call is complete.
     */
    startProjectingAsync(
        projectionViewId: number,
        anchorViewId: number): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously sends a window (app view) to the projector or other secondary display, and provides info about the display.
     * @param projectionViewId The new ID of the window to be displayed by the projector or other secondary display.
     * @param anchorViewId The ID of the original window before projection.
     * @param displayDeviceInfo Information about the display device.
     * @return  The asynchronous results of the operation. Use this to determine when the async call is complete.
     */
    startProjectingAsync(
        projectionViewId: number,
        anchorViewId: number,
        displayDeviceInfo: undefined.DeviceInformation): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously hides a window (app view) displayed by a projector or other secondary display.
     * @param projectionViewId The ID of the window currently displayed by the projector or other secondary display.
     * @param anchorViewId The ID of the original window before projection.
     * @return  The asynchronous results of the operation. Use this to determine when the async call is complete.
     */
    stopProjectingAsync(
        projectionViewId: number,
        anchorViewId: number): undefined.IPromiseWithIAsyncAction;

    /**
     * Asynchronously swaps the calling window (app view) with the window displayed on the projector or other secondary display. The result is that the calling window is displayed on the projector, and the formerly projected window is displayed on the device screen.
     * @param projectionViewId The ID of the window currently displayed by the projector.
     * @param anchorViewId The ID of the window to swap with the projected window.
     * @return  The asynchronous results of the operation. Use this to determine when the async call is complete.
     */
    swapDisplaysForViewsAsync(
        projectionViewId: number,
        anchorViewId: number): undefined.IPromiseWithIAsyncAction;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Contains a set of common app user interface settings and operations. 
 */
declare class UISettings {

    /**
     * Creates a new default instance of the UISettings class. 
     */
    constructor(): this;

    /**
     * Gets whether animations are enabled for the user interface. 
     */
    animationsEnabled: boolean;

    /**
     * Gets the blink rate of a new caret created by the app view. 
     */
    caretBlinkRate: number;

    /**
     * Gets whether the caret can be used for browse operations. 
     */
    caretBrowsingEnabled: boolean;

    /**
     * Gets the width of a new caret created by the app view. 
     */
    caretWidth: number;

    /**
     * Gets the size of a new cursor created by the app view. 
     */
    cursorSize: undefined.Size;

    /**
     * Gets the maximum allowed time between clicks in a double-click operation. 
     */
    doubleClickTime: number;

    /**
     * Returns the color value of the specified color type.
     * @param desiredColor An enumeration value that specifies the type of color to get a value for.
     * @return  The color value of the specified color type.
     */
    getColorValue(desiredColor: undefined.UIColorType): undefined.Color;

    /**
     * Gets the directional preference of the user interface created by the app view. 
     */
    handPreference: undefined.HandPreference;

    /**
     * Gets the length of time a message is displayed for the app view. 
     */
    messageDuration: number;

    /**
     * Gets the amount of time the mouse pointer can rest in a hover rectangle before a hover event is raised. 
     */
    mouseHoverTime: number;

    /**
     * Occurs when color values have changed. 
     */
    oncolorvalueschanged: undefined.TypedEventHandler<undefined.UISettings, any>;
    addEventListener(
        type: "colorvalueschanged",
        listener: undefined.TypedEventHandler<undefined.UISettings, any>): void;
    removeEventListener(
        type: "colorvalueschanged",
        listener: undefined.TypedEventHandler<undefined.UISettings, any>): void;

    /**
     * Occurs when the system text size setting is changed. 
     */
    ontextscalefactorchanged: undefined.TypedEventHandler<undefined.UISettings, any>;
    addEventListener(
        type: "textscalefactorchanged",
        listener: undefined.TypedEventHandler<undefined.UISettings, any>): void;
    removeEventListener(
        type: "textscalefactorchanged",
        listener: undefined.TypedEventHandler<undefined.UISettings, any>): void;

    /**
     * Gets the size of a scroll bar arrow for windows associated with the app view. 
     */
    scrollBarArrowSize: undefined.Size;

    /**
     * Gets the size of a scroll bar for windows associated with the app view. 
     */
    scrollBarSize: undefined.Size;

    /**
     * Gets the size of a thumb box for windows associated with the app view. 
     */
    scrollBarThumbBoxSize: undefined.Size;

    /**
     * Gets the value of the system text size setting. 
     */
    textScaleFactor: number;

    /**
     * Gets the color used for a specific user interface element type, such as a button face or window text.
     * @param desiredElement The type of element for which the color will be obtained.
     * @return  The color of the element type, expressed as a 32-bit color value.
     */
    uiElementColor(desiredElement: undefined.UIElementType): undefined.Color;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Represents UI states and behaviors associated with the device mode (Tablet or Desktop) and input device type. 
 */
declare class UIViewSettings {

    /**
     * Gets the UI states and behaviors associated with the device mode (Tablet or Desktop) for the active app.
     * @return  A UIViewSettings instance that can be used to get and set view settings properties.
     */
    getForCurrentView(): undefined.UIViewSettings;

    /**
     * Gets a value that indicates whether the device UI is optimized for touch input or mouse input. 
     */
    userInteractionMode: undefined.UserInteractionMode
}


/**
 * Manages delayed activation for an app. 
 */
declare class ActivatedDeferral {

    /**
     * Notifies the system that the app has set up its state and initial UI and is ready to be displayed. 
     */
    complete(): void
}


/**
 * Manages an app activation operation. 
 */
declare class ActivatedOperation {

    /**
     * Requests that the completion of app activation be delayed.
     * @return  The activation deferral object.
     */
    getDeferral(): undefined.ActivatedDeferral
}


/**
 * Manages the document source for app printing. 
 */
declare class HtmlPrintDocumentSource {

    /**
     * Gets and sets the bottom margin of the document source. 
     */
    bottomMargin: number;

    /**
     * Performs app-defined tasks that are associated with freeing, releasing, or resetting resources that were allocated for the document source. 
     */
    close(): void;

    /**
     * Gets and sets the content of the document source to print. 
     */
    content: undefined.PrintContent;

    /**
     * Gets and sets a value that controls whether header and footer are enabled in the document source. 
     */
    enableHeaderFooter: boolean;

    /**
     * Gets and sets the left margin of the document source. 
     */
    leftMargin: number;

    /**
     * Gets the range of pages that prints. 
     */
    pageRange: string;

    /**
     * Gets and sets the size of the document source by percentage. 
     */
    percentScale: number;

    /**
     * Gets and sets the right margin of the document source. 
     */
    rightMargin: number;

    /**
     * Gets and sets a value that controls whether content shrinks to fit the document source. 
     */
    shrinkToFit: boolean;

    /**
     * Gets and sets the top margin of the document source. 
     */
    topMargin: number;

    /**
     * Tries to set the page range of the document source.
     * @param strPageRange The page range to set.
     * @return  A Boolean value that indicates whether trySetPageRange set the page range in strPageRange. TRUE indicates the page range was set and FALSE otherwise.
     */
    trySetPageRange(strPageRange: string): boolean
}


/**
 * Manages delayed suspension for an app. GetDeferral 
 */
declare class SuspendingDeferral {

    /**
     * Notifies the system that the app has saved its data and is ready to be suspended. 
     */
    complete(): void
}


/**
 * Provides data for an app suspension event. 
 */
declare class SuspendingEventArgs {

    /**
     * Gets the app suspension operation. 
     */
    suspendingOperation: undefined.SuspendingOperation
}


/**
 * Manages an app suspension operation. 
 */
declare class SuspendingOperation {

    /**
     * Gets the time remaining before a delayed app suspension operation continues. 
     */
    deadline: Date;

    /**
     * Requests that the app suspension operation be delayed.
     * @return  The suspension deferral.
     */
    getDeferral(): undefined.SuspendingDeferral
}


/**
 * Enables an app to receive notifications related to the lifetime of the app. 
 */
declare class WebUIApplication {

    /**
     * Occurs when the app is activated. 
     */
    onactivated: undefined.ActivatedEventHandler;
    addEventListener(type: "activated", listener: undefined.ActivatedEventHandler): void;
    removeEventListener(type: "activated", listener: undefined.ActivatedEventHandler): void;

    /**
     * Occurs when the app is navigating. 
     */
    onnavigated: undefined.NavigatedEventHandler;
    addEventListener(type: "navigated", listener: undefined.NavigatedEventHandler): void;
    removeEventListener(type: "navigated", listener: undefined.NavigatedEventHandler): void;

    /**
     * Occurs when the app is resuming. 
     */
    onresuming: undefined.ResumingEventHandler;
    addEventListener(type: "resuming", listener: undefined.ResumingEventHandler): void;
    removeEventListener(type: "resuming", listener: undefined.ResumingEventHandler): void;

    /**
     * Occurs when the app is suspending. 
     */
    onsuspending: undefined.SuspendingEventHandler;
    addEventListener(type: "suspending", listener: undefined.SuspendingEventHandler): void;
    removeEventListener(type: "suspending", listener: undefined.SuspendingEventHandler): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data when an app is activated to add an appointment to the user’s calendar. 
 */
declare class WebUIAppointmentsProviderAddAppointmentActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the appointment that is provided to the app when the user tries to add it. 
     */
    addAppointmentOperation: undefined.AddAppointmentOperation;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed by the appointments provider. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to remove an appointment from the user’s calendar. 
 */
declare class WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the appointment that is provided to the app when the user tries to remove it. 
     */
    removeAppointmentOperation: undefined.RemoveAppointmentOperation;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed by the appointments provider. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to replace an appointment in the user’s calendar. 
 */
declare class WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the appointment that is provided to the app when the user tries to replace it. 
     */
    replaceAppointmentOperation: undefined.ReplaceAppointmentOperation;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed by the appointments provider. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to show the details of an appointment. 
 */
declare class WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs {

    /**
     * Gets the app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the start date of the appointment instance for which the app should display details. 
     */
    instanceStartDate: Date;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the local identifier of the appointment for which the app should display details. 
     */
    localId: string;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the roaming identifier of the appointment for which the app should display details. 
     */
    roamingId: string;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed by the appointments provider. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to show a specified time frame on the user’s calendar. 
 */
declare class WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the duration of the time frame to be shown. 
     */
    duration: number;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the starting date and time of the time frame to be shown. 
     */
    timeToShow: Date;

    /**
     * Gets the action to be performed by the appointments provider. 
     */
    verb: string
}


/**
 * Represents an instance of a background task that has been triggered to run. 
 */
declare class WebUIBackgroundTaskInstance {

    /**
     * Gets the current background task. 
     */
    current: undefined.IWebUIBackgroundTaskInstance
}


/**
 * Provides access to an instance of a background task. 
 */
declare class WebUIBackgroundTaskInstanceRuntimeClass {

    /**
     * Informs the system that the background task might continue to perform work after the IBackgroundTask.Run method returns. This method is not applicable to JavaScript background tasks.
     * @return  A background task deferral.
     */
    getDeferral(): undefined.BackgroundTaskDeferral;

    /**
     * Gets the instance ID of the background task instance. 
     */
    instanceId: string;

    /**
     * Attaches a cancellation event handler to the background task instance. 
     */
    oncanceled: undefined.BackgroundTaskCanceledEventHandler;
    addEventListener(type: "canceled", listener: undefined.BackgroundTaskCanceledEventHandler): void;
    removeEventListener(type: "canceled", listener: undefined.BackgroundTaskCanceledEventHandler): void;

    /**
     * Gets or sets progress status for a background task instance. 
     */
    progress: number;

    /**
     * Gets or sets the success value for the background task. The success value is what is returned to the foreground instance of your app in the completed event. 
     */
    succeeded: boolean;

    /**
     * Gets the number of times resource management policy caused the background task to be suspended. 
     */
    suspendedCount: number;

    /**
     * Gets access to the registered background task for this background task instance. 
     */
    task: undefined.BackgroundTaskRegistration;

    /**
     * Gets additional information associated with a background task instance. 
     */
    triggerDetails: any;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides information about the activated event that fires when the user saves or opens a file that needs updates from the app. 
 */
declare class WebUICachedFileUpdaterActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the letterbox UI of the file picker that is displayed when a file needs updates from the app. 
     */
    cachedFileUpdaterUI: undefined.CachedFileUpdaterUI;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Enables a camera settings app to handle the activation parameters for the app. 
 */
declare class WebUICameraSettingsActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the object that controls device settings on the camera. 
     */
    videoDeviceController: any;

    /**
     * Gets the object that implements additional extended settings for the camera. 
     */
    videoDeviceExtension: any
}


/**
 * Provides data when an app is activated to call a contact. 
 */
declare class WebUIContactCallActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the contact for the call. 
     */
    contact: undefined.Contact;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the identifier of the service used for the call. 
     */
    serviceId: string;

    /**
     * Gets the user identifier of the service used for the call. 
     */
    serviceUserId: string;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to map a contact. 
 */
declare class WebUIContactMapActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the address of a contact for the mapping operation. 
     */
    address: undefined.ContactAddress;

    /**
     * Gets the contact for the mapping operation. 
     */
    contact: undefined.Contact;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to message a contact. 
 */
declare class WebUIContactMessageActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the contact for the message. 
     */
    contact: undefined.Contact;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the identifier of the service used for the message. 
     */
    serviceId: string;

    /**
     * Gets the user identifier of the service used for the message. 
     */
    serviceUserId: string;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed. 
     */
    verb: string
}


/**
 * Provides data when an app is activated because it uses the Contact Picker. 
 */
declare class WebUIContactPickerActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the letterbox UI of the contact picker that is displayed when the user wants to pick contacts that are provided by the app. 
     */
    contactPickerUI: undefined.ContactPickerUI;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides data when an app is activated to post a contact. 
 */
declare class WebUIContactPostActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the contact for the post. 
     */
    contact: undefined.Contact;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the identifier of the service used for the post. 
     */
    serviceId: string;

    /**
     * Gets the user identifier of the service used for the post. 
     */
    serviceUserId: string;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed. 
     */
    verb: string
}


/**
 * Provides data when an app is activated to video call a contact. 
 */
declare class WebUIContactVideoCallActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the contact for the video call. 
     */
    contact: undefined.Contact;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the identifier of the service used for the video call. 
     */
    serviceId: string;

    /**
     * Gets the user identifier of the service used for the video call. 
     */
    serviceUserId: string;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action to be performed. 
     */
    verb: string
}


/**
 * Provides information for a device that invokes AutoPlay. 
 */
declare class WebUIDeviceActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the device identifier for the device that invoked AutoPlay. 
     */
    deviceInformationId: string;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action associated with the activated device. 
     */
    verb: string
}


/**
 * Provides information for a device that invokes pairing. 
 */
declare class WebUIDevicePairingActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets info about the device that triggered the operation. 
     */
    deviceInformation: undefined.DeviceInformation;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides data when an app is activated from another app by using the DIAL protocol. 
 */
declare class WebUIDialReceiverActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the name of the app that invoked the dial receiver app. 
     */
    appName: string;

    /**
     * Gets the arguments that are passed to the app during its launch activation. 
     */
    arguments: string;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the identifier of the source tile that launched the app. 
     */
    tileId: string
}


/**
 * Provides data when an app is activated because it is the app associated with a file. 
 */
declare class WebUIFileActivatedEventArgs {

    /**
     * Gets the app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the files for which the app was activated. 
     */
    files: undefined.IVectorView<undefined.IStorageItem>;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the neighboring files of the files for which the app was activated. 
     */
    neighboringFilesQuery: undefined.StorageFileQueryResult;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the action associated with the activated file. 
     */
    verb: string
}


/**
 * Provides information about an activated event that fires when the user tries to pick files or folders that are provided by the app. 
 */
declare class WebUIFileOpenPickerActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the family name of the caller's package. 
     */
    callerPackageFamilyName: string;

    /**
     * Gets the letterbox UI of the file picker that is displayed when the user wants to pick files or folders that are provided by the app. 
     */
    fileOpenPickerUI: undefined.FileOpenPickerUI;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a file open picker operation. 
 */
declare class WebUIFileOpenPickerContinuationEventArgs {

    /**
     * Gets the app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets a set of values populated by the app before a FileOpenPicker operation that deactivates the app in order to provide context when the app is activated. 
     */
    continuationData: undefined.ValueSet;

    /**
     * Gets the files for which the app was activated. 
     */
    files: undefined.IVectorView<undefined.StorageFile>;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about an activated event that fires when the user saves a file through the file picker and selects the app as the location. 
 */
declare class WebUIFileSavePickerActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the family name of the caller's package. 
     */
    callerPackageFamilyName: string;

    /**
     * Gets the ID of the enterprise that owns the file. 
     */
    enterpriseId: string;

    /**
     * Gets the letterbox UI of the file picker that is displayed when the user saves a file and selects the app as the save location. 
     */
    fileSavePickerUI: undefined.FileSavePickerUI;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a file save picker operation. 
 */
declare class WebUIFileSavePickerContinuationEventArgs {

    /**
     * Gets the app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets a set of values populated by the app before a FileSavePicker operation that deactivates the app in order to provide context when the app is activated. 
     */
    continuationData: undefined.ValueSet;

    /**
     * Gets the file for which the app was activated. 
     */
    file: undefined.StorageFile;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about an activated event that fires after the app was suspended for a folder picker operation. 
 */
declare class WebUIFolderPickerContinuationEventArgs {

    /**
     * Gets the app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets a set of values populated by the app before a FolderPicker operation that deactivates the app in order to provide context when the app is activated. 
     */
    continuationData: undefined.ValueSet;

    /**
     * Gets the folder selected by the user during the folder picker operation. 
     */
    folder: undefined.StorageFolder;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides event information when an app is launched. 
 */
declare class WebUILaunchActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the arguments that are passed to the app during its launch activation. 
     */
    arguments: string;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * (Applies to Windows only) Gets an indication about whether a pre-launch has been activated. 
     */
    prelaunchActivated: boolean;

    /**
     * Gets the execution state of the app before this activation. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the ID of the source that was invoked to launch the application. 
     */
    tileId: string
}


/**
 * Represents arguments used when the lock screen is activated. 
 */
declare class WebUILockScreenActivatedEventArgs {

    /**
     * Gets the object that manages an app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets information about the app activation operation. 
     */
    info: any;

    /**
     * Gets and activation kind for the app activation operation. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the previous execution state. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides event information when communication to and from the lock screen is required. 
 */
declare class WebUILockScreenCallActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the arguments that are passed to the app during its launch activation. 
     */
    arguments: string;

    /**
     * Gets the UI that handles communication to and from the lock screen. 
     */
    callUI: undefined.LockScreenCallUI;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object, which provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the identifier of the source that launched the app. 
     */
    tileId: string
}


/**
 * Manages delayed navigation for an app. 
 */
declare class WebUINavigatedDeferral {

    /**
     * Notifies the system that the app has set up its state and UI and is ready to be displayed after a top level navigation. 
     */
    complete(): void
}


/**
 * Provides data for an app navigation event. 
 */
declare class WebUINavigatedEventArgs {

    /**
     * Gets the app navigation operation. 
     */
    navigatedOperation: undefined.WebUINavigatedOperation
}


/**
 * Manages an app navigation operation. 
 */
declare class WebUINavigatedOperation {

    /**
     * Requests that the completion of app navigation be delayed.
     * @return  The navigated deferral object.
     */
    getDeferral(): undefined.WebUINavigatedDeferral
}


/**
 * Represents the arguments related to activating a 3D print workflow. 
 */
declare class WebUIPrint3DWorkflowActivatedEventArgs {

    /**
     * Gets the activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the kind of activation. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the previous execution state. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the print workflow. 
     */
    workflow: undefined.Print3DWorkflow
}


/**
 * Provided in response to the event that is raised when print task settings are activated. 
 */
declare class WebUIPrintTaskSettingsActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the configuration information for the print task. 
     */
    configuration: undefined.PrintTaskConfiguration;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before the settings were activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides data when an app is activated because it is the app associated with a URI scheme name. 
 */
declare class WebUIProtocolActivatedEventArgs {

    /**
     * Gets the app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the family name of the caller's package. 
     */
    callerPackageFamilyName: string;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the data used for activation. 
     */
    data: undefined.ValueSet;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the Uniform Resource Identifier (URI) for which the app was activated. 
     */
    uri: undefined.Uri
}


/**
 * Describes the activation arguments when an app is launched via LaunchUriForResultsAsync . 
 */
declare class WebUIProtocolForResultsActivatedEventArgs {

    /**
     * Gets the app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the family name of the caller's package. 
     */
    callerPackageFamilyName: string;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the data associated with the activation. 
     */
    data: undefined.ValueSet;

    /**
     * Gets the kind of activation. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the previous execution state. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets info about the protocol for results operation that triggered the activation. 
     */
    protocolForResultsOperation: undefined.ProtocolForResultsOperation;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the Uniform Resource Identifier (URI) for which the app was activated. 
     */
    uri: undefined.Uri
}


/**
 * Provides event information when a restricted app is launched. 
 */
declare class WebUIRestrictedLaunchActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets information about a shared context for the restricted launch. 
     */
    sharedContext: any;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about the activated event that fires when the user searches the app from the Search charm and the app isn't the main app on screen. 
 */
declare class WebUISearchActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the identifier for the currently shown app view. 
     */
    currentlyShownApplicationViewId: number;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the Internet Engineering Task Force (IETF) language tag (BCP 47 standard) that identifies the language currently associated with the user's text input device. 
     */
    language: string;

    /**
     * Gets a SearchPaneQueryLinguisticDetails object that provides info about query text that the user enters through an Input Method Editor (IME). 
     */
    linguisticDetails: undefined.SearchPaneQueryLinguisticDetails;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the text that the user wants the app to search for. The user entered this text into the search box of the search pane. 
     */
    queryText: string;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information for an application that is a target for share operations. 
 */
declare class WebUIShareTargetActivatedEventArgs {

    /**
     * Gets the app activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets information about data included in a share operation. 
     */
    shareOperation: undefined.ShareOperation;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information about an event that occurs when the app is activated because a user tapped on the body of a toast notification or performed an action inside a toast notification. 
 */
declare class WebUIToastNotificationActivatedEventArgs {

    /**
     * Gets the app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the arguments that the app can retrieve after it is activated through an interactive toast notification. 
     */
    argument: string;

    /**
     * Gets the kind of activation. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the previous execution state of the app. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets a set of values that you can use to obtain the user input from an interactive toast notification. 
     */
    userInput: undefined.ValueSet
}


/**
 * Provides information about an activated event raised when the app is activated from a voice command. 
 */
declare class WebUIVoiceCommandActivatedEventArgs {

    /**
     * Gets the app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the SpeechRecognitionResult object representing the voice command that activated the app. 
     */
    result: undefined.SpeechRecognitionResult;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information to an app that was launched as the result of a wallet action. 
 */
declare class WebUIWalletActionActivatedEventArgs {

    /**
     * Gets the ID of the action, such as the id of the verb, transaction and so on. 
     */
    actionId: string;

    /**
     * Gets the action that was performed on the WalletItem. 
     */
    actionKind: undefined.WalletActionKind;

    /**
     * Gets the app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the ID of the WalletItem on which the user performed the action. 
     */
    itemId: string;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Represents the arguments involved in activated a web account provider. 
 */
declare class WebUIWebAccountProviderActivatedEventArgs {

    /**
     * Gets the activated operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets the kind of activation. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the web account provider operation. 
     */
    operation: undefined.IWebAccountProviderOperation;

    /**
     * Gets the previous execution state of the app. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen. 
     */
    splashScreen: undefined.SplashScreen
}


/**
 * Provides information to an app that was launched after being suspended for a web authentication broker operation. 
 */
declare class WebUIWebAuthenticationBrokerContinuationEventArgs {

    /**
     * Gets the app activation operation. 
     */
    activatedOperation: undefined.ActivatedOperation;

    /**
     * Gets a set of values populated by the app before a web authentication broker operation that deactivates the app in order to provide context when the app is activated. 
     */
    continuationData: undefined.ValueSet;

    /**
     * Gets the activation type. 
     */
    kind: undefined.ActivationKind;

    /**
     * Gets the execution state of the app before it was activated. 
     */
    previousExecutionState: undefined.ApplicationExecutionState;

    /**
     * Gets the splash screen object that provides information about the transition from the splash screen to the activated app. 
     */
    splashScreen: undefined.SplashScreen;

    /**
     * Gets the WebAuthenticationResult object returned from the web authentication broker operation. 
     */
    webAuthenticationResult: undefined.WebAuthenticationResult
}


/**
 * Represents a method that handles the app activation event. 
 */
declare type WebUI$ActivatedEventHandler = (ev: undefined.IActivatedEventArgs & Windows$WinRTEvent<any>) => void;


/**
 * Represents a method that handles the app navigation event. 
 */
declare type WebUI$NavigatedEventHandler = (ev: undefined.IWebUINavigatedEventArgs & Windows$WinRTEvent<any>) => void;


/**
 * Represents a method that handles the app resumption event. 
 */
declare type WebUI$ResumingEventHandler = (ev: Windows$WinRTEvent<any>) => void;


/**
 * Represents a method that handles the app suspension event. 
 */
declare type WebUI$SuspendingEventHandler = (ev: undefined.ISuspendingEventArgs & Windows$WinRTEvent<any>) => void;


/**
 * Provides access to an instance of a background task. 
 */
declare interface WebUI$IWebUIBackgroundTaskInstance {

    /**
     * Gets or sets the success value for the background task. The success value is what is returned to the foreground instance of your app in the completed event. 
     */
    succeeded: boolean
}


/**
 * Provides data for an app navigation event. 
 */
declare interface WebUI$IWebUINavigatedEventArgs {

    /**
     * Gets the app navigation operation. 
     */
    navigatedOperation: undefined.WebUINavigatedOperation
}






































/**
 * Describes a color in terms of alpha, red, green, and blue channels. 
 */
declare interface UI$Color {

    /**
     * Gets or sets the sRGB alpha channel value of the color. 
     */
    a: number,

        /**
         * Gets or sets the sRGB blue channel value of the color. 
         */
        b: number,

        /**
         * Gets or sets the sRGB green channel value of the color. 
         */
        g: number,

        /**
         * Gets or sets the sRGB red channel value of the color. 
         */
        r: number
}


/**
 * Encapsulates the methods needed to implement the AtomPub protocol which enables HTTP CRUD access to Web resources using the Atom 1.0 wire format. 
 */
declare class AtomPubClient {

    /**
     * Creates a new AtomPubClient object with the credential to use when making requests to the server. Initially, a 'username/password' tuple. However, for domain credentials, the username must be in 'domain\user form'.
     * @param serverCredential The specified security credentials.
     */
    constructor(serverCredential: undefined.PasswordCredential): this;

    /**
     * Creates a new AtomPubClient object. 
     */
    constructor(): this;

    /**
     * Gets or sets a Boolean value that specifies whether to bypass the cache when retrieving the feed. 
     */
    bypassCacheOnRetrieve: boolean;

    /**
     * Cancels any in-progress asynchronous operations, causing them to fail (asynchronously) with an error code indicating cancellation. 
     */
    cancelAsyncOperations(): void;

    /**
     * Creates a new media resource in the specified collection.
     * @param uri The URI of the specified collection in which the new resource should be created.
     * @param mediaType The type for the media resource.
     * @param description The description of the new resource that is turned into the Slug: header of the POST request.
     * @param mediaStream Specifies the IInputStream to use as the media resource.
     * @return  The object that is used to create the resource asynchronously and to report the progress and completion status of the operation.
     */
    createMediaResourceAsync(
        uri: undefined.Uri,
        mediaType: string,
        description: string,
        mediaStream: undefined.IInputStream): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.SyndicationItem, undefined.TransferProgress>;

    /**
     * Creates a new Entry resource in the specified collection. The Uri of the collection in which to create the new resource can be discovered from the ResourceCollection object retrieved from the RetrieveResourceAsync method.
     * @param uri The Uri of the specified collection in which the new resource should be created.
     * @param description The description of the new resource that is turned into the Slug: header of the POST request.
     * @param item The new resource to be created.
     * @return  The object that is used to create the resource asynchronously and to report the progress and completion status of the operation.
     */
    createResourceAsync(
        uri: undefined.Uri,
        description: string,
        item: undefined.SyndicationItem): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.SyndicationItem, undefined.TransferProgress>;

    /**
     * Deletes an existing Entry or Media Link resource.
     * @param uri The Uri of the resource to be deleted.
     * @return  The object that is used to delete the resource asynchronously and to report the progress and completion status of the operation.
     */
    deleteResourceAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncActionWithProgress<undefined.TransferProgress>;

    /**
     * Deletes an existing Entry or Media Link resource. This differs from the DeleteResourceAsync method in that the SyndicationItem object that represents the resource to be deleted is specified instead of the Uri. The DeleteResourceItemAsync method uses the EditUri property of the specified SyndicationItem as the Uri of the resource to be deleted.
     * @param item The resource to be deleted.
     * @return  The object that is used to delete the resource asynchronously and to report the progress and completion status of the operation.
     */
    deleteResourceItemAsync(
        item: undefined.SyndicationItem): undefined.IPromiseWithIAsyncActionWithProgress<undefined.TransferProgress>;

    /**
     * Gets or sets the maximum number of bytes to buffer when receiving a response from a server. 
     */
    maxResponseBufferSize: number;

    /**
     * Gets or sets the credentials to use when making requests via a proxy. 
     */
    proxyCredential: undefined.PasswordCredential;

    /**
     * Starts an asynchronous operation to download the syndication feed from the given URI. This method instantiates a SyndicationFeed object from the feed string, which can be in one of the formats specified in SyndicationFormat .
     * @param uri The URI from which the feed is downloaded.
     * @return  Contains the results of the operation.
     */
    retrieveFeedAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.SyndicationFeed, undefined.RetrievalProgress>;

    /**
     * Retrieves a media link resource from the specified Uniform Resource Identifier (URI).
     * @param uri The URI for the media resource.
     * @return  The object used to retrieve the media resource and report the progress and completion status of the operation.
     */
    retrieveMediaResourceAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IInputStream, undefined.RetrievalProgress>;

    /**
     * Retrieves an Entry resource or Media Link resource from the specified Uniform Resource Identifier (URI).
     * @param uri The specified URI.
     * @return  The object that is used to retrieve the resource asynchronously and to report the progress and completion status of the operation.
     */
    retrieveResourceAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.SyndicationItem, undefined.RetrievalProgress>;

    /**
     * Retrieves a service document from the specified Uri.
     * @param uri The specified Uri.
     * @return  The object that is used to retrieve the service document asynchronously and to report the progress and completion status of the operation.
     */
    retrieveServiceDocumentAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.ServiceDocument, undefined.RetrievalProgress>;

    /**
     * Gets or sets the credentials to use when making requests to the server. 
     */
    serverCredential: undefined.PasswordCredential;

    /**
     * Sets an HTTP header for the request. This method can be called multiple times to set multiple headers. When the same header is set multiple times, the values will be concatenated and separated by ",".
     * @param name The name of the header.
     * @param value The value of the header.
     */
    setRequestHeader(name: string, value: string): void;

    /**
     * Gets or sets the maximum amount of time, in milliseconds, to wait for any of the asynchronous operations to complete. If the operation is not complete within this amount of time, it will fail with a status code indicating that it timed out. 
     */
    timeout: number;

    /**
     * Updates a media link resource from the specified Uniform Resource Identifier (URI).
     * @param uri The URI of the resource to be updated.
     * @param mediaType The media type of the resource.
     * @param mediaStream The IInputStream of the media that is updating the media resource.
     * @return  Completion status or error codes.
     */
    updateMediaResourceAsync(
        uri: undefined.Uri,
        mediaType: string,
        mediaStream: undefined.IInputStream): undefined.IPromiseWithIAsyncActionWithProgress<undefined.TransferProgress>;

    /**
     * Updates an existing Entry or Media Link resource. If an ETag: header has previously been seen while retrieving this resource (in a response to RetrieveResourceAsync , CreateResourceAsync or a previous call to UpdateResourceAsync), this method automatically sends an If-Match: header with the remembered value.
     * @param uri The URI of the resource to be updated.
     * @param item The resource to be updated.
     * @return  The object that is used to update the resource asynchronously and to report the progress and completion status of the operation.
     */
    updateResourceAsync(
        uri: undefined.Uri,
        item: undefined.SyndicationItem): undefined.IPromiseWithIAsyncActionWithProgress<undefined.TransferProgress>;

    /**
     * Updates an existing Entry or Media Link resource. This differs from the UpdateResourceAsync method in that the EditUri property of the specified SyndicationItem object is used as the Uri of the resource to be updated.
     * @param item The resource to be updated.
     * @return  The object that is used to update the resource asynchronously and to report the progress and completion status of the operation.
     */
    updateResourceItemAsync(
        item: undefined.SyndicationItem): undefined.IPromiseWithIAsyncActionWithProgress<undefined.TransferProgress >
}


/**
 * Encapsulates one or more collections within a workspace. 
 */
declare class ResourceCollection {

    /**
     * Gets or sets the collection of app:accept elements. 
     */
    accepts: undefined.IVectorView<string>;

    /**
     * Gets the list of attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets or sets the Uniform Resource Identifier (URI) for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets the collection of atom:category elements within the app:categories element. 
     */
    categories: undefined.IVectorView<undefined.SyndicationCategory>;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Generates the DOM object that represents this element, and all the attributes and child elements including foreign markups.
     * @param format The format of the element. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @return  The XML document.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets or sets the local name of the element. It must be valid according to XML 1.0. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this attribute is NULL. 
     */
    nodeValue: string;

    /**
     * Gets the atom:title element under the app:collection element. 
     */
    title: undefined.ISyndicationText;

    /**
     * Gets the Uniform Resource Identifier (URI) representing the href attribute of the app:collection element. This is the absolute URI resolved against the xml:base attribute when it is present. If the href attribute is a relative URI string and there is no xml:base attribute, this property will be Null. 
     */
    uri: undefined.Uri
}


/**
 * Encapsulates a service document. 
 */
declare class ServiceDocument {

    /**
     * Gets the list of attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets or sets the Uniform Resource Identifier (URI) for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Generates the DOM object that represents this element, and all the attributes and child elements including foreign markups.
     * @param format The format of the element. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @return  The XML document.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets or sets the local name of the element. It must be valid according to XML 1.0. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this attribute is NULL. 
     */
    nodeValue: string;

    /**
     * Gets the collection of app:workspace elements in the service document. 
     */
    workspaces: undefined.IVectorView<undefined.Workspace >
}


/**
 * Encapsulates a workspace in a service document. 
 */
declare class Workspace {

    /**
     * Gets the list of attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets or sets the Uniform Resource Identifier (URI) for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets the read-only collection of app:collection elements within the app:workspace element. 
     */
    collections: undefined.IVectorView<undefined.ResourceCollection>;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Generates the DOM object that represents this element, and all the attributes and child elements including foreign markups.
     * @param format The format for the element. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @return  The XML document.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets or sets the local name of the element. It must be valid according to XML 1.0. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this attribute is NULL. 
     */
    nodeValue: string;

    /**
     * Gets the atom:title element under the app:workspace element. 
     */
    title: undefined.ISyndicationText
}


/**
 * Provides a simple diagnostic facility for tracing and profiling web traffic in applications built on Microsoft’s HTTP stacks. 
 */
declare class HttpDiagnosticProvider {

    /**
     * Creates a new HttpDiagnosticProvider based on the specified ProcessDiagnosticInfo object.
     * @param processDiagnosticInfo The ProcessDiagnosticInfo that identifies the process to watch.
     * @return  The newly created HttpDiagnosticProvider .
     */
    createFromProcessDiagnosticInfo(
        processDiagnosticInfo: undefined.ProcessDiagnosticInfo): undefined.HttpDiagnosticProvider;

    /**
     * Subscribe to the RequestResponseCompleted event to receive a notification that a request has been submitted. 
     */
    onrequestresponsecompleted: undefined.TypedEventHandler<undefined.HttpDiagnosticProvider, undefined.HttpDiagnosticProviderRequestResponseCompletedEventArgs>;
    addEventListener(
        type: "requestresponsecompleted",
        listener: undefined.TypedEventHandler<undefined.HttpDiagnosticProvider, undefined.HttpDiagnosticProviderRequestResponseCompletedEventArgs>): void;
    removeEventListener(
        type: "requestresponsecompleted",
        listener: undefined.TypedEventHandler<undefined.HttpDiagnosticProvider, undefined.HttpDiagnosticProviderRequestResponseCompletedEventArgs>): void;

    /**
     * Subscribe to the RequestSent event to receive a notification that a request has been sent. 
     */
    onrequestsent: undefined.TypedEventHandler<undefined.HttpDiagnosticProvider, undefined.HttpDiagnosticProviderRequestSentEventArgs>;
    addEventListener(
        type: "requestsent",
        listener: undefined.TypedEventHandler<undefined.HttpDiagnosticProvider, undefined.HttpDiagnosticProviderRequestSentEventArgs>): void;
    removeEventListener(
        type: "requestsent",
        listener: undefined.TypedEventHandler<undefined.HttpDiagnosticProvider, undefined.HttpDiagnosticProviderRequestSentEventArgs>): void;

    /**
     * Subscribe to the ResponseReceived event to receive a notification that a response has been received. 
     */
    onresponsereceived: undefined.TypedEventHandler<undefined.HttpDiagnosticProvider, undefined.HttpDiagnosticProviderResponseReceivedEventArgs>;
    addEventListener(
        type: "responsereceived",
        listener: undefined.TypedEventHandler<undefined.HttpDiagnosticProvider, undefined.HttpDiagnosticProviderResponseReceivedEventArgs>): void;
    removeEventListener(
        type: "responsereceived",
        listener: undefined.TypedEventHandler<undefined.HttpDiagnosticProvider, undefined.HttpDiagnosticProviderResponseReceivedEventArgs>): void;

    /**
     * Starts the HttpDiagnosticProvider monitoring the attached process target. 
     */
    start(): void;

    /**
     * Stops the HttpDiagnosticProvider from monitoring the attached process target. 
     */
    stop(): void;
    addEventListener(type: string, listener: undefined.EventHandler<any>): void;
    removeEventListener(type: string, listener: undefined.EventHandler<any>): void
}


/**
 * Provides data for the RequestResponseCompleted event. 
 */
declare class HttpDiagnosticProviderRequestResponseCompletedEventArgs {

    /**
     * Gets a locally unique ID for this activity, for correlating with other events. 
     */
    activityId: string;

    /**
     * Gets the type of operation initiating this request. 
     */
    initiator: undefined.HttpDiagnosticRequestInitiator;
    processId: any;

    /**
     * Gets the URI of the requested response. 
     */
    requestedUri: undefined.Uri;
    sourceLocations: any;
    threadId: any;

    /**
     * Gets the timestamp for connection events. 
     */
    timestamps: undefined.HttpDiagnosticProviderRequestResponseTimestamps
}


/**
 * Provides all the timestamps for connection events. 
 */
declare class HttpDiagnosticProviderRequestResponseTimestamps {

    /**
     * Gets the last time local cache was checked. 
     */
    cacheCheckedTimestamp: Date;

    /**
     * Gets the timestamp for the end of the TCP connection phase. 
     */
    connectionCompletedTimestamp: Date;

    /**
     * Gets the timestamp for the start of the TCP connection phase. 
     */
    connectionInitiatedTimestamp: Date;

    /**
     * Gets the time of the DNS name resolution. 
     */
    nameResolvedTimestamp: Date;

    /**
     * Gets the timestamp for the last byte sent. 
     */
    requestCompletedTimestamp: Date;

    /**
     * Gets the timestamp for the first byte sent. 
     */
    requestSentTimestamp: Date;

    /**
     * Gets the timestamp for the last byte received. 
     */
    responseCompletedTimestamp: Date;

    /**
     * Gets the timestamp for the fir byte received. 
     */
    responseReceivedTimestamp: Date;

    /**
     * Gets the time of the SSL handshake negotiation. 
     */
    sslNegotiatedTimestamp: Date
}


/**
 * Provides data for the RequestSent event. 
 */
declare class HttpDiagnosticProviderRequestSentEventArgs {

    /**
     * Gets a locally unique ID for this activity, for correlating with other events. 
     */
    activityId: string;

    /**
     * Gets the type of operation initiating this request. 
     */
    initiator: undefined.HttpDiagnosticRequestInitiator;

    /**
     * Gets the HttpRequestMessage including headers. 
     */
    message: undefined.HttpRequestMessage;

    /**
     * Gets the process ID. 
     */
    processId: number;

    /**
     * Gets the source location call stack. 
     */
    sourceLocations: undefined.IVectorView<undefined.HttpDiagnosticSourceLocation>;

    /**
     * Gets the thread ID. 
     */
    threadId: number;

    /**
     * Gets the timestamp of when the HttpRequestMessage was sent. 
     */
    timestamp: Date
}


/**
 * Provides data for the ResponseReceived event. 
 */
declare class HttpDiagnosticProviderResponseReceivedEventArgs {

    /**
     * Gets a locally unique ID for this activity, for correlating with other events. 
     */
    activityId: string;

    /**
     * Gets the HttpResponseMessage including headers, the status code, and data. 
     */
    message: undefined.HttpResponseMessage;

    /**
     * Gets the timestamp of when the HttpResponseMessage was received. 
     */
    timestamp: Date
}


/**
 * Contains the source location of the HTTP activity. 
 */
declare class HttpDiagnosticSourceLocation {

    /**
     * Gets the column number. 
     */
    columnNumber: number;

    /**
     * Gets the line number. 
     */
    lineNumber: number;

    /**
     * Gets the source URI. 
     */
    sourceUri: undefined.Uri
}


/**
 * The base protocol filter for an HttpClient instance. 
 */
declare class HttpBaseProtocolFilter {

    /**
     * Initializes a new instance of the HttpBaseProtocolFilter class. 
     */
    constructor(): this;

    /**
     * Get or set a value that indicates whether the HttpBaseProtocolFilter should follow redirection responses. 
     */
    allowAutoRedirect: boolean;

    /**
     * Get or set a value that indicates whether the HttpBaseProtocolFilter can prompt for user credentials when requested by the server. 
     */
    allowUI: boolean;

    /**
     * Gets or sets a value that indicates whether the HttpBaseProtocolFilter can automatically decompress the HTTP content response. 
     */
    automaticDecompression: boolean;

    /**
     * Get or set the read and write cache control behavior to be used on the HttpBaseProtocolFilter object. 
     */
    cacheControl: undefined.HttpCacheControl;

    /**
     * Get or set the client SSL certificate that will be sent to the server if the server requests a client certificate. 
     */
    clientCertificate: undefined.Certificate;

    /**
     * Closes the HttpBaseProtocolFilter instance and releases allocated resources. 
     */
    close(): void;

    /**
     * Get the HttpCookieManager with the cookies associated with an app. 
     */
    cookieManager: undefined.HttpCookieManager;

    /**
     * Gets or sets the cookie usage behavior. By default, cookies are handled automatically. 
     */
    cookieUsageBehavior: undefined.HttpCookieUsageBehavior;

    /**
     * Get a vector of SSL server certificate errors that the app might subsequently choose to ignore. 
     */
    ignorableServerCertificateErrors: undefined.IVector<undefined.ChainValidationResult>;

    /**
     * Get or set the maximum number of TCP connections allowed per HTTP server by the HttpBaseProtocolFilter object. 
     */
    maxConnectionsPerServer: number;

    /**
     * Gets or sets the version of the HTTP protocol used. 
     */
    maxVersion: undefined.HttpVersion;

    /**
     * Get or set the credentials to be used to negotiate with an HTTP proxy. 
     */
    proxyCredential: undefined.PasswordCredential;

    /**
     * Send an HTTP request using the HttpBaseProtocolFilter as an asynchronous operation.
     * @param request The HTTP request message to send.
     * @return  The object representing the asynchronous operation.
     */
    sendRequestAsync(
        request: undefined.HttpRequestMessage): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.HttpResponseMessage, undefined.HttpProgress>;

    /**
     * Get or set the credentials to be used to authenticate with an HTTP server. 
     */
    serverCredential: undefined.PasswordCredential;

    /**
     * Get or set a value that indicates whether the HttpBaseProtocolFilter can use a proxy for sending HTTP requests. 
     */
    useProxy: boolean
}


/**
 * Provides control of the local HTTP cache for responses to HTTP requests by methods in the Windows.Web.Http and Windows.Web.Http.Filters namespaces. 
 */
declare class HttpCacheControl {

    /**
     * Get or set the read behavior to use for cache control on the HttpCacheControl object. 
     */
    readBehavior: undefined.HttpCacheReadBehavior;

    /**
     * Get or set the write behavior to use for cache control on the HttpCacheControl object. 
     */
    writeBehavior: undefined.HttpCacheWriteBehavior
}


/**
 * An interface used to implement custom filters for an HttpClient instance. 
 */
declare type Filters$IHttpFilter = {

    /**
     * Send an HTTP request on the IHttpFilter instance as an asynchronous operation.
     * @param request The HTTP request message to send.
     * @return  The object representing the asynchronous operation.
     */
    sendRequestAsync(
        request: undefined.HttpRequestMessage): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.HttpResponseMessage,
    undefined.HttpProgress >
}


/**
 * Represents the value of the Cache-Control HTTP header on HTTP content associated with an HTTP request or response. 
 */
declare class HttpCacheDirectiveHeaderValueCollection mixins Array<undefined.HttpNameValueHeaderValue>{

    /**
     * Adds a new HttpNameValueHeaderValue item to the end of the collection.
     * @param value The HttpNameValueHeaderValue object to append.
     */
    append(value: undefined.HttpNameValueHeaderValue): void;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpNameValueHeaderValue item in the collection.
     * @return  An object that can be used to enumerate the HttpNameValueHeaderValue items in the collection. The iterator points to the first HttpNameValueHeaderValue item in the HttpCacheDirectiveHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpNameValueHeaderValue>;

    /**
     * Returns the HttpNameValueHeaderValue at the specified index in the collection.
     * @param index The zero-based index of a specified item in the HttpCacheDirectiveHeaderValueCollection .
     * @return  The HttpNameValueHeaderValue at the specified index in the HttpCacheDirectiveHeaderValueCollection .
     */
    getAt(index: number): undefined.HttpNameValueHeaderValue;

    /**
     * Retrieves the HttpNameValueHeaderValue items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpNameValueHeaderValue items in the HttpCacheDirectiveHeaderValueCollection .
     */
    getMany(
        startIndex: number): {
        items: undefined.HttpNameValueHeaderValue,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpCacheDirectiveHeaderValueCollection .
     * @return  The view of the HttpCacheDirectiveHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpNameValueHeaderValue>;

    /**
     * Retrieves the index of an HttpNameValueHeaderValue in the collection.
     * @param value The HttpNameValueHeaderValue to find in the HttpCacheDirectiveHeaderValueCollection .
     */
    indexOf(
        value: undefined.HttpNameValueHeaderValue): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpNameValueHeaderValue): number;

    /**
     * Inserts an HttpNameValueHeaderValue into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpNameValueHeaderValue): void;

    /**
     * Gets or sets the value of the max-age directive in the Cache-Control HTTP header. 
     */
    maxAge: number;

    /**
     * Gets or sets the value of the max-stale directive in the Cache-Control HTTP header. 
     */
    maxStale: number;

    /**
     * Gets or sets the value of the min-fresh directive in the Cache-Control HTTP header. 
     */
    minFresh: number;

    /**
     * Parses and adds an entry to the HttpCacheDirectiveHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpCacheDirectiveHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpNameValueHeaderValue item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpNameValueHeaderValue items in the collection with the specified HttpNameValueHeaderValue items.
     * @param items The collection of HttpNameValueHeaderValue items to add to the collection.
     */
    replaceAll(items: undefined.HttpNameValueHeaderValue): void;

    /**
     * Sets the HttpNameValueHeaderValue at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpNameValueHeaderValue .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpNameValueHeaderValue): void;

    /**
     * Gets or sets the value of the s-maxage directive in the Cache-Control HTTP header. 
     */
    sharedMaxAge: number;

    /**
     * Gets the number of HttpNameValueHeaderValue objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpCacheDirectiveHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpNameValueHeaderValue,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.HttpNameValueHeaderValue, fromIndex?: number): number
}


/**
 * Represents authentication information used in the Proxy-Authenticate and WWW-Authenticate HTTP header values. 
 */
declare class HttpChallengeHeaderValue {

    /**
     * Converts a string to an HttpChallengeHeaderValue instance.
     * @param input A string that represents authentication header value information.
     * @return  An HttpChallengeHeaderValue instance.
     */
    parse(input: string): undefined.HttpChallengeHeaderValue;

    /**
     * Determines whether a string is valid HttpChallengeHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        challengeHeaderValue: undefined.HttpChallengeHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpChallengeHeaderValue class with the scheme to use for authorization and the SPNEGO token.
     * @param scheme The scheme to use for authorization.
     * @param token The SPNEGO token to use with the Negotiate protocol scheme.
     */
    constructor(scheme: string, token: string): this;

    /**
     * Initializes a new instance of the HttpChallengeHeaderValue class with the scheme to use for authorization.
     * @param scheme The scheme to use for authorization.
     */
    constructor(scheme: string): this;

    /**
     * Gets the credentials that contain the authentication information of the user agent for the resource being requested. 
     */
    parameters: undefined.IVector<undefined.HttpNameValueHeaderValue>;

    /**
     * Gets the scheme to use for authentication. 
     */
    scheme: string;

    /**
     * The SPNEGO token to use with the Negotiate protocol scheme. 
     */
    token: string
}


/**
 * Represents the value of the Proxy-Authenticate or WWW-Authenticate HTTP header on an HTTP response. 
 */
declare class HttpChallengeHeaderValueCollection mixins Array<undefined.HttpChallengeHeaderValue>{

    /**
     * Adds a new HttpChallengeHeaderValue item to the end of the collection.
     * @param value The HttpChallengeHeaderValue object to append.
     */
    append(value: undefined.HttpChallengeHeaderValue): void;

    /**
     * Removes all HttpChallengeHeaderValue objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpChallengeHeaderValue item in the collection.
     * @return  An object that can be used to enumerate the HttpChallengeHeaderValue items in the collection. The iterator points to the first HttpChallengeHeaderValue item in the HttpChallengeHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpChallengeHeaderValue>;

    /**
     * Returns the HttpChallengeHeaderValue at the specified index in the collection.
     * @param index The zero-based index of a specified item in the HttpChallengeHeaderValueCollection .
     * @return  The HttpChallengeHeaderValue at the specified index in the HttpChallengeHeaderValueCollection
     */
    getAt(index: number): undefined.HttpChallengeHeaderValue;

    /**
     * Retrieves the HttpChallengeHeaderValue items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpChallengeHeaderValue items in the HttpChallengeHeaderValueCollection .
     */
    getMany(
        startIndex: number): {
        items: undefined.HttpChallengeHeaderValue,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpChallengeHeaderValueCollection .
     * @return  The view of the HttpChallengeHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpChallengeHeaderValue>;

    /**
     * Retrieves the index of an HttpChallengeHeaderValue in the collection.
     * @param value The HttpChallengeHeaderValue to find in the HttpChallengeHeaderValueCollection .
     */
    indexOf(
        value: undefined.HttpChallengeHeaderValue): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpChallengeHeaderValue): number;

    /**
     * Inserts an HttpChallengeHeaderValue into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpChallengeHeaderValue): void;

    /**
     * Parses and adds an entry to the HttpChallengeHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpChallengeHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpChallengeHeaderValue item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpChallengeHeaderValue items in the collection with the specified HttpChallengeHeaderValue items.
     * @param items The collection of HttpChallengeHeaderValue items to add to the collection.
     */
    replaceAll(items: undefined.HttpChallengeHeaderValue): void;

    /**
     * Sets the HttpChallengeHeaderValue at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpChallengeHeaderValue .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpChallengeHeaderValue): void;

    /**
     * Gets the number of HttpChallengeHeaderValue objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpChallengeHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpChallengeHeaderValue,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.HttpChallengeHeaderValue, fromIndex?: number): number
}


/**
 * Represents connection information used in the Connection HTTP header on an HTTP request. 
 */
declare class HttpConnectionOptionHeaderValue {

    /**
     * Converts a string to an HttpConnectionOptionHeaderValue instance.
     * @param input A string that represents the connection information in the Connection HTTP header.
     * @return  An HttpConnectionOptionHeaderValue instance.
     */
    parse(input: string): undefined.HttpConnectionOptionHeaderValue;

    /**
     * Determines whether a string is valid HttpConnectionOptionHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        connectionOptionHeaderValue: undefined.HttpConnectionOptionHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpConnectionOptionHeaderValue class.
     * @param token The value of the connection-token to use.
     */
    constructor(token: string): this;

    /**
     * Gets the value of the connection-token in the Connection HTTP header. 
     */
    token: string
}


/**
 * Represents the value of the Connection HTTP header on an HTTP request. 
 */
declare class HttpConnectionOptionHeaderValueCollection mixins Array<undefined.HttpConnectionOptionHeaderValue>{

    /**
     * Adds a new HttpConnectionOptionHeaderValue item to the end of the collection.
     * @param value The HttpConnectionOptionHeaderValue object to append.
     */
    append(value: undefined.HttpConnectionOptionHeaderValue): void;

    /**
     * Removes all HttpConnectionOptionHeaderValue objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpConnectionOptionHeaderValue item in the collection.
     * @return  An object that can be used to enumerate the HttpConnectionOptionHeaderValue items in the collection. The iterator points to the first HttpConnectionOptionHeaderValue item in the HttpConnectionOptionHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpConnectionOptionHeaderValue>;

    /**
     * Returns the HttpConnectionOptionHeaderValue at the specified index in the collection.
     * @param index The zero-based index of a specified item in the HttpConnectionOptionHeaderValueCollection .
     * @return  The HttpConnectionOptionHeaderValue at the specified index in the HttpConnectionOptionHeaderValueCollection .
     */
    getAt(index: number): undefined.HttpConnectionOptionHeaderValue;

    /**
     * Retrieves the HttpConnectionOptionHeaderValue items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpConnectionOptionHeaderValue items in the HttpConnectionOptionHeaderValueCollection .
     */
    getMany(
        startIndex: number): {
        items: undefined.HttpConnectionOptionHeaderValue,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpConnectionOptionHeaderValueCollection .
     * @return  The view of the HttpConnectionOptionHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpConnectionOptionHeaderValue>;

    /**
     * Retrieves the index of an HttpConnectionOptionHeaderValue in the collection.
     * @param value The HttpConnectionOptionHeaderValue to find in the HttpConnectionOptionHeaderValueCollection .
     */
    indexOf(
        value: undefined.HttpConnectionOptionHeaderValue): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpConnectionOptionHeaderValue): number;

    /**
     * Inserts an HttpConnectionOptionHeaderValue into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpConnectionOptionHeaderValue): void;

    /**
     * Parses and adds an entry to the HttpConnectionOptionHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpConnectionOptionHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpConnectionOptionHeaderValue item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpConnectionOptionHeaderValue items in the collection with the specified HttpConnectionOptionHeaderValue items.
     * @param items The collection of HttpConnectionOptionHeaderValue items to add to the collection.
     */
    replaceAll(items: undefined.HttpConnectionOptionHeaderValue): void;

    /**
     * Sets the HttpConnectionOptionHeaderValue at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpConnectionOptionHeaderValue .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpConnectionOptionHeaderValue): void;

    /**
     * Gets the number of HttpConnectionOptionHeaderValue objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpConnectionOptionHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpConnectionOptionHeaderValue,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(
        searchElement: undefined.HttpConnectionOptionHeaderValue,
        fromIndex?: number): number
}


/**
 * Represents content encoding information used in the Content-Encoding HTTP header on HTTP content in a request or a response. 
 */
declare class HttpContentCodingHeaderValue {

    /**
     * Converts a string to an HttpContentCodingHeaderValue instance.
     * @param input A string that represents the content coding information in the Content-Encoding HTTP header.
     * @return  An HttpContentCodingHeaderValue instance.
     */
    parse(input: string): undefined.HttpContentCodingHeaderValue;

    /**
     * Determines whether a string is valid HttpContentCodingHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        contentCodingHeaderValue: undefined.HttpContentCodingHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpContentCodingHeaderValue class.
     * @param contentCoding The value of the content-coding to use.
     */
    constructor(contentCoding: string): this;

    /**
     * Gets the value of the content-coding information used in the Content-Encoding HTTP header. 
     */
    contentCoding: string
}


/**
 * Represents the value of the Content-Encoding HTTP header on HTTP content in a request or a response. 
 */
declare class HttpContentCodingHeaderValueCollection mixins Array<undefined.HttpContentCodingHeaderValue>{

    /**
     * Adds a new HttpContentCodingHeaderValue item to the end of the collection.
     * @param value The HttpContentCodingHeaderValue object to append.
     */
    append(value: undefined.HttpContentCodingHeaderValue): void;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpContentCodingHeaderValue item in the collection.
     * @return  An object that can be used to enumerate the HttpContentCodingHeaderValue items in the collection. The iterator points to the first HttpContentCodingHeaderValue item in the HttpContentCodingHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpContentCodingHeaderValue>;

    /**
     * Returns the HttpContentCodingHeaderValue at the specified index in the collection.
     * @param index The zero-based index of a specified item in the HttpContentCodingHeaderValueCollection .
     * @return  The HttpContentCodingHeaderValue at the specified index in the HttpContentCodingHeaderValueCollection .
     */
    getAt(index: number): undefined.HttpContentCodingHeaderValue;

    /**
     * Retrieves the HttpContentCodingHeaderValue items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpContentCodingHeaderValue items in the HttpContentCodingHeaderValueCollection .
     */
    getMany(
        startIndex: number): {
        items: undefined.HttpContentCodingHeaderValue,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpContentCodingHeaderValueCollection .
     * @return  The view of the HttpContentCodingHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpContentCodingHeaderValue>;

    /**
     * Retrieves the index of an HttpContentCodingHeaderValue in the collection.
     * @param value The HttpContentCodingHeaderValue to find in the HttpContentCodingHeaderValueCollection .
     */
    indexOf(
        value: undefined.HttpContentCodingHeaderValue): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpContentCodingHeaderValue): number;

    /**
     * Inserts an HttpContentCodingHeaderValue into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpContentCodingHeaderValue): void;

    /**
     * Parses and adds an entry to the HttpContentCodingHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpContentCodingHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpContentCodingHeaderValue item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpContentCodingHeaderValue items in the collection with the specified HttpContentCodingHeaderValue items.
     * @param items The HttpContentCodingHeaderValue items to add to the collection.
     */
    replaceAll(items: undefined.HttpContentCodingHeaderValue): void;

    /**
     * Sets the HttpContentCodingHeaderValue at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpContentCodingHeaderValue .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpContentCodingHeaderValue): void;

    /**
     * Gets the number of HttpContentCodingHeaderValue objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpContentCodingHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpContentCodingHeaderValue,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(
        searchElement: undefined.HttpContentCodingHeaderValue,
        fromIndex?: number): number
}


/**
 * Represents accept encoding information used in the Accept-Encoding HTTP header on an HTTP request. 
 */
declare class HttpContentCodingWithQualityHeaderValue {

    /**
     * Converts a string to an HttpContentCodingWithQualityHeaderValue instance.
     * @param input A string that represents the content coding information in the Accept-Encoding HTTP header.
     * @return  An HttpContentCodingWithQualityHeaderValue instance.
     */
    parse(input: string): undefined.HttpContentCodingWithQualityHeaderValue;

    /**
     * Determines whether a string is valid HttpContentCodingWithQualityHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        contentCodingWithQualityHeaderValue: undefined.HttpContentCodingWithQualityHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpContentCodingHeaderValue class with content-coding information and a qvalue.
     * @param contentCoding The value of the content-coding information to use.
     * @param quality The value of the qvalue to use.
     */
    constructor(contentCoding: string, quality: number): this;

    /**
     * Initializes a new instance of the HttpContentCodingHeaderValue class with content-coding information.
     * @param contentCoding The value of the content-coding to use.
     */
    constructor(contentCoding: string): this;

    /**
     * Gets the value of the content-coding characteristic in the Accept-Encoding HTTP header. 
     */
    contentCoding: string;

    /**
     * Gets the value of the qvalue attribute in the Accept-Encoding HTTP header. 
     */
    quality: number
}


/**
 * Represents the value of the Accept-Encoding HTTP header on an HTTP request. 
 */
declare class HttpContentCodingWithQualityHeaderValueCollection mixins Array<undefined.HttpContentCodingWithQualityHeaderValue>{

    /**
     * Adds a new HttpContentCodingWithQualityHeaderValue item to the end of the collection.
     * @param value The HttpContentCodingWithQualityHeaderValue object to append.
     */
    append(value: undefined.HttpContentCodingWithQualityHeaderValue): void;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpContentCodingWithQualityHeaderValue item in the collection.
     * @return  An object that can be used to enumerate the HttpContentCodingWithQualityHeaderValue items in the collection. The iterator points to the first HttpContentCodingWithQualityHeaderValue item in the HttpContentCodingWithQualityHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpContentCodingWithQualityHeaderValue>;

    /**
     * Returns the HttpContentCodingWithQualityHeaderValue at the specified index in the collection.
     * @param index The zero-based index of a specified item in the collection.
     * @return  The HttpContentCodingWithQualityHeaderValue at the specified index in the HttpContentCodingWithQualityHeaderValueCollection .
     */
    getAt(index: number): undefined.HttpContentCodingWithQualityHeaderValue;

    /**
     * Retrieves the HttpContentCodingWithQualityHeaderValue items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpContentCodingWithQualityHeaderValue items in the HttpContentCodingWithQualityHeaderValueCollection .
     */
    getMany(
        startIndex: number): {
        items: undefined.HttpContentCodingWithQualityHeaderValue,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpContentCodingWithQualityHeaderValueCollection .
     * @return  The view of the HttpContentCodingWithQualityHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpContentCodingWithQualityHeaderValue>;

    /**
     * Retrieves the index of an HttpContentCodingWithQualityHeaderValue in the collection.
     * @param value The HttpContentCodingWithQualityHeaderValue to find in the HttpContentCodingWithQualityHeaderValueCollection .
     */
    indexOf(
        value: undefined.HttpContentCodingWithQualityHeaderValue): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpContentCodingWithQualityHeaderValue): number;

    /**
     * Inserts an HttpContentCodingWithQualityHeaderValue into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpContentCodingWithQualityHeaderValue): void;

    /**
     * Parses and adds an entry to the HttpContentCodingWithQualityHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpContentCodingWithQualityHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpContentCodingWithQualityHeaderValue item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpContentCodingWithQualityHeaderValue items in the collection with the specified HttpContentCodingWithQualityHeaderValue items.
     * @param items The HttpContentCodingWithQualityHeaderValue items to add to the collection.
     */
    replaceAll(items: undefined.HttpContentCodingWithQualityHeaderValue): void;

    /**
     * Sets the HttpContentCodingWithQualityHeaderValue at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpContentCodingWithQualityHeaderValue .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpContentCodingWithQualityHeaderValue): void;

    /**
     * Gets the number of HttpContentCodingWithQualityHeaderValue objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpContentCodingWithQualityHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpContentCodingWithQualityHeaderValue,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(
        searchElement: undefined.HttpContentCodingWithQualityHeaderValue,
        fromIndex?: number): number
}


/**
 * Represents the value of the Content-Disposition HTTP header on HTTP content in a request or a response. 
 */
declare class HttpContentDispositionHeaderValue {

    /**
     * Converts a string to an HttpContentDispositionHeaderValue instance.
     * @param input A string that represents the content disposition information in the Content-Disposition HTTP header.
     * @return  An HttpContentDispositionHeaderValue instance.
     */
    parse(input: string): undefined.HttpContentDispositionHeaderValue;

    /**
     * Determines whether a string is valid HttpContentDispositionHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        contentDispositionHeaderValue: undefined.HttpContentDispositionHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpContentDispositionHeaderValue class with content-coding information for use in the Content-Disposition HTTP header.
     * @param dispositionType The value of the disposition-type information to be used in the Content-Disposition HTTP header.
     */
    constructor(dispositionType: string): this;

    /**
     * Gets or sets the value of the disposition-type information in the Content-Disposition HTTP header. 
     */
    dispositionType: string;

    /**
     * Gets or sets the value of the filename-parm information in the Content-Disposition HTTP header for a single file. 
     */
    fileName: string;

    /**
     * Gets or sets the value of the filename-parm characteristic in the Content-Disposition HTTP header for multiple files. 
     */
    fileNameStar: string;

    /**
     * Gets or sets the name for a content body part in the Content-Disposition HTTP header. 
     */
    name: string;

    /**
     * Gets a set of parameters included in the Content-Disposition HTTP header. 
     */
    parameters: undefined.IVector<undefined.HttpNameValueHeaderValue>;

    /**
     * Gets or sets the approximate size, in bytes, of the file used in the Content-Disposition HTTP header. 
     */
    size: number
}


/**
 * Provides a collection of the HTTP headers associated with content on an HTTP request or response. 
 */
declare class HttpContentHeaderCollection {

    /**
     * Initializes a new instance of the HttpContentHeaderCollection class. 
     */
    constructor(): this;

    /**
     * Adds a new item to the end of the HttpContentHeaderCollection .
     * @param name The name of the value to add.
     * @param value The item value to add.
     */
    append(name: string, value: string): void;

    /**
     * Removes all objects from the HttpContentHeaderCollection . 
     */
    clear(): void;

    /**
     * Gets or sets the HttpContentDispositionHeaderValue object that represents the value of an HTTP Content-Disposition header on the HTTP content. 
     */
    contentDisposition: undefined.HttpContentDispositionHeaderValue;

    /**
     * Gets the HttpContentCodingHeaderValueCollection of HttpContentCodingHeaderValue objects that represent the value of an HTTP Content-Encoding header on the HTTP content. 
     */
    contentEncoding: undefined.HttpContentCodingHeaderValueCollection;

    /**
     * Gets the HttpLanguageHeaderValueCollection of objects that represent the value of an HTTP Content-Language header on the HTTP content. 
     */
    contentLanguage: undefined.HttpLanguageHeaderValueCollection;

    /**
     * Gets or sets the value of the HTTP Content-Length header on the HTTP content. 
     */
    contentLength: number;

    /**
     * Gets or sets the value of the HTTP Content-Location header on the HTTP content. 
     */
    contentLocation: undefined.Uri;

    /**
     * Gets or sets the value of an HTTP Content-MD5 header on the HTTP content. 
     */
    contentMD5: undefined.IBuffer;

    /**
     * Gets or sets the HttpContentRangeHeaderValue object that represent the value of an HTTP Content-Range header on the HTTP content. 
     */
    contentRange: undefined.HttpContentRangeHeaderValue;

    /**
     * Gets or sets the HttpMediaTypeHeaderValue object that represent the value of an HTTP Content-Type header on the HTTP content. 
     */
    contentType: undefined.HttpMediaTypeHeaderValue;

    /**
     * Gets or sets the DateTime object that represents the value of an HTTP Expires header on the HTTP content. 
     */
    expires: Date;

    /**
     * Retrieves an iterator to the first item in the HttpContentHeaderCollection .
     * @return  An object that can be used to enumerate the items in the collection. The iterator points to the first item in the HttpContentHeaderCollection .
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Returns an immutable view of the HttpContentHeaderCollection .
     * @return  The view of the HttpContentHeaderCollection .
     */
    getView(): undefined.IMapView<string, string>;

    /**
     * Determines whether the HttpContentHeaderCollection contains the specified key.
     * @param key The key associated with the item to locate.
     * @return  true if the key is found; otherwise, false.
     */
    hasKey(key: string): boolean;

    /**
     * Inserts or replaces an item in the HttpContentHeaderCollection with the specified key and value.
     * @param key The key of the item to be inserted.
     * @param value The value of the item to insert.
     * @return  true if an item with the specified key is an existing item that was replaced; otherwise false.
     */
    insert(key: string, value: string): boolean;

    /**
     * Gets or sets the DateTime object that represents the value of an HTTP Last-Modified header on the HTTP content. 
     */
    lastModified: Date;

    /**
     * Finds an item in the HttpContentHeaderCollection if it exists.
     * @param key The key of the item to lookup.
     * @return  The value of the item if found.
     */
    lookup(key: string): string;

    /**
     * Removes a specific object from the HttpContentHeaderCollection .
     * @param key The key of the item to remove.
     */
    remove(key: string): void;

    /**
     * Removes a specific item from the HttpContentHeaderCollection .
     * @param key The key of the item to remove.
     * @return  true if the item was removed, otherwise false.
     */
    remove(key: string): boolean;

    /**
     * Gets the number of objects in the HttpContentHeaderCollection . 
     */
    size: number;

    /**
     * Try to append the specified item to the HttpContentHeaderCollection without validation.
     * @param name The name of the item to append.
     * @param value The value of the item to append.
     * @return  true if the item was appended; otherwise false.
     */
    tryAppendWithoutValidation(name: string, value: string): boolean
}


/**
 * Represents the value of the Content-Range HTTP header on HTTP content in a request or a response. 
 */
declare class HttpContentRangeHeaderValue {

    /**
     * Converts a string to an HttpContentRangeHeaderValue instance.
     * @param input A string that represents the content range information in the Content-Range HTTP header.
     * @return  An HttpContentRangeHeaderValue instance.
     */
    parse(input: string): undefined.HttpContentRangeHeaderValue;

    /**
     * Determines whether a string is valid HttpContentRangeHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        contentRangeHeaderValue: undefined.HttpContentRangeHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpContentRangeHeaderValue class with a content length.
     * @param length The length, in bytes, of the full content entity body.
     */
    constructor(length: number): this;

    /**
     * Initializes a new instance of the HttpContentRangeHeaderValue class with a start and stop position.
     * @param from The position, in bytes, at which to start sending data.
     * @param to The position, in bytes, at which to stop sending data.
     */
    constructor(from: number, to: number): this;

    /**
     * Initializes a new instance of the HttpContentRangeHeaderValue class with a start and stop position and a content length.
     * @param from The position, in bytes, at which to start sending data.
     * @param to The position, in bytes, at which to stop sending data.
     * @param length The length, in bytes, of the full content entity body.
     */
    constructor(from: number, to: number, length: number): this;

    /**
     * Gets the position at which to start sending data in the Content-Range HTTP header. 
     */
    firstBytePosition: number;

    /**
     * Gets the position at which to stop sending data in the Content-Range HTTP header. 
     */
    lastBytePosition: number;

    /**
     * Gets the length of the full content entity body in the Content-Range HTTP header. 
     */
    length: number;

    /**
     * Gets or sets the value of the range units used in the Content-Range HTTP header. 
     */
    unit: string
}


/**
 * Represents cookie information used in the Cookie HTTP header on an HTTP request. 
 */
declare class HttpCookiePairHeaderValue {

    /**
     * Converts a string to an HttpCookiePairHeaderValue instance.
     * @param input A string that represents the cookie name and value in the Cookie HTTP header.
     * @return  An HttpCookiePairHeaderValue instance.
     */
    parse(input: string): undefined.HttpCookiePairHeaderValue;

    /**
     * Determines whether a string is valid HttpCookiePairHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        cookiePairHeaderValue: undefined.HttpCookiePairHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpCookiePairHeaderValue class. with a cookie name and a value for the cookie.
     * @param name A token that represents the cookie name.
     * @param value A value for the cookie.
     */
    constructor(name: string, value: string): this;

    /**
     * Initializes a new instance of the HttpCookiePairHeaderValue class. with a cookie name.
     * @param name A token that represents the cookie name.
     */
    constructor(name: string): this;

    /**
     * Gets a token that represents the cookie name used in the Cookie HTTP header. 
     */
    name: string;

    /**
     * Gets or sets a value for the cookie used in the Cookie HTTP header. 
     */
    value: string
}


/**
 * Represents the value of the Cookie HTTP header on an HTTP request. 
 */
declare class HttpCookiePairHeaderValueCollection mixins Array<undefined.HttpCookiePairHeaderValue>{

    /**
     * Adds a new HttpCookiePairHeaderValue item to the end of the collection.
     * @param value The new item to add.
     */
    append(value: undefined.HttpCookiePairHeaderValue): void;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpCookiePairHeaderValue item in the collection.
     * @return  An object that can be used to enumerate the HttpCookiePairHeaderValue items in the collection. The iterator points to the first HttpCookiePairHeaderValue item in the HttpCookiePairHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpCookiePairHeaderValue>;

    /**
     * Returns the HttpCookiePairHeaderValue at the specified index in the collection.
     * @param index The zero-based index of a specified item in the collection.
     * @return  The HttpCookiePairHeaderValue at the specified index in the HttpCookiePairHeaderValueCollection .
     */
    getAt(index: number): undefined.HttpCookiePairHeaderValue;

    /**
     * Retrieves the HttpCookiePairHeaderValue items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpCookiePairHeaderValue items in the HttpCookiePairHeaderValueCollection .
     */
    getMany(
        startIndex: number): {
        items: undefined.HttpCookiePairHeaderValue,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpCookiePairHeaderValueCollection .
     * @return  The view of the HttpCookiePairHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpCookiePairHeaderValue>;

    /**
     * Retrieves the index of an HttpCookiePairHeaderValue in the collection.
     * @param value The HttpCookiePairHeaderValue to find in the HttpCookiePairHeaderValueCollection .
     */
    indexOf(
        value: undefined.HttpCookiePairHeaderValue): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpCookiePairHeaderValue): number;

    /**
     * Inserts an HttpCookiePairHeaderValue into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpCookiePairHeaderValue): void;

    /**
     * Parses and adds an entry to the HttpCookiePairHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpCookiePairHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpCookiePairHeaderValue item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpCookiePairHeaderValue items in the collection with the specified HttpCookiePairHeaderValue items.
     * @param items The HttpCookiePairHeaderValue items to add to the collection.
     */
    replaceAll(items: undefined.HttpCookiePairHeaderValue): void;

    /**
     * Sets the HttpCookiePairHeaderValue at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpCookiePairHeaderValue .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpCookiePairHeaderValue): void;

    /**
     * Gets the number of HttpCookiePairHeaderValue objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpCookiePairHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpCookiePairHeaderValue,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.HttpCookiePairHeaderValue, fromIndex?: number): number
}


/**
 * Represents the value of the Authorization or Proxy-Authorization HTTP header on an HTTP request. 
 */
declare class HttpCredentialsHeaderValue {

    /**
     * Converts a string to an HttpCredentialsHeaderValue instance.
     * @param input A string that represents the credential information in the Authorization or Proxy-Authorization HTTP header.
     * @return  An HttpCredentialsHeaderValue instance.
     */
    parse(input: string): undefined.HttpCredentialsHeaderValue;

    /**
     * Determines whether a string is valid HttpCredentialsHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        credentialsHeaderValue: undefined.HttpCredentialsHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpCredentialsHeaderValue class with the scheme and user token information to use for authentication.
     * @param scheme The scheme to use for authentication.
     * @param token The user token information to use for authentication.
     */
    constructor(scheme: string, token: string): this;

    /**
     * Initializes a new instance of the HttpCredentialsHeaderValue class with the scheme to use for authentication.
     * @param scheme The scheme to use for authentication.
     */
    constructor(scheme: string): this;

    /**
     * Gets a set of name/value pairs included in the Authorization or Proxy-Authorization HTTP header. 
     */
    parameters: undefined.IVector<undefined.HttpNameValueHeaderValue>;

    /**
     * Gets the scheme to use for authentication. 
     */
    scheme: string;

    /**
     * Gets the user token information used in the Authorization or Proxy-Authorization HTTP header. 
     */
    token: string
}


/**
 * Represents the value of the Retry-After HTTP header on an HTTP response. 
 */
declare class HttpDateOrDeltaHeaderValue {

    /**
     * Converts a string to an HttpDateOrDeltaHeaderValue instance.
     * @param input A string that represents the HTTP-date or delta-seconds information in the Retry-After HTTP header.
     * @return  An HttpDateOrDeltaHeaderValue instance.
     */
    parse(input: string): undefined.HttpDateOrDeltaHeaderValue;

    /**
     * Determines whether a string is valid HttpDateOrDeltaHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        dateOrDeltaHeaderValue: undefined.HttpDateOrDeltaHeaderValue,
        returnValue: boolean
    };

    /**
     * Gets the value of the HTTP-date information used in the Retry-After HTTP header. 
     */
    date: Date;

    /**
     * Gets the value of the delta-seconds information used in the Retry-After HTTP header. 
     */
    delta: number
}


/**
 * Represents a token for a particular server behavior required by the client that is used in the Expect HTTP header on an HTTP request. 
 */
declare class HttpExpectationHeaderValue {

    /**
     * Converts a string to an HttpExpectationHeaderValue instance.
     * @param input A string that represents the information in the Expect HTTP header.
     * @return  An HttpExpectationHeaderValue instance.
     */
    parse(input: string): undefined.HttpExpectationHeaderValue;

    /**
     * Determines whether a string is valid HttpCredentialsHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        expectationHeaderValue: undefined.HttpExpectationHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpExpectationHeaderValue class with a name and value for the name.
     * @param name A token that represents a name used in the Expect HTTP header.
     * @param value A value for the name used in the Expect HTTP header.
     */
    constructor(name: string, value: string): this;

    /**
     * Initializes a new instance of the HttpExpectationHeaderValue class with a name.
     * @param name A token that represents a name used in the Expect HTTP header.
     */
    constructor(name: string): this;

    /**
     * Gets or sets a token that represents a name for a server behavior used in the Expect HTTP header. 
     */
    name: string;

    /**
     * Gets a set of parameters for a server behavior included in the Expect HTTP header. 
     */
    parameters: undefined.IVector<undefined.HttpNameValueHeaderValue>;

    /**
     * Gets or sets a value for a server behavior used in the Expect HTTP header. 
     */
    value: string
}


/**
 * Represents the value of the Expect HTTP header on an HTTP request. 
 */
declare class HttpExpectationHeaderValueCollection mixins Array<undefined.HttpExpectationHeaderValue>{

    /**
     * Adds a new HttpExpectationHeaderValue item to the end of the collection.
     * @param value The new item to add.
     */
    append(value: undefined.HttpExpectationHeaderValue): void;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpExpectationHeaderValue item in the collection.
     * @return  An object that can be used to enumerate the HttpExpectationHeaderValue items in the collection. The iterator points to the first HttpExpectationHeaderValue item in the HttpExpectationHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpExpectationHeaderValue>;

    /**
     * Returns the HttpExpectationHeaderValue at the specified index in the collection.
     * @param index The zero-based index of a specified item in the collection.
     * @return  The HttpExpectationHeaderValue at the specified index in the HttpExpectationHeaderValueCollection .
     */
    getAt(index: number): undefined.HttpExpectationHeaderValue;

    /**
     * Retrieves the HttpExpectationHeaderValue items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpExpectationHeaderValue items in the HttpExpectationHeaderValueCollection .
     */
    getMany(
        startIndex: number): {
        items: undefined.HttpExpectationHeaderValue,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpExpectationHeaderValueCollection .
     * @return  The view of the HttpExpectationHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpExpectationHeaderValue>;

    /**
     * Retrieves the index of an HttpExpectationHeaderValue in the collection.
     * @param value The HttpExpectationHeaderValue to find in the HttpExpectationHeaderValueCollection .
     */
    indexOf(
        value: undefined.HttpExpectationHeaderValue): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpExpectationHeaderValue): number;

    /**
     * Inserts an HttpExpectationHeaderValue into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpExpectationHeaderValue): void;

    /**
     * Parses and adds an entry to the HttpExpectationHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpExpectationHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpExpectationHeaderValue item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpExpectationHeaderValue items in the collection with the specified HttpExpectationHeaderValue items.
     * @param items The HttpExpectationHeaderValue items to add to the collection.
     */
    replaceAll(items: undefined.HttpExpectationHeaderValue): void;

    /**
     * Sets the HttpExpectationHeaderValue at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpExpectationHeaderValue .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpExpectationHeaderValue): void;

    /**
     * Gets the number of HttpExpectationHeaderValue objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpExpectationHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpExpectationHeaderValue,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(
        searchElement: undefined.HttpExpectationHeaderValue,
        fromIndex?: number): number
}


/**
 * Represents the value of the Content-Language HTTP header on HTTP content in a request or a response. 
 */
declare class HttpLanguageHeaderValueCollection mixins Array<undefined.Language>{

    /**
     * Adds a new Language item to the end of the collection.
     * @param value The new item to add.
     */
    append(value: undefined.Language): void;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first Language item in the collection.
     * @return  An object that can be used to enumerate the Language items in the collection. The iterator points to the first Language item in the HttpLanguageHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.Language>;

    /**
     * Returns the Language item at the specified index in the collection.
     * @param index The zero-based index of a specified item in the collection.
     * @return  The Language item at the specified index in the HttpLanguageHeaderValueCollection .
     */
    getAt(index: number): undefined.Language;

    /**
     * Retrieves the Language items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the Language items in the HttpLanguageHeaderValueCollection .
     */
    getMany(startIndex: number): {
        items: undefined.Language,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpLanguageHeaderValueCollection .
     * @return  The view of the HttpLanguageHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.Language>;

    /**
     * Retrieves the index of a Language in the collection.
     * @param value The item to find in the HttpLanguageHeaderValueCollection .
     */
    indexOf(value: undefined.Language): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.Language): number;

    /**
     * Inserts a Language into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.Language): void;

    /**
     * Parses and adds an entry to the HttpLanguageHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpLanguageHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last Language item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the Language items in the collection with the specified Language items.
     * @param items The Language items to add to the collection.
     */
    replaceAll(items: undefined.Language): void;

    /**
     * Sets the Language at the specified index in the collection.
     * @param index The zero-based index at which to set the Language .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.Language): void;

    /**
     * Gets the number of Language objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpLanguageHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.Language,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.Language, fromIndex?: number): number
}


/**
 * Represents accept language information used in the Accept-Language HTTP header on an HTTP request. 
 */
declare class HttpLanguageRangeWithQualityHeaderValue {

    /**
     * Converts a string to an HttpLanguageRangeWithQualityHeaderValue instance.
     * @param input A string that represents the language-range and quality factor information used in the Accept-Encoding HTTP header.
     * @return  An HttpLanguageRangeWithQualityHeaderValue instance.
     */
    parse(input: string): undefined.HttpLanguageRangeWithQualityHeaderValue;

    /**
     * Determines whether a string is valid HttpLanguageRangeWithQualityHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        languageRangeWithQualityHeaderValue: undefined.HttpLanguageRangeWithQualityHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpLanguageRangeWithQualityHeaderValue class with language-range and quality information.
     * @param languageRange The value of the language-range information used in the Accept-Language HTTP header.
     * @param quality The value of the qvalue or quality factor used in the Accept-Language HTTP header.
     */
    constructor(languageRange: string, quality: number): this;

    /**
     * Initializes a new instance of the HttpLanguageRangeWithQualityHeaderValue class with language-range information.
     * @param languageRange The value of the language-range information used in the Accept-Language HTTP header.
     */
    constructor(languageRange: string): this;

    /**
     * Gets the value of the language-range information from the HttpLanguageRangeWithQualityHeaderValue used in the Accept-Language HTTP header. 
     */
    languageRange: string;

    /**
     * Gets the value of the qvalue or quality factor from the HttpLanguageRangeWithQualityHeaderValue used in the Accept-Language HTTP header. 
     */
    quality: number
}


/**
 * Represents the value of the Accept-Language HTTP header on an HTTP request. 
 */
declare class HttpLanguageRangeWithQualityHeaderValueCollection mixins Array<undefined.HttpLanguageRangeWithQualityHeaderValue>{

    /**
     * Adds a new HttpLanguageRangeWithQualityHeaderValue item to the end of the collection.
     * @param value The new item to add.
     */
    append(value: undefined.HttpLanguageRangeWithQualityHeaderValue): void;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpLanguageRangeWithQualityHeaderValue item in the collection.
     * @return  An object that can be used to enumerate the HttpLanguageRangeWithQualityHeaderValue items in the collection. The iterator points to the first HttpLanguageRangeWithQualityHeaderValue item in the HttpLanguageRangeWithQualityHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpLanguageRangeWithQualityHeaderValue>;

    /**
     * Returns the HttpLanguageRangeWithQualityHeaderValue at the specified index in the collection.
     * @param index The zero-based index of a specified item in the collection.
     * @return  The HttpLanguageRangeWithQualityHeaderValue at the specified index in the HttpLanguageRangeWithQualityHeaderValueCollection .
     */
    getAt(index: number): undefined.HttpLanguageRangeWithQualityHeaderValue;

    /**
     * Retrieves the HttpLanguageRangeWithQualityHeaderValue items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpLanguageRangeWithQualityHeaderValue items in the HttpLanguageRangeWithQualityHeaderValueCollection .
     */
    getMany(
        startIndex: number): {
        items: undefined.HttpLanguageRangeWithQualityHeaderValue,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpLanguageRangeWithQualityHeaderValueCollection .
     * @return  The view of the HttpLanguageRangeWithQualityHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpLanguageRangeWithQualityHeaderValue>;

    /**
     * Retrieves the index of an HttpLanguageRangeWithQualityHeaderValue in the collection.
     * @param value The HttpLanguageRangeWithQualityHeaderValue to find in the HttpLanguageRangeWithQualityHeaderValueCollection .
     */
    indexOf(
        value: undefined.HttpLanguageRangeWithQualityHeaderValue): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpLanguageRangeWithQualityHeaderValue): number;

    /**
     * Inserts an HttpLanguageRangeWithQualityHeaderValue into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpLanguageRangeWithQualityHeaderValue): void;

    /**
     * Parses and adds an entry to the HttpLanguageRangeWithQualityHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpLanguageRangeWithQualityHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpLanguageRangeWithQualityHeaderValue item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpLanguageRangeWithQualityHeaderValue items in the collection with the specified HttpLanguageRangeWithQualityHeaderValue items.
     * @param items The HttpLanguageRangeWithQualityHeaderValue items to add to the collection.
     */
    replaceAll(items: undefined.HttpLanguageRangeWithQualityHeaderValue): void;

    /**
     * Sets the HttpLanguageRangeWithQualityHeaderValue at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpLanguageRangeWithQualityHeaderValue .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpLanguageRangeWithQualityHeaderValue): void;

    /**
     * Gets the number of HttpLanguageRangeWithQualityHeaderValue objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpLanguageRangeWithQualityHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpLanguageRangeWithQualityHeaderValue,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(
        searchElement: undefined.HttpLanguageRangeWithQualityHeaderValue,
        fromIndex?: number): number
}


/**
 * Represents the value of the Content-Type HTTP header on the HTTP content in a request or a response. 
 */
declare class HttpMediaTypeHeaderValue {

    /**
     * Converts a string to an HttpMediaTypeHeaderValue instance.
     * @param input A string that represents the media-type and character set information used in the Content-Type HTTP header.
     * @return  An HttpMediaTypeHeaderValue instance.
     */
    parse(input: string): undefined.HttpMediaTypeHeaderValue;

    /**
     * Determines whether a string is valid HttpMediaTypeHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        mediaTypeHeaderValue: undefined.HttpMediaTypeHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpMediaTypeHeaderValue class.
     * @param mediaType The media-type of the entity-body used in the Content-Type HTTP header.
     */
    constructor(mediaType: string): this;

    /**
     * Gets or sets the character set of the entity-body used in the Content-Type HTTP header. 
     */
    charSet: string;

    /**
     * Gets or sets the media-type of the entity-body used in the Content-Type HTTP header. 
     */
    mediaType: string;

    /**
     * Gets a set of parameters included in the Content-Type HTTP header. 
     */
    parameters: undefined.IVector<undefined.HttpNameValueHeaderValue >
}


/**
 * Represents accept information used in the Accept HTTP header on an HTTP request. 
 */
declare class HttpMediaTypeWithQualityHeaderValue {

    /**
     * Converts a string to an HttpMediaTypeWithQualityHeaderValue instance.
     * @param input A string that represents the media-type, character set, and quality information used in the Accept HTTP header.
     * @return  An HttpMediaTypeWithQualityHeaderValue instance.
     */
    parse(input: string): undefined.HttpMediaTypeWithQualityHeaderValue;

    /**
     * Determines whether a string is valid HttpMediaTypeWithQualityHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        mediaTypeWithQualityHeaderValue: undefined.HttpMediaTypeWithQualityHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpMediaTypeHeaderValue class with a media type and quality.
     * @param mediaType The media-type of the entity-body to accept that is used in the Accept HTTP header.
     * @param quality The qvalue or quality.
     */
    constructor(mediaType: string, quality: number): this;

    /**
     * Initializes a new instance of the HttpMediaTypeHeaderValue class with a media type.
     * @param mediaType The media-type of the entity-body to accept that is used in the Accept HTTP header.
     */
    constructor(mediaType: string): this;

    /**
     * Gets or sets the character set of the content to accept that is used in the Accept HTTP header. 
     */
    charSet: string;

    /**
     * Gets or sets the media-type of the content to accept that is used in the Accept HTTP header. 
     */
    mediaType: string;

    /**
     * Gets a set of parameters included in the Accept HTTP header. 
     */
    parameters: undefined.IVector<undefined.HttpNameValueHeaderValue>;

    /**
     * Get or set the qvalue or quality used in the Accept HTTP header. 
     */
    quality: number
}


/**
 * Represents the value of the Accept HTTP header on an HTTP request. 
 */
declare class HttpMediaTypeWithQualityHeaderValueCollection mixins Array<undefined.HttpMediaTypeWithQualityHeaderValue>{

    /**
     * Adds a new HttpMediaTypeWithQualityHeaderValue item to the end of the collection.
     * @param value The new item to add.
     */
    append(value: undefined.HttpMediaTypeWithQualityHeaderValue): void;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpMediaTypeWithQualityHeaderValue item in the collection.
     * @return  An object that can be used to enumerate the HttpMediaTypeWithQualityHeaderValue items in the collection. The iterator points to the first HttpMediaTypeWithQualityHeaderValue item in the HttpMediaTypeWithQualityHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpMediaTypeWithQualityHeaderValue>;

    /**
     * Returns the HttpMediaTypeWithQualityHeaderValue at the specified index in the collection.
     * @param index The zero-based index of a specified item in the collection.
     * @return  The HttpMediaTypeWithQualityHeaderValue at the specified index in the HttpMediaTypeWithQualityHeaderValueCollection .
     */
    getAt(index: number): undefined.HttpMediaTypeWithQualityHeaderValue;

    /**
     * Retrieves the HttpMediaTypeWithQualityHeaderValue items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpMediaTypeWithQualityHeaderValue items in the HttpMediaTypeWithQualityHeaderValueCollection .
     */
    getMany(
        startIndex: number): {
        items: undefined.HttpMediaTypeWithQualityHeaderValue,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpMediaTypeWithQualityHeaderValueCollection .
     * @return  The view of the HttpMediaTypeWithQualityHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpMediaTypeWithQualityHeaderValue>;

    /**
     * Retrieves the index of an HttpMediaTypeWithQualityHeaderValue in the collection.
     * @param value The HttpMediaTypeWithQualityHeaderValue to find in the HttpMediaTypeWithQualityHeaderValueCollection .
     */
    indexOf(
        value: undefined.HttpMediaTypeWithQualityHeaderValue): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpMediaTypeWithQualityHeaderValue): number;

    /**
     * Inserts an HttpMediaTypeWithQualityHeaderValue into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpMediaTypeWithQualityHeaderValue): void;

    /**
     * Parses and adds an entry to the HttpMediaTypeWithQualityHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpMediaTypeWithQualityHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpMediaTypeWithQualityHeaderValue item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpMediaTypeWithQualityHeaderValue items in the collection with the specified HttpMediaTypeWithQualityHeaderValue items.
     * @param items The HttpMediaTypeWithQualityHeaderValue items to add to the collection.
     */
    replaceAll(items: undefined.HttpMediaTypeWithQualityHeaderValue): void;

    /**
     * Sets the HttpMediaTypeWithQualityHeaderValue at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpMediaTypeWithQualityHeaderValue .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpMediaTypeWithQualityHeaderValue): void;

    /**
     * Gets the number of HttpMediaTypeWithQualityHeaderValue objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpMediaTypeWithQualityHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpMediaTypeWithQualityHeaderValue,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(
        searchElement: undefined.HttpMediaTypeWithQualityHeaderValue,
        fromIndex?: number): number
}


/**
 * Represents the value of the Allow HTTP header on an HTTP response. 
 */
declare class HttpMethodHeaderValueCollection mixins Array<undefined.HttpMethod>{

    /**
     * Adds a new HttpMethod item to the end of the collection.
     * @param value The new item to add.
     */
    append(value: undefined.HttpMethod): void;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpMethod item in the collection.
     * @return  An object that can be used to enumerate the HttpMethod items in the collection. The iterator points to the first HttpMethod item in the HttpMethodHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpMethod>;

    /**
     * Returns the HttpMethod at the specified index in the collection.
     * @param index The zero-based index of a specified item in the collection.
     * @return  The HttpMethod at the specified index in the HttpMethodHeaderValueCollection .
     */
    getAt(index: number): undefined.HttpMethod;

    /**
     * Retrieves the HttpMethod items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpMethod items in the HttpMethodHeaderValueCollection .
     */
    getMany(startIndex: number): {
        items: undefined.HttpMethod,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpMethodHeaderValueCollection .
     * @return  The view of the HttpMethodHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpMethod>;

    /**
     * Retrieves the index of an HttpMethod in the collection.
     * @param value The HttpMethod to find in the HttpMethodHeaderValueCollection .
     */
    indexOf(value: undefined.HttpMethod): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpMethod): number;

    /**
     * Inserts an HttpMethod into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpMethod): void;

    /**
     * Parses and adds an entry to the HttpMethodHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpMethodHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpMethod item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpMethod items in the collection with the specified HttpMethod items.
     * @param items The HttpMethod items to add to the collection.
     */
    replaceAll(items: undefined.HttpMethod): void;

    /**
     * Sets the HttpMethod at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpMethod .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpMethod): void;

    /**
     * Gets the number of HttpMethod objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpMethodHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpMethod,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.HttpMethod, fromIndex?: number): number
}


/**
 * Represents name and value information used in a number of HTTP headers. 
 */
declare class HttpNameValueHeaderValue {

    /**
     * Converts a string to an HttpNameValueHeaderValue instance.
     * @param input A string that represents the name and value.
     * @return  An HttpNameValueHeaderValue instance.
     */
    parse(input: string): undefined.HttpNameValueHeaderValue;

    /**
     * Determines whether a string is valid HttpNameValueHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        nameValueHeaderValue: undefined.HttpNameValueHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpNameValueHeaderValue class. with a name and value.
     * @param name The name to be used.
     * @param value The value to associate with the name.
     */
    constructor(name: string, value: string): this;

    /**
     * Initializes a new instance of the HttpNameValueHeaderValue class. with a name.
     * @param name The name to be used.
     */
    constructor(name: string): this;

    /**
     * Gets the name used in the HttpNameValueHeaderValue object. 
     */
    name: string;

    /**
     * Gets or sets the value associated with a name used in the HttpNameValueHeaderValue object. 
     */
    value: string
}


/**
 * Represents product information used by the HttpProductHeaderValue and HttpProductInfoHeaderValueCollection classes in the User-Agent HTTP header. 
 */
declare class HttpProductHeaderValue {

    /**
     * Converts a string to an HttpProductHeaderValue instance.
     * @param input A string that represents the product name and version.
     * @return  An HttpProductHeaderValue instance.
     */
    parse(input: string): undefined.HttpProductHeaderValue;

    /**
     * Determines whether a string is valid HttpProductHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        productHeaderValue: undefined.HttpProductHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpProductHeaderValue class with a product name and a product version.
     * @param productName The name of the product token used in the User-Agent HTTP header.
     * @param productVersion The version of the product token used in the User-Agent HTTP header.
     */
    constructor(productName: string, productVersion: string): this;

    /**
     * Initializes a new instance of the HttpProductHeaderValue class with a product name.
     * @param productName The name of the product token used in the User-Agent HTTP header.
     */
    constructor(productName: string): this;

    /**
     * Gets a token that represents the name of the product to be used in the User-Agent HTTP header. 
     */
    name: string;

    /**
     * Gets a token that represents the version of the product to be used in the User-Agent HTTP header. 
     */
    version: string
}


/**
 * Represents product information used in the User-Agent HTTP header on an HTTP request. 
 */
declare class HttpProductInfoHeaderValue {

    /**
     * Converts a string to an HttpProductInfoHeaderValue instance.
     * @param input A string that represents the product information.
     * @return  An HttpProductInfoHeaderValue instance.
     */
    parse(input: string): undefined.HttpProductInfoHeaderValue;

    /**
     * Determines whether a string is valid HttpProductInfoHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        productInfoHeaderValue: undefined.HttpProductInfoHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpProductInfoHeaderValue class with a product name and version.
     * @param productName The name of the product token used in the User-Agent HTTP header.
     * @param productVersion The version of the product token used in the User-Agent HTTP header.
     */
    constructor(productName: string, productVersion: string): this;

    /**
     * Initializes a new instance of the HttpProductInfoHeaderValue class with a product comment.
     * @param productComment The product comment used in the User-Agent HTTP header.
     */
    constructor(productComment: string): this;

    /**
     * Gets the product comment from the HttpProductInfoHeaderValue used in the User-Agent HTTP header. 
     */
    comment: string;

    /**
     * Gets the product from the HttpProductInfoHeaderValue used in the User-Agent HTTP header. 
     */
    product: undefined.HttpProductHeaderValue
}


/**
 * Represents the value of the User-Agent HTTP header on an HTTP request. 
 */
declare class HttpProductInfoHeaderValueCollection mixins Array<undefined.HttpProductInfoHeaderValue>{

    /**
     * Adds a new HttpProductInfoHeaderValue item to the end of the collection.
     * @param value The new item to add.
     */
    append(value: undefined.HttpProductInfoHeaderValue): void;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpProductInfoHeaderValue item in the collection.
     * @return  An object that can be used to enumerate the HttpProductInfoHeaderValue items in the collection. The iterator points to the first HttpProductInfoHeaderValue item in the HttpProductInfoHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpProductInfoHeaderValue>;

    /**
     * Returns the HttpProductInfoHeaderValue at the specified index in the collection.
     * @param index The zero-based index of a specified item in the collection.
     * @return  The HttpProductInfoHeaderValue at the specified index in the HttpProductInfoHeaderValueCollection .
     */
    getAt(index: number): undefined.HttpProductInfoHeaderValue;

    /**
     * Retrieves the HttpProductInfoHeaderValue items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpProductInfoHeaderValue items in the HttpProductInfoHeaderValueCollection .
     */
    getMany(
        startIndex: number): {
        items: undefined.HttpProductInfoHeaderValue,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpProductInfoHeaderValueCollection .
     * @return  The view of the HttpProductInfoHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpProductInfoHeaderValue>;

    /**
     * Determines whether an element is in the collection.
     * @param item The item to find in the collection.
     * @return  true if the item was found in the collection; otherwise, false.
     */
    indexOf(item: undefined.HttpProductInfoHeaderValue): boolean;

    /**
     * Retrieves the index of an HttpProductInfoHeaderValue in the collection.
     * @param value The HttpProductInfoHeaderValue to find in the HttpProductInfoHeaderValueCollection .
     */
    indexOf(
        value: undefined.HttpProductInfoHeaderValue): {
        index: number,
        returnValue: boolean
    };

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpProductInfoHeaderValue): number;

    /**
     * Inserts an HttpProductInfoHeaderValue into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpProductInfoHeaderValue): void;

    /**
     * Parses and adds an entry to the HttpProductInfoHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpMethodHeaderValueCollection.
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpProductInfoHeaderValue item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpProductInfoHeaderValue items in the collection with the specified HttpProductInfoHeaderValue items.
     * @param items The HttpProductInfoHeaderValue items to add to the collection.
     */
    replaceAll(items: undefined.HttpProductInfoHeaderValue): void;

    /**
     * Sets the HttpProductInfoHeaderValue at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpProductInfoHeaderValue .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpProductInfoHeaderValue): void;

    /**
     * Gets the number of HttpProductInfoHeaderValue objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpProductInfoHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpProductInfoHeaderValue,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(
        searchElement: undefined.HttpProductInfoHeaderValue,
        fromIndex?: number): number
}


/**
 * Provides a collection of the HTTP headers associated with an HTTP request. 
 */
declare class HttpRequestHeaderCollection {

    /**
     * Gets the HttpMediaTypeWithQualityHeaderValueCollection of HttpMediaTypeWithQualityHeaderValue objects that represent the value of an Accept HTTP header on an HTTP request. 
     */
    accept: undefined.HttpMediaTypeWithQualityHeaderValueCollection;

    /**
     * Gets the HttpContentCodingWithQualityHeaderValueCollection of HttpContentCodingWithQualityHeaderValue objects that represent the value of an Accept-Encoding HTTP header on an HTTP request. 
     */
    acceptEncoding: undefined.HttpContentCodingWithQualityHeaderValueCollection;

    /**
     * Gets the HttpLanguageRangeWithQualityHeaderValueCollection of HttpLanguageRangeWithQualityHeaderValue objects that represent the value of an Accept-Language HTTP header on an HTTP request. 
     */
    acceptLanguage: undefined.HttpLanguageRangeWithQualityHeaderValueCollection;

    /**
     * Adds a new item to the end of the HttpRequestHeaderCollection .
     * @param name The name of the value to add.
     * @param value The item value to add.
     */
    append(name: string, value: string): void;

    /**
     * Gets or sets the HttpCredentialsHeaderValue object that represents the value of an Authorization HTTP header on an HTTP request. 
     */
    authorization: undefined.HttpCredentialsHeaderValue;

    /**
     * Gets the HttpCacheDirectiveHeaderValueCollection that represents the value of a Cache-Control HTTP header on an HTTP request. 
     */
    cacheControl: undefined.HttpCacheDirectiveHeaderValueCollection;

    /**
     * Removes all objects from the HttpRequestHeaderCollection . 
     */
    clear(): void;

    /**
     * Gets the HttpConnectionOptionHeaderValueCollection of HttpConnectionOptionHeaderValue objects that represent the value of a Connection HTTP header on an HTTP request. 
     */
    connection: undefined.HttpConnectionOptionHeaderValueCollection;

    /**
     * Gets the HttpCookiePairHeaderValueCollection of HttpCookiePairHeaderValue objects that represent the value of an Cookie HTTP header sent on an HTTP request. 
     */
    cookie: undefined.HttpCookiePairHeaderValueCollection;

    /**
     * Gets or sets the DateTime object that represents the value of a Date HTTP header on an HTTP request. 
     */
    date: Date;

    /**
     * Gets the HttpExpectationHeaderValueCollection of HttpExpectationHeaderValue objects that represent the value of an Expect HTTP header on an HTTP request. 
     */
    expect: undefined.HttpExpectationHeaderValueCollection;

    /**
     * Retrieves an iterator to the first item in the HttpRequestHeaderCollection .
     * @return  An object that can be used to enumerate the items in the collection. The iterator points to the first item in the HttpRequestHeaderCollection .
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Gets or sets the String that represents the value of a From HTTP header on an HTTP request. 
     */
    from: string;

    /**
     * Returns an immutable view of the HttpRequestHeaderCollection .
     * @return  The view of the HttpRequestHeaderCollection .
     */
    getView(): undefined.IMapView<string, string>;

    /**
     * Determines whether the HttpRequestHeaderCollection contains the specified key.
     * @param key The key associated with the item to locate.
     * @return  true if the key is found; otherwise, false.
     */
    hasKey(key: string): boolean;

    /**
     * Gets or sets the HostName that represents the value of a Host HTTP header on an HTTP request. 
     */
    host: undefined.HostName;

    /**
     * Gets or sets the DateTime object that represents the value of an If-Modified-Since HTTP header on an HTTP request. 
     */
    ifModifiedSince: Date;

    /**
     * Gets or sets the DateTime object that represents the value of an If-Unmodified-Since HTTP header on an HTTP request. 
     */
    ifUnmodifiedSince: Date;

    /**
     * Inserts or replaces an item in the HttpRequestHeaderCollection with the specified key and value.
     * @param key The key of the item to be inserted.
     * @param value The value of the item to insert.
     * @return  true if an item with the specified key is an existing item that was replaced; otherwise false.
     */
    insert(key: string, value: string): boolean;

    /**
     * Finds an item in the HttpRequestHeaderCollection if it exists.
     * @param key The key of the item to lookup.
     * @return  The value of the item if found.
     */
    lookup(key: string): string;

    /**
     * Gets or sets an integer value that represents the value of a Max-Forwards HTTP header on an HTTP request. 
     */
    maxForwards: number;

    /**
     * Gets or sets the HttpCredentialsHeaderValue object that represent the value of a Proxy-Authorization HTTP header on an HTTP request. 
     */
    proxyAuthorization: undefined.HttpCredentialsHeaderValue;

    /**
     * Gets or sets the Uri that represents the value of a Referer HTTP header on an HTTP request. 
     */
    referer: undefined.Uri;

    /**
     * Removes a specific object from the HttpRequestHeaderCollection .
     * @param key The key of the item to remove.
     */
    remove(key: string): void;

    /**
     * Removes a specific item from the HttpRequestHeaderCollection .
     * @param key The key of the item to remove.
     * @return  true if the item was removed, otherwise false.
     */
    remove(key: string): boolean;

    /**
     * Gets the number of objects in the HttpRequestHeaderCollection . 
     */
    size: number;

    /**
     * Gets the HttpTransferCodingHeaderValueCollection of HttpTransferCodingHeaderValue objects that represent the value of a Transfer-Encoding HTTP header on an HTTP request. 
     */
    transferEncoding: undefined.HttpTransferCodingHeaderValueCollection;

    /**
     * Try to append the specified item to the HttpRequestHeaderCollection without validation.
     * @param name The name of the item to append.
     * @param value The value of the item to append.
     * @return  true if the item was appended; otherwise false.
     */
    tryAppendWithoutValidation(name: string, value: string): boolean;

    /**
     * Gets the HttpProductInfoHeaderValueCollection of HttpProductInfoHeaderValue objects that represent the value of a User-Agent HTTP header on an HTTP request. 
     */
    userAgent: undefined.HttpProductInfoHeaderValueCollection
}


/**
 * Provides a collection of the HTTP headers associated with an HTTP response. 
 */
declare class HttpResponseHeaderCollection {

    /**
     * Gets or sets the TimeSpan object that represents the value of an Age HTTP header on an HTTP response. 
     */
    age: number;

    /**
     * Gets the HttpMethodHeaderValueCollection of HttpMethod objects that represent the value of an Allow HTTP header on an HTTP response. 
     */
    allow: undefined.HttpMethodHeaderValueCollection;

    /**
     * Adds a new item to the end of the HttpResponseHeaderCollection .
     * @param name The name of the value to add.
     * @param value The item value to add.
     */
    append(name: string, value: string): void;

    /**
     * Gets the HttpCacheDirectiveHeaderValueCollection of objects that represent the value of a Cache-Control HTTP header on an HTTP response. 
     */
    cacheControl: undefined.HttpCacheDirectiveHeaderValueCollection;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Gets the HttpConnectionOptionHeaderValueCollection of HttpConnectionOptionHeaderValue objects that represent the value of a Connection HTTP header on an HTTP response. 
     */
    connection: undefined.HttpConnectionOptionHeaderValueCollection;

    /**
     * Gets or sets the DateTime object that represents the value of a Date HTTP header on an HTTP response. 
     */
    date: Date;

    /**
     * Retrieves an iterator to the first item in the HttpResponseHeaderCollection .
     * @return  An object that can be used to enumerate the items in the collection. The iterator points to the first item in the HttpResponseHeaderCollection .
     */
    first(): undefined.IIterator<undefined.IKeyValuePair<any, any >> ;

    /**
     * Returns an immutable view of the HttpResponseHeaderCollection .
     * @return  The view of the HttpResponseHeaderCollection .
     */
    getView(): undefined.IMapView<string, string>;

    /**
     * Determines whether the HttpResponseHeaderCollection contains the specified key.
     * @param key The key associated with the item to locate.
     * @return  true if the key is found; otherwise, false.
     */
    hasKey(key: string): boolean;

    /**
     * Inserts or replaces an item in the HttpResponseHeaderCollection with the specified key and value.
     * @param key The key of the item to be inserted.
     * @param value The value of the item to insert.
     * @return  true if an item with the specified key is an existing item that was replaced; otherwise false.
     */
    insert(key: string, value: string): boolean;

    /**
     * Gets or sets the Uri that represents the value or a Location HTTP header on an HTTP response. 
     */
    location: undefined.Uri;

    /**
     * Lookup an item in the HttpResponseHeaderCollection .
     * @param key The key of the item to lookup.
     * @return  The value of the item if found.
     */
    lookup(key: string): string;

    /**
     * Gets the HttpChallengeHeaderValueCollection of HttpChallengeHeaderValue objects that represent the value of a Proxy-Authenticate HTTP header on an HTTP response. 
     */
    proxyAuthenticate: undefined.HttpChallengeHeaderValueCollection;

    /**
     * Removes an item with a given key from the HttpResponseHeaderCollection .
     * @param key Key of the item to be removed.
     */
    remove(key: string): void;

    /**
     * Gets or sets the HttpDateOrDeltaHeaderValue object that represent the value of a Retry-After HTTP header on an HTTP response. 
     */
    retryAfter: undefined.HttpDateOrDeltaHeaderValue;

    /**
     * Gets the number of objects in the HttpResponseHeaderCollection . 
     */
    size: number;

    /**
     * Gets the HttpTransferCodingHeaderValueCollection of HttpTransferCodingHeaderValue objects that represent the value of a Transfer-Encoding HTTP header on an HTTP response. 
     */
    transferEncoding: undefined.HttpTransferCodingHeaderValueCollection;

    /**
     * Try to append the specified item to the HttpResponseHeaderCollection without validation.
     * @param name The name of the item to append.
     * @param value The value of the item to append.
     * @return  true if the item was appended; otherwise false.
     */
    tryAppendWithoutValidation(name: string, value: string): boolean;

    /**
     * Gets the HttpChallengeHeaderValueCollection of HttpChallengeHeaderValue objects that represent the value of a WWW-Authenticate HTTP header on an HTTP response. 
     */
    wwwAuthenticate: undefined.HttpChallengeHeaderValueCollection
}


/**
 * Represents transfer coding information used in the Transfer-Encoding HTTP header on an HTTP request. 
 */
declare class HttpTransferCodingHeaderValue {

    /**
     * Converts a string to an HttpTransferCodingHeaderValue instance.
     * @param input A string that represents the transfer-coding information.
     * @return  An HttpProductInfoHeaderValue instance.
     */
    parse(input: string): undefined.HttpTransferCodingHeaderValue;

    /**
     * Determines whether a string is valid HttpTransferCodingHeaderValue information.
     * @param input The string to validate.
     */
    tryParse(
        input: string): {
        transferCodingHeaderValue: undefined.HttpTransferCodingHeaderValue,
        returnValue: boolean
    };

    /**
     * Initializes a new instance of the HttpProductInfoHeaderValue class.
     * @param input The transfer-coding information to initialize the HttpProductInfoHeaderValue object.
     */
    constructor(input: string): this;

    /**
     * Gets a set of parameters used in the Transfer-Encoding HTTP header. 
     */
    parameters: undefined.IVector<undefined.HttpNameValueHeaderValue>;

    /**
     * Gets the transfer-coding value used in the Transfer-Encoding HTTP header. 
     */
    value: string
}


/**
 * Represents the value of the Transfer-Encoding HTTP header on an HTTP request. 
 */
declare class HttpTransferCodingHeaderValueCollection mixins Array<undefined.HttpTransferCodingHeaderValue>{

    /**
     * Adds a new HttpTransferCodingHeaderValue item to the end of the collection.
     * @param value The new item to add.
     */
    append(value: undefined.HttpTransferCodingHeaderValue): void;

    /**
     * Removes all objects from the collection. 
     */
    clear(): void;

    /**
     * Retrieves an iterator to the first HttpTransferCodingHeaderValue item in the collection.
     * @return  An object that can be used to enumerate the HttpTransferCodingHeaderValue items in the collection. The iterator points to the first HttpTransferCodingHeaderValue item in the HttpTransferCodingHeaderValueCollection .
     */
    first(): undefined.IIterator<undefined.HttpTransferCodingHeaderValue>;

    /**
     * Returns the HttpTransferCodingHeaderValue at the specified index in the collection.
     * @param index The zero-based index of a specified item in the collection.
     * @return  The HttpTransferCodingHeaderValue at the specified index in the HttpTransferCodingHeaderValueCollection .
     */
    getAt(index: number): undefined.HttpTransferCodingHeaderValue;

    /**
     * Retrieves the HttpTransferCodingHeaderValue items that start at the specified index in the collection.
     * @param startIndex The zero-based index of the start of the HttpTransferCodingHeaderValue items in the HttpTransferCodingHeaderValueCollection .
     */
    getMany(
        startIndex: number): {
        items: undefined.HttpTransferCodingHeaderValue,
        returnValue: number
    };

    /**
     * Returns an immutable view of the HttpTransferCodingHeaderValueCollection .
     * @return  The view of the HttpTransferCodingHeaderValueCollection .
     */
    getView(): undefined.IVectorView<undefined.HttpTransferCodingHeaderValue>;

    /**
     * Determines the index of a specific item in the collection.
     * @param item The object to locate in the collection.
     * @return  The index of item if found in the collection; otherwise, –1.
     */
    indexOf(item: undefined.HttpTransferCodingHeaderValue): number;

    /**
     * Determines whether an element is in the collection.
     * @param item The item to find in the collection.
     * @return  true if the item was found in the collection; otherwise, false.
     */
    indexOf(item: undefined.HttpTransferCodingHeaderValue): boolean;

    /**
     * Retrieves the index of an HttpTransferCodingHeaderValue in the collection.
     * @param value The HttpTransferCodingHeaderValue to find in the HttpTransferCodingHeaderValueCollection .
     */
    indexOf(
        value: undefined.HttpTransferCodingHeaderValue): {
        index: number,
        returnValue: boolean
    };

    /**
     * Inserts an HttpTransferCodingHeaderValue into the collection at the specified index.
     * @param index The zero-based index at which value should be inserted.
     * @param value The object to insert into the collection.
     */
    insertAt(index: number, value: undefined.HttpTransferCodingHeaderValue): void;

    /**
     * Parses and adds an entry to the HttpTransferCodingHeaderValueCollection .
     * @param input The entry to add.
     */
    parseAdd(input: string): void;

    /**
     * Removes the entry at the specified index from the HttpTransferCodingHeaderValueCollection .
     * @param index The index of the entry to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the element at the specified index of the collection.
     * @param index The zero-based index of the element to remove.
     */
    removeAt(index: number): void;

    /**
     * Removes the last HttpTransferCodingHeaderValue item from the collection. 
     */
    removeAtEnd(): void;

    /**
     * Replaces all the HttpTransferCodingHeaderValue items in the collection with the specified HttpTransferCodingHeaderValue items.
     * @param items The HttpTransferCodingHeaderValue items to add to the collection.
     */
    replaceAll(items: undefined.HttpTransferCodingHeaderValue): void;

    /**
     * Sets the HttpTransferCodingHeaderValue at the specified index in the collection.
     * @param index The zero-based index at which to set the HttpTransferCodingHeaderValue .
     * @param value The item to set.
     */
    setAt(index: number, value: undefined.HttpTransferCodingHeaderValue): void;

    /**
     * Gets the number of HttpTransferCodingHeaderValue objects in the collection. 
     */
    size: number;

    /**
     * Tries to parse and add the specified item to the HttpTransferCodingHeaderValueCollection .
     * @param input The item to parse and add.
     * @return  true if the item successfully parsed and was added; otherwise false.
     */
    tryParseAdd(input: string): boolean;
    indexOf(
        value: undefined.HttpTransferCodingHeaderValue,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(
        searchElement: undefined.HttpTransferCodingHeaderValue,
        fromIndex?: number): number
}


/**
 * Provides HTTP content that uses a buffer. 
 */
declare class HttpBufferContent {

    /**
     * Initializes a new instance of the HttpBufferContent class with the specified buffer.
     * @param content The content used to initialize the HttpBufferContent .
     */
    constructor(content: undefined.IBuffer): this;

    /**
     * Initializes a new instance of the HttpBufferContent class with an offset and count of bytes from the specified buffer.
     * @param content The content used to initialize the HttpBufferContent .
     * @param offset The offset in bytes from the beginning of the content buffer to initialize the HttpBufferContent .
     * @param count The count of bytes in the content buffer to initialize the HttpBufferContent .
     */
    constructor(content: undefined.IBuffer, offset: number, count: number): this;

    /**
     * Serialize the HttpBufferContent into memory as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    bufferAllAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<number, number>;

    /**
     * Closes the HttpBufferContent instance and releases allocated resources. 
     */
    close(): void;

    /**
     * Get a collection of content headers set on the HttpBufferContent . 
     */
    headers: undefined.HttpContentHeaderCollection;

    /**
     * Serialize the HttpBufferContent to a buffer as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    readAsBufferAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Serialize the HttpBufferContent and return an input stream that represents the content as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    readAsInputStreamAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IInputStream, number>;

    /**
     * Serialize the HttpBufferContent to a String as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    readAsStringAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<string, number>;

    /**
     * Computes the HttpBufferContent length in bytes.
     */
    tryComputeLength(): {
        length: number,
        returnValue: boolean
    };

    /**
     * Write the HttpBufferContent to an output stream as an asynchronous operation.
     * @param outputStream The output stream to write to.
     * @return  The object that represents the asynchronous operation.
     */
    writeToStreamAsync(
        outputStream: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Sends HTTP requests and receives HTTP responses from a resource identified by a URI. 
 */
declare class HttpClient {

    /**
     * Initializes a new instance of the HttpClient class. 
     */
    constructor(): this;

    /**
     * Initializes a new instance of the HttpClient class with a specific filter for handling HTTP response messages.
     * @param filter The HTTP filter to use for handling response messages.
     */
    constructor(filter: undefined.IHttpFilter): this;

    /**
     * Closes the HttpClient instance and releases allocated resources. 
     */
    close(): void;

    /**
     * Gets a collection of headers that should be sent with each request. 
     */
    defaultRequestHeaders: undefined.HttpRequestHeaderCollection;

    /**
     * Send a DELETE request to the specified Uri as an asynchronous operation.
     * @param uri The Uri the request is sent to.
     * @return  The object representing the asynchronous operation.
     */
    deleteAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.HttpResponseMessage, undefined.HttpProgress>;

    /**
     * Send a GET request to the specified Uri with an HTTP completion option as an asynchronous operation.
     * @param uri The Uri the request is sent to.
     * @param completionOption An HTTP completion option value that indicates when the operation should be considered completed.
     * @return  The object representing the asynchronous operation.
     */
    getAsync(
        uri: undefined.Uri,
        completionOption: undefined.HttpCompletionOption): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.HttpResponseMessage, undefined.HttpProgress>;

    /**
     * Send a GET request to the specified Uri as an asynchronous operation.
     * @param uri The Uri to which the request is to be sent.
     * @return  The object representing the asynchronous operation.
     */
    getAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.HttpResponseMessage, undefined.HttpProgress>;

    /**
     * Send a GET request to the specified Uri and return the response body as a buffer in an asynchronous operation.
     * @param uri The Uri the request is sent to.
     * @return  The object representing the asynchronous operation.
     */
    getBufferAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, undefined.HttpProgress>;

    /**
     * Send a GET request to the specified Uri and return the response body as a stream in an asynchronous operation.
     * @param uri The Uri the request is sent to.
     * @return  The object representing the asynchronous operation.
     */
    getInputStreamAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IInputStream, undefined.HttpProgress>;

    /**
     * Send a GET request to the specified Uri and return the response body as a string in an asynchronous operation.
     * @param uri The Uri the request is sent to.
     * @return  The object representing the asynchronous operation.
     */
    getStringAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperationWithProgress<string, undefined.HttpProgress>;

    /**
     * Send a POST request to the specified Uri as an asynchronous operation.
     * @param uri The Uri the request is sent to.
     * @param content The HTTP request content to send to the server.
     * @return  The object representing the asynchronous operation.
     */
    postAsync(
        uri: undefined.Uri,
        content: undefined.IHttpContent): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.HttpResponseMessage, undefined.HttpProgress>;

    /**
     * Send a PUT request to the specified Uri as an asynchronous operation.
     * @param uri The Uri the request is sent to.
     * @param content The HTTP request content to send to the server.
     * @return  The object representing the asynchronous operation.
     */
    putAsync(
        uri: undefined.Uri,
        content: undefined.IHttpContent): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.HttpResponseMessage, undefined.HttpProgress>;

    /**
     * Send an HTTP request with an HTTP completion option as an asynchronous operation.
     * @param request The HTTP request message to send.
     * @param completionOption A value that indicates whether the HttpClient operation is considered completed when all of the response is read, or when just the headers are read.
     * @return  The object representing the asynchronous operation.
     */
    sendRequestAsync(
        request: undefined.HttpRequestMessage,
        completionOption: undefined.HttpCompletionOption): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.HttpResponseMessage, undefined.HttpProgress>;

    /**
     * Send an HTTP request as an asynchronous operation.
     * @param request The HTTP request message to send.
     * @return  The object representing the asynchronous operation.
     */
    sendRequestAsync(
        request: undefined.HttpRequestMessage): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.HttpResponseMessage, undefined.HttpProgress >
}


/**
 * Provides a set of properties and methods to manage an HTTP cookie. 
 */
declare class HttpCookie {

    /**
     * Initializes a new instance of the HttpCookie class with a specified name, domain, and path.
     * @param name The name for the HttpCookie
     * @param domain The domain for which the HttpCookie is valid.
     * @param path The URIs to which the HttpCookie applies.
     */
    constructor(name: string, domain: string, path: string): this;

    /**
     * Get the domain for which the HttpCookie is valid. 
     */
    domain: string;

    /**
     * Get or set the expiration date and time for the HttpCookie . 
     */
    expires: Date;

    /**
     * Get or set a value that controls whether a script or other active content can access this HttpCookie . 
     */
    httpOnly: boolean;

    /**
     * Get the token that represents the HttpCookie name. 
     */
    name: string;

    /**
     * Get the URI path component to which the HttpCookie applies. 
     */
    path: string;

    /**
     * Get or set the security level for the HttpCookie . 
     */
    secure: boolean;

    /**
     * Get or set the value for the HttpCookie . 
     */
    value: string
}


/**
 * Provides a collection container for instances of the HttpCookie class. 
 */
declare class HttpCookieCollection mixins Array<undefined.HttpCookie>{

    /**
     * Retrieves an iterator to the first HttpCookie item in the HttpCookieCollection .
     * @return  An iterator to the first HttpCookie item in the HttpCookieCollection .
     */
    first(): undefined.IIterator<undefined.HttpCookie>;

    /**
     * Returns the HttpCookie at the specified index from the HttpCookieCollection .
     * @param index The zero-based index of a specified item in the HttpCookieCollection .
     * @return  The HTTP cookie at the specified index from the HttpCookieCollection .
     */
    getAt(index: number): undefined.HttpCookie;

    /**
     * Retrieves the HttpCookie items that start at the specified index in the HttpCookieCollection .
     * @param startIndex The zero-based index of the start of the HttpCookie items in the HttpCookieCollection .
     */
    getMany(startIndex: number): {
        items: undefined.HttpCookie,
        returnValue: number
    };

    /**
     * Retrieves the index of an HttpCookie in the HttpCookieCollection .
     * @param value The HttpCookie to find in the HttpCookieCollection .
     */
    indexOf(value: undefined.HttpCookie): {
        index: number,
        returnValue: boolean
    };

    /**
     * Gets the number of cookies in the HttpCookieCollection . 
     */
    size: number;
    indexOf(
        value: undefined.HttpCookie,
        ...extra: any[]): {
        index: number,
        returnValue: boolean
    };
    indexOf(searchElement: undefined.HttpCookie, fromIndex?: number): number
}


/**
 * Add or delete an HttpCookie or view the cookies associated with an app. 
 */
declare class HttpCookieManager {

    /**
     * Delete an HttpCookie from the cookies associated with an app.
     * @param cookie The HttpCookie to delete.
     */
    deleteCookie(cookie: undefined.HttpCookie): void;

    /**
     * Gets an HttpCookieCollection that contains the HttpCookie instances that are associated with a specific URI.
     * @param uri The URI of the HttpCookie instances desired.
     * @return  The HttpCookieCollection that contains the HttpCookie instances that are associated with a specific URI.
     */
    getCookies(uri: undefined.Uri): undefined.HttpCookieCollection;

    /**
     * Add or change an HttpCookie in the cookies associated with an app.
     * @param cookie The HttpCookie to change or add.
     * @param thirdParty A value that indicates whether the HttpCookie is a third party HTTP cookie.
     * @return  true if the HttpCookie replaced an existing cookie; otherwise false.
     */
    setCookie(cookie: undefined.HttpCookie, thirdParty: boolean): boolean;

    /**
     * Add or change an HttpCookie in the cookies associated with an app that is sent on future requests.
     * @param cookie The HttpCookie to change or add.
     * @return  true if the HttpCookie replaced an existing cookie; otherwise false.
     */
    setCookie(cookie: undefined.HttpCookie): boolean
}


/**
 * Provides HTTP content that uses name/value data encoded with the application/x-www-form-urlencoded MIME type. 
 */
declare class HttpFormUrlEncodedContent {

    /**
     * Initializes a new instance of the HttpFormUrlEncodedContent class with the specified content.
     * @param content The content used to initialize the HttpFormUrlEncodedContent .
     */
    constructor(content: undefined.IIterable<undefined.IKeyValuePair<any, any >> ): this;

    /**
     * Serialize the HttpFormUrlEncodedContent into memory as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    bufferAllAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<number, number>;

    /**
     * Closes the HttpFormUrlEncodedContent instance and releases allocated resources. 
     */
    close(): void;

    /**
     * Get a collection of content headers set on the HttpFormUrlEncodedContent . 
     */
    headers: undefined.HttpContentHeaderCollection;

    /**
     * Serialize the HttpFormUrlEncodedContent to a buffer as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsBufferAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Serialize the HttpFormUrlEncodedContent and return an input stream that represents the content as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsInputStreamAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IInputStream, number>;

    /**
     * Serialize the HttpFormUrlEncodedContent to a String as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsStringAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<string, number>;

    /**
     * Computes the HttpFormUrlEncodedContent length in bytes.
     */
    tryComputeLength(): {
        length: number,
        returnValue: boolean
    };

    /**
     * Write the HttpFormUrlEncodedContent to an output stream as an asynchronous operation.
     * @param outputStream The output stream to write to.
     * @return  The object that represents the asynchronous operation.
     */
    writeToStreamAsync(
        outputStream: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Retrieves standard HTTP methods such as GET and POST and creates new HTTP methods. 
 */
declare class HttpMethod {

    /**
     * Gets the HTTP DELETE method. 
     */
    delete: undefined.HttpMethod;

    /**
     * Gets the HTTP GET method. 
     */
    get: undefined.HttpMethod;

    /**
     * Gets the HTTP HEAD method. 
     */
    head: undefined.HttpMethod;

    /**
     * Gets the HTTP OPTIONS method. 
     */
    options: undefined.HttpMethod;

    /**
     * Gets the HTTP PATCH method, 
     */
    patch: undefined.HttpMethod;

    /**
     * Gets the HTTP POST method. 
     */
    post: undefined.HttpMethod;

    /**
     * Gets the HTTP PUT method. 
     */
    put: undefined.HttpMethod;

    /**
     * Initializes a new instance of the HttpMethod class with a specific HTTP method.
     * @param method The HTTP method.
     */
    constructor(method: string): this;

    /**
     * Gets the HTTP method. 
     */
    method: string
}


/**
 * Provides HTTP content that uses the multipart/ MIME type. 
 */
declare class HttpMultipartContent {

    /**
     * Initializes a new instance of the HttpMultipartContent class. 
     */
    constructor(): this;

    /**
     * Initializes a new instance of the HttpMultipartContent class with the specified MIME subtype and boundary string.
     * @param subtype The MIME subtype of the multipart content.
     * @param boundary The boundary string for the multipart content.
     */
    constructor(subtype: string, boundary: string): this;

    /**
     * Initializes a new instance of the HttpMultipartContent class with the specified MIME subtype.
     * @param subtype The MIME subtype of the multipart content.
     */
    constructor(subtype: string): this;

    /**
     * Add HTTP content to the HttpMultipartContent instance.
     * @param content The HTTP content to add to HttpMultipartContent .
     */
    add(content: undefined.IHttpContent): void;

    /**
     * Serialize the HttpMultipartContent into memory as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    bufferAllAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<number, number>;

    /**
     * Closes the HttpMultipartContent instance and releases allocated resources. 
     */
    close(): void;

    /**
     * Gets an object that can be used to enumerate the contents in the HttpMultipartContent object.
     * @return  An object that can be used to enumerate the contents in the HttpMultipartContent object.
     */
    first(): undefined.IIterator<undefined.IHttpContent>;

    /**
     * Get a collection of content headers set on the HttpMultipartContent . 
     */
    headers: undefined.HttpContentHeaderCollection;

    /**
     * Serialize the HttpMultipartContent to a buffer as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsBufferAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Serialize the HttpMultipartContent and return an input stream that represents the content as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsInputStreamAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IInputStream, number>;

    /**
     * Serialize the HttpMultipartContent to a String as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsStringAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<string, number>;

    /**
     * Determines whether the HttpMultipartContent has a valid length in bytes.
     */
    tryComputeLength(): {
        length: number,
        returnValue: boolean
    };

    /**
     * Write the HttpMultipartContent to an output stream as an asynchronous operation.
     * @param outputStream The output stream to write to.
     * @return  The object that represents the asynchronous operation.
     */
    writeToStreamAsync(
        outputStream: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides HTTP content that uses the multipart/form-data MIME type. 
 */
declare class HttpMultipartFormDataContent {

    /**
     * Initializes a new instance of the HttpMultipartFormDataContent class. 
     */
    constructor(): this;

    /**
     * Initializes a new instance of the HttpMultipartFormDataContent class with the specified boundary string.
     * @param boundary The boundary string for the multipart content.
     */
    constructor(boundary: string): this;

    /**
     * Add HTTP content with a specified name from a file to the HttpMultipartFormDataContent instance.
     * @param content The HTTP content to add to HttpMultipartFormDataContent .
     * @param name The name for the HTTP content to add to HttpMultipartFormDataContent .
     * @param fileName The file name for the HTTP content to add to HttpMultipartFormDataContent .
     */
    add(content: undefined.IHttpContent, name: string, fileName: string): void;

    /**
     * Add HTTP content to the HttpMultipartFormDataContent instance.
     * @param content The HTTP content to add to HttpMultipartFormDataContent .
     */
    add(content: undefined.IHttpContent): void;

    /**
     * Add HTTP content with a specified name to the HttpMultipartFormDataContent instance.
     * @param content The HTTP content to add to HttpMultipartFormDataContent .
     * @param name The name for the HTTP content to add to HttpMultipartFormDataContent .
     */
    add(content: undefined.IHttpContent, name: string): void;

    /**
     * Serialize the HttpMultipartFormDataContent into memory as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    bufferAllAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<number, number>;

    /**
     * Closes the HttpMultipartFormDataContent instance and releases allocated resources. 
     */
    close(): void;

    /**
     * Gets an object that can be used to enumerate the contents in the HttpMultipartFormDataContent object.
     * @return  An object that can be used to enumerate the contents in the HttpMultipartFormDataContent object.
     */
    first(): undefined.IIterator<undefined.IHttpContent>;

    /**
     * Get a collection of content headers set on the HttpMultipartFormDataContent . 
     */
    headers: undefined.HttpContentHeaderCollection;

    /**
     * Serialize the HttpMultipartFormDataContent to a buffer as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsBufferAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Serialize the HttpMultipartFormDataContent and return an input stream that represents the content as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsInputStreamAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IInputStream, number>;

    /**
     * Serialize the HttpMultipartFormDataContent to a String as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsStringAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<string, number>;

    /**
     * Determines whether the HttpMultipartFormDataContent has a valid length in bytes.
     */
    tryComputeLength(): {
        length: number,
        returnValue: boolean
    };

    /**
     * Write the HttpMultipartFormDataContent to an output stream as an asynchronous operation.
     * @param outputStream The output stream to write to.
     * @return  The object that represents the asynchronous operation.
     */
    writeToStreamAsync(
        outputStream: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Represents an HTTP request message including headers. 
 */
declare class HttpRequestMessage {

    /**
     * Initializes a new instance of the HttpRequestMessage class. 
     */
    constructor(): this;

    /**
     * Initializes a new instance of the HttpRequestMessage class with an HTTP method and a request Uri .
     * @param method The HTTP method to perform
     * @param uri The Uri to request.
     */
    constructor(method: undefined.HttpMethod, uri: undefined.Uri): this;

    /**
     * Closes the HttpRequestMessage instance and releases allocated resources. 
     */
    close(): void;

    /**
     * Gets or sets the HTTP content to send to the server on the HttpRequestMessage object. 
     */
    content: undefined.IHttpContent;

    /**
     * Gets the collection of the HTTP request headers associated with the HttpRequestMessage . 
     */
    headers: undefined.HttpRequestHeaderCollection;

    /**
     * Gets or sets the HTTP method to be performed on the request URI. 
     */
    method: undefined.HttpMethod;

    /**
     * Gets a set of properties on the HttpRequestMessage instance that are for use by the developer. 
     */
    properties: undefined.IMap<string, any>;

    /**
     * Gets or sets the Uri used for the HttpRequestMessage object. 
     */
    requestUri: undefined.Uri;

    /**
     * Get information about the underlying transport socket used by an HTTP connection. 
     */
    transportInformation: undefined.HttpTransportInformation
}


/**
 * Represents an HTTP response message including headers, the status code, and data. 
 */
declare class HttpResponseMessage {

    /**
     * Initializes a new instance of the HttpResponseMessage class with a specific HttpStatusCode .
     * @param statusCode The status code of the HTTP response.
     */
    constructor(statusCode: undefined.HttpStatusCode): this;

    /**
     * Initializes a new instance of the HttpResponseMessage class. 
     */
    constructor(): this;

    /**
     * Closes the HttpResponseMessage instance and releases allocated resources. 
     */
    close(): void;

    /**
     * Gets or sets the content of the HTTP response message on the HttpResponseMessage object. 
     */
    content: undefined.IHttpContent;

    /**
     * Throws an exception if the IsSuccessStatusCode property for the HTTP response is false.
     * @return  The HTTP response if the request was successful.
     */
    ensureSuccessStatusCode(): undefined.HttpResponseMessage;

    /**
     * Gets the collection of HTTP response headers associated with the HttpResponseMessage that were sent by the server. 
     */
    headers: undefined.HttpResponseHeaderCollection;

    /**
     * Gets a value that indicates whether the HTTP response was successful. 
     */
    isSuccessStatusCode: boolean;

    /**
     * Gets or sets the reason phrase which typically is sent by servers together with the status code. 
     */
    reasonPhrase: string;

    /**
     * Gets or sets the request message which led to this response message. 
     */
    requestMessage: undefined.HttpRequestMessage;

    /**
     * Gets the source of the data received in the HttpResponseMessage . 
     */
    source: undefined.HttpResponseMessageSource;

    /**
     * Gets or sets the status code of the HTTP response. 
     */
    statusCode: undefined.HttpStatusCode;

    /**
     * Gets or sets the HTTP protocol version used on the HttpResponseMessage object. 
     */
    version: undefined.HttpVersion
}


/**
 * Provides HTTP content that uses a stream. 
 */
declare class HttpStreamContent {

    /**
     * Initializes a new instance of the HttpStreamContent class with the specified content.
     * @param content The content used to initialize the HttpStreamContent .
     */
    constructor(content: undefined.IInputStream): this;

    /**
     * Serialize the HttpStreamContent into memory as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    bufferAllAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<number, number>;

    /**
     * Closes the HttpStreamContent instance and releases allocated resources. 
     */
    close(): void;

    /**
     * Get a collection of content headers set on the HttpStreamContent . 
     */
    headers: undefined.HttpContentHeaderCollection;

    /**
     * Serialize the HttpStreamContent to a buffer as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsBufferAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Serialize the HttpStreamContent and return an input stream that represents the content as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsInputStreamAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IInputStream, number>;

    /**
     * Serialize the HttpStreamContent to a String as an asynchronous operation.
     * @return  The object representing the asynchronous operation.
     */
    readAsStringAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<string, number>;

    /**
     * Determines whether the HttpStreamContent has a valid length in bytes.
     */
    tryComputeLength(): {
        length: number,
        returnValue: boolean
    };

    /**
     * Write the HttpStreamContent to an output stream as an asynchronous operation.
     * @param outputStream The output stream to write to.
     * @return  The object that represents the asynchronous operation.
     */
    writeToStreamAsync(
        outputStream: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides HTTP content that uses a string. 
 */
declare class HttpStringContent {

    /**
     * Initializes a new instance of the HttpStringContent class with the specified content and encoding.
     * @param content The content used to initialize the HttpStringContent .
     * @param encoding The encoding to use for the content.
     */
    constructor(content: string, encoding: undefined.UnicodeEncoding): this;

    /**
     * Initializes a new instance of the HttpStringContent class with the specified content, encoding, and media type.
     * @param content The content used to initialize the HttpStringContent .
     * @param encoding The encoding to use for the content.
     * @param mediaType The media type to use for the content.
     */
    constructor(content: string, encoding: undefined.UnicodeEncoding, mediaType: string): this;

    /**
     * Initializes a new instance of the HttpStringContent class with the specified content.
     * @param content The content used to initialize the HttpStringContent .
     */
    constructor(content: string): this;

    /**
     * Serialize the HttpStringContent into memory as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    bufferAllAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<number, number>;

    /**
     * Closes the HttpStringContent instance and releases allocated resources. 
     */
    close(): void;

    /**
     * Get a collection of content headers set on the HttpStringContent . 
     */
    headers: undefined.HttpContentHeaderCollection;

    /**
     * Serialize the HttpStringContent to a buffer as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    readAsBufferAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer, number>;

    /**
     * Serialize the HttpStringContent and return an input stream that represents the content as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    readAsInputStreamAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IInputStream, number>;

    /**
     * Serialize the HttpStringContent to a String as an asynchronous operation.
     * @return  The object that represents the asynchronous operation.
     */
    readAsStringAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<string, number>;

    /**
     * Compute the HttpStringContent length in bytes.
     */
    tryComputeLength(): {
        length: number,
        returnValue: boolean
    };

    /**
     * Write the HttpStringContent to an output stream as an asynchronous operation.
     * @param outputStream The output stream to write to.
     * @return  The object that represents the asynchronous operation.
     */
    writeToStreamAsync(
        outputStream: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperationWithProgress<number, number >
}


/**
 * Provides information about the underlying transport used by the HTTP connection. 
 */
declare class HttpTransportInformation {

    /**
     * Gets the certificate from the server with the SSL information. 
     */
    serverCertificate: undefined.Certificate;

    /**
     * Gets the category of an error on an SSL connection. 
     */
    serverCertificateErrorSeverity: undefined.SocketSslErrorSeverity;

    /**
     * Gets the list of errors that occurred making an SSL connection. 
     */
    serverCertificateErrors: undefined.IVectorView<undefined.ChainValidationResult>;

    /**
     * Gets the intermediate certificates sent by the server during SSL negotiation on this HttpTransportInformation object. 
     */
    serverIntermediateCertificates: undefined.IVectorView<undefined.Certificate >
}


/**
 * Contains status information on the progress of an HttpClient operation. 
 */
declare interface Http$HttpProgress {

    /**
     * The total number of bytes received. 
     */
    bytesReceived: number,

        /**
         * The total number of bytes sent. 
         */
        bytesSent: number,

        /**
         * The number of retries. 
         */
        retries: number,

        /**
         * The step in the progress of an HTTP connection. 
         */
        stage: undefined.HttpProgressStage,

        /**
         * The total number of data bytes to receive. 
         */
        totalBytesToReceive: number,

        /**
         * The total number of data bytes to send. 
         */
        totalBytesToSend: number
}


/**
 * Provides a base interface for an HTTP entity body and content headers. 
 */
declare type Http$IHttpContent = {

        /**
         * Serialize the HTTP content into memory as an asynchronous operation.
         * @return  The object that represents the asynchronous operation.
         */
        bufferAllAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<number,
        number>,

        /**
         * Serialize the HTTP content to a buffer as an asynchronous operation.
         * @return  The object representing the asynchronous operation.
         */
        readAsBufferAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IBuffer,
        number>,

        /**
         * Serialize the HTTP content and return an input stream that represents the content as an asynchronous operation.
         * @return  The object representing the asynchronous operation.
         */
        readAsInputStreamAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.IInputStream,
        number>,

        /**
         * Serialize the HTTP content to a String as an asynchronous operation.
         * @return  The object representing the asynchronous operation.
         */
        readAsStringAsync(): undefined.IPromiseWithIAsyncOperationWithProgress<string,
        number>,

        /**
         * Determines whether the HTTP content has a valid length in bytes.
         */
        tryComputeLength(): {
            length: number,
            returnValue: boolean
        },

        /**
         * Write the HTTP content to an output stream as an asynchronous operation.
         * @param outputStream The output stream to write to.
         * @return  The object representing the asynchronous operation.
         */
        writeToStreamAsync(
            outputStream: undefined.IOutputStream): undefined.IPromiseWithIAsyncOperationWithProgress<number,
        number>,

        /**
         * Get a collection of content headers set on the IHttpContent . 
         */
        headers: undefined.HttpContentHeaderCollection
    } & &



    /**
     * Represents a custom attribute not defined in the specification. 
     */
    declare class SyndicationAttribute {

        /**
         * Creates a new SyndicationAttribute object. 
         */
        constructor(): this;

        /**
         * Creates a new SyndicationAttribute object with the specified Name, Namespace, and Value property values.
         * @param attributeName The name of the attribute.
         * @param attributeNamespace The namespace of the attribute.
         * @param attributeValue The value of the attribute.
         */
        constructor(attributeName: string, attributeNamespace: string, attributeValue: string): this;

        /**
         * Gets the name of the syndication attribute. 
         */
        name: string;

        /**
         * Gets the namespace of the attribute. 
         */
        namespace: string;

        /**
         * Gets or sets the value of the attribute. 
         */
        value: string
    }


/**
 * Represents the category of a feed or an item. This class encapsulates information in the /rss/channel/item/category element in RSS 2.0 or the atom:category element in Atom 1.0. 
 */
declare class SyndicationCategory {

    /**
     * Creates SyndicationCategory object with the specified property values.
     * @param term A string that identifies the category.
     * @param scheme The scheme of the category.
     * @param label A label for display in end-user applications.
     */
    constructor(term: string, scheme: string, label: string): this;

    /**
     * Creates a SyndicationCategory object. 
     */
    constructor(): this;

    /**
     * Creates a SyndicationCategory object with the specified term property.
     * @param term A string that identifies the category. This parameter represents the required term attribute on atom:category or the text content of the category element in RSS 2.0.
     */
    constructor(term: string): this;

    /**
     * Gets the list of custom attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @param format The format of the data.
     * @return  The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the label for the category. This property represents the label attribute on atom:category. It provides a label for display in end-user applications. 
     */
    label: string;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets or sets the local name of the element. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL. 
     */
    nodeValue: string;

    /**
     * Gets or sets the scheme of the category. This property represents the scheme attribute on atom:category or the domain attribute on the category element in RSS 2.0. 
     */
    scheme: string;

    /**
     * Gets or sets a string that identifies the category. This property represents the required term attribute on atom:category or the text content of the category element in RSS 2.0. 
     */
    term: string
}


/**
 * Implements the ISyndicationClient interface which retrieves feeds from a URI asynchronously. 
 */
declare class SyndicationClient {

    /**
     * Creates a new SyndicationClient object. 
     */
    constructor(): this;

    /**
     * Creates a new SyndicationClient object with authentication credentials.
     * @param serverCredential Credentials for user authentication.
     */
    constructor(serverCredential: undefined.PasswordCredential): this;

    /**
     * Gets or sets a Boolean value that specifies whether to bypass the cache when retrieving the feed. 
     */
    bypassCacheOnRetrieve: boolean;

    /**
     * Gets or sets the maximum number of bytes to buffer when receiving a response from a server. 
     */
    maxResponseBufferSize: number;

    /**
     * Gets or sets the credentials to use when making requests via a proxy. 
     */
    proxyCredential: undefined.PasswordCredential;

    /**
     * Starts an asynchronous operation to download the syndication feed from the given URI. This method instantiates a SyndicationFeed object from the feed string, which can be in one of the formats specified in SyndicationFormat .
     * @param uri The URI from which the feed is downloaded.
     * @return  Contains the results of the operation.
     */
    retrieveFeedAsync(
        uri: undefined.Uri): undefined.IPromiseWithIAsyncOperationWithProgress<undefined.SyndicationFeed, undefined.RetrievalProgress>;

    /**
     * Gets or sets the credentials to use when making requests to the server. 
     */
    serverCredential: undefined.PasswordCredential;

    /**
     * Sets an HTTP header for the request. This method can be called multiple times to set multiple headers. When the same header is set multiple times, the values will be concatenated and separated by ",".
     * @param name The name of the header.
     * @param value The value of the header.
     */
    setRequestHeader(name: string, value: string): void;

    /**
     * Gets or sets the maximum amount of time, in milliseconds, to wait for any of the asynchronous operations to complete. If the operation is not complete within this amount of time, it will fail with a status code indicating that it timed out. 
     */
    timeout: number
}


/**
 * Represents feed content including Text, HTML, XHTML, URL, and XML. This object encapsulates the atom:content element in Atom 1.0 and can contain a link to external content. 
 */
declare class SyndicationContent {

    /**
     * Creates a new SyndicationContent object with the specified Uri property value.
     * @param sourceUri The Uri value.
     */
    constructor(sourceUri: undefined.Uri): this;

    /**
     * Creates a new SyndicationContent object. 
     */
    constructor(): this;

    /**
     * Creates a new SyndicationContent object with the specified Text and Type property values.
     * @param text The text of the content.
     * @param type The type of the content.
     */
    constructor(text: string, type: undefined.SyndicationTextType): this;

    /**
     * Gets the list of custom attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @param format The format of the data.
     * @return  The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets or sets the local name of the element. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL. 
     */
    nodeValue: string;

    /**
     * Gets or sets the URI to the content. This property represents the src attribute on atom:content. 
     */
    sourceUri: undefined.Uri;

    /**
     * Gets the syndication content. 
     */
    text: string;

    /**
     * Gets or sets the type of the content. 
     */
    type: string;

    /**
     * Gets or sets the XML content. 
     */
    xml: undefined.XmlDocument
}


/**
 * Represents an error encountered during a Syndication operation. 
 */
declare class SyndicationError {

    /**
     * Gets the specific error using the returned HRESULT value. Possible values are defined by SyndicationErrorStatus .
     * @param hresult An HRESULT returned during the operation.
     * @return  The error encountered.
     */
    getStatus(hresult: number): undefined.SyndicationErrorStatus
}


/**
 * Contains information about a feed. This class encapsulates the information in the /rss/channel element in RSS 2.0 or the atom:feed element in Atom 1.0. 
 */
declare class SyndicationFeed {

    /**
     * Creates a new SyndicationFeed object. 
     */
    constructor(): this;

    /**
     * Creates a new SyndicationFeed object with a Title, Subtitle, and Uri.
     * @param title The Title of the syndication feed.
     * @param subtitle The Subtitle of the syndication feed.
     * @param uri The Uri value.
     */
    constructor(title: string, subtitle: string, uri: undefined.Uri): this;

    /**
     * Gets the list of custom attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets the authors of an item. This property represents the collection of all the atom:author elements under atom:entry. 
     */
    authors: undefined.IVector<undefined.SyndicationPerson>;

    /**
     * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets a collection of categories of the feed. This property represents the collection of all the atom:category elements under atom:feed. 
     */
    categories: undefined.IVector<undefined.SyndicationCategory>;

    /**
     * Gets a collection of the contributors of the feed. This property represents the collection of all the atom:contributor elements under atom:feed. 
     */
    contributors: undefined.IVector<undefined.SyndicationPerson>;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Gets the first Uniform Resource Identifier (URI) in a sequence. This property represents the atom:link element with attribute rel=”first”. 
     */
    firstUri: undefined.Uri;

    /**
     * Gets or sets the generator of the feed. This property represents the atom:generator element or the generator element in RSS 2.0. 
     */
    generator: undefined.SyndicationGenerator;

    /**
     * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @param format The format of the data.
     * @return  The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the Uniform Resource Identifier (URI) for the image for the feed. This property represents the atom:icon element. 
     */
    iconUri: undefined.Uri;

    /**
     * Gets or sets the identifier for the syndication feed. 
     */
    id: string;

    /**
     * Gets or sets the Uniform Resource Identifier (URI) of the logo for the feed. This property represents the atom:logo element or image/uri element in RSS 2.0. 
     */
    imageUri: undefined.Uri;

    /**
     * Gets the collection of items in the feed. This property represents the collection of atom:entry elements or a collection of item elements in RSS 2.0. 
     */
    items: undefined.IVector<undefined.SyndicationItem>;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets or sets the time the feed was last modified. This property represents the /rss/channel/lastBuildDate or atom:updated element. 
     */
    lastUpdatedTime: Date;

    /**
     * Gets the last Uniform Resource Identifier (URI) in the sequence. This property represents the atom:link element with attribute rel=”last”. 
     */
    lastUri: undefined.Uri;

    /**
     * Gets the links associated with the feed. This property represents a collection of the atom:link elements under atom:feed. In RSS 2.0, this maps to the link element. 
     */
    links: undefined.IVector<undefined.SyndicationLink>;

    /**
     * Initializes the object from the given feed string, which can be in either RSS 2.0 or Atom 1.0 format.
     * @param feed The feed string, which can be in either RSS 2.0 or Atom 1.0 format.
     */
    load(feed: string): void;

    /**
     * Initializes the SyndicationFeed object from the given DOM object, which can contain XML content in either RSS 2.0 or Atom 1.0 format.
     * @param feedDocument The DOM object which contains XML content in either RSS 2.0 or Atom 1.0 format.
     */
    loadFromXml(feedDocument: undefined.XmlDocument): void;

    /**
     * Gets the next Uniform Resource Identifier (URI) in the sequence. This property represents the atom:link element with attribute rel="next". 
     */
    nextUri: undefined.Uri;

    /**
     * Gets or sets the local name of the element. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL. 
     */
    nodeValue: string;

    /**
     * Gets the previous Uniform Resource Identifier (URI) in the sequence. This property represents the atom:link element with attribute rel="previous". 
     */
    previousUri: undefined.Uri;

    /**
     * Gets or sets information about the rights for the feed. This property represents the atom:rights element or the copyright element in RSS 2.0. 
     */
    rights: undefined.ISyndicationText;

    /**
     * Gets the format of the source document. If the object is not loaded from a document, this property will return SyndicationFormat_Atom10. 
     */
    sourceFormat: undefined.SyndicationFormat;

    /**
     * Gets or sets the subtitle of the feed. This property represents the atom:subtitle element or the description element in RSS 2.0. 
     */
    subtitle: undefined.ISyndicationText;

    /**
     * Gets or sets the title of the syndication feed. 
     */
    title: undefined.ISyndicationText
}


/**
 * Describes the agent or the tool used to generate the feed. This class encapsulates information in the /rss/channel/generator element in RSS 2.0 or the /atom:feed/atom:generator element in Atom 1.0. 
 */
declare class SyndicationGenerator {

    /**
     * Creates a new SyndicationGenerator object. 
     */
    constructor(): this;

    /**
     * Creates a new SyndicationGenerator object with the specified Text property value.
     * @param text Identifies the generator. This parameter represents the text content in the atom:generator element or the generator element in RSS 2.0.
     */
    constructor(text: string): this;

    /**
     * Gets the list of custom attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @param format The format of the data.
     * @return  The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets or sets the local name of the element. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL. 
     */
    nodeValue: string;

    /**
     * Gets or sets the text that identifies the generator. 
     */
    text: string;

    /**
     * Gets or sets the Uniform Resource Identifier (URI) of the syndication generator. 
     */
    uri: undefined.Uri;

    /**
     * Gets or sets the version of the generator. 
     */
    version: string
}


/**
 * Represents an item in the feed. This class encapsulates information in the /rss/channel/item element in RSS 2.0 or the atom:entry element in Atom 1.0. 
 */
declare class SyndicationItem {

    /**
     * Creates a new SyndicationItem object with a title, content, and URI.
     * @param title Title of the new item.
     * @param content The content for this feed item.
     * @param uri The URI associated with this item.
     */
    constructor(title: string, content: undefined.SyndicationContent, uri: undefined.Uri): this;

    /**
     * Creates a new SyndicationItem object. 
     */
    constructor(): this;

    /**
     * Gets the list of custom attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets the authors of an item. This property represents the collection of all the atom:author elements under atom:entry. 
     */
    authors: undefined.IVector<undefined.SyndicationPerson>;

    /**
     * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets a collection of categories of the feed. This property represents the collection of all the atom:category elements under atom:feed. 
     */
    categories: undefined.IVector<undefined.SyndicationCategory>;

    /**
     * Gets or sets the Uniform Resource Identifier (URI) of the comments for the item. This property represents the /rss/channel/item/comments element. 
     */
    commentsUri: undefined.Uri;

    /**
     * Gets or sets the content of the item. 
     */
    content: undefined.SyndicationContent;

    /**
     * Gets a collection of the contributors of the feed. This property represents the collection of all the atom:contributor elements under atom:feed. 
     */
    contributors: undefined.IVector<undefined.SyndicationPerson>;

    /**
     * Gets the Uniform Resource Identifier (URI) of an editable media resource. 
     */
    editMediaUri: undefined.Uri;

    /**
     * Gets the Uniform Resource Identifier (URI) of an editable resource. 
     */
    editUri: undefined.Uri;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Gets an ETag HTTP header. 
     */
    etag: string;

    /**
     * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @param format The format of the data.
     * @return  The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the identifier for the syndication feed. 
     */
    id: string;

    /**
     * Gets the Uniform Resource Identifier (URI) of this item. AtomPubClient creates this property after new resource is created. 
     */
    itemUri: undefined.Uri;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets or sets the most recent time the item was modified. This property represents the atom:updated element. 
     */
    lastUpdatedTime: Date;

    /**
     * Gets the links contained in the item. 
     */
    links: undefined.IVector<undefined.SyndicationLink>;

    /**
     * Initializes the object from the given feed string, which can be in either RSS 2.0 or Atom 1.0 format.
     * @param item The feed string, which can be in either RSS 2.0 or Atom 1.0 format.
     */
    load(item: string): void;

    /**
     * Initializes the object from the given DOM object, which can contain XML content in either RSS 2.0 or Atom 1.0 format.
     * @param itemDocument The DOM object, which can contain XML content in either RSS 2.0 or Atom 1.0 format.
     */
    loadFromXml(itemDocument: undefined.XmlDocument): void;

    /**
     * Gets or sets the local name of the element. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL. 
     */
    nodeValue: string;

    /**
     * Gets or sets the date the item was published. 
     */
    publishedDate: Date;

    /**
     * Gets or sets information about the rights of an item. This property represents the atom:rights element. 
     */
    rights: undefined.ISyndicationText;

    /**
     * Gets or sets the source feed of the item. This property represents the atom:source element or the source element in RSS 2.0. 
     */
    source: undefined.SyndicationFeed;

    /**
     * Gets or sets a summary of the item. 
     */
    summary: undefined.ISyndicationText;

    /**
     * Gets or sets the title of the item. 
     */
    title: undefined.ISyndicationText
}


/**
 * Represents a link within a syndication feed or item. This class encapsulates information in the /rss/channel/link or / rss/channel/item/link element in RSS 2.0 or the atom:link element in Atom 1.0. 
 */
declare class SyndicationLink {

    /**
     * Creates a new SyndicationLink object. 
     */
    constructor(): this;

    /**
     * Creates a new SyndicationLink object with a Uri, Relationship, Title, MediaType, and Length.
     * @param uri The Uri value.
     * @param relationship The relationship type.
     * @param title The title of the syndication link.
     * @param mediaType The MediaType of the syndication link.
     * @param length The length, in bytes, of the syndication link.
     */
    constructor(uri: undefined.Uri, relationship: string, title: string, mediaType: string, length: number): this;

    /**
     * Creates a new SyndicationLink with a Uri.
     * @param uri The Uri value.
     */
    constructor(uri: undefined.Uri): this;

    /**
     * Gets the list of custom attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @param format The format of the data.
     * @return  The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets or sets the length of the linked resource, in bytes. 
     */
    length: number;

    /**
     * Gets or sets the media type of the linked resource. The string must have the pattern ".+/.+". 
     */
    mediaType: string;

    /**
     * Gets or sets the local name of the element. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL. 
     */
    nodeValue: string;

    /**
     * Gets or sets the relationship type of the link. 
     */
    relationship: string;

    /**
     * Gets or sets the language of the resource pointed to by the Uri property. This property represents the hreflang attribute on atom:link. It must adhere to the pattern defined by RFC 3066. 
     */
    resourceLanguage: string;

    /**
     * Gets or sets the title of the syndication link. 
     */
    title: string;

    /**
     * Gets or sets the URI of the linked resource. 
     */
    uri: undefined.Uri
}


/**
 * Implements the ISyndicationNode interface which represents a generic XML syndication element. 
 */
declare class SyndicationNode {

    /**
     * Creates a new SyndicationNode object with the specified NodeName, NodeNamespace, and NodeValue property values.
     * @param nodeName The local name of the element. It must be valid according to XML 1.0.
     * @param nodeNamespace The namespace of the element.
     * @param nodeValue The text content of the element. If the element contains only child elements, this parameter is NULL.
     */
    constructor(nodeName: string, nodeNamespace: string, nodeValue: string): this;

    /**
     * Creates a new SyndicationNode object. 
     */
    constructor(): this;

    /**
     * Gets the list of custom attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @param format The format of the data.
     * @return  The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets or sets the local name of the element. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL. 
     */
    nodeValue: string
}


/**
 * Represents an author or contributor of syndication content. 
 */
declare class SyndicationPerson {

    /**
     * Creates a SyndicationPerson object with the specified Name, Email, and Uri property values.
     * @param name The name of the SyndicationPerson . This parameter represents the atom:name element.
     * @param email Gets or sets the email address of the person. This property represents the atom:email element.
     * @param uri Gets or sets the URI of the person. This property represents the atom:uri element. It is the absolute URI resolved against the xml:base attribute, if it is present. If the href attribute is a relative URI string and there is no xml:base attribute, this property is NULL because relative URI is not supported by the runtime URI class.
     */
    constructor(name: string, email: string, uri: undefined.Uri): this;

    /**
     * Creates a SyndicationPerson object. 
     */
    constructor(): this;

    /**
     * Creates a SyndicationPerson object with the specified Name property value.
     * @param name The name of the SyndicationPerson . This parameter represents the atom:name element.
     */
    constructor(name: string): this;

    /**
     * Gets the list of custom attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Gets or sets the email address of the person. 
     */
    email: string;

    /**
     * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @param format The format of the data.
     * @return  The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets the name of the syndication person. 
     */
    name: string;

    /**
     * Gets or sets the local name of the element. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL. 
     */
    nodeValue: string;

    /**
     * Gets or sets the Uniform Resource Identifier (URI) of the person. This property represents the atom:uri element. It is the absolute URI resolved against the xml:base attribute, if it is present. If the href attribute is a relative URI string and there is no xml:base attribute, this property is NULL because the relative URI is not supported by the runtime URI class. 
     */
    uri: undefined.Uri
}


/**
 * Implements the ISyndicationText interface that encapsulates elements in RSS 2.0 or Atom 1.0 that can have either text, HTML, or XHTML. In Atom 1.0, this object maps to an atomTextConstruct in the schema, which can be atom:title, atom:subtitle, atom:rights, or atom:summary elements. 
 */
declare class SyndicationText {

    /**
     * Creates a new SyndicationText object with the specified Text and Type property values.
     * @param text The content of a text content construct like atom:title.
     * @param type The type of the content. This value can be "text", "html", and "xhtml".
     */
    constructor(text: string, type: undefined.SyndicationTextType): this;

    /**
     * Creates a new SyndicationText object. 
     */
    constructor(): this;

    /**
     * Creates a new SyndicationText object with the specified Text property value.
     * @param text The content of a text content construct like atom:title.
     */
    constructor(text: string): this;

    /**
     * Gets the list of custom attributes of the element. 
     */
    attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>;

    /**
     * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
     */
    baseUri: undefined.Uri;

    /**
     * Gets the list of child elements within the element. 
     */
    elementExtensions: undefined.IVector<undefined.ISyndicationNode>;

    /**
     * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @param format The format of the data.
     * @return  The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument;

    /**
     * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
     */
    language: string;

    /**
     * Gets or sets the local name of the element. 
     */
    nodeName: string;

    /**
     * Gets or sets the namespace of the element. 
     */
    nodeNamespace: string;

    /**
     * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL. 
     */
    nodeValue: string;

    /**
     * Gets the content of a text content construct like atom:title. 
     */
    text: string;

    /**
     * Gets or sets the type of the content. 
     */
    type: string;

    /**
     * Gets or sets the XML content. 
     */
    xml: undefined.XmlDocument
}


/**
 * Contains progress information for a data transfer operation. 
 */
declare interface Syndication$TransferProgress {

    /**
     * The number of bytes received. 
     */
    bytesRetrieved: number,

        /**
         * The number of bytes sent. 
         */
        bytesSent: number,

        /**
         * The total number of bytes that will be received during the transfer operation. 
         */
        totalBytesToRetrieve: number,

        /**
         * The total number of bytes that will be sent during the transfer operation. 
         */
        totalBytesToSend: number
}


/**
 * Contains progress information for a data retrieval operation. 
 */
declare interface Syndication$RetrievalProgress {

    /**
     * The number of bytes that have been received in this data retrieval operation. 
     */
    bytesRetrieved: number,

        /**
         * The total number of bytes to be received during this data retrieval operation. 
         */
        totalBytesToRetrieve: number
}


/**
 * Represents a generic syndication XML element extension. 
 */
declare interface Syndication$ISyndicationNode {

    /**
     * Generates the DOM object that represents this element, all the attributes and child elements including foreign markups. The only formats accepted by this method are Atom 1.0 and RSS 2.0.
     * @param format The format of the data.
     * @return  The DOM object that represents this element, and all the attributes and child elements, including foreign markups.
     */
    getXmlDocument(format: undefined.SyndicationFormat): undefined.XmlDocument,

        /**
         * Gets the list of custom attributes of the element. 
         */
        attributeExtensions: undefined.IVector<undefined.SyndicationAttribute>,

        /**
         * Gets or sets the base URI for the element. This property represents the xml:base attribute on the element. It may be inherited from an ancestor element. 
         */
        baseUri: undefined.Uri,

        /**
         * Gets the list of child elements within the element. 
         */
        elementExtensions: undefined.IVector<undefined.ISyndicationNode>,

        /**
         * Gets or sets the language of the element. This property represents the xml:lang attribute on the element. It may be inherited from an ancestor element. It must be valid according to XML 1.0. 
         */
        language: string,

        /**
         * Gets or sets the local name of the element. 
         */
        nodeName: string,

        /**
         * Gets or sets the namespace of the element. 
         */
        nodeNamespace: string,

        /**
         * Gets or sets the text content of the element. If the element contains only child elements, this property is NULL. 
         */
        nodeValue: string
}


/**
 * Represents text, HTML, or XHTML content. This interface encapsulates elements in RSS 2.0 or Atom 1.0 that can have either text, HTML, or XHTML content. In Atom 1.0 this interface maps to an atomTextConstruct in the schema, which can be element atom:title, atom:subtitle, atom:rights or atom:summary. 
 */
declare type Syndication$ISyndicationText = {

    /**
     * Gets or sets the content of a text content construct like atom:title. 
     */
    text: string,

    /**
     * Gets or sets the type of the content. 
     */
    type: string,

    /**
     * Gets or sets the XML content. 
     */
    xml: undefined.XmlDocument
}


/**
 * Provides error status resulting from a web service operation. 
 */
declare class WebError {

    /**
     * Gets a WebErrorStatus value based on an error encountered by a web service operation.
     * @param hresult The error encountered by a web service operation represented as an hResult.
     * @return  The error status value for a web service operation.
     */
    getStatus(hresult: number): undefined.WebErrorStatus
}