// @flow
/**
 * Flowtype definitions for benchmark
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'benchmark' {
    declare module.exports: typeof Benchmark
    declare     export interface Benchmark$Options {
        async?: boolean,
        defer?: boolean,
            delay?: number,
            id?: string,
            initCount?: number,
            maxTime?: number,
            minSamples?: number,
            minTime?: number,
            name?: string,
            onAbort?: Function,
            onComplete?: Function,
            onCycle?: Function,
            onError?: Function,
            onReset?: Function,
            onStart?: Function,
            setup?: Function | string,
            teardown?: Function | string,
            fn?: Function | string,
            queued?: boolean
    }

    declare     export interface Benchmark$Platform {
        description: string,
            layout: string,
            manufacturer: string,
            name: string,
            os: string,
            prerelease: string,
            product: string,
            version: string,
            toString(): string
    }

    declare     export interface Benchmark$Support {
        air: boolean,
            argumentsClass: boolean,
            browser: boolean,
            charByIndex: boolean,
            charByOwnIndex: boolean,
            decompilation: boolean,
            descriptors: boolean,
            getAllKeys: boolean,
            iteratesOwnFirst: boolean,
            java: boolean,
            nodeClass: boolean,
            timeout: boolean
    }

    declare     export interface Benchmark$Stats {
        deviation: number,
            mean: number,
            moe: number,
            rme: number,
            sample: any[],
            sem: number,
            variance: number
    }

    declare     export interface Benchmark$Times {
        cycle: number,
            elapsed: number,
            period: number,
            timeStamp: number
    }

    declare     export class Deferred {
        constructor(clone: Benchmark): this;
        benchmark: Benchmark;
        cycles: number;
        elapsed: number;
        timeStamp: number
    }

    declare     export class Event {
        constructor(type: string | Object): this;
        aborted: boolean;
        cancelled: boolean;
        currentTarget: Object;
        result: any;
        target: Object;
        timeStamp: number;
        type: string
    }

    declare     export class Suite {
        options: {
            name: string
        };
        constructor(name?: string, options?: Benchmark$Options): this;
        aborted: boolean;
        length: number;
        running: boolean;
        abort(): Benchmark$Suite;
        add(
            name: string,
            fn: Function | string,
            options?: Benchmark$Options): Benchmark$Suite;
        add(fn: Function | string, options?: Benchmark$Options): Benchmark$Suite;
        add(name: string, options?: Benchmark$Options): Benchmark$Suite;
        add(options: Benchmark$Options): Benchmark$Suite;
        clone(options: Benchmark$Options): Benchmark$Suite;
        emit(type: string | Object): any;
        filter(callback: Function | string): Benchmark$Suite;
        forEach(callback: Function): Benchmark$Suite;
        indexOf(value: any): number;
        invoke(name: string, ...args: any[]): any[];
        join(separator?: string): string;
        listeners(type: string): Function[];
        map(callback: Function): any[];
        off(type?: string, callback?: Function): Benchmark;
        off(types: string[]): Benchmark;
        on(type?: string, callback?: Function): Benchmark;
        on(types: string[]): Benchmark;
        pluck(property: string): any[];
        pop(): Function;
        push(benchmark: Benchmark): number;
        reduce<T>(callback: Function, accumulator: T): T;
        reset(): Benchmark$Suite;
        reverse(): any[];
        run(options?: Benchmark$Options): Benchmark$Suite;
        shift(): Benchmark;
        slice(start: number, end: number): any[];
        slice(start: number, deleteCount: number, ...values: any[]): any[];
        unshift(benchmark: Benchmark): number
    }
}