/**
 * Flowtype definitions for react-redux
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare
var npm$namespace$ReactRedux: {
    connect: typeof ReactRedux$connect,
}
declare type ReactRedux$ComponentClass<P>= ___React.ComponentClass<P>;

declare type ReactRedux$StatelessComponent<P>= ___React.StatelessComponent<P>;

declare type ReactRedux$ReactNode = ___React.ReactNode;

declare type ReactRedux$Store<S>= Redux.Store<S>;

declare type ReactRedux$Dispatch<S>= Redux.Dispatch<S>;

declare type ReactRedux$ActionCreator<A>= Redux.ActionCreator<A>;

declare interface ReactRedux$ComponentDecorator<TOriginalProps, TOwnProps>{
    (component: ReactRedux$ComponentClass<TOriginalProps>| ReactRedux$StatelessComponent<TOriginalProps>): ReactRedux$ComponentClass<TOwnProps >
}


/**
 * Decorator that infers the type from the original component
 * 
Can't use the above decorator because it would default the type to {}
*/
declare
export interface ReactRedux$InferableComponentDecorator {
    (component: TComponentConstruct): TComponentConstruct
}


/**
 * Connects a React component to a Redux store.
 * 
- Without arguments, just wraps the component, without changing the behavior / props

- If 2 params are passed (3rd param, mergeProps, is skipped), default behavior
is to override ownProps (as stated in the docs), so what remains is everything that's
not a state or dispatch prop

- When 3rd param is passed, we don't know if ownProps propagate and whether they
should be valid component props, because it depends on mergeProps implementation.
As such, it is the user's responsibility to extend ownProps interface from state or
dispatch props or both when applicable
 * @param mapStateToProps 
 * @param mapDispatchToProps 
 * @param mergeProps 
 * @param options 
*/
declare
export function ReactRedux$connect(): ReactRedux$InferableComponentDecorator

declare type ReactRedux$FuncOrSelf<T>= T | (() => T);

declare interface ReactRedux$MapStateToProps<TStateProps, TOwnProps>{
    (state: any, ownProps?: TOwnProps): TStateProps
}

declare interface ReactRedux$MapDispatchToPropsFunction<TDispatchProps, TOwnProps>{
    (dispatch: ReactRedux$Dispatch<any>, ownProps?: TOwnProps): TDispatchProps
}

declare interface ReactRedux$MapDispatchToPropsObject {
    [name: string]: ReactRedux$ActionCreator<any >
}

declare interface ReactRedux$MergeProps<TStateProps, TDispatchProps, TOwnProps>{
    (stateProps: TStateProps, dispatchProps: TDispatchProps, ownProps: TOwnProps): TStateProps & TDispatchProps
}

declare interface ReactRedux$Options {

    /**
     * If true, implements shouldComponentUpdate and shallowly compares the result of mergeProps,
     * preventing unnecessary updates, assuming that the component is a “pure” component
    and does not rely on any input or state other than its props and the selected Redux store’s state.
    Defaults to true.
     * @default  true
    */
    pure?: boolean,

        /**
         * If true, stores a ref to the wrapped component instance and makes it available via 
         * getWrappedInstance() method. Defaults to false.
         */
        withRef?: boolean
}

declare
export interface ReactRedux$ProviderProps {

    /**
     * The single Redux store in your application.
     */
    store?: ReactRedux$Store<any>,
        children?: ReactRedux$ReactNode
}


/**
 * Makes the Redux store available to the connect() calls in the component hierarchy below.
 */
declare
export class Provider mixins ___React.Component<ReactRedux$ProviderProps, {}>{}
declare module 'react-redux' {
    declare module.exports: typeof ReactRedux
}