/**
 * Flowtype definitions for tabris
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$tabris: {
    create: typeof tabris$create,
}
declare interface tabris$Bounds {

    /**
     * the horizontal offset from the parent's left edge in dip
     */
    left: number,

        /**
         * the vertical offset from the parent's top edge in dip
         */
        top: number,

        /**
         * the width of the widget in dip
         */
        width: number,

        /**
         * the height of the widget in dip
         */
        height: number
}

declare interface tabris$Transformation {

    /**
     * Clock-wise rotation in radians. Defaults to `0`.
     */
    rotation: number,

        /**
         * Horizontal scale factor. Defaults to `1`.
         */
        scaleX: number,
        scaleY: number,

        /**
         * Horizontal translation (shift) in dip. Defaults to `0`.
         */
        translationX: number,

        /**
         * Vertical translation (shift) in dip. Defaults to `0`.
         */
        translationY: number
}

declare interface tabris$Image {

    /**
     * Image path or URL.
     */
    src?: string,

        /**
         * Image width, extracted from the image file when missing.
         */
        width?: number,

        /**
         * Image height, extracted from the image file when missing.
         */
        height?: number,

        /**
         * Image scale factor - the image will be scaled down by this factor.
         * Ignored when width or height are set.
         */
        scale?: number
}

declare interface tabris$CanvasContext {}


/**
 * Event handling API supported by widgets and various other objects.
 */
declare interface tabris$EventSupport<T>{

    /**
     * Adds the listener to the list of functions to be notified when event is fired.
     * In the listener function, `this` will point to the object itself. Supports chaining.
     * @param event the name of the event to listen on
     * @param listener the listener function
     */
    on(event: string, listener: (target: T, ...args: any[]) => any): T,

    /**
     * Same as `on`, but removes the listener after it has been invoked by an event.
     * Supports chaining.
     * @param event the name of the event to listen on
     * @param listener the listener function
     */
    once(event: string, listener: (target: T, ...args: any[]) => any): T,

    /**
     * Removes all listeners for all events from this widget. Supports chaining.
     */
    off(): T,

    /**
     * Removes all listeners for event from this widget. Supports chaining.
     * @param event the event name to remove listeners for
     */
    off(event: string): T,

    /**
     * Removes all occurrences of listener that are bound to event from this widget.
     * Supports chaining.
     * @param event the event to remove the listener from
     * @param listener the listener function to remove
     */
    off(event: string, listener: (target: T, ...args: any[]) => any): T,

    /**
     * Triggers an event on this object. Supports chaining.
     * @param event the name of the event to trigger
     * @param args the arguments to pass to the listener functions
     */
    trigger(event: string, ...args: any[]): T
}

declare interface tabris$AnimationOptions {

    /**
     * The time until the animation starts in ms, defaults to `0`.
     */
    delay?: number,

        /**
         * The duration in ms.
         */
        duration: number,

        /**
         * One of `linear`, `ease-in`, `ease-out`, `ease-in-out`.
         */
        easing: string,

        /**
         * The number of times to repeat the animation, defaults to `0`.
         */
        repeat: number,

        /**
         * `true` to alternate the direction of the animation on every repeat.
         */
        reverse: boolean,

        /**
         * No effect, but will be given in animation events.
         */
        name: string
}

declare function tabris$create(type: string, properties: tabris$WidgetProperties): tabris$Widget<any >


    /**
     * API supported by all widgets.
     */
    declare type tabris$Widget<T>= {

        /**
         * Gets the current value of the given property.
         * @param property 
         */
        get(property: string): any,

        /**
         * Sets the given property. Supports chaining.
         * @param property the name of the property to set
         * @param value the value to set the property to
         * @param options passed to the change event resulting from this method call
         */
        set(property: string, value: any, options?: Object): T,

        /**
         * Sets all key-value pairs in the properties object as widget properties. Supports chaining.
         * @param properties the properties to set
         * @param options passed to the change event resulting from this method call
         */
        set(properties: tabris$WidgetProperties, options?: Object): T,

        /**
         * Starts an animation that transforms the given properties from their current values to the given ones.
         * Supported properties are transform and opacity.
         * @param properties The properties and target values to animate.
         * @param options Configures the animation itself.
         */
        animate(properties: tabris$WidgetProperties, options: tabris$AnimationOptions): void,

        /**
         * Appends this widget to the given parent.
         * The parent widget must support children (extending Composite).
         * @param parent the parent widget to append this one to
         */
        appendTo(parent: tabris$Composite): T,

        /**
         * Applies the given properties to all descendants that match the associated selector(s).
         * @param properties an object in the format
        `{selector: {property: value, property: value, ... }, selector: ...}`
        */
        apply(properties: Object): T,

        /**
         * Returns a (possibly empty) collection of all children of this widget.
         */
        children(): tabris$WidgetCollection,

        /**
         * Returns a (possibly empty) collection of all children of this widget that match the selector.
         * @param selector a selector string to filter children
         */
        children(selector: string): tabris$WidgetCollection,

        /**
         * Removes this widget from its parent and destroys it. Also disposes of all its children.
         * Triggers a `remove` event on the parent and a `dispose` event on itself.
        The widget can no longer be used.
        */
        dispose(): void,

        /**
         * Returns a (possibly empty) collection of all descendants of this widget.
         */
        find(): tabris$WidgetCollection,

        /**
         * Returns a (possibly empty) collection of all descendants of this widget that match the selector.
         * @param selector 
         */
        find(selector: string): tabris$WidgetCollection,

        /**
         * Returns `true` if the widget has been disposed, otherwise `false`.
         */
        isDisposed(): boolean,

        /**
         * Returns the parent of this widget.
         */
        parent(): T,

        /**
         * An application-wide unique identifier automatically assigned to all widgets on creation.
         * Do not change it.
         */
        cid: string,

        /**
         * Direct access to the value of the property of the same name.
         * May be used instead of `widget.get("id");`.
        Do not use this field to change the value, instead use `widget.set("id", id);`.
        */
        id: string,

        /**
         * The exact string that was used to create this widget using the `tabris.create` method.
         */
        type: string
    } & tabris$EventSupport


declare interface tabris$WidgetProperties {

    /**
     * The background color of the widget.
     */
    background?: string,

        /**
         * An image to be displayed on the widget's background.
         * If the image is smaller than the widget, it will be tiled.
         */
        backgroundImage?: tabris$Image,

        /**
         * The vertical position of the widget's baseline relative to a sibling widget.
         */
        baseline?: any,

        /**
         * The position of the widget's bottom edge relative to the parent or a sibling widget.
         */
        bottom?: any,

        /**
         * The actual location and size of the widget, relative to its parent. This property is read-only.
         */
        bounds?: tabris$Bounds,

        /**
         * The horizontal position of the widget's center relative to the parent's center.
         */
        centerX?: number,

        /**
         * The vertical position of the widget's center relative to the parent's center.
         */
        centerY?: number,

        /**
         * Whether the widget can be operated.
         */
        enabled?: boolean,

        /**
         * The font used for the widget.
         */
        font?: string,

        /**
         * The height of the widget.
         */
        height?: number,

        /**
         * Whether the entire widget should be highlighted while touched.
         */
        highlightOnTouch?: boolean,

        /**
         * A string to identify the widget by using selectors. Id's are optional.
         * It is strongly recommended that they are unique within a page.
         */
        id?: string,

        /**
         * Shorthand for all layout properties. See [Layout](../layout.md).
         */
        layoutData?: Object,

        /**
         * The position of the widget's left edge relative to the parent or a sibling widget.
         */
        left?: any,

        /**
         * Opacity of the entire widget. Can be used for fade animations.
         */
        opacity?: number,

        /**
         * The position of the widget's right edge relative to the parent or a sibling widget.
         */
        right?: any,

        /**
         * Text color of the widget.
         */
        textColor?: string,

        /**
         * The position of the widget's top edge relative to the parent or a sibling widget.
         */
        top?: any,

        /**
         * Modifications to the widget's shape, size, or position. Can be used for animations.
         * *Note:* In Android, the transform property does not affect the bounds property,
        while it does so in iOS.
        */
        transform?: tabris$Transformation,

        /**
         * Whether the widget is visible.
         */
        visible?: boolean,

        /**
         * The width of the widget.
         */
        width?: number
}


/**
 * An executable item that is integrated in the application's navigation menu.
 * Add a listener on select to implement the action.
 */
declare type tabris$Action = {
    set(property: string, value: any, options?: Object): tabris$Action,
    set(properties: tabris$ActionProperties, options?: Object): tabris$Action
} & tabris$Widget


declare type tabris$ActionProperties = {

    /**
     * Icon image for the action.
     */
    image?: tabris$Image,

    /**
     * Actions with higher placement priority will be placed at a more significant position in the UI,
     * e.g. low priority actions could go into a menu instead of being included in a toolbar.
    Any of `low`, `high`, `normal`.
    */
    placementPriority?: string,

    /**
     * The text to be displayed for the action.
     */
    title?: string
} & tabris$WidgetProperties



/**
 * A push button. Can contain a text or an image.
 */
declare type tabris$Button = {
    set(property: string, value: any, options?: Object): tabris$Button,
    set(properties: tabris$ButtonProperties, options?: Object): tabris$Button
} & tabris$Widget


declare type tabris$ButtonProperties = {

    /**
     * The horizontal alignment of the button text.
     * Any of `left`, `right`, `center`. Defaults to `center`.
     */
    alignment?: string,

    /**
     * An image to be displayed on the button.
     */
    image?: tabris$Image,

    /**
     * The button's label text.
     */
    text?: string
} & tabris$WidgetProperties



/**
 * Canvas is a widget which allows drawing on it using a canvas context.
 * Canvas context is a subset of the HTML5 [CanvasRenderingContext2D](https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D).
 */
declare type tabris$Canvas = {

    /**
     * Returns the drawing context.
     * @param contextType This must be `"2d"`
     * @param width 
     * @param height 
     */
    getContext(contextType: string, width: number, height: number): tabris$CanvasContext
} & tabris$Composite



/**
 * This widget represents a space in a CollectionView on which an item is displayed.
 * Cell widgets are not created by the application but by the CollectionView widget.
 */
declare type tabris$Cell = {
    set(property: string, value: any, options?: Object): tabris$Cell,
    set(properties: tabris$CellProperties, options?: Object): tabris$Cell
} & tabris$Composite


declare type tabris$CellProperties = {

    /**
     * The item that is currently represented by this cell.
     * This property is not set by the application but by the CollectionView widget.
     */
    item?: any,

    /**
     * The index of the item that is currently represented by this cell.
     * This property is not set by the application but by the CollectionView widget.
     */
    itemIndex?: number
} & tabris$WidgetProperties



/**
 * A check box widget.
 */
declare type tabris$CheckBox = {
    set(property: string, value: any, options?: Object): tabris$CheckBox,
    set(properties: tabris$CheckBoxProperties, options?: Object): tabris$CheckBox
} & tabris$Widget


declare type tabris$CheckBoxProperties = {

    /**
     * The checked state of the check box.
     */
    selection?: boolean,

    /**
     * The label text of the check box.
     */
    text?: string
} & tabris$WidgetProperties



/**
 * A scrollable list that displays data items in cells, one per row.
 * Cells are created on demand and filled with widgets in the initializeCell callback.
 */
declare type tabris$CollectionView = {
    set(property: string, value: any, options?: Object): tabris$CollectionView,
    set(
        properties: tabris$CollectionViewProperties,
        options?: Object): tabris$CollectionView,

    /**
     * Inserts the given items into this view. Items are added at the end.
     * This operation will modify the items property.
     * @param items 
     */
    insert(items: any[]): void,

    /**
     * Inserts the given items into this view at the given index.
     * This operation will modify the items property.
     * @param items 
     * @param index the position to insert the items at.
    If a negative index is given, it is interpreted as relative to the end.
    If the given index is greater than the item count, new items will be appended at the end.
    */
    insert(items: any[], index: number): void,

    /**
     * Triggers a refresh of all visible items.
     * This will issue change:item events on the corresponding cells.
     */
    refresh(): void,

    /**
     * Triggers a refresh of the item with the given index.
     * If the item is scrolled into view, an change:item event will be issued on the corresponding cell.
     * @param index The index of the item that was changed.
     */
    refresh(index: number): void,

    /**
     * Removes the item at the given index from this view. This operation will modify the items property.
     * @param index The index of the item to remove. If this is negative, it is interpreted as relative to the end.
     */
    remove(index: number): void,

    /**
     * Removes count items beginning with the given index from this view.
     * This operation will modify the items property.
     * @param index The index of the first item to remove.
    If this is negative, it is interpreted as relative to the end.
     * @param count The number of items to remove.
    */
    remove(index: number, count: number): void,

    /**
     * Scrolls the item with the given index into view.
     * @param index The index of the item to reveal. If this is negative, it is interpreted as relative to the end
     */
    reveal(index: number): void
} & tabris$Widget


declare type tabris$CollectionViewProperties = {

    /**
     * The name of the cell type to use for a given item.
     * This name will be passed to the `initializeCell` and `itemHeight` functions.
    Cells will be reused only by items that require the same cell type.
    If set to a function, this function will be called for every item, providing the item as a parameter,
    and must return a name for the cell type to use for the given item.
    */
    cellType?: (item: any) => string | string,

    /**
     * A callback used to initialize a collection cell by attaching widget and change:item listener.
     * Cells are created by the framework and recycled on scrolling.
    This callback receives the cell as the first and the cell type as second parameter.
     * @static  
    */
    initializeCell?: (cell: tabris$Cell, type: string) => any,

    /**
     * The height of a collection cell. If set to a function, this function will be called for every item,
     * providing the item and the cell type as parameters, and must return the item height for the given item.
     */
    itemHeight?: (item: any, type: string) => number | number,

    /**
     * An array of data items to be displayed by the collection view.
     * For dynamic content, use the methods `insert` and `remove` instead of setting this property directly.
     */
    items?: any[],

    /**
     * Enables the user to trigger a refresh by using the pull-to-refresh gesture.
     */
    refreshEnabled?: boolean,

    /**
     * Whether the refresh indicator is currently visible. Will be set to `true` when a refresh event
     * is triggered. Reset it to `false` when the refresh is finished.
     */
    refreshIndicator?: boolean,

    /**
     * The message text displayed together with the refresh indicator. Currently not supported on Android.
     */
    refreshMessage?: string
} & tabris$WidgetProperties


declare interface tabris$Parent<T>{

    /**
     * Adds the given widget(s) in the given order to the composite.
     * @param child 
     * @param child *
     */
    append(...children: tabris$Widget<any>[]): T,

    /**
     * Adds all widgets in the given collection to the composite.
     * @param collection 
     */
    append(collection: tabris$WidgetCollection): T
}


/**
 * An empty widget that can contain other widgets.
 */
declare type tabris$Composite = {} & tabris$Widget & tabris$Parent



/**
 * A navigation drawer that can be swiped in from the left edge of the screen. Can contain any kind of widgets.
 * It may be useful to include a `PageSelector` that displays all top-level pages.
 */
declare type tabris$Drawer = {

    /**
     * Closes the drawer.
     */
    close(): tabris$Drawer,

    /**
     * Opens the drawer.
     */
    open(): tabris$Drawer
} & tabris$Composite



/**
 * A widget to display an image.
 */
declare type tabris$ImageView = {
    set(property: string, value: any, options?: Object): tabris$ImageView,
    set(properties: tabris$ImageViewProperties, options?: Object): tabris$ImageView
} & tabris$Widget


declare interface tabris$ImageViewProperties {
    image?: tabris$Image,

        /**
         * Any of `auto`, `fit`, `fill`, `stretch`, `none`. Defaults to `auto`.;
         */
        scaleMode?: string
}


/**
 * Pages contain an application's UI. Top-level pages are included in the application's main menu.
 */
declare type tabris$Page = {
    set(property: string, value: any, options?: Object): tabris$Page,
    set(properties: tabris$PageProperties, options?: Object): tabris$Page,

    /**
     * Opens the page, i.e. makes it the active page.
     */
    open(): tabris$Page,

    /**
     * Closes and disposes of the page.
     */
    close(): void
} & tabris$Widget & tabris$Parent


declare type tabris$PageProperties = {
    image?: tabris$Image,
    title?: string,
    topLevel?: boolean
} & tabris$WidgetProperties



/**
 * A CollectionView that contains all top-level pages and allows to open them.
 * New top-level pages are added dynamically.
 */
declare type tabris$PageSelector = {} & tabris$CollectionView



/**
 * A widget with a drop-down list of items to choose from.
 */
declare type tabris$Picker = {
    set(property: string, value: any, options?: Object): tabris$Picker,
    set(properties: tabris$PickerProperties, options?: Object): tabris$Picker
} & tabris$Widget


declare type tabris$PickerProperties = {
    items?: string[],
    selection?: string,
    selectionIndex?: number
} & tabris$WidgetProperties



/**
 * A widget representing a numeric value as a horizontal bar with a growing indicator.
 */
declare type tabris$ProgressBar = {
    set(property: string, value: any, options?: Object): tabris$ProgressBar,
    set(properties: tabris$ProgressBarProperties, options?: Object): tabris$ProgressBar
} & tabris$Widget


declare interface tabris$ProgressBarProperties {

    /**
     * Defaults to 100.
     */
    maximum?: number,

        /**
         * Defaults to 0.
         */
        minimum?: number,

        /**
         * Defaults to 0.
         */
        selection?: number,

        /**
         * Any of `normal`, `paused, `error`. Defaults to `normal`.
         */
        state?: string
}


/**
 * A radio button. Selecting a radio button de-selects all its siblings (i.e. all radio buttons
 * within the same parent).
 */
declare type tabris$RadioButton = {
    set(property: string, value: any, options?: Object): tabris$RadioButton,
    set(properties: tabris$RadioButtonProperties, options?: Object): tabris$RadioButton
} & tabris$Widget


declare type tabris$RadioButtonProperties = {

    /**
     * The checked state of the radio button.
     */
    selection?: boolean,

    /**
     * The label text of the radio button.
     */
    text?: string
} & tabris$WidgetProperties



/**
 * A composite that allows its content to overflow either vertically (default) or horizontally.
 * Children of a ScrollView may not be attached to its edge in scrolling direction (to the bottom
for vertical scrolling, to the right for horizontal scrolling).
*/
declare type tabris$ScrollView = {
    set(property: string, value: any, options?: Object): tabris$ScrollView,
    set(properties: tabris$ScrollViewProperties, options?: Object): tabris$ScrollView
} & tabris$Composite


declare type tabris$ScrollViewProperties = {

    /**
     * Specifies the scrolling direction of the scroll composite.
     * Either `vertical` or `horizontal`. Default to `vertical`.
     * @static  
     */
    direction?: string
} & tabris$WidgetProperties



/**
 * An action that displays a search text field with dynamic proposals when selected.
 * Add a listener on select to implement the action. On input, you may set a list of proposals.
 */
declare type tabris$SearchAction = {
    set(property: string, value: any, options?: Object): tabris$SearchAction,
    set(
        properties: tabris$SearchActionProperties,
        options?: Object): tabris$SearchAction
} & tabris$Action


declare type tabris$SearchActionProperties = {

    /**
     * A hint text that is displayed when the search input is empty.
     */
    message?: string,

    /**
     * The list of proposals to display.
     */
    proposals?: string[],

    /**
     * The text in the search input field.
     */
    text?: string
} & tabris$ActionProperties



/**
 * A widget representing a numeric value as an movable indicator on a horizontal line.
 */
declare type tabris$Slider = {
    set(property: string, value: any, options?: Object): tabris$Slider,
    set(properties: tabris$SliderProperties, options?: Object): tabris$Slider
} & tabris$Widget


declare type tabris$SliderProperties = {
    maximum?: number,
    minimum?: number,
    selection?: number
} & tabris$WidgetProperties



/**
 * A switch widget that can be toggled.
 */
declare type tabris$Switch = {
    set(property: string, value: any, options?: Object): tabris$Switch,
    set(properties: tabris$SwitchProperties, options?: Object): tabris$Switch
} & tabris$Widget


declare type tabris$SwitchProperties = {

    /**
     * The checked state of the switch.
     */
    selection?: boolean
} & tabris$WidgetProperties



/**
 * A container representing a single tab of the TabFolder widget.
 */
declare type tabris$Tab = {
    set(property: string, value: any, options?: Object): tabris$Tab,
    set(properties: tabris$TabProperties, options?: Object): tabris$Tab
} & tabris$Composite


declare type tabris$TabProperties = {
    badge?: string,
    image?: tabris$Image,
    title?: string
} & tabris$WidgetProperties



/**
 * A widget that can switch between [tabs](#tab).
 */
declare type tabris$TabFolder = {
    set(property: string, value: any, options?: Object): tabris$TabFolder,
    set(properties: tabris$TabFolderProperties, options?: Object): tabris$TabFolder,

    /**
     * Adds the given tabs in the given order to the TabFolder.
     * @param children 
     */
    append(...children: tabris$Tab[]): tabris$TabFolder
} & tabris$Widget


declare type tabris$TabFolderProperties = {

    /**
     * Enables swiping through tabs.
     */
    paging?: boolean,
    selection?: tabris$Tab,

    /**
     * The placement of the tab titles. When set to `"auto"`, the position is platform dependent.
     * Any of `top`, `bottom`, `auto`. Defaults to `auto`.
     * @static  
     */
    tabBarLocation?: string
} & tabris$WidgetProperties



/**
 * A widget that allows to enter text.
 */
declare type tabris$TextInput = {
    set(property: string, value: any, options?: Object): tabris$TextInput,
    set(properties: tabris$TextInputProperties, options?: Object): tabris$TextInput
} & tabris$Widget


declare type tabris$TextInputProperties = {

    /**
     * The horizontal alignment of the text.
     * Any of `left`, `right`, `center`. Default: `left`.
     */
    alignment?: string,

    /**
     * Automatically switch to capital letters after every key pressed.
     */
    autoCapitalize?: boolean,

    /**
     * Enables the spell checker and auto-correction feature.
     */
    autoCorrect?: boolean,
    editable?: boolean,

    /**
     * Selects the keyboard type to use for editing this widget.
     * Any of `ascii`, `decimal`, `email`, `number`, `numbersAndPunctuation`, `phone`, `url`, `default`.
     */
    keyboard?: string,

    /**
     * A hint text that is displayed when the input field is empty.
     */
    message?: string,

    /**
     * The text in the input field.
     */
    text?: string,

    /**
     * The type of the text widget.
     * Any of `default`, `password`, `search`, `multiline`.
     * @static  
     */
    type?: string
} & tabris$WidgetProperties



/**
 * A widget to display a text. For images, use ImageView.
 */
declare type tabris$TextView = {
    set(property: string, value: any, options?: Object): tabris$TextView,
    set(properties: tabris$TextViewProperties, options?: Object): tabris$TextView
} & tabris$Widget


declare type tabris$TextViewProperties = {

    /**
     * The horizontal alignment of the text.
     * Any of `left`, `right`, `center`. Default: `left`.
     */
    alignment?: string,

    /**
     * Allows for a subset of HTML tags in the text.
     * Supported tags are: `a`, `del`, `ins`, `b`, `i`, `strong`, `em`, `big`, `small`, `br`.
    All tags must be closed (e.g. use `<br/>` instead of `<br>`). Nesting tags is currently not supported.
     * @static  
    */
    markupEnabled?: boolean,

    /**
     * Limit the number of lines to be displayed to the given maximum. `null` disables this limit.
     */
    maxLines?: number,

    /**
     * The text to display.
     */
    text?: string
} & tabris$WidgetProperties



/**
 * A push button that "snaps in", i.e. it is selected when pressed and deselected when pressed again.
 */
declare type tabris$ToggleButton = {
    set(property: string, value: any, options?: Object): tabris$ToggleButton,
    set(
        properties: tabris$ToggleButtonProperties,
        options?: Object): tabris$ToggleButton
} & tabris$Widget


declare type tabris$ToggleButtonProperties = {

    /**
     * The horizontal alignment of the button text.
     * Any of `left`, `right`, `center`. Default: `left`.
     */
    alignment?: string,

    /**
     * An image to be displayed on the button.
     */
    image?: tabris$Image,

    /**
     * The selection state of the toggle button.
     */
    selection?: boolean,

    /**
     * The button's label text.
     */
    text?: string
} & tabris$WidgetProperties



/**
 * A widget that plays a video from a URL.
 */
declare type tabris$Video = {
    set(property: string, value: any, options?: Object): tabris$Video,
    set(properties: tabris$VideoProperties, options?: Object): tabris$Video
} & tabris$Widget


declare type tabris$VideoProperties = {

    /**
     * The URL of the video to play.
     */
    url?: string
} & tabris$WidgetProperties



/**
 * A widget that can display a web page.
 * Since this widget requires a lot of recourses it's recommended to have no more than one instance at a time.
 */
declare type tabris$WebView = {
    set(property: string, value: any, options?: Object): tabris$Video,
    set(properties: tabris$WebViewProperties, options?: Object): tabris$Video
} & tabris$Widget


declare type tabris$WebViewProperties = {

    /**
     * A complete HTML document to display. Always returns the last set value.
     */
    html?: string,

    /**
     * The URL of the web page to display. Returns empty string when content from html property is displayed.
     */
    url?: string
} & tabris$WidgetProperties



/**
 * 
 */
declare type tabris$WidgetCollection = {

    /**
     * Animates all widgets in this collection.
     * @param properties The properties and target values to animate.
     * @param options Configures the animation itself.
     */
    animate(properties: tabris$WidgetProperties, options: tabris$AnimationOptions): void,

    /**
     * Append all widgets in this collection to the given widget.
     * @param parent 
     */
    appendTo(parent: tabris$Composite): tabris$WidgetCollection,

    /**
     * Returns a collection containing all children of all widgets in this collection.
     */
    children(): tabris$WidgetCollection,

    /**
     * Same as `collection.children().filter(selector)`.
     * @param selector 
     */
    children(selector: string): tabris$WidgetCollection,

    /**
     * Disposes all widgets in this collection.
     */
    dispose(): void,

    /**
     * Returns a collection containing all descendants of all widgets in this collection.
     */
    find(): tabris$WidgetCollection,

    /**
     * Returns a collection containing all descendants of all widgets in this collection that match the given selector.
     * @param selector 
     */
    find(selector: string): tabris$WidgetCollection,

    /**
     * Returns a collection containing all direct parents of all widgets in this collection.
     */
    parent(): tabris$WidgetCollection,

    /**
     * A read-only field containing the number of widgets in the collection.
     */
    length: number
} & tabris$EventSupport



/**
 * The object `tabris.app` provides information about the application.
 */
declare interface tabris$App {

    /**
     * Installs a patch from the given URL.
     * When the patch is successfully installed, it will remain inactive until the application is reloaded.
     * @param url The URL to fetch a patch from.
     * @param callback A callback function to be called when the installation has finished or failed.
    In case of a failure, the callback will receive a parameter `error` that contains an Error object.
    If the installation succeeds, this parameter will be `undefined` and a second parameter will contain
    the parsed content of the file `patch.json` from the installed patch.
     * @provisional  
    */
    installPatch(url: string, callback: (error: Error, patch: Object) => any): void,

        /**
         * Forces the running application to reload the main module and start over.
         */
        reload(): void
}

declare export var app: tabris$App;


/**
 * The object `tabris.device` provides information about the device that executes the application.
 * All properties are read-only.
 */
declare type tabris$Device = {
    get(property: string): void,

    /**
     * The user language configured on the device as an [RFC 4646](http://tools.ietf.org/html/rfc4646) compliant string. For example `"de"`, `"es-ES"`, etc. This property is also available globally as `navigator.language`.
     */
    get(property: "language"): string,

    /**
     * The name of the device model. For example `"iPad4,1"` or `"Nexus 7"`.
     * This property is also available globally as `device.model`.
     */
    get(property: "model"): string,

    /**
     * The device orientation. One of `portrait-primary`, `portrait-secondary`, `landscape-primary`, and `landscape-secondary`.
     */
    get(property: "orientation"): string,

    /**
     * The name of the platform. Currently either `"Android"` or `"iOS"`.
     * This property is also available globally as `device.platform`.
     */
    get(property: "platform"): string,

    /**
     * The ratio between physical pixels and device independent pixels.
     * This property is also available globally as [`window.devicePixelRatio`](https://developer.mozilla.org/en-US/docs/Web/API/Window.devicePixelRatio).
     */
    get(property: "scaleFactor"): number,

    /**
     * The entire height of the device's screen in device independent pixel.
     * Depends on the current device orientation. This property is also available globally as [screen.height](https://developer.mozilla.org/en-US/docs/Web/API/Screen.height).
     */
    get(property: "screenHeight"): number,

    /**
     * The entire width of the device's screen in device independent pixel.
     * Depends on the current device orientation. This property is also available as globally as [screen.width](https://developer.mozilla.org/en-US/docs/Web/API/Screen.width).
     */
    get(property: "screenWidth"): number,

    /**
     * The platform version. On iOS it lools like this: `"8.1.1"`.
     * On Android, the [version code](https://developer.android.com/reference/android/os/Build.VERSION_CODES.html)
    is returned. This property is also available globally as `device.version`.
    */
    get(property: "version"): string
} & tabris$EventSupport


declare export var device: tabris$Device;


/**
 * The object `tabris.ui` is the root element for all widgets.
 * This is the parent for all top-level pages, actions and the drawer.
 */
declare type tabris$UI = {
    get(property: string): void,

    /**
     * The currently visible page.
     */
    get(property: "activePage"): tabris$Page,

    /**
     * Background color for the navigation elements.
     */
    get(property: "background"): string,

    /**
     * Text color for the navigation elements.
     */
    get(property: "textColor"): string,

    /**
     * Whether the toolbars above and below pages are visible.
     */
    get(property: "toolbarVisible"): boolean
} & tabris$EventSupport


declare export var ui: tabris$UI;
declare module 'tabris' {
    declare module.exports: typeof tabris
}