/**
 * Flowtype definitions for pouchdb-core
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface Core$Error {}

declare interface Core$Callback<E, R>{
    (error: E | void, result: R | void): void
}

declare type Core$AnyCallback = Core$Callback<any, any>;

declare type Core$DocumentId = string;

declare type Core$DocumentKey = string;

declare type Core$RevisionId = string;

declare type Core$Availability = "available" | "compacted" | "not compacted" | "missing";

declare type Core$Attachment = string | ArrayBuffer;

declare type Core$Encodable = {
    [propertyName: string]: any
};

declare interface Core$Options {
    ajax?: Configuration$RemoteRequesterConfiguration
}

declare interface Core$BasicResponse {

    /**
     * `true` if the operation was successful; `false` otherwise 
     */
    ok: boolean
}

declare type Core$Response = {

    /**
     * id of the targeted document 
     */
    id: Core$DocumentId,

    /**
     * resulting revision of the targeted document 
     */
    rev: Core$RevisionId
} & Core$BasicResponse


declare interface Core$DatabaseInfo {}

declare interface Core$Revision<Content>{
    ok: Core$Document<Content>& Core$RevisionIdMeta
}

declare interface Core$RevisionInfo {
    rev: Core$RevisionId,
        status: Core$Availability
}

declare interface Core$IdMeta {
    _id: Core$DocumentId
}

declare interface Core$RevisionIdMeta {
    _rev: Core$RevisionId
}

declare interface Core$GetMeta {

    /**
     * Conflicting leaf revisions.
     * 
    Only present if `GetOptions.conflicts` is `true`
    */
    _conflicts?: Core$RevisionId[],
        _rev?: Core$RevisionId,

        /**
         * Only present if `GetOptions.revs` is `true` 
         */
        _revs_info?: Core$RevisionInfo[],

        /**
         * Only present if `GetOptions.revs_info` is `true` 
         */
        _revisions?: {
            ids: Core$RevisionId[],
            start: number
        }
}

declare type Core$NewDocument<Content>= Content;

declare type Core$Document<Content>= Content & Core$IdMeta;

declare type Core$ExistingDocument<Content>= Core$Document<Content>& Core$RevisionIdMeta;

declare type Core$AllDocsOptions = {

    /**
     * Include attachment data for each document.
     * 
    Requires `include_docs` to be `true`.

    By default, attachments are Base64-encoded.
     * @see  binary
    */
    attachments?: boolean,

    /**
     * Return attachments as Buffers.
     * 
    Requires `include_docs` to be `true`.
    Requires `attachments` to be `true`. 
    */
    binary?: boolean,

    /**
     * Include conflict information for each document.
     * 
    Requires `include_docs` to be `true`. 
    */
    conflicts?: boolean,

    /**
     * Reverse ordering of results. 
     */
    descending?: boolean,

    /**
     * Include contents for each document. 
     */
    include_docs?: boolean,

    /**
     * Maximum number of documents to return. 
     */
    limit?: number,

    /**
     * Number of documents to skip before returning.
     * 
    Causes poor performance on IndexedDB and LevelDB. 
    */
    skip?: number
} & Core$Options


declare type Core$AllDocsWithKeyOptions = {

    /**
     * Constrain results to documents matching this key. 
     */
    key: Core$DocumentKey
} & Core$AllDocsOptions


declare type Core$AllDocsWithKeysOptions = {

    /**
     * Constrains results to documents matching any of these keys. 
     */
    keys: Core$DocumentId[]
} & Core$AllDocsOptions


declare type Core$AllDocsWithinRangeOptions = {

    /**
     * Low end of range, or high end if `descending` is `true`. 
     */
    startkey: Core$DocumentKey,

    /**
     * High end of range, or low end if `descending` is `true`. 
     */
    endkey: Core$DocumentKey,

    /**
     * Include any documents identified by `endkey`.
     * 
    Defaults to `true`. 
    */
    inclusive_end?: boolean
} & Core$AllDocsOptions


declare interface Core$AllDocsMeta {
    _attachments?: {
        [attachmentId: string]: Core$Attachment
    }
}

declare interface Core$AllDocsResponse<Content>{

    /**
     * The `skip` if provided, or in CouchDB the actual offset 
     */
    offset: number,
    total_rows: number,
    rows: {

        /**
         * Only present if `include_docs` was `true`. 
         */
        doc?: Core$Document<Content & Core$AllDocsMeta>,
        id: Core$DocumentId,
        key: Core$DocumentKey,
        value: {
            rev: Core$RevisionId
        }
    }[]
}

declare type Core$DestroyOptions = {} & Core$Options


declare type Core$GetOptions = {

    /**
     * Include list of conflicting leaf revisions. 
     */
    conflicts?: boolean,

    /**
     * Specific revision to fetch 
     */
    rev?: Core$RevisionId,

    /**
     * Include revision history of the document. 
     */
    revs?: boolean,

    /**
     * Include a list of revisions of the document, and their
     * availability. 
     */
    revs_info?: boolean
} & Core$Options


declare type Core$GetOpenRevisions = {

    /**
     * Fetch all leaf revisions if open_revs="all" or fetch all leaf
     * revisions specified in open_revs array. Leaves will be returned
    in the same order as specified in input array. 
    */
    open_revs: "all" | Core$RevisionId[]
} & Core$Options



/**
 * 
 * @todo  does this have any other properties? 
 */
declare type Core$PutOptions = {} & Core$Options


declare type Core$PostOptions = {} & Core$PutOptions


declare type Core$CompactOptions = {
    interval?: number
}

declare type Core$InfoOptions = {} & Core$Options



/**
 * Pass this to `PouchDB.plugin()`.
 */
declare
export type PouchDB$Plugin = "This should be passed to PouchDB.plugin()";

declare interface Configuration$CommonDatabaseConfiguration {

    /**
     * Database name.
     */
    name?: string,

        /**
         * Database adapter to use.
         * 
        If unspecified, PouchDB will infer this automatically, preferring
        IndexedDB to WebSQL in browsers that support both (i.e. Chrome,
        Opera and Android 4.4+).
        */
        adapter?: string
}

declare type Configuration$LocalDatabaseConfiguration = {

    /**
     * Enables auto compaction, which means compact() is called after
     * every change to the database.

    Defaults to false.
    */
    auto_compaction?: boolean,

    /**
     * How many old revisions we keep track (not a copy) of.
     */
    revs_limit?: number
} & Configuration$CommonDatabaseConfiguration


declare interface Configuration$RemoteRequesterConfiguration {

    /**
     * Time before HTTP requests time out (in ms).
     */
    timeout?: number,

        /**
         * Appends a random string to the end of all HTTP GET requests to avoid
         * them being cached on IE. Set this to true to prevent this happening.
         */
        cache?: boolean,

        /**
         * HTTP headers to add to requests.
         */
        headers?: {
            [name: string]: string
        },
        username?: string,
        password?: string,

        /**
         * Enables transferring cookies and HTTP Authorization information.
         * 
        Defaults to true.
        */
        withCredentials?: boolean,

        /**
         * Disables automatic creation of databases.
         */
        skip_setup?: boolean
}

declare type Configuration$RemoteDatabaseConfiguration = {
    ajax?: Configuration$RemoteRequesterConfiguration
} & Configuration$CommonDatabaseConfiguration


declare type Configuration$DatabaseConfiguration = Configuration$LocalDatabaseConfiguration | Configuration$RemoteDatabaseConfiguration;

declare interface PouchDB$Static {
    plugin(plugin: PouchDB$Plugin): PouchDB$Static,
        new<Content>(
            name?: string,
            options?: Configuration$DatabaseConfiguration): PouchDB$Database<Content >
}

declare interface PouchDB$Database<Content>{

    /**
     * Fetch all documents matching the given key. 
     */
    allDocs(options: Core$AllDocsWithKeyOptions): Promise<Core$AllDocsResponse<Content >> ,

    /**
     * Fetch all documents matching any of the given keys. 
     */
    allDocs(options: Core$AllDocsWithKeysOptions): Promise<Core$AllDocsResponse<Content >> ,

    /**
     * Fetch all documents matching the given key range. 
     */
    allDocs(
        options: Core$AllDocsWithinRangeOptions): Promise<Core$AllDocsResponse<Content >> ,

    /**
     * Fetch all documents. 
     */
    allDocs(options?: Core$AllDocsOptions): Promise<Core$AllDocsResponse<Content >> ,
    bulkDocs(
        docs: Core$Document<Content>[],
        options: Core$PutOptions | void,
        callback: Core$Callback<Core$Error, Core$Response[]>): void,
    bulkDocs(
        docs: Core$Document<Content>[],
        options?: Core$PutOptions): Promise<Core$Response[]>,

    /**
     * Compact the database 
     */
    compact(options?: Core$CompactOptions): Promise<Core$Response>,
    compact(
        options: Core$CompactOptions,
        callback: Core$Callback<Core$Error, Core$Response>): void,

    /**
     * Destroy the database 
     */
    destroy(options: Core$DestroyOptions | void, callback: Core$AnyCallback): void,
    destroy(options?: Core$DestroyOptions | void): Promise<void>,

    /**
     * Fetch a document 
     */
    get(
        docId: Core$DocumentId,
        options: Core$GetOpenRevisions): Promise<Core$Revision<Content>[]>,
    get(
        docId: Core$DocumentId,
        options: Core$GetOpenRevisions,
        callback: Core$Callback<any, Core$Revision<Content>[]>): void,
    get(
        docId: Core$DocumentId,
        options: Core$GetOptions): Promise<Core$Document<Content>& Core$GetMeta>,
    get(
        docId: Core$DocumentId,
        options: Core$GetOptions,
        callback: Core$Callback<any, Core$Document<Content>& Core$GetMeta>): void,
    get(
        docId: Core$DocumentId,
        options: void,
        callback: Core$Callback<any, Core$Document<Content >> ): void,
    get(docId: Core$DocumentId): Promise<Core$Document<Content >> ,

    /**
     * Create a new document without providing an id.
     * 
    You should prefer put() to post(), because when you post(), you are
    missing an opportunity to use allDocs() to sort documents by _id
    (because your _ids are random).
     * @see  {
     * @link  https://pouchdb.com/2014/06/17/12-pro-tips-for-better-code-with-pouchdb.html|PouchDB Pro Tips}
    */
    post(
        doc: Core$NewDocument<Content>,
        options: Core$PostOptions | void,
        callback: Core$Callback<Core$Error, Core$Response>): void,
    post(
        doc: Core$NewDocument<Content>,
        options?: Core$PostOptions): Promise<Core$Response>,

    /**
     * Create a new document or update an existing document.
     * 
    If the document already exists, you must specify its revision _rev,
    otherwise a conflict will occur.
    There are some restrictions on valid property names of the documents.
    If you try to store non-JSON data (for instance Date objects) you may
    see inconsistent results. 
    */
    put(
        doc: Core$Document<Content>,
        id: Core$DocumentId | void,
        revision: Core$RevisionId | void,
        options: Core$PutOptions | void,
        callback: Core$Callback<Core$Error, Core$Response>): void,
    put(
        doc: Core$Document<Content>,
        id?: Core$DocumentId,
        revision?: Core$RevisionId,
        options?: Core$PutOptions): Promise<Core$Response>,

    /**
     * Remove a doc from the database 
     */
    remove(
        doc: Core$Document<Content>,
        options: Core$Options,
        callback: Core$Callback<Core$Error, Core$Response>): void,
    remove(
        docId: Core$DocumentId,
        revision: Core$RevisionId,
        options: Core$Options,
        callback: Core$Callback<Core$Error, Core$Response>): void,
    remove(doc: Core$Document<Content>, options?: Core$Options): Promise<Core$Response>,
    remove(
        docId: Core$DocumentId,
        revision: Core$RevisionId,
        options?: Core$Options): Promise<Core$Response>,

    /**
     * Get database information 
     */
    info(
        options: Core$InfoOptions | void,
        callback: Core$Callback<any, Core$DatabaseInfo>): void,
    info(options?: Core$InfoOptions): Promise<Core$DatabaseInfo >
}
declare module 'pouchdb-core' {
    declare var PouchDb: PouchDB$Static;
    declare module.exports: typeof PouchDb
}
declare
var PouchDB: PouchDB$Static;