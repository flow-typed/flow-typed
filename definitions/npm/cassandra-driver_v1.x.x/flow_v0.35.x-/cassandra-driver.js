// @flow
/**
 * Flowtype definitions for cassandra-driver
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'cassandra-driver' {
    declare type Callback = Function;
    declare type ResultCallback = (err: Error, result: types$ResultSet) => void;


    declare     var EC2MultiRegionTranslator: addressResolution$EC2MultiRegionTranslatorStatic;

    declare interface addressResolution$AddressTranslator {
        translate(address: string, port: number, callback: Callback): void
    }

    declare interface addressResolution$EC2MultiRegionTranslatorStatic {
        new(): addressResolution$EC2MultiRegionTranslator
    }

    declare type addressResolution$EC2MultiRegionTranslator = {
        logError(address: string, err: Error): void
    } & addressResolution$AddressTranslator


    declare     var DCAwareRoundRobinPolicy: loadBalancing$DCAwareRoundRobinPolicyStatic;

    declare     var RoundRobinPolicy: loadBalancing$RoundRobinPolicyStatic;

    declare     var TokenAwarePolicy: loadBalancing$TokenAwarePolicyStatic;

    declare     var WhiteListPolicy: loadBalancing$WhiteListPolicyStatic;

    declare interface loadBalancing$LoadBalancingPolicy {
        init(client: Client, hosts: HostMap, callback: Callback): void,
            getDistance(host: Host): types$distance,
            newQueryPlan(keyspace: string, queryOptions: any, callback: Callback): void
    }

    declare interface loadBalancing$DCAwareRoundRobinPolicyStatic {
        new(
            localDc?: string,
            usedHostsPerRemoteDc?: number): loadBalancing$DCAwareRoundRobinPolicy
    }

    declare type loadBalancing$DCAwareRoundRobinPolicy = {
        localHostsArray: Array<Host>,
        remoteHostsArray: Array<Host >
    } & loadBalancing$LoadBalancingPolicy


    declare interface loadBalancing$RoundRobinPolicyStatic {
        new(): loadBalancing$RoundRobinPolicy
    }

    declare type loadBalancing$RoundRobinPolicy = {} & loadBalancing$LoadBalancingPolicy


    declare interface loadBalancing$TokenAwarePolicyStatic {
        new(childPolicy: loadBalancing$LoadBalancingPolicy): loadBalancing$TokenAwarePolicy
    }

    declare type loadBalancing$TokenAwarePolicy = {} & loadBalancing$LoadBalancingPolicy


    declare interface loadBalancing$WhiteListPolicyStatic {
        new(
            childPolicy: loadBalancing$LoadBalancingPolicy,
            whiteList: Array<string>): loadBalancing$WhiteListPolicy
    }

    declare type loadBalancing$WhiteListPolicy = {} & loadBalancing$LoadBalancingPolicy


    declare     var ConstantReconnectionPolicy: reconnection$ConstantReconnectionPolicyStatic;

    declare     var ExponentialReconnectionPolicy: reconnection$ExponentialReconnectionPolicyStatic;

    declare interface reconnection$ReconnectionPolicy {
        newSchedule(): {
            next: Function
        }
    }

    declare interface reconnection$ConstantReconnectionPolicyStatic {
        new(delay: number): reconnection$ConstantReconnectionPolicy
    }

    declare type reconnection$ConstantReconnectionPolicy = {} & reconnection$ReconnectionPolicy


    declare interface reconnection$ExponentialReconnectionPolicyStatic {
        new(
            baseDelay: number,
            maxDelay: number,
            startWithNoDelay: boolean): reconnection$ExponentialReconnectionPolicy
    }

    declare type reconnection$ExponentialReconnectionPolicy = {} & reconnection$ReconnectionPolicy


    declare     var RetryPolicy: retry$RetryPolicyStatic;

    declare interface retry$DecisionInfo {
        decision: number,
            consistency: number
    }

    declare interface retry$RequestInfo {
        request: any,
            nbRetry: number
    }

    declare interface retry$RetryPolicyStatic {
        new(): retry$RetryPolicy,
        retryDecision: any
    }

    declare interface retry$RetryPolicy {
        onReadTimeout(
                requestInfo: retry$RequestInfo,
                consistency: types$consistencies,
                received: number,
                blockFor: number,
                isDataPresent: boolean): retry$DecisionInfo,
            onUnavailable(
                requestInfo: retry$RequestInfo,
                consistency: types$consistencies,
                required: number,
                alive: number): retry$DecisionInfo,
            onWriteTimeout(
                requestInfo: retry$RequestInfo,
                consistency: types$consistencies,
                received: number,
                blockFor: number,
                writeType: string): retry$DecisionInfo,
            rethrowResult(): {
                decision: retryDecision
            },
            retryResult(): {
                decision: retryDecision,
                consistency: types$consistencies,
                useCurrentHost: boolean
            }
    }

    declare     var npm$namespace$types: {
        generateTimestamp: typeof types$generateTimestamp,
        timeuuid: typeof types$timeuuid,
    }
    declare     var BigDecimal: types$BigDecimalStatic;

    declare     var InetAddress: types$InetAddressStatic;

    declare     var Integer: types$IntegerStatic;

    declare     var LocalDate: types$LocalDateStatic;

    declare     var LocalTime: types$LocalTimeStatic;

    declare     var Long: _Long;

    declare     var ResultSet: types$ResultSetStatic;

    declare     var Row: types$RowStatic;

    declare     var TimeUuid: types$TimeUuidStatic;

    declare     var Tuple: types$TupleStatic;

    declare     var Uuid: types$UuidStatic;

    declare interface types$responseErrorCodes {
        [key: string]: number
    }

    declare interface types$unset {
        unset: boolean
    }

    declare     function types$generateTimestamp(date?: Date, microseconds?: number): _Long

    declare     function types$timeuuid(
        options?: {
            msecs: number | Date,
            node: Buffer,
            clockseq: number,
            nsecs: number
        },
        buffer?: Buffer,
        offset?: number): string

    declare interface types$BigDecimalStatic {
        new(unscaledValue: number, scale: number): types$BigDecimal,
        fromBuffer(buf: Buffer): types$BigDecimal,
            toBuffer(value: types$BigDecimal): Buffer,
            fromString(value: string): types$BigDecimal,
            fromNumber(value: number): types$BigDecimal
    }

    declare interface types$BigDecimal {
        equals(other: types$BigDecimal): boolean,
            inspect(): string,
            notEquals(other: types$BigDecimal): boolean,
            compare(other: types$BigDecimal): number,
            subtract(other: types$BigDecimal): types$BigDecimal,
            add(other: types$BigDecimal): types$BigDecimal,
            greaterThan(other: types$BigDecimal): boolean,
            isNegative(): boolean,
            isZero(): boolean,
            toString(): string,
            toNumber(): number,
            toJSON(): string
    }

    declare interface types$InetAddressStatic {
        new(buffer: Buffer): types$InetAddress,
        fromString(value: string): types$InetAddress
    }

    declare interface types$InetAddress {
        equals(other: types$InetAddress): boolean,
            getBuffer(): Buffer,
            inspect(): string,
            toString(): string,
            toJSON(): string,
            length: number,
            version: number
    }

    declare interface types$IntegerStatic {
        new(bits: Array<number>, sign: number): types$Integer,
        fromInt(value: number): types$Integer,
            fromNumber(value: number): types$Integer,
            fromBits(bits: Array<number>): types$Integer,
            fromString(str: string, opt_radix?: number): types$Integer,
            fromBuffer(bits: Buffer): types$Integer,
            toBuffer(value: types$Integer): Buffer,
            ZERO: types$Integer,
            ONE: types$Integer
    }

    declare interface types$Integer {
        toInt(): number,
            toNumber(): number,
            toString(opt_radix?: number): string,
            getBits(index: number): number,
            getBitsUnsigned(index: number): number,
            getSign(): number,
            isZero(): boolean,
            isNegative(): boolean,
            isOdd(): boolean,
            equals(other: types$Integer): boolean,
            notEquals(other: types$Integer): boolean,
            greaterThan(other: types$Integer): boolean,
            greaterThanOrEqual(other: types$Integer): boolean,
            lessThan(other: types$Integer): boolean,
            lessThanOrEqual(other: types$Integer): boolean,
            compare(other: types$Integer): number,
            shorten(numBits: number): types$Integer,
            negate(): types$Integer,
            add(other: types$Integer): types$Integer,
            subtract(other: types$Integer): types$Integer,
            multiply(other: types$Integer): types$Integer,
            divide(other: types$Integer): types$Integer,
            modulo(other: types$Integer): types$Integer,
            not(): types$Integer,
            and(other: types$Integer): types$Integer,
            or(other: types$Integer): types$Integer,
            xor(other: types$Integer): types$Integer,
            shiftLeft(numBits: number): types$Integer,
            shiftRight(numBits: number): types$Integer,
            inspect(): string,
            abs(): types$Integer,
            toJSON(): string
    }

    declare interface types$LocalDateStatic {
        new(year: number, month: number, day: number): types$LocalDate,
        now(): types$LocalDate,
            utcNow(): types$LocalDate,
            fromDate(date: Date): types$LocalDate,
            fromString(value: string): types$LocalDate,
            fromBuffer(buffer: Buffer): types$LocalDate
    }

    declare interface types$LocalDate {
        _value: number,
            year: number,
            month: number,
            day: number,
            equals(other: types$LocalDate): boolean,
            inspect(): string,
            toBuffer(): Buffer,
            toString(): string,
            toJSON(): string
    }

    declare interface types$LocalTimeStatic {
        new(totalNanoseconds: _Long): types$LocalTime,
        fromString(value: string): types$LocalTime,
            now(nanoseconds?: number): types$LocalTime,
            fromDate(date: Date, nanoseconds: number): types$LocalTime,
            fromMilliseconds(milliseconds: number, nanoseconds?: number): types$LocalTime,
            fromBuffer(value: Buffer): types$LocalTime
    }

    declare interface types$LocalTime {
        hour: number,
            minute: number,
            second: number,
            nanosecond: number,
            compare(other: types$LocalTime): boolean,
            equals(other: types$LocalTime): boolean,
            getTotalNanoseconds(): _Long,
            inspect(): string,
            toBuffer(): Buffer,
            toString(): string,
            toJSON(): string
    }

    declare interface types$ResultSetStatic {
        new(
            response: any,
            host: string,
            triedHost: {
                [key: string]: any
            },
            consistency: consistencies): types$ResultSet
    }

    declare interface types$ResultSet {
        info: {
                queriedHost: Host,
                triedHosts: {
                    [key: string]: string
                },
                achievedConsistency: consistencies,
                traceId: types$Uuid,
                warnings: Array<string>,
                customPayload: any
            },
            rows: Array<types$Row>,
            rowLength: number,
            columns: Array<{
                [key: string]: string
            }>,
            pageState: string,
            nextPage: any,
            first(): types$Row,
            getPageState(): string,
            getColumns(): Array<{
                [key: string]: string
            } >
    }

    declare interface types$ResultStreamStatic {
        new(opt: any): types$ResultSet
    }

    declare type types$ResultStream = {
        buffer: Buffer,
        paused: boolean,
        _valve(readNext: Function): void,
        add(chunk: Buffer): void
    }

    declare interface types$RowStatic {
        new(columns: Array<{
            [key: string]: string
        }>): types$Row
    }

    declare interface types$Row {
        get(columnName: string | number): {
                [key: string]: any
            },
            values(): Array<{
                [key: string]: any
            }>,
            keys(): Array<string>,
            forEach(callback: Callback): void
    }

    declare interface types$TimeUuidStatic {
        new(
            value?: Date,
            ticks?: number,
            nodeId?: string | Buffer,
            clockId?: string | Buffer): types$TimeUuid,
        fromDate(
                date: Date,
                ticks?: number,
                nodeId?: string | Buffer,
                clockId?: string | Buffer): types$TimeUuid,
            fromString(value: string): types$TimeUuid,
            min(date: Date, ticks?: number): types$TimeUuid,
            max(date: Date, ticks?: number): types$TimeUuid,
            now(nodeId?: string | Buffer, clockId?: string | Buffer): types$TimeUuid
    }

    declare type types$TimeUuid = {
        getDatePrecision(): {
            date: Date,
            ticks: number
        },
        getDate(): Date,
        getNodeId(): Buffer,
        getNodeIdString(): string
    } & types$Uuid


    declare interface types$TupleStatic {
        new(...arguments: Array<any>): types$Tuple,
        fromArray(elements: Array<any>): types$Tuple
    }

    declare interface types$Tuple {
        elements: Array<any>,
            length: number,
            get(index: number): any,
            toString(): string,
            toJSON(): string,
            values(): Array<any >
    }

    declare interface types$UuidStatic {
        new(buffer: Buffer): types$Uuid,
        fromString(value: string): types$Uuid,
            random(): types$Uuid
    }

    declare interface types$Uuid {
        buffer: Buffer,
            getBuffer(): Buffer,
            equals(other: types$Uuid): boolean,
            toString(): string,
            inspect(): string,
            toJSON(): string
    }
    declare     var Client: ClientStatic;
    declare     var Host: HostStatic;
    declare     var HostMap: HostMapStatic;
    declare     var Encoder: EncoderStatic;
    declare interface ClientOptions {
        contactPoints: Array<string>,
            keyspace: string,
            policies?: {
                addressResolution?: undefined.AddressTranslator,
                loadBalancing?: undefined.LoadBalancingPolicy,
                reconnection?: undefined.ReconnectionPolicy,
                retry?: undefined.RetryPolicy
            },
            queryOptions?: QueryOptions,
            pooling?: {
                heartBeatInterval: number,
                coreConnectionsPerHost: {
                    [key: number]: number
                },
                warmup: boolean
            },
            protocolOptions?: {
                port: number,
                maxSchemaAgreementWaitSeconds: number,
                maxVersion: number
            },
            socketOptions?: {
                connectTimeout: number,
                defunctReadTimeoutThreshold: number,
                keepAlive: boolean,
                keepAliveDelay: number,
                readTimeout: number,
                tcpNoDelay: boolean,
                coalescingThreshold: number
            },
            authProvider?: auth$AuthProvider,
            sslOptions?: any,
            encoding?: {
                map: Function,
                set: Function,
                copyBuffer: boolean,
                useUndefinedAsUnset: boolean
            }
    }
    declare interface QueryOptions {
        autoPage?: boolean,
            captureStackTrace?: boolean,
            consistency?: number,
            customPayload?: any,
            fetchSize?: number,
            hints?: Array<string>| Array<Array<string >> ,
            logged?: boolean,
            pageState?: Buffer | string,
            prepare?: boolean,
            readTimeout?: number,
            retry?: undefined.RetryPolicy,
            retryOnTimeout?: boolean,
            routingIndexes?: Array<number>,
            routingKey?: Buffer | Array<Buffer>,
            routingNames?: Array<string>,
            serialConsistency?: number,
            timestamp?: number | _Long,
            traceQuery?: boolean
    }
    declare interface ClientStatic {
        new(options?: ClientOptions): Client
    }
    declare type Client = {
        hosts: HostMap,
        keyspace: string,
        metadata: metadata$Metadata,
        batch(
            queries: Array<string>| Array<{
                query: string,
                params?: any
            }>,
            options: QueryOptions,
            callback: ResultCallback): void,
        connect(callback: Callback): void,
        eachRow(
            query: string,
            params?: any,
            options?: QueryOptions,
            rowCallback?: Callback,
            callback?: Callback): void,
        execute(
            query: string,
            params?: any,
            options?: QueryOptions,
            callback?: ResultCallback): void,
        getReplicas(keyspace: string, token: Buffer): Array<any>,
        shutdown(callback?: Callback): void,
        stream(
            query: string,
            params?: any,
            options?: QueryOptions,
            callback?: Callback): NodeJS.ReadableStream
    }
    declare interface HostStatic {
        new(address: string, protocolVersion: number, options: ClientOptions): Host
    }
    declare type Host = {
        address: string,
        cassandraVersion: string,
        dataCenter: string,
        rack: string,
        tokens: Array<string>,
        canBeConsideredAsUp(): boolean,
        getCassandraVersion(): Array<number>,
        isUp(): boolean
    }
    declare interface HostMapStatic {
        new(): HostMap
    }
    declare type HostMap = {
        length: number,
        forEach(callback: Callback): void,
        get(key: string): Host,
        keys(): Array<string>,
        remove(key: string): void,
        removeMultiple(keys: Array<string>): void,
        set(key: string, value: Host): void,
        values(): Array<Host >
    }
    declare interface EncoderStatic {
        new(protocolVersion: number, options: ClientOptions): Encoder
    }
    declare interface Encoder {
        decode(buffer: Buffer, type: {
                code: number,
                info?: any
            }): void,
            encode(value: any, typeInfo?: string | number | {
                code: number,
                info?: any
            }): Buffer
    }
    declare     var Authenticator: auth$AuthenticatorStatic;

    declare     var PlainTextAuthProvider: auth$PlainTextAuthProviderStatic;

    declare interface auth$AuthenticatorStatic {
        new(): auth$Authenticator
    }

    declare interface auth$Authenticator {
        evaluateChallenge(challenge: Buffer, callback: Callback): void,
            initialResponse(callback: Callback): void,
            onAuthenticationSuccess(token?: Buffer): void
    }

    declare interface auth$AuthProvider {
        newAuthenticator(endpoint: string, name: string): void
    }

    declare interface auth$PlainTextAuthProviderStatic {
        new(username: string, password: string): auth$PlainTextAuthProvider
    }

    declare type auth$PlainTextAuthProvider = {
        newAuthenticator(endpoint: string, name: string): void
    } & auth$AuthProvider

    declare class DriverError {
        constructor(message: string, constructor?: any): this
    }

    declare class ArgumentError mixins DriverError {
        constructor(message: string): this
    }

    declare class AuthenticationError mixins DriverError {
        constructor(message: string): this
    }

    declare class DriverInternalError mixins DriverError {
        constructor(message: string): this
    }

    declare class NoHostAvailableError mixins DriverError {
        constructor(innerErrors: any, message?: string): this
    }

    declare class NotSupportedError mixins DriverError {
        constructor(message: string): this
    }

    declare class OperationTimedOutError mixins DriverError {}

    declare class ResponseError mixins DriverError {
        constructor(code: number, message: string): this
    }
    declare     var Aggregate: metadata$AggregateStatic;

    declare     var Index: metadata$IndexStatic;

    declare     var MaterializedView: metadata$MaterializedViewStatic;

    declare     var Metadata: metadata$MetadataStatic;

    declare     var SchemaFunction: metadata$SchemaFunctionStatic;

    declare     var TableMetadata: metadata$TableMetadataStatic;

    declare type metadata$caching = "all" | "keys_only" | "rows_only" | "none";

    declare interface metadata$AggregateStatic {
        new(): metadata$Aggregate
    }

    declare interface metadata$Aggregate {
        argumentTypes: Array<{
                code: number,
                info: any
            }>,
            finalFunction: string,
            initCondition: string,
            keyspaceName: string,
            returnType: string,
            signature: Array<string>,
            stateFunction: string,
            stateType: string
    }

    declare interface metadata$DataTypeInfo {
        code: number,
            info: string | metadata$DataTypeInfo | Array<metadata$DataTypeInfo>,
            options: {
                frozen: boolean,
                reversed: boolean
            }
    }

    declare interface metadata$ColumnInfo {
        name: string,
            type: metadata$DataTypeInfo
    }

    declare interface metadata$DataCollection {
        bloomFilterFalsePositiveChance: number,
            caching: metadata$caching,
            clusterKeys: Array<{
                c: metadata$ColumnInfo,
                index: number,
                order: string
            }>,
            clusteringOrder: Array<string>,
            columns: Array<metadata$ColumnInfo>,
            columnsByName: {
                [key: string]: metadata$ColumnInfo
            },
            comment: string,
            compactionClass: string,
            compactionOptions: any,
            compression: any,
            crcCheckChange?: number,
            defaultTtl: number,
            extensions: any,
            gcGraceSeconds: number,
            localReadRepairChance: number,
            maxIndexInterval?: number,
            minIndexInterval?: number,
            name: string,
            partitionKeys: Array<{
                c: metadata$ColumnInfo,
                index: number
            }>,
            populateCacheOnFlush: boolean,
            readRepairChance: number,
            speculateRetry: string
    }

    declare interface metadata$IndexStatic {
        new(name: string, target: string, kind: IndexType, options: Object): metadata$Index,
        fromRows(indexRows: Array<types$Row>): Array<metadata$Index>,
            fromColumnRows(
                columnRows: Array<types$Row>,
                columnsByName: {
                    [key: string]: metadata$ColumnInfo
                }): Array<metadata$Index >
    }

    declare interface metadata$Index {
        kind: IndexType,
            name: string,
            options: Object,
            target: string,
            isCompositesKind(): boolean,
            isCustomKind(): boolean,
            isKeysKind(): boolean
    }

    declare interface metadata$MaterializedViewStatic {
        new(name: string): metadata$MaterializedView
    }

    declare type metadata$MaterializedView = {} & metadata$DataCollection


    declare interface metadata$MetadataStatic {
        new(options: ClientOptions, controlConnection: any): metadata$Metadata
    }

    declare interface metadata$Metadata {
        clearPrepared(): void,
            getAggregate(
                keyspaceName: string,
                name: string,
                signature: Array<string>| Array<{
                    code: number,
                    info: any
                }>,
                callback: Callback): void,
            getAggregates(keyspaceName: string, name: string, callback: Callback): void,
            getFunction(
                keyspaceName: string,
                name: string,
                signature: Array<string>| Array<{
                    code: number,
                    info: any
                }>,
                callback: Callback): void,
            getFunctions(keyspaceName: string, name: string, callback: Callback): void,
            getMaterializedView(keyspaceName: string, name: string, callback: Callback): void,
            getReplicas(keyspaceName: string, tokenBuffer: Buffer): Array<any>,
            getTable(keyspaceName: string, name: string, callback: Callback): void,
            getTrace(traceId: types$Uuid, callback: Callback): void,
            getUdt(keyspaceName: string, name: string, callback: Callback): void,
            refreshKeyspace(name: string, callback?: Callback): void,
            refreshKeyspaces(callback?: Callback): void
    }

    declare interface metadata$SchemaFunctionStatic {
        new(): metadata$SchemaFunction
    }

    declare interface metadata$SchemaFunction {
        argumentNames: Array<string>,
            argumentTypes: Array<{
                code: number,
                info: any
            }>,
            body: string,
            calledOnNullInput: boolean,
            keyspaceName: string,
            language: string,
            name: string,
            returnType: string,
            signature: Array<string >
    }

    declare interface metadata$TableMetadataStatic {
        new(name: string): metadata$TableMetadata
    }

    declare type metadata$TableMetadata = {
        indexes: Array<metadata$Index>,
        indexInterval?: number,
        isCompact: boolean,
        memtableFlushPeriod: number,
        replicateOnWrite: boolean
    } & metadata$DataCollection

}